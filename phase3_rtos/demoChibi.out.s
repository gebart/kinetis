
demoChibi.axf:     file format elf32-littlearm


Disassembly of section .entry:

00000000 <_vector_rom>:
   0:	20010000 	andcs	r0, r1, r0
   4:	00000411 	andeq	r0, r0, r1, lsl r4
   8:	000004d9 	ldrdeq	r0, [r0], -r9
   c:	000004dd 	ldrdeq	r0, [r0], -sp
  10:	000004dd 	ldrdeq	r0, [r0], -sp
  14:	000004dd 	ldrdeq	r0, [r0], -sp
  18:	000004dd 	ldrdeq	r0, [r0], -sp
	...
  2c:	00002501 	andeq	r2, r0, r1, lsl #10
  30:	000004e1 	andeq	r0, r0, r1, ror #9
  34:	00000000 	andeq	r0, r0, r0
  38:	000004e1 	andeq	r0, r0, r1, ror #9
  3c:	000024e1 	andeq	r2, r0, r1, ror #9
  40:	000004e1 	andeq	r0, r0, r1, ror #9
  44:	000004e1 	andeq	r0, r0, r1, ror #9
  48:	000004e1 	andeq	r0, r0, r1, ror #9
  4c:	000004e1 	andeq	r0, r0, r1, ror #9
  50:	000004e1 	andeq	r0, r0, r1, ror #9
  54:	000004e1 	andeq	r0, r0, r1, ror #9
  58:	000004e1 	andeq	r0, r0, r1, ror #9
  5c:	000004e1 	andeq	r0, r0, r1, ror #9
  60:	000004e1 	andeq	r0, r0, r1, ror #9
  64:	000004e1 	andeq	r0, r0, r1, ror #9
  68:	000004e1 	andeq	r0, r0, r1, ror #9
  6c:	000004e1 	andeq	r0, r0, r1, ror #9
  70:	000004e1 	andeq	r0, r0, r1, ror #9
  74:	000004e1 	andeq	r0, r0, r1, ror #9
  78:	000004e1 	andeq	r0, r0, r1, ror #9
  7c:	000004e1 	andeq	r0, r0, r1, ror #9
  80:	000004e1 	andeq	r0, r0, r1, ror #9
  84:	000004e1 	andeq	r0, r0, r1, ror #9
  88:	000004e1 	andeq	r0, r0, r1, ror #9
  8c:	000004e1 	andeq	r0, r0, r1, ror #9
  90:	000004e1 	andeq	r0, r0, r1, ror #9
  94:	000004e1 	andeq	r0, r0, r1, ror #9
  98:	000004e1 	andeq	r0, r0, r1, ror #9
  9c:	000004e1 	andeq	r0, r0, r1, ror #9
  a0:	000004e1 	andeq	r0, r0, r1, ror #9
  a4:	000004e1 	andeq	r0, r0, r1, ror #9
  a8:	000004e1 	andeq	r0, r0, r1, ror #9
  ac:	000004e1 	andeq	r0, r0, r1, ror #9
  b0:	000004e1 	andeq	r0, r0, r1, ror #9
  b4:	000004e1 	andeq	r0, r0, r1, ror #9
  b8:	000004e1 	andeq	r0, r0, r1, ror #9
  bc:	000004e1 	andeq	r0, r0, r1, ror #9
  c0:	000004e1 	andeq	r0, r0, r1, ror #9
  c4:	000004e1 	andeq	r0, r0, r1, ror #9
  c8:	000004e1 	andeq	r0, r0, r1, ror #9
  cc:	000004e1 	andeq	r0, r0, r1, ror #9
  d0:	000004e1 	andeq	r0, r0, r1, ror #9
  d4:	000004e1 	andeq	r0, r0, r1, ror #9
  d8:	000004e1 	andeq	r0, r0, r1, ror #9
  dc:	000004e1 	andeq	r0, r0, r1, ror #9
  e0:	000004e1 	andeq	r0, r0, r1, ror #9
  e4:	000004e1 	andeq	r0, r0, r1, ror #9
  e8:	000004e1 	andeq	r0, r0, r1, ror #9
  ec:	000004e1 	andeq	r0, r0, r1, ror #9
  f0:	000004e1 	andeq	r0, r0, r1, ror #9
  f4:	000004e1 	andeq	r0, r0, r1, ror #9
  f8:	000004e1 	andeq	r0, r0, r1, ror #9
  fc:	000004e1 	andeq	r0, r0, r1, ror #9
 100:	000004e1 	andeq	r0, r0, r1, ror #9
 104:	000004e1 	andeq	r0, r0, r1, ror #9
 108:	000004e1 	andeq	r0, r0, r1, ror #9
 10c:	000004e1 	andeq	r0, r0, r1, ror #9
 110:	000004e1 	andeq	r0, r0, r1, ror #9
 114:	000004e1 	andeq	r0, r0, r1, ror #9
 118:	000004e1 	andeq	r0, r0, r1, ror #9
 11c:	000004e1 	andeq	r0, r0, r1, ror #9
 120:	000004e1 	andeq	r0, r0, r1, ror #9
 124:	000004e1 	andeq	r0, r0, r1, ror #9
 128:	000004e1 	andeq	r0, r0, r1, ror #9
 12c:	000004e1 	andeq	r0, r0, r1, ror #9
 130:	000004e1 	andeq	r0, r0, r1, ror #9
 134:	000004e1 	andeq	r0, r0, r1, ror #9
 138:	000004e1 	andeq	r0, r0, r1, ror #9
 13c:	000004e1 	andeq	r0, r0, r1, ror #9
 140:	000004e1 	andeq	r0, r0, r1, ror #9
 144:	000004e1 	andeq	r0, r0, r1, ror #9
 148:	000004e1 	andeq	r0, r0, r1, ror #9
 14c:	000004e1 	andeq	r0, r0, r1, ror #9
 150:	000004e1 	andeq	r0, r0, r1, ror #9
 154:	000004e1 	andeq	r0, r0, r1, ror #9
 158:	000004e1 	andeq	r0, r0, r1, ror #9
 15c:	000004e1 	andeq	r0, r0, r1, ror #9
 160:	000004e1 	andeq	r0, r0, r1, ror #9
 164:	000004e1 	andeq	r0, r0, r1, ror #9
 168:	000004e1 	andeq	r0, r0, r1, ror #9
 16c:	000004e1 	andeq	r0, r0, r1, ror #9
 170:	000004e1 	andeq	r0, r0, r1, ror #9
 174:	000004e1 	andeq	r0, r0, r1, ror #9
 178:	000004e1 	andeq	r0, r0, r1, ror #9
 17c:	000004e1 	andeq	r0, r0, r1, ror #9
 180:	000004e1 	andeq	r0, r0, r1, ror #9
 184:	000004e1 	andeq	r0, r0, r1, ror #9
 188:	000004e1 	andeq	r0, r0, r1, ror #9
 18c:	000004e1 	andeq	r0, r0, r1, ror #9
 190:	000004e1 	andeq	r0, r0, r1, ror #9
 194:	000004e1 	andeq	r0, r0, r1, ror #9
 198:	000004e1 	andeq	r0, r0, r1, ror #9
 19c:	000004e1 	andeq	r0, r0, r1, ror #9
 1a0:	000004e1 	andeq	r0, r0, r1, ror #9
 1a4:	000004e1 	andeq	r0, r0, r1, ror #9
 1a8:	000004e1 	andeq	r0, r0, r1, ror #9
	...
 400:	01234567 	teqeq	r3, r7, ror #10
 404:	89abcdef 	stmibhi	fp!, {r0, r1, r2, r3, r5, r6, r7, r8, sl, fp, lr, pc}
 408:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff
 40c:	fffffffe 			; <UNDEFINED> instruction: 0xfffffffe

00000410 <_reset_handler>:
    .thumb_func

_default_reset_handler:

unlock_watchdog:
    ldr r6, =0x4005200e
 410:	4e34      	ldr	r6, [pc, #208]	; (4e4 <PendSVVector+0x4>)
    ldr r0, =0xc520
 412:	4835      	ldr	r0, [pc, #212]	; (4e8 <PendSVVector+0x8>)
    strh r0, [r6]
 414:	8030      	strh	r0, [r6, #0]
    ldr r0, =0xd928
 416:	4835      	ldr	r0, [pc, #212]	; (4ec <PendSVVector+0xc>)
    strh r0, [r6]
 418:	8030      	strh	r0, [r6, #0]

0000041a <disable_watchdog>:

disable_watchdog:
    ldr r6, =0x40052000
 41a:	4e35      	ldr	r6, [pc, #212]	; (4f0 <PendSVVector+0x10>)
    ldr r0, =0x01d2
 41c:	4835      	ldr	r0, [pc, #212]	; (4f4 <PendSVVector+0x14>)
    strh r0, [r6]
 41e:	8030      	strh	r0, [r6, #0]

00000420 <first_break>:
     * address 0x00000000 (which is the first element in the vector_table) by
     * the hardware. The next three lines are required in case this image
     * is not located at 0x0 (i.e. it is being launched from a bootloader).
     */

    ldr r1, =_vector_table
 420:	4935      	ldr	r1, [pc, #212]	; (4f8 <PendSVVector+0x18>)
    ldr r2, [r1]
 422:	680a      	ldr	r2, [r1, #0]
    mov	sp,r2
 424:	4695      	mov	sp, r2

00000426 <chibi_setup>:

chibi_setup:
    /*
     * ChibiOS requires a process stack to be initialized.
     */
    ldr r1, =_process_stack_start
 426:	4935      	ldr	r1, [pc, #212]	; (4fc <PendSVVector+0x1c>)
    msr PSP, r1
 428:	f381 8809 	msr	PSP, r1

    /* TODO: FPU register initialization per crt0.c */
    /*
     * Set up system to run in privileged mode using the PSP stack
     */
    ldr r1, =0x00000002
 42c:	4934      	ldr	r1, [pc, #208]	; (500 <PendSVVector+0x20>)
    msr CONTROL, r1
 42e:	f381 8814 	msr	CONTROL, r1
    isb
 432:	f3bf 8f6f 	isb	sy

00000436 <c_data_init>:
     * Relocate the .text section from FLASH to SRAM only if the load
     * address and the start address are not the same. This code supports
     * running an entire image out of SRAM.
     */

    ldr r0, =_text_start
 436:	4833      	ldr	r0, [pc, #204]	; (504 <PendSVVector+0x24>)
    ldr r1, =_text_end
 438:	4933      	ldr	r1, [pc, #204]	; (508 <PendSVVector+0x28>)
    ldr r2, =_text_load
 43a:	4a34      	ldr	r2, [pc, #208]	; (50c <PendSVVector+0x2c>)

    cmp r0, r2
 43c:	4290      	cmp	r0, r2
    beq end_text_loop
 43e:	f000 8008 	beq.w	452 <end_text_loop>

00000442 <text_loop>:
text_loop:
    cmp r0, r1
 442:	4288      	cmp	r0, r1
    ittt    lt
 444:	bfbe      	ittt	lt
    ldrlt   r3, [r2], #4
 446:	f852 3b04 	ldrlt.w	r3, [r2], #4
    strlt   r3, [r0], #4
 44a:	f840 3b04 	strlt.w	r3, [r0], #4
    blt     text_loop
 44e:	f7ff bff8 	blt.w	442 <text_loop>

00000452 <end_text_loop>:

    /*
     * Relocate the .ramcode section from FLASH to SRAM.
     */

    ldr r0, =_ramcode_start
 452:	482f      	ldr	r0, [pc, #188]	; (510 <PendSVVector+0x30>)
    ldr r1, =_ramcode_end
 454:	492f      	ldr	r1, [pc, #188]	; (514 <PendSVVector+0x34>)
    ldr r2, =_ramcode_load
 456:	4a30      	ldr	r2, [pc, #192]	; (518 <PendSVVector+0x38>)

00000458 <ramcode_loop>:

ramcode_loop:
    cmp r0, r1
 458:	4288      	cmp	r0, r1
    ittt    lt
 45a:	bfbe      	ittt	lt
    ldrlt   r3, [r2], #4
 45c:	f852 3b04 	ldrlt.w	r3, [r2], #4
    strlt   r3, [r0], #4
 460:	f840 3b04 	strlt.w	r3, [r0], #4
    blt     ramcode_loop
 464:	f7ff bff8 	blt.w	458 <ramcode_loop>

    /*
     * Relocate vector table to SRAM.
     */

     ldr r0, =_vector_ram_start
 468:	482c      	ldr	r0, [pc, #176]	; (51c <PendSVVector+0x3c>)
     ldr r1, =_vector_ram_end
 46a:	492d      	ldr	r1, [pc, #180]	; (520 <PendSVVector+0x40>)
     ldr r2, =_vector_rom
 46c:	4a2d      	ldr	r2, [pc, #180]	; (524 <PendSVVector+0x44>)

0000046e <vector_loop>:
vector_loop:
    cmp r0, r1
 46e:	4288      	cmp	r0, r1
    ittt    lt
 470:	bfbe      	ittt	lt
    ldrlt   r3, [r2], #4
 472:	f852 3b04 	ldrlt.w	r3, [r2], #4
    strlt   r3, [r0], #4
 476:	f840 3b04 	strlt.w	r3, [r0], #4
    blt     vector_loop
 47a:	f7ff bff8 	blt.w	46e <vector_loop>

    /*
     * Point to the SRAM vector table.
     */

    ldr r1,=0xe000ed08
 47e:	492a      	ldr	r1, [pc, #168]	; (528 <PendSVVector+0x48>)
    ldr r0,=_vector_ram_start
 480:	4826      	ldr	r0, [pc, #152]	; (51c <PendSVVector+0x3c>)
    str r0,[r1]
 482:	6008      	str	r0, [r1, #0]

00000484 <c_runtime_setup>:
     * Note: _data_start contains the SRAM (destination) address and
     *       _text_end contains the (source) address of the .data section
     *       in FLASH.
     */

    ldr r0, =_data_start
 484:	4829      	ldr	r0, [pc, #164]	; (52c <PendSVVector+0x4c>)
    ldr r1, =_data_end
 486:	492a      	ldr	r1, [pc, #168]	; (530 <PendSVVector+0x50>)
    ldr r2, =_data_load
 488:	4a2a      	ldr	r2, [pc, #168]	; (534 <PendSVVector+0x54>)

0000048a <data_loop>:

data_loop:
    cmp r0, r1
 48a:	4288      	cmp	r0, r1
    ittt    lt
 48c:	bfbe      	ittt	lt
    ldrlt   r3, [r2], #4
 48e:	f852 3b04 	ldrlt.w	r3, [r2], #4
    strlt   r3, [r0], #4
 492:	f840 3b04 	strlt.w	r3, [r0], #4
    blt     data_loop
 496:	f7ff bff8 	blt.w	48a <data_loop>

    /*
     * Zero out the .bss section in SRAM.
     */

    ldr r0, =_bss_start
 49a:	4827      	ldr	r0, [pc, #156]	; (538 <PendSVVector+0x58>)
    ldr r1, =_bss_end
 49c:	4927      	ldr	r1, [pc, #156]	; (53c <PendSVVector+0x5c>)
    ldr r2, =0x00000000
 49e:	4a28      	ldr	r2, [pc, #160]	; (540 <PendSVVector+0x60>)

000004a0 <bss_loop>:

bss_loop:
    cmp r0, r1
 4a0:	4288      	cmp	r0, r1
    itt     lt
 4a2:	bfbc      	itt	lt
    strlt   r2, [r0], #4
 4a4:	f840 2b04 	strlt.w	r2, [r0], #4
    blt     bss_loop
 4a8:	f7ff bffa 	blt.w	4a0 <bss_loop>

    /*
     * Zero out heap.
     */

    ldr r0, =_heap_start
 4ac:	4825      	ldr	r0, [pc, #148]	; (544 <PendSVVector+0x64>)
    ldr r1, =_heap_end
 4ae:	4926      	ldr	r1, [pc, #152]	; (548 <PendSVVector+0x68>)

000004b0 <heap_loop>:

heap_loop:
    cmp r0, r1
 4b0:	4288      	cmp	r0, r1
    itt     lt
 4b2:	bfbc      	itt	lt
    strlt   r2, [r0], #4
 4b4:	f840 2b04 	strlt.w	r2, [r0], #4
    blt     heap_loop
 4b8:	f7ff bffa 	blt.w	4b0 <heap_loop>
    ldr r0, =_stack_start
    ldr r1, =_stack_end
    ldr r2, =0xefefefef
*/

    ldr r0, =_stack_end
 4bc:	4823      	ldr	r0, [pc, #140]	; (54c <PendSVVector+0x6c>)
    ldr r1, =_stack_start
 4be:	4924      	ldr	r1, [pc, #144]	; (550 <PendSVVector+0x70>)
    ldr r2, =0xefefefef
 4c0:	4a24      	ldr	r2, [pc, #144]	; (554 <PendSVVector+0x74>)

000004c2 <stack_loop>:

stack_loop:
    cmp r0, r1
 4c2:	4288      	cmp	r0, r1
    itt     lt
 4c4:	bfbc      	itt	lt
    strlt   r2, [r0], #4
 4c6:	f840 2b04 	strlt.w	r2, [r0], #4
    blt     stack_loop
 4ca:	f7ff bffa 	blt.w	4c2 <stack_loop>

000004ce <call_user_asm_code>:

call_user_asm_code:
    bl main
 4ce:	f000 f89f 	bl	610 <main>

000004d2 <end_loop>:
    /*
     * Epilogue processing would go here.
     */

end_loop:
    b end_loop
 4d2:	f7ff bffe 	b.w	4d2 <end_loop>
 4d6:	bf00      	nop

000004d8 <_nmi_handler>:

    .align 2
    .thumb_func

_default_nmi_handler:
    b _default_nmi_handler
 4d8:	f7ff bffe 	b.w	4d8 <_nmi_handler>

000004dc <_bus_fault_handler>:

    .align 2
    .thumb_func

_default_fault_handler:
    b _default_fault_handler
 4dc:	f7ff bffe 	b.w	4dc <_bus_fault_handler>

000004e0 <PendSVVector>:

    .align 2
    .thumb_func

_default_irq_handler:
    b _default_irq_handler
 4e0:	f7ff bffe 	b.w	4e0 <PendSVVector>
    .thumb_func

_default_reset_handler:

unlock_watchdog:
    ldr r6, =0x4005200e
 4e4:	4005200e 	andmi	r2, r5, lr
    ldr r0, =0xc520
 4e8:	0000c520 	andeq	ip, r0, r0, lsr #10
    strh r0, [r6]
    ldr r0, =0xd928
 4ec:	0000d928 	andeq	sp, r0, r8, lsr #18
    strh r0, [r6]

disable_watchdog:
    ldr r6, =0x40052000
 4f0:	40052000 	andmi	r2, r5, r0
    ldr r0, =0x01d2
 4f4:	000001d2 	ldrdeq	r0, [r0], -r2
     * address 0x00000000 (which is the first element in the vector_table) by
     * the hardware. The next three lines are required in case this image
     * is not located at 0x0 (i.e. it is being launched from a bootloader).
     */

    ldr r1, =_vector_table
 4f8:	00000000 	andeq	r0, r0, r0

chibi_setup:
    /*
     * ChibiOS requires a process stack to be initialized.
     */
    ldr r1, =_process_stack_start
 4fc:	2000f800 	andcs	pc, r0, r0, lsl #16

    /* TODO: FPU register initialization per crt0.c */
    /*
     * Set up system to run in privileged mode using the PSP stack
     */
    ldr r1, =0x00000002
 500:	00000002 	andeq	r0, r0, r2
     * Relocate the .text section from FLASH to SRAM only if the load
     * address and the start address are not the same. This code supports
     * running an entire image out of SRAM.
     */

    ldr r0, =_text_start
 504:	00000560 	andeq	r0, r0, r0, ror #10
    ldr r1, =_text_end
 508:	00002cf0 	strdeq	r2, [r0], -r0
    ldr r2, =_text_load
 50c:	00000560 	andeq	r0, r0, r0, ror #10

    /*
     * Relocate the .ramcode section from FLASH to SRAM.
     */

    ldr r0, =_ramcode_start
 510:	1fff0000 	svcne	0x00ff0000
    ldr r1, =_ramcode_end
 514:	1fff0000 	svcne	0x00ff0000
    ldr r2, =_ramcode_load
 518:	00002cf0 	strdeq	r2, [r0], -r0

    /*
     * Relocate vector table to SRAM.
     */

     ldr r0, =_vector_ram_start
 51c:	20000000 	andcs	r0, r0, r0
     ldr r1, =_vector_ram_end
 520:	20000400 	andcs	r0, r0, r0, lsl #8
     ldr r2, =_vector_rom
 524:	00000000 	andeq	r0, r0, r0

    /*
     * Point to the SRAM vector table.
     */

    ldr r1,=0xe000ed08
 528:	e000ed08 	and	lr, r0, r8, lsl #26
     * Note: _data_start contains the SRAM (destination) address and
     *       _text_end contains the (source) address of the .data section
     *       in FLASH.
     */

    ldr r0, =_data_start
 52c:	20000400 	andcs	r0, r0, r0, lsl #8
    ldr r1, =_data_end
 530:	20000430 	andcs	r0, r0, r0, lsr r4
    ldr r2, =_data_load
 534:	00002cf0 	strdeq	r2, [r0], -r0

    /*
     * Zero out the .bss section in SRAM.
     */

    ldr r0, =_bss_start
 538:	20000430 	andcs	r0, r0, r0, lsr r4
    ldr r1, =_bss_end
 53c:	20000750 	andcs	r0, r0, r0, asr r7
    ldr r2, =0x00000000
 540:	00000000 	andeq	r0, r0, r0

    /*
     * Zero out heap.
     */

    ldr r0, =_heap_start
 544:	20000750 	andcs	r0, r0, r0, asr r7
    ldr r1, =_heap_end
 548:	2000f000 	andcs	pc, r0, r0
    ldr r0, =_stack_start
    ldr r1, =_stack_end
    ldr r2, =0xefefefef
*/

    ldr r0, =_stack_end
 54c:	2000f800 	andcs	pc, r0, r0, lsl #16
    ldr r1, =_stack_start
 550:	20010000 	andcs	r0, r1, r0
    ldr r2, =0xefefefef
 554:	efefefef 	svc	0x00efefef

Disassembly of section .text:

00000560 <assert_>:
#define TSI_ORANGE_BIT    BIT_5

#define TSI_YELLOW_INDEX  8
#define TSI_YELLOW_BIT    BIT_8

void assert_(const char *file, const int line) { }
     560:	b480      	push	{r7}
     562:	b083      	sub	sp, #12
     564:	af00      	add	r7, sp, #0
     566:	6078      	str	r0, [r7, #4]
     568:	6039      	str	r1, [r7, #0]
     56a:	f107 070c 	add.w	r7, r7, #12
     56e:	46bd      	mov	sp, r7
     570:	bc80      	pop	{r7}
     572:	4770      	bx	lr

00000574 <Thread1>:

static WORKING_AREA(waThread1, 128);
static msg_t Thread1(void *arg) {
     574:	b580      	push	{r7, lr}
     576:	b082      	sub	sp, #8
     578:	af00      	add	r7, sp, #0
     57a:	6078      	str	r0, [r7, #4]
    while (TRUE) {
        chThdSleepMilliseconds(500);
     57c:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
     580:	f001 fb6e 	bl	1c60 <chThdSleep>
        gpioToggle(N_LED_YELLOW_PORT, N_LED_YELLOW_PIN);
     584:	f44f 4010 	mov.w	r0, #36864	; 0x9000
     588:	f2c4 0004 	movt	r0, #16388	; 0x4004
     58c:	f04f 011c 	mov.w	r1, #28
     590:	f000 fa02 	bl	998 <gpioToggle>
    }
     594:	e7f2      	b.n	57c <Thread1+0x8>
     596:	bf00      	nop

00000598 <clocksInit>:

    return 0;
}

static void clocksInit(void)
{
     598:	b580      	push	{r7, lr}
     59a:	af00      	add	r7, sp, #0
     * System:  100 MHz
     * Bus:      50 MHz
     * Flexbus:  50 MHz
     * Flash:    25 MHz
     */
    clockSetDividers(DIVIDE_BY_1, DIVIDE_BY_2, DIVIDE_BY_4, DIVIDE_BY_4);
     59c:	f04f 0000 	mov.w	r0, #0
     5a0:	f04f 0101 	mov.w	r1, #1
     5a4:	f04f 0203 	mov.w	r2, #3
     5a8:	f04f 0303 	mov.w	r3, #3
     5ac:	f000 fc46 	bl	e3c <clockSetDividers>
    clockConfigMcgOut(MCG_PLL_EXTERNAL_100MHZ);
     5b0:	f04f 0000 	mov.w	r0, #0
     5b4:	f000 fd52 	bl	105c <clockConfigMcgOut>
}
     5b8:	bd80      	pop	{r7, pc}
     5ba:	bf00      	nop

000005bc <systickInit>:

static void systickInit(void)
{
     5bc:	b580      	push	{r7, lr}
     5be:	b082      	sub	sp, #8
     5c0:	af00      	add	r7, sp, #0
    uint32_t freq = clockGetFreq(CLOCK_CORE);
     5c2:	f04f 0002 	mov.w	r0, #2
     5c6:	f000 fce5 	bl	f94 <clockGetFreq>
     5ca:	6078      	str	r0, [r7, #4]

    NVIC_SYSTICK_RELOAD = freq / CH_FREQUENCY - 1;
     5cc:	f24e 0314 	movw	r3, #57364	; 0xe014
     5d0:	f2ce 0300 	movt	r3, #57344	; 0xe000
     5d4:	6879      	ldr	r1, [r7, #4]
     5d6:	f644 52d3 	movw	r2, #19923	; 0x4dd3
     5da:	f2c1 0262 	movt	r2, #4194	; 0x1062
     5de:	fba2 0201 	umull	r0, r2, r2, r1
     5e2:	ea4f 1292 	mov.w	r2, r2, lsr #6
     5e6:	f102 32ff 	add.w	r2, r2, #4294967295
     5ea:	601a      	str	r2, [r3, #0]
    NVIC_SYSTICK_VALUE = 0;
     5ec:	f24e 0318 	movw	r3, #57368	; 0xe018
     5f0:	f2ce 0300 	movt	r3, #57344	; 0xe000
     5f4:	f04f 0200 	mov.w	r2, #0
     5f8:	601a      	str	r2, [r3, #0]
    NVIC_SYSTICK_CONTROL = NVIC_SYSTICK_CONTROL_ENABLE
     5fa:	f24e 0310 	movw	r3, #57360	; 0xe010
     5fe:	f2ce 0300 	movt	r3, #57344	; 0xe000
     602:	f04f 0207 	mov.w	r2, #7
     606:	601a      	str	r2, [r3, #0]
                         | NVIC_SYSTICK_CONTROL_TICKINT
                         | NVIC_SYSTICK_CONTROL_CLKSOURCE;
}
     608:	f107 0708 	add.w	r7, r7, #8
     60c:	46bd      	mov	sp, r7
     60e:	bd80      	pop	{r7, pc}

00000610 <main>:

int main(void)
{
     610:	b580      	push	{r7, lr}
     612:	b082      	sub	sp, #8
     614:	af02      	add	r7, sp, #8
    clocksInit();
     616:	f7ff ffbf 	bl	598 <clocksInit>
    systickInit();
     61a:	f7ff ffcf 	bl	5bc <systickInit>
    chSysInit();
     61e:	f000 fe47 	bl	12b0 <chSysInit>

    gpioConfig(N_LED_ORANGE_PORT, N_LED_ORANGE_PIN, GPIO_OUTPUT | GPIO_LOW);
     622:	f44f 4010 	mov.w	r0, #36864	; 0x9000
     626:	f2c4 0004 	movt	r0, #16388	; 0x4004
     62a:	f04f 010b 	mov.w	r1, #11
     62e:	f04f 0222 	mov.w	r2, #34	; 0x22
     632:	f000 f883 	bl	73c <gpioConfig>
    gpioConfig(N_LED_YELLOW_PORT, N_LED_YELLOW_PIN, GPIO_OUTPUT | GPIO_LOW);
     636:	f44f 4010 	mov.w	r0, #36864	; 0x9000
     63a:	f2c4 0004 	movt	r0, #16388	; 0x4004
     63e:	f04f 011c 	mov.w	r1, #28
     642:	f04f 0222 	mov.w	r2, #34	; 0x22
     646:	f000 f879 	bl	73c <gpioConfig>

    chThdCreateStatic(waThread1, sizeof(waThread1), NORMALPRIO, Thread1, NULL);
     64a:	f04f 0300 	mov.w	r3, #0
     64e:	9300      	str	r3, [sp, #0]
     650:	f240 4030 	movw	r0, #1072	; 0x430
     654:	f2c2 0000 	movt	r0, #8192	; 0x2000
     658:	f44f 71dc 	mov.w	r1, #440	; 0x1b8
     65c:	f04f 0240 	mov.w	r2, #64	; 0x40
     660:	f240 5375 	movw	r3, #1397	; 0x575
     664:	f2c0 0300 	movt	r3, #0
     668:	f001 fa6a 	bl	1b40 <chThdCreateStatic>

    hwInterruptsEnable();
     66c:	b662      	cpsie	i

    while (TRUE) {
        chThdSleepMilliseconds(123);
     66e:	f04f 007b 	mov.w	r0, #123	; 0x7b
     672:	f001 faf5 	bl	1c60 <chThdSleep>
        gpioToggle(N_LED_ORANGE_PORT, N_LED_ORANGE_PIN);
     676:	f44f 4010 	mov.w	r0, #36864	; 0x9000
     67a:	f2c4 0004 	movt	r0, #16388	; 0x4004
     67e:	f04f 010b 	mov.w	r1, #11
     682:	f000 f989 	bl	998 <gpioToggle>
    }
     686:	e7f2      	b.n	66e <main+0x5e>

00000688 <gpioPortGet>:
*
* RETURNS: The corresponding GPIO_BASE_ADDR.
*
*******************************************************************************/
static volatile gpioPort_t *gpioPortGet(uint32_t port)
{
     688:	b580      	push	{r7, lr}
     68a:	b084      	sub	sp, #16
     68c:	af00      	add	r7, sp, #0
     68e:	6078      	str	r0, [r7, #4]
    uint32_t addr;

    switch (port) {
     690:	687b      	ldr	r3, [r7, #4]
     692:	f44f 4230 	mov.w	r2, #45056	; 0xb000
     696:	f2c4 0204 	movt	r2, #16388	; 0x4004
     69a:	4293      	cmp	r3, r2
     69c:	d02b      	beq.n	6f6 <gpioPortGet+0x6e>
     69e:	f44f 4230 	mov.w	r2, #45056	; 0xb000
     6a2:	f2c4 0204 	movt	r2, #16388	; 0x4004
     6a6:	4293      	cmp	r3, r2
     6a8:	d80c      	bhi.n	6c4 <gpioPortGet+0x3c>
     6aa:	f44f 4210 	mov.w	r2, #36864	; 0x9000
     6ae:	f2c4 0204 	movt	r2, #16388	; 0x4004
     6b2:	4293      	cmp	r3, r2
     6b4:	d013      	beq.n	6de <gpioPortGet+0x56>
     6b6:	f44f 4220 	mov.w	r2, #40960	; 0xa000
     6ba:	f2c4 0204 	movt	r2, #16388	; 0x4004
     6be:	4293      	cmp	r3, r2
     6c0:	d013      	beq.n	6ea <gpioPortGet+0x62>
     6c2:	e02a      	b.n	71a <gpioPortGet+0x92>
     6c4:	f44f 4240 	mov.w	r2, #49152	; 0xc000
     6c8:	f2c4 0204 	movt	r2, #16388	; 0x4004
     6cc:	4293      	cmp	r3, r2
     6ce:	d018      	beq.n	702 <gpioPortGet+0x7a>
     6d0:	f44f 4250 	mov.w	r2, #53248	; 0xd000
     6d4:	f2c4 0204 	movt	r2, #16388	; 0x4004
     6d8:	4293      	cmp	r3, r2
     6da:	d018      	beq.n	70e <gpioPortGet+0x86>
     6dc:	e01d      	b.n	71a <gpioPortGet+0x92>
    case PORTA: addr = GPIOA_BASE_ADDR; break;
     6de:	f44f 4370 	mov.w	r3, #61440	; 0xf000
     6e2:	f2c4 030f 	movt	r3, #16399	; 0x400f
     6e6:	60fb      	str	r3, [r7, #12]
     6e8:	e022      	b.n	730 <gpioPortGet+0xa8>
    case PORTB: addr = GPIOB_BASE_ADDR; break;
     6ea:	f24f 0340 	movw	r3, #61504	; 0xf040
     6ee:	f2c4 030f 	movt	r3, #16399	; 0x400f
     6f2:	60fb      	str	r3, [r7, #12]
     6f4:	e01c      	b.n	730 <gpioPortGet+0xa8>
    case PORTC: addr = GPIOC_BASE_ADDR; break;
     6f6:	f24f 0380 	movw	r3, #61568	; 0xf080
     6fa:	f2c4 030f 	movt	r3, #16399	; 0x400f
     6fe:	60fb      	str	r3, [r7, #12]
     700:	e016      	b.n	730 <gpioPortGet+0xa8>
    case PORTD: addr = GPIOD_BASE_ADDR; break;
     702:	f24f 03c0 	movw	r3, #61632	; 0xf0c0
     706:	f2c4 030f 	movt	r3, #16399	; 0x400f
     70a:	60fb      	str	r3, [r7, #12]
     70c:	e010      	b.n	730 <gpioPortGet+0xa8>
    case PORTE: addr = GPIOE_BASE_ADDR; break;
     70e:	f44f 4371 	mov.w	r3, #61696	; 0xf100
     712:	f2c4 030f 	movt	r3, #16399	; 0x400f
     716:	60fb      	str	r3, [r7, #12]
     718:	e00a      	b.n	730 <gpioPortGet+0xa8>
    default:
        assert(0);
     71a:	f642 4020 	movw	r0, #11296	; 0x2c20
     71e:	f2c0 0000 	movt	r0, #0
     722:	f04f 012e 	mov.w	r1, #46	; 0x2e
     726:	f7ff ff1b 	bl	560 <assert_>
        return 0;
     72a:	f04f 0300 	mov.w	r3, #0
     72e:	e000      	b.n	732 <gpioPortGet+0xaa>
    }

    return ((volatile gpioPort_t *) addr);
     730:	68fb      	ldr	r3, [r7, #12]
}
     732:	4618      	mov	r0, r3
     734:	f107 0710 	add.w	r7, r7, #16
     738:	46bd      	mov	sp, r7
     73a:	bd80      	pop	{r7, pc}

0000073c <gpioConfig>:
*
* RETURNS: Nothing
*
*******************************************************************************/
void gpioConfig(uint32_t port, uint32_t pin, uint32_t opt)
{
     73c:	b580      	push	{r7, lr}
     73e:	b088      	sub	sp, #32
     740:	af00      	add	r7, sp, #0
     742:	60f8      	str	r0, [r7, #12]
     744:	60b9      	str	r1, [r7, #8]
     746:	607a      	str	r2, [r7, #4]
    /*
     * Ensure pin number is legal
     */

    assert((pin < 32));
     748:	68bb      	ldr	r3, [r7, #8]
     74a:	2b1f      	cmp	r3, #31
     74c:	d907      	bls.n	75e <gpioConfig+0x22>
     74e:	f642 4020 	movw	r0, #11296	; 0x2c20
     752:	f2c0 0000 	movt	r0, #0
     756:	f04f 0145 	mov.w	r1, #69	; 0x45
     75a:	f7ff ff01 	bl	560 <assert_>

    /*
     * Config the SIM Clock Gate
     */

    switch (port) {
     75e:	68fb      	ldr	r3, [r7, #12]
     760:	f44f 4230 	mov.w	r2, #45056	; 0xb000
     764:	f2c4 0204 	movt	r2, #16388	; 0x4004
     768:	4293      	cmp	r3, r2
     76a:	d039      	beq.n	7e0 <gpioConfig+0xa4>
     76c:	f44f 4230 	mov.w	r2, #45056	; 0xb000
     770:	f2c4 0204 	movt	r2, #16388	; 0x4004
     774:	4293      	cmp	r3, r2
     776:	d80c      	bhi.n	792 <gpioConfig+0x56>
     778:	f44f 4210 	mov.w	r2, #36864	; 0x9000
     77c:	f2c4 0204 	movt	r2, #16388	; 0x4004
     780:	4293      	cmp	r3, r2
     782:	d013      	beq.n	7ac <gpioConfig+0x70>
     784:	f44f 4220 	mov.w	r2, #40960	; 0xa000
     788:	f2c4 0204 	movt	r2, #16388	; 0x4004
     78c:	4293      	cmp	r3, r2
     78e:	d01a      	beq.n	7c6 <gpioConfig+0x8a>
     790:	e04d      	b.n	82e <STACK_SIZE+0x2e>
     792:	f44f 4240 	mov.w	r2, #49152	; 0xc000
     796:	f2c4 0204 	movt	r2, #16388	; 0x4004
     79a:	4293      	cmp	r3, r2
     79c:	d02d      	beq.n	7fa <gpioConfig+0xbe>
     79e:	f44f 4250 	mov.w	r2, #53248	; 0xd000
     7a2:	f2c4 0204 	movt	r2, #16388	; 0x4004
     7a6:	4293      	cmp	r3, r2
     7a8:	d034      	beq.n	814 <STACK_SIZE+0x14>
     7aa:	e040      	b.n	82e <STACK_SIZE+0x2e>
    case PORTA: SIM_SCGC5 |= SIM_SCGC5_PORTA_ENABLE; break;
     7ac:	f248 0338 	movw	r3, #32824	; 0x8038
     7b0:	f2c4 0304 	movt	r3, #16388	; 0x4004
     7b4:	f248 0238 	movw	r2, #32824	; 0x8038
     7b8:	f2c4 0204 	movt	r2, #16388	; 0x4004
     7bc:	6812      	ldr	r2, [r2, #0]
     7be:	f442 7200 	orr.w	r2, r2, #512	; 0x200
     7c2:	601a      	str	r2, [r3, #0]
     7c4:	e03c      	b.n	840 <STACK_SIZE+0x40>
    case PORTB: SIM_SCGC5 |= SIM_SCGC5_PORTB_ENABLE; break;
     7c6:	f248 0338 	movw	r3, #32824	; 0x8038
     7ca:	f2c4 0304 	movt	r3, #16388	; 0x4004
     7ce:	f248 0238 	movw	r2, #32824	; 0x8038
     7d2:	f2c4 0204 	movt	r2, #16388	; 0x4004
     7d6:	6812      	ldr	r2, [r2, #0]
     7d8:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
     7dc:	601a      	str	r2, [r3, #0]
     7de:	e02f      	b.n	840 <STACK_SIZE+0x40>
    case PORTC: SIM_SCGC5 |= SIM_SCGC5_PORTC_ENABLE; break;
     7e0:	f248 0338 	movw	r3, #32824	; 0x8038
     7e4:	f2c4 0304 	movt	r3, #16388	; 0x4004
     7e8:	f248 0238 	movw	r2, #32824	; 0x8038
     7ec:	f2c4 0204 	movt	r2, #16388	; 0x4004
     7f0:	6812      	ldr	r2, [r2, #0]
     7f2:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
     7f6:	601a      	str	r2, [r3, #0]
     7f8:	e022      	b.n	840 <STACK_SIZE+0x40>
    case PORTD: SIM_SCGC5 |= SIM_SCGC5_PORTD_ENABLE; break;
     7fa:	f248 0338 	movw	r3, #32824	; 0x8038
     7fe:	f2c4 0304 	movt	r3, #16388	; 0x4004
     802:	f248 0238 	movw	r2, #32824	; 0x8038
     806:	f2c4 0204 	movt	r2, #16388	; 0x4004
     80a:	6812      	ldr	r2, [r2, #0]
     80c:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
     810:	601a      	str	r2, [r3, #0]
     812:	e015      	b.n	840 <STACK_SIZE+0x40>
    case PORTE: SIM_SCGC5 |= SIM_SCGC5_PORTE_ENABLE; break;
     814:	f248 0338 	movw	r3, #32824	; 0x8038
     818:	f2c4 0304 	movt	r3, #16388	; 0x4004
     81c:	f248 0238 	movw	r2, #32824	; 0x8038
     820:	f2c4 0204 	movt	r2, #16388	; 0x4004
     824:	6812      	ldr	r2, [r2, #0]
     826:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
     82a:	601a      	str	r2, [r3, #0]
     82c:	e008      	b.n	840 <STACK_SIZE+0x40>
    default:
        assert(0);
     82e:	f642 4020 	movw	r0, #11296	; 0x2c20
     832:	f2c0 0000 	movt	r0, #0
     836:	f04f 0152 	mov.w	r1, #82	; 0x52
     83a:	f7ff fe91 	bl	560 <assert_>
        return;
     83e:	e07a      	b.n	936 <STACK_SIZE+0x136>

    /*
     * Configure the Port Controller
     */

    uint32_t portCtrlBits = PORT_MUX_GPIO;
     840:	f44f 7380 	mov.w	r3, #256	; 0x100
     844:	61fb      	str	r3, [r7, #28]

    if (opt & GPIO_OUTPUT) {
     846:	687b      	ldr	r3, [r7, #4]
     848:	f003 0302 	and.w	r3, r3, #2
     84c:	2b00      	cmp	r3, #0
     84e:	d013      	beq.n	878 <STACK_SIZE+0x78>
        if (opt & GPIO_ODE) {
     850:	687b      	ldr	r3, [r7, #4]
     852:	f003 0308 	and.w	r3, r3, #8
     856:	2b00      	cmp	r3, #0
     858:	d004      	beq.n	864 <STACK_SIZE+0x64>
            portCtrlBits |= PORT_ODE;
     85a:	69fb      	ldr	r3, [r7, #28]
     85c:	f043 0320 	orr.w	r3, r3, #32
     860:	61fb      	str	r3, [r7, #28]
     862:	e022      	b.n	8aa <STACK_SIZE+0xaa>
        } else {
            if (opt & GPIO_DSE)
     864:	687b      	ldr	r3, [r7, #4]
     866:	f003 0304 	and.w	r3, r3, #4
     86a:	2b00      	cmp	r3, #0
     86c:	d01d      	beq.n	8aa <STACK_SIZE+0xaa>
                portCtrlBits |= PORT_DSE;
     86e:	69fb      	ldr	r3, [r7, #28]
     870:	f043 0340 	orr.w	r3, r3, #64	; 0x40
     874:	61fb      	str	r3, [r7, #28]
     876:	e018      	b.n	8aa <STACK_SIZE+0xaa>
        }

    } else if (opt & GPIO_INPUT) {
     878:	687b      	ldr	r3, [r7, #4]
     87a:	f003 0301 	and.w	r3, r3, #1
     87e:	b2db      	uxtb	r3, r3
     880:	2b00      	cmp	r3, #0
     882:	d009      	beq.n	898 <STACK_SIZE+0x98>
        if (opt & GPIO_PFE)
     884:	687b      	ldr	r3, [r7, #4]
     886:	f003 0340 	and.w	r3, r3, #64	; 0x40
     88a:	2b00      	cmp	r3, #0
     88c:	d00d      	beq.n	8aa <STACK_SIZE+0xaa>
            portCtrlBits |= PORT_PFE;
     88e:	69fb      	ldr	r3, [r7, #28]
     890:	f043 0310 	orr.w	r3, r3, #16
     894:	61fb      	str	r3, [r7, #28]
     896:	e008      	b.n	8aa <STACK_SIZE+0xaa>

    } else {
        assert(0);
     898:	f642 4020 	movw	r0, #11296	; 0x2c20
     89c:	f2c0 0000 	movt	r0, #0
     8a0:	f04f 0169 	mov.w	r1, #105	; 0x69
     8a4:	f7ff fe5c 	bl	560 <assert_>
        return;
     8a8:	e045      	b.n	936 <STACK_SIZE+0x136>
    }

    if (opt & GPIO_PULLUP)
     8aa:	687b      	ldr	r3, [r7, #4]
     8ac:	f003 0380 	and.w	r3, r3, #128	; 0x80
     8b0:	2b00      	cmp	r3, #0
     8b2:	d004      	beq.n	8be <STACK_SIZE+0xbe>
        portCtrlBits |= PORT_PULLUP_ENABLE;
     8b4:	69fb      	ldr	r3, [r7, #28]
     8b6:	f043 0303 	orr.w	r3, r3, #3
     8ba:	61fb      	str	r3, [r7, #28]
     8bc:	e008      	b.n	8d0 <STACK_SIZE+0xd0>
    else if (opt & GPIO_PULLDOWN)
     8be:	687b      	ldr	r3, [r7, #4]
     8c0:	f403 7380 	and.w	r3, r3, #256	; 0x100
     8c4:	2b00      	cmp	r3, #0
     8c6:	d003      	beq.n	8d0 <STACK_SIZE+0xd0>
        portCtrlBits |= PORT_PULLDOWN_ENABLE;
     8c8:	69fb      	ldr	r3, [r7, #28]
     8ca:	f043 0302 	orr.w	r3, r3, #2
     8ce:	61fb      	str	r3, [r7, #28]

    PORT_PCR(port, pin) = portCtrlBits;
     8d0:	68bb      	ldr	r3, [r7, #8]
     8d2:	ea4f 0283 	mov.w	r2, r3, lsl #2
     8d6:	68fb      	ldr	r3, [r7, #12]
     8d8:	18d3      	adds	r3, r2, r3
     8da:	69fa      	ldr	r2, [r7, #28]
     8dc:	601a      	str	r2, [r3, #0]

    /*
     * Configure the GPIO Controller
     */

    volatile gpioPort_t *gpioPort = gpioPortGet(port);
     8de:	68f8      	ldr	r0, [r7, #12]
     8e0:	f7ff fed2 	bl	688 <gpioPortGet>
     8e4:	61b8      	str	r0, [r7, #24]
    uint32_t pinBit = 1 << pin;
     8e6:	68bb      	ldr	r3, [r7, #8]
     8e8:	f04f 0201 	mov.w	r2, #1
     8ec:	fa02 f303 	lsl.w	r3, r2, r3
     8f0:	617b      	str	r3, [r7, #20]

    if (opt & GPIO_OUTPUT) {
     8f2:	687b      	ldr	r3, [r7, #4]
     8f4:	f003 0302 	and.w	r3, r3, #2
     8f8:	2b00      	cmp	r3, #0
     8fa:	d01c      	beq.n	936 <STACK_SIZE+0x136>
        gpioPort->pddr |= pinBit;
     8fc:	69bb      	ldr	r3, [r7, #24]
     8fe:	695a      	ldr	r2, [r3, #20]
     900:	697b      	ldr	r3, [r7, #20]
     902:	431a      	orrs	r2, r3
     904:	69bb      	ldr	r3, [r7, #24]
     906:	615a      	str	r2, [r3, #20]
        if (opt & GPIO_HIGH)
     908:	687b      	ldr	r3, [r7, #4]
     90a:	f003 0310 	and.w	r3, r3, #16
     90e:	2b00      	cmp	r3, #0
     910:	d006      	beq.n	920 <STACK_SIZE+0x120>
            gpioPort->psor |= pinBit;
     912:	69bb      	ldr	r3, [r7, #24]
     914:	685a      	ldr	r2, [r3, #4]
     916:	697b      	ldr	r3, [r7, #20]
     918:	431a      	orrs	r2, r3
     91a:	69bb      	ldr	r3, [r7, #24]
     91c:	605a      	str	r2, [r3, #4]
     91e:	e00a      	b.n	936 <STACK_SIZE+0x136>
        else if (opt & GPIO_LOW)
     920:	687b      	ldr	r3, [r7, #4]
     922:	f003 0320 	and.w	r3, r3, #32
     926:	2b00      	cmp	r3, #0
     928:	d005      	beq.n	936 <STACK_SIZE+0x136>
            gpioPort->pcor |= pinBit;
     92a:	69bb      	ldr	r3, [r7, #24]
     92c:	689a      	ldr	r2, [r3, #8]
     92e:	697b      	ldr	r3, [r7, #20]
     930:	431a      	orrs	r2, r3
     932:	69bb      	ldr	r3, [r7, #24]
     934:	609a      	str	r2, [r3, #8]
    }
}
     936:	f107 0720 	add.w	r7, r7, #32
     93a:	46bd      	mov	sp, r7
     93c:	bd80      	pop	{r7, pc}
     93e:	bf00      	nop

00000940 <gpioSet>:

/*******************************************************************************
* gpioSet
*******************************************************************************/
void gpioSet(uint32_t port, uint32_t pin)
{
     940:	b580      	push	{r7, lr}
     942:	b084      	sub	sp, #16
     944:	af00      	add	r7, sp, #0
     946:	6078      	str	r0, [r7, #4]
     948:	6039      	str	r1, [r7, #0]
    volatile gpioPort_t *gpioPort = gpioPortGet(port);
     94a:	6878      	ldr	r0, [r7, #4]
     94c:	f7ff fe9c 	bl	688 <gpioPortGet>
     950:	60f8      	str	r0, [r7, #12]
    gpioPort->psor = 1 << pin;
     952:	683b      	ldr	r3, [r7, #0]
     954:	f04f 0201 	mov.w	r2, #1
     958:	fa02 f303 	lsl.w	r3, r2, r3
     95c:	461a      	mov	r2, r3
     95e:	68fb      	ldr	r3, [r7, #12]
     960:	605a      	str	r2, [r3, #4]
}
     962:	f107 0710 	add.w	r7, r7, #16
     966:	46bd      	mov	sp, r7
     968:	bd80      	pop	{r7, pc}
     96a:	bf00      	nop

0000096c <gpioClear>:

/*******************************************************************************
* gpioClear
*******************************************************************************/
void gpioClear(uint32_t port, uint32_t pin)
{
     96c:	b580      	push	{r7, lr}
     96e:	b084      	sub	sp, #16
     970:	af00      	add	r7, sp, #0
     972:	6078      	str	r0, [r7, #4]
     974:	6039      	str	r1, [r7, #0]
    volatile gpioPort_t *gpioPort = gpioPortGet(port);
     976:	6878      	ldr	r0, [r7, #4]
     978:	f7ff fe86 	bl	688 <gpioPortGet>
     97c:	60f8      	str	r0, [r7, #12]
    gpioPort->pcor = 1 << pin;
     97e:	683b      	ldr	r3, [r7, #0]
     980:	f04f 0201 	mov.w	r2, #1
     984:	fa02 f303 	lsl.w	r3, r2, r3
     988:	461a      	mov	r2, r3
     98a:	68fb      	ldr	r3, [r7, #12]
     98c:	609a      	str	r2, [r3, #8]
}
     98e:	f107 0710 	add.w	r7, r7, #16
     992:	46bd      	mov	sp, r7
     994:	bd80      	pop	{r7, pc}
     996:	bf00      	nop

00000998 <gpioToggle>:

/*******************************************************************************
* gpioToggle
*******************************************************************************/
void gpioToggle(uint32_t port, uint32_t pin)
{
     998:	b580      	push	{r7, lr}
     99a:	b084      	sub	sp, #16
     99c:	af00      	add	r7, sp, #0
     99e:	6078      	str	r0, [r7, #4]
     9a0:	6039      	str	r1, [r7, #0]
    volatile gpioPort_t *gpioPort = gpioPortGet(port);
     9a2:	6878      	ldr	r0, [r7, #4]
     9a4:	f7ff fe70 	bl	688 <gpioPortGet>
     9a8:	60f8      	str	r0, [r7, #12]
    gpioPort->ptor = 1 << pin;
     9aa:	683b      	ldr	r3, [r7, #0]
     9ac:	f04f 0201 	mov.w	r2, #1
     9b0:	fa02 f303 	lsl.w	r3, r2, r3
     9b4:	461a      	mov	r2, r3
     9b6:	68fb      	ldr	r3, [r7, #12]
     9b8:	60da      	str	r2, [r3, #12]
}
     9ba:	f107 0710 	add.w	r7, r7, #16
     9be:	46bd      	mov	sp, r7
     9c0:	bd80      	pop	{r7, pc}
     9c2:	bf00      	nop

000009c4 <gpioPortWrite>:
*
* RETURNS:
*
*******************************************************************************/
void gpioPortWrite(uint32_t port, uint32_t mask, uint32_t value)
{
     9c4:	b480      	push	{r7}
     9c6:	b085      	sub	sp, #20
     9c8:	af00      	add	r7, sp, #0
     9ca:	60f8      	str	r0, [r7, #12]
     9cc:	60b9      	str	r1, [r7, #8]
     9ce:	607a      	str	r2, [r7, #4]
}
     9d0:	f107 0714 	add.w	r7, r7, #20
     9d4:	46bd      	mov	sp, r7
     9d6:	bc80      	pop	{r7}
     9d8:	4770      	bx	lr
     9da:	bf00      	nop

000009dc <gpioPortRead>:
*
* RETURNS:
*
*******************************************************************************/
uint32_t gpioPortRead(uint32_t port)
{
     9dc:	b480      	push	{r7}
     9de:	b083      	sub	sp, #12
     9e0:	af00      	add	r7, sp, #0
     9e2:	6078      	str	r0, [r7, #4]
    return 0;
     9e4:	f04f 0300 	mov.w	r3, #0
}
     9e8:	4618      	mov	r0, r3
     9ea:	f107 070c 	add.w	r7, r7, #12
     9ee:	46bd      	mov	sp, r7
     9f0:	bc80      	pop	{r7}
     9f2:	4770      	bx	lr

000009f4 <gpioRead>:
*
* RETURNS:
*
*******************************************************************************/
uint32_t gpioRead(uint32_t port, uint32_t pin)
{
     9f4:	b580      	push	{r7, lr}
     9f6:	b084      	sub	sp, #16
     9f8:	af00      	add	r7, sp, #0
     9fa:	6078      	str	r0, [r7, #4]
     9fc:	6039      	str	r1, [r7, #0]
    volatile gpioPort_t *gpioPort = gpioPortGet(port);
     9fe:	6878      	ldr	r0, [r7, #4]
     a00:	f7ff fe42 	bl	688 <gpioPortGet>
     a04:	60f8      	str	r0, [r7, #12]
    return ((gpioPort->pdir & (1 << pin)) ? TRUE : FALSE);
     a06:	68fb      	ldr	r3, [r7, #12]
     a08:	691a      	ldr	r2, [r3, #16]
     a0a:	683b      	ldr	r3, [r7, #0]
     a0c:	f04f 0101 	mov.w	r1, #1
     a10:	fa01 f303 	lsl.w	r3, r1, r3
     a14:	4013      	ands	r3, r2
     a16:	2b00      	cmp	r3, #0
     a18:	bf0c      	ite	eq
     a1a:	2300      	moveq	r3, #0
     a1c:	2301      	movne	r3, #1
}
     a1e:	4618      	mov	r0, r3
     a20:	f107 0710 	add.w	r7, r7, #16
     a24:	46bd      	mov	sp, r7
     a26:	bd80      	pop	{r7, pc}

00000a28 <fei2fee>:
    .flashDiv     = FLASH_DIVIDER_DFLT,
};


static void fei2fee(clockConfig_t cc)
{
     a28:	b480      	push	{r7}
     a2a:	b083      	sub	sp, #12
     a2c:	af00      	add	r7, sp, #0
     a2e:	4603      	mov	r3, r0
     a30:	71fb      	strb	r3, [r7, #7]
     * Uno problemo: The largest divide factor available by FRDIV is 1024... And
     * 50MHz / 1024 = 48.3 kHz, which exceeds the 39.0625 kHz range. With our
     * setup, it doesn't seem that we can reach a FEE mode (and I don't want to
     * risk the tower to see what could happen if I did!)
     */
}
     a32:	f107 070c 	add.w	r7, r7, #12
     a36:	46bd      	mov	sp, r7
     a38:	bc80      	pop	{r7}
     a3a:	4770      	bx	lr

00000a3c <fei2pee>:

static void fei2pee(clockConfig_t cc)
{
     a3c:	b480      	push	{r7}
     a3e:	b083      	sub	sp, #12
     a40:	af00      	add	r7, sp, #0
     a42:	4603      	mov	r3, r0
     a44:	71fb      	strb	r3, [r7, #7]
                                                    /* External crystal setup */
    /* Select the OSCCLK */
    SIM_SOPT2 &= ~SIM_SOPT2_MCGCLKSEL;
     a46:	f248 0304 	movw	r3, #32772	; 0x8004
     a4a:	f2c4 0304 	movt	r3, #16388	; 0x4004
     a4e:	f248 0204 	movw	r2, #32772	; 0x8004
     a52:	f2c4 0204 	movt	r2, #16388	; 0x4004
     a56:	6812      	ldr	r2, [r2, #0]
     a58:	f022 0201 	bic.w	r2, r2, #1
     a5c:	601a      	str	r2, [r3, #0]
     * Enabling the XTAL for 50MHz
     * RANGE=1, match the frequency of the crystal being used
     * HGO=1,   set for high gain operation (best against noise)
     * EREFS=1, enable the external oscillator
     */
    clock.mcg->c2 = (MCG_C2_RANGE_MASK & (0x1 << 4)) |
     a5e:	f240 4300 	movw	r3, #1024	; 0x400
     a62:	f2c2 0300 	movt	r3, #8192	; 0x2000
     a66:	681b      	ldr	r3, [r3, #0]
     a68:	f04f 021c 	mov.w	r2, #28
     a6c:	705a      	strb	r2, [r3, #1]
     * mode from FBE (here we are going to PEE)
     *
     * IREFS=0, select external reference clock and enable the external
     * oscillator.
     */
    clock.mcg->c1 = ((MCG_C1_CLKS_MASK & (0x2 << 6)) |
     a6e:	f240 4300 	movw	r3, #1024	; 0x400
     a72:	f2c2 0300 	movt	r3, #8192	; 0x2000
     a76:	681b      	ldr	r3, [r3, #0]
     a78:	f04f 0298 	mov.w	r2, #152	; 0x98
     a7c:	701a      	strb	r2, [r3, #0]
                    (MCG_C1_FRDIV_MASK & (0x3 << 3))) &
                    (~MCG_C1_IREFS);

                                                    /* Wait for status update */
    /* Wait for oscillator to initialize */
    while (!(clock.mcg->s & MCG_S_OSCINIT)) {}
     a7e:	bf00      	nop
     a80:	f240 4300 	movw	r3, #1024	; 0x400
     a84:	f2c2 0300 	movt	r3, #8192	; 0x2000
     a88:	681b      	ldr	r3, [r3, #0]
     a8a:	799b      	ldrb	r3, [r3, #6]
     a8c:	b2db      	uxtb	r3, r3
     a8e:	f003 0302 	and.w	r3, r3, #2
     a92:	2b00      	cmp	r3, #0
     a94:	d0f4      	beq.n	a80 <fei2pee+0x44>
    /* Wait for reference clock's to become the external reference */
    while (clock.mcg->s & MCG_S_IREFST) {}
     a96:	bf00      	nop
     a98:	f240 4300 	movw	r3, #1024	; 0x400
     a9c:	f2c2 0300 	movt	r3, #8192	; 0x2000
     aa0:	681b      	ldr	r3, [r3, #0]
     aa2:	799b      	ldrb	r3, [r3, #6]
     aa4:	b2db      	uxtb	r3, r3
     aa6:	f003 0310 	and.w	r3, r3, #16
     aaa:	2b00      	cmp	r3, #0
     aac:	d1f4      	bne.n	a98 <fei2pee+0x5c>
    /* Wait for the indicator that MCGOTUCLK is fed by the external ref clock */
    while ((clock.mcg->s & MCG_S_CLKST_MASK) != (0x2 << 2)) {}
     aae:	bf00      	nop
     ab0:	f240 4300 	movw	r3, #1024	; 0x400
     ab4:	f2c2 0300 	movt	r3, #8192	; 0x2000
     ab8:	681b      	ldr	r3, [r3, #0]
     aba:	799b      	ldrb	r3, [r3, #6]
     abc:	b2db      	uxtb	r3, r3
     abe:	f003 030c 	and.w	r3, r3, #12
     ac2:	2b08      	cmp	r3, #8
     ac4:	d1f4      	bne.n	ab0 <fei2pee+0x74>

                                            /* Generate correct PLL frequency */
    clock.mcg->c5 &= 0xE0; /* clear bits */
     ac6:	f240 4300 	movw	r3, #1024	; 0x400
     aca:	f2c2 0300 	movt	r3, #8192	; 0x2000
     ace:	681a      	ldr	r2, [r3, #0]
     ad0:	f240 4300 	movw	r3, #1024	; 0x400
     ad4:	f2c2 0300 	movt	r3, #8192	; 0x2000
     ad8:	681b      	ldr	r3, [r3, #0]
     ada:	791b      	ldrb	r3, [r3, #4]
     adc:	b2db      	uxtb	r3, r3
     ade:	f023 031f 	bic.w	r3, r3, #31
     ae2:	b2db      	uxtb	r3, r3
     ae4:	7113      	strb	r3, [r2, #4]
    clock.mcg->c5 |= clockConfigParam[cc].divider;
     ae6:	f240 4300 	movw	r3, #1024	; 0x400
     aea:	f2c2 0300 	movt	r3, #8192	; 0x2000
     aee:	6819      	ldr	r1, [r3, #0]
     af0:	f240 4300 	movw	r3, #1024	; 0x400
     af4:	f2c2 0300 	movt	r3, #8192	; 0x2000
     af8:	681b      	ldr	r3, [r3, #0]
     afa:	791b      	ldrb	r3, [r3, #4]
     afc:	b2d8      	uxtb	r0, r3
     afe:	79fb      	ldrb	r3, [r7, #7]
     b00:	f240 420c 	movw	r2, #1036	; 0x40c
     b04:	f2c2 0200 	movt	r2, #8192	; 0x2000
     b08:	ea4f 03c3 	mov.w	r3, r3, lsl #3
     b0c:	18d3      	adds	r3, r2, r3
     b0e:	785b      	ldrb	r3, [r3, #1]
     b10:	4303      	orrs	r3, r0
     b12:	b2db      	uxtb	r3, r3
     b14:	710b      	strb	r3, [r1, #4]
    clock.mcg->c6 &= 0xE0;
     b16:	f240 4300 	movw	r3, #1024	; 0x400
     b1a:	f2c2 0300 	movt	r3, #8192	; 0x2000
     b1e:	681a      	ldr	r2, [r3, #0]
     b20:	f240 4300 	movw	r3, #1024	; 0x400
     b24:	f2c2 0300 	movt	r3, #8192	; 0x2000
     b28:	681b      	ldr	r3, [r3, #0]
     b2a:	795b      	ldrb	r3, [r3, #5]
     b2c:	b2db      	uxtb	r3, r3
     b2e:	f023 031f 	bic.w	r3, r3, #31
     b32:	b2db      	uxtb	r3, r3
     b34:	7153      	strb	r3, [r2, #5]
    clock.mcg->c6 |= clockConfigParam[cc].multiplier;
     b36:	f240 4300 	movw	r3, #1024	; 0x400
     b3a:	f2c2 0300 	movt	r3, #8192	; 0x2000
     b3e:	6819      	ldr	r1, [r3, #0]
     b40:	f240 4300 	movw	r3, #1024	; 0x400
     b44:	f2c2 0300 	movt	r3, #8192	; 0x2000
     b48:	681b      	ldr	r3, [r3, #0]
     b4a:	795b      	ldrb	r3, [r3, #5]
     b4c:	b2d8      	uxtb	r0, r3
     b4e:	79fb      	ldrb	r3, [r7, #7]
     b50:	f240 420c 	movw	r2, #1036	; 0x40c
     b54:	f2c2 0200 	movt	r2, #8192	; 0x2000
     b58:	ea4f 03c3 	mov.w	r3, r3, lsl #3
     b5c:	18d3      	adds	r3, r2, r3
     b5e:	789b      	ldrb	r3, [r3, #2]
     b60:	4303      	orrs	r3, r0
     b62:	b2db      	uxtb	r3, r3
     b64:	714b      	strb	r3, [r1, #5]
                                                            /* Enter PBE mode */
    /* PLLS=1, select the PLL. */
    clock.mcg->c6 |= MCG_C6_PLLS;
     b66:	f240 4300 	movw	r3, #1024	; 0x400
     b6a:	f2c2 0300 	movt	r3, #8192	; 0x2000
     b6e:	681a      	ldr	r2, [r3, #0]
     b70:	f240 4300 	movw	r3, #1024	; 0x400
     b74:	f2c2 0300 	movt	r3, #8192	; 0x2000
     b78:	681b      	ldr	r3, [r3, #0]
     b7a:	795b      	ldrb	r3, [r3, #5]
     b7c:	b2db      	uxtb	r3, r3
     b7e:	f043 0340 	orr.w	r3, r3, #64	; 0x40
     b82:	b2db      	uxtb	r3, r3
     b84:	7153      	strb	r3, [r2, #5]

                                                    /* Wait for status update */
    /* Wait for the PLL to be the clock source */
    while (!(clock.mcg->s & MCG_S_PLLST)) {}
     b86:	bf00      	nop
     b88:	f240 4300 	movw	r3, #1024	; 0x400
     b8c:	f2c2 0300 	movt	r3, #8192	; 0x2000
     b90:	681b      	ldr	r3, [r3, #0]
     b92:	799b      	ldrb	r3, [r3, #6]
     b94:	b2db      	uxtb	r3, r3
     b96:	f003 0320 	and.w	r3, r3, #32
     b9a:	2b00      	cmp	r3, #0
     b9c:	d0f4      	beq.n	b88 <fei2pee+0x14c>
    /* Wait until the PLL has acquired lock on the external frequency */
    while (!(clock.mcg->s & MCG_S_LOCK)) {}
     b9e:	bf00      	nop
     ba0:	f240 4300 	movw	r3, #1024	; 0x400
     ba4:	f2c2 0300 	movt	r3, #8192	; 0x2000
     ba8:	681b      	ldr	r3, [r3, #0]
     baa:	799b      	ldrb	r3, [r3, #6]
     bac:	b2db      	uxtb	r3, r3
     bae:	f003 0340 	and.w	r3, r3, #64	; 0x40
     bb2:	2b00      	cmp	r3, #0
     bb4:	d0f4      	beq.n	ba0 <fei2pee+0x164>

                                                            /* Enter PEE mode */
    /* Select the output of the PLL */
    clock.mcg->c1 &= ~MCG_C1_CLKS_MASK;
     bb6:	f240 4300 	movw	r3, #1024	; 0x400
     bba:	f2c2 0300 	movt	r3, #8192	; 0x2000
     bbe:	681a      	ldr	r2, [r3, #0]
     bc0:	f240 4300 	movw	r3, #1024	; 0x400
     bc4:	f2c2 0300 	movt	r3, #8192	; 0x2000
     bc8:	681b      	ldr	r3, [r3, #0]
     bca:	781b      	ldrb	r3, [r3, #0]
     bcc:	b2db      	uxtb	r3, r3
     bce:	f003 033f 	and.w	r3, r3, #63	; 0x3f
     bd2:	b2db      	uxtb	r3, r3
     bd4:	7013      	strb	r3, [r2, #0]

                                                    /* Wait for status update */
    /* Wait until output of the PLL is selected */
    while ((clock.mcg->s & MCG_S_CLKST_MASK) != (0x3 << 2)) {}
     bd6:	bf00      	nop
     bd8:	f240 4300 	movw	r3, #1024	; 0x400
     bdc:	f2c2 0300 	movt	r3, #8192	; 0x2000
     be0:	681b      	ldr	r3, [r3, #0]
     be2:	799b      	ldrb	r3, [r3, #6]
     be4:	b2db      	uxtb	r3, r3
     be6:	f003 030c 	and.w	r3, r3, #12
     bea:	2b0c      	cmp	r3, #12
     bec:	d1f4      	bne.n	bd8 <fei2pee+0x19c>

    mcgState.currentMode = MODE_PEE;
     bee:	f240 53e8 	movw	r3, #1512	; 0x5e8
     bf2:	f2c2 0300 	movt	r3, #8192	; 0x2000
     bf6:	f04f 0202 	mov.w	r2, #2
     bfa:	701a      	strb	r2, [r3, #0]
}
     bfc:	f107 070c 	add.w	r7, r7, #12
     c00:	46bd      	mov	sp, r7
     c02:	bc80      	pop	{r7}
     c04:	4770      	bx	lr
     c06:	bf00      	nop

00000c08 <fei2blpi>:

static void fei2blpi(clockConfig_t cc)
{
     c08:	b480      	push	{r7}
     c0a:	b083      	sub	sp, #12
     c0c:	af00      	add	r7, sp, #0
     c0e:	4603      	mov	r3, r0
     c10:	71fb      	strb	r3, [r7, #7]
                                                            /* Not configured */
}
     c12:	f107 070c 	add.w	r7, r7, #12
     c16:	46bd      	mov	sp, r7
     c18:	bc80      	pop	{r7}
     c1a:	4770      	bx	lr

00000c1c <fei2blpe>:

static void fei2blpe(clockConfig_t cc)
{
     c1c:	b480      	push	{r7}
     c1e:	b083      	sub	sp, #12
     c20:	af00      	add	r7, sp, #0
     c22:	4603      	mov	r3, r0
     c24:	71fb      	strb	r3, [r7, #7]
                                                            /* Not configured */
}
     c26:	f107 070c 	add.w	r7, r7, #12
     c2a:	46bd      	mov	sp, r7
     c2c:	bc80      	pop	{r7}
     c2e:	4770      	bx	lr

00000c30 <fee2fei>:


static void fee2fei(clockConfig_t cc)
{
     c30:	b480      	push	{r7}
     c32:	b083      	sub	sp, #12
     c34:	af00      	add	r7, sp, #0
     c36:	4603      	mov	r3, r0
     c38:	71fb      	strb	r3, [r7, #7]
                                                            /* Not configured */
}
     c3a:	f107 070c 	add.w	r7, r7, #12
     c3e:	46bd      	mov	sp, r7
     c40:	bc80      	pop	{r7}
     c42:	4770      	bx	lr

00000c44 <fee2pee>:

static void fee2pee(clockConfig_t cc)
{
     c44:	b480      	push	{r7}
     c46:	b083      	sub	sp, #12
     c48:	af00      	add	r7, sp, #0
     c4a:	4603      	mov	r3, r0
     c4c:	71fb      	strb	r3, [r7, #7]
                                                            /* Not configured */
}
     c4e:	f107 070c 	add.w	r7, r7, #12
     c52:	46bd      	mov	sp, r7
     c54:	bc80      	pop	{r7}
     c56:	4770      	bx	lr

00000c58 <fee2blpi>:

static void fee2blpi(clockConfig_t cc)
{
     c58:	b480      	push	{r7}
     c5a:	b083      	sub	sp, #12
     c5c:	af00      	add	r7, sp, #0
     c5e:	4603      	mov	r3, r0
     c60:	71fb      	strb	r3, [r7, #7]
                                                            /* Not configured */
}
     c62:	f107 070c 	add.w	r7, r7, #12
     c66:	46bd      	mov	sp, r7
     c68:	bc80      	pop	{r7}
     c6a:	4770      	bx	lr

00000c6c <fee2blpe>:

static void fee2blpe(clockConfig_t cc)
{
     c6c:	b480      	push	{r7}
     c6e:	b083      	sub	sp, #12
     c70:	af00      	add	r7, sp, #0
     c72:	4603      	mov	r3, r0
     c74:	71fb      	strb	r3, [r7, #7]
                                                            /* Not configured */
}
     c76:	f107 070c 	add.w	r7, r7, #12
     c7a:	46bd      	mov	sp, r7
     c7c:	bc80      	pop	{r7}
     c7e:	4770      	bx	lr

00000c80 <pee2fei>:


static void pee2fei(clockConfig_t cc)
{
     c80:	b480      	push	{r7}
     c82:	b083      	sub	sp, #12
     c84:	af00      	add	r7, sp, #0
     c86:	4603      	mov	r3, r0
     c88:	71fb      	strb	r3, [r7, #7]

                                                            /* Enter PBE mode */
    clock.mcg->c1 = (MCG_C1_CLKS_MASK & (0x2 << 6)); /* Select external clock */
     c8a:	f240 4300 	movw	r3, #1024	; 0x400
     c8e:	f2c2 0300 	movt	r3, #8192	; 0x2000
     c92:	681b      	ldr	r3, [r3, #0]
     c94:	f04f 0280 	mov.w	r2, #128	; 0x80
     c98:	701a      	strb	r2, [r3, #0]

                                                    /* Wait for status update */
    while ((clock.mcg->s & MCG_S_CLKST_MASK) != (0x2 << 2)) {}
     c9a:	bf00      	nop
     c9c:	f240 4300 	movw	r3, #1024	; 0x400
     ca0:	f2c2 0300 	movt	r3, #8192	; 0x2000
     ca4:	681b      	ldr	r3, [r3, #0]
     ca6:	799b      	ldrb	r3, [r3, #6]
     ca8:	b2db      	uxtb	r3, r3
     caa:	f003 030c 	and.w	r3, r3, #12
     cae:	2b08      	cmp	r3, #8
     cb0:	d1f4      	bne.n	c9c <pee2fei+0x1c>

                                                            /* Enter FBE mode */
    /*
     * With the FLL frequency valid, we can now clear the PLLS bit to select FLL
     */
    clock.mcg->c6 &= ~MCG_C6_PLLS;
     cb2:	f240 4300 	movw	r3, #1024	; 0x400
     cb6:	f2c2 0300 	movt	r3, #8192	; 0x2000
     cba:	681a      	ldr	r2, [r3, #0]
     cbc:	f240 4300 	movw	r3, #1024	; 0x400
     cc0:	f2c2 0300 	movt	r3, #8192	; 0x2000
     cc4:	681b      	ldr	r3, [r3, #0]
     cc6:	795b      	ldrb	r3, [r3, #5]
     cc8:	b2db      	uxtb	r3, r3
     cca:	f023 0340 	bic.w	r3, r3, #64	; 0x40
     cce:	b2db      	uxtb	r3, r3
     cd0:	7153      	strb	r3, [r2, #5]

                                                    /* Wait for status update */
    /* Wait until the current source is FLL */
    while (clock.mcg->s & MCG_S_PLLST) {}
     cd2:	bf00      	nop
     cd4:	f240 4300 	movw	r3, #1024	; 0x400
     cd8:	f2c2 0300 	movt	r3, #8192	; 0x2000
     cdc:	681b      	ldr	r3, [r3, #0]
     cde:	799b      	ldrb	r3, [r3, #6]
     ce0:	b2db      	uxtb	r3, r3
     ce2:	f003 0320 	and.w	r3, r3, #32
     ce6:	2b00      	cmp	r3, #0
     ce8:	d1f4      	bne.n	cd4 <pee2fei+0x54>

                                            /* Generate correct FLL frequency */
    clock.mcg->c4 = clockConfigParam[cc].multiplier;
     cea:	f240 4300 	movw	r3, #1024	; 0x400
     cee:	f2c2 0300 	movt	r3, #8192	; 0x2000
     cf2:	6819      	ldr	r1, [r3, #0]
     cf4:	79fb      	ldrb	r3, [r7, #7]
     cf6:	f240 420c 	movw	r2, #1036	; 0x40c
     cfa:	f2c2 0200 	movt	r2, #8192	; 0x2000
     cfe:	ea4f 03c3 	mov.w	r3, r3, lsl #3
     d02:	18d3      	adds	r3, r2, r3
     d04:	789b      	ldrb	r3, [r3, #2]
     d06:	70cb      	strb	r3, [r1, #3]

                                                            /* Enter FEI mode */
    clock.mcg->c1 = (MCG_C1_CLKS_MASK & (0x0 << 6)) |
     d08:	f240 4300 	movw	r3, #1024	; 0x400
     d0c:	f2c2 0300 	movt	r3, #8192	; 0x2000
     d10:	681b      	ldr	r3, [r3, #0]
     d12:	f04f 0204 	mov.w	r2, #4
     d16:	701a      	strb	r2, [r3, #0]
                    (MCG_C1_IREFS);

                                                    /* Wait for status update */
    /* Wait for reference clock's to become the internal reference */
    while (!(clock.mcg->s & MCG_S_IREFST)) {}
     d18:	bf00      	nop
     d1a:	f240 4300 	movw	r3, #1024	; 0x400
     d1e:	f2c2 0300 	movt	r3, #8192	; 0x2000
     d22:	681b      	ldr	r3, [r3, #0]
     d24:	799b      	ldrb	r3, [r3, #6]
     d26:	b2db      	uxtb	r3, r3
     d28:	f003 0310 	and.w	r3, r3, #16
     d2c:	2b00      	cmp	r3, #0
     d2e:	d0f4      	beq.n	d1a <pee2fei+0x9a>
    /* Wait until the output of the FLL is selected */
    while ((clock.mcg->s & MCG_S_CLKST_MASK) != (0x0 << 2)) {}
     d30:	bf00      	nop
     d32:	f240 4300 	movw	r3, #1024	; 0x400
     d36:	f2c2 0300 	movt	r3, #8192	; 0x2000
     d3a:	681b      	ldr	r3, [r3, #0]
     d3c:	799b      	ldrb	r3, [r3, #6]
     d3e:	b2db      	uxtb	r3, r3
     d40:	f003 030c 	and.w	r3, r3, #12
     d44:	2b00      	cmp	r3, #0
     d46:	d1f4      	bne.n	d32 <pee2fei+0xb2>

    mcgState.currentMode = MODE_FEI;
     d48:	f240 53e8 	movw	r3, #1512	; 0x5e8
     d4c:	f2c2 0300 	movt	r3, #8192	; 0x2000
     d50:	f04f 0200 	mov.w	r2, #0
     d54:	701a      	strb	r2, [r3, #0]
}
     d56:	f107 070c 	add.w	r7, r7, #12
     d5a:	46bd      	mov	sp, r7
     d5c:	bc80      	pop	{r7}
     d5e:	4770      	bx	lr

00000d60 <pee2fee>:

static void pee2fee(clockConfig_t cc)
{
     d60:	b480      	push	{r7}
     d62:	b083      	sub	sp, #12
     d64:	af00      	add	r7, sp, #0
     d66:	4603      	mov	r3, r0
     d68:	71fb      	strb	r3, [r7, #7]
                                                            /* Not configured */
}
     d6a:	f107 070c 	add.w	r7, r7, #12
     d6e:	46bd      	mov	sp, r7
     d70:	bc80      	pop	{r7}
     d72:	4770      	bx	lr

00000d74 <pee2blpi>:

static void pee2blpi(clockConfig_t cc)
{
     d74:	b480      	push	{r7}
     d76:	b083      	sub	sp, #12
     d78:	af00      	add	r7, sp, #0
     d7a:	4603      	mov	r3, r0
     d7c:	71fb      	strb	r3, [r7, #7]
                                                            /* Not configured */
}
     d7e:	f107 070c 	add.w	r7, r7, #12
     d82:	46bd      	mov	sp, r7
     d84:	bc80      	pop	{r7}
     d86:	4770      	bx	lr

00000d88 <pee2blpe>:

static void pee2blpe(clockConfig_t cc)
{
     d88:	b480      	push	{r7}
     d8a:	b083      	sub	sp, #12
     d8c:	af00      	add	r7, sp, #0
     d8e:	4603      	mov	r3, r0
     d90:	71fb      	strb	r3, [r7, #7]
                                                            /* Not configured */
}
     d92:	f107 070c 	add.w	r7, r7, #12
     d96:	46bd      	mov	sp, r7
     d98:	bc80      	pop	{r7}
     d9a:	4770      	bx	lr

00000d9c <blpi2fei>:


static void blpi2fei(clockConfig_t cc)
{
     d9c:	b480      	push	{r7}
     d9e:	b083      	sub	sp, #12
     da0:	af00      	add	r7, sp, #0
     da2:	4603      	mov	r3, r0
     da4:	71fb      	strb	r3, [r7, #7]
                                                            /* Not configured */
}
     da6:	f107 070c 	add.w	r7, r7, #12
     daa:	46bd      	mov	sp, r7
     dac:	bc80      	pop	{r7}
     dae:	4770      	bx	lr

00000db0 <blpi2fee>:

static void blpi2fee(clockConfig_t cc)
{
     db0:	b480      	push	{r7}
     db2:	b083      	sub	sp, #12
     db4:	af00      	add	r7, sp, #0
     db6:	4603      	mov	r3, r0
     db8:	71fb      	strb	r3, [r7, #7]
                                                            /* Not configured */
}
     dba:	f107 070c 	add.w	r7, r7, #12
     dbe:	46bd      	mov	sp, r7
     dc0:	bc80      	pop	{r7}
     dc2:	4770      	bx	lr

00000dc4 <blpi2pee>:

static void blpi2pee(clockConfig_t cc)
{
     dc4:	b480      	push	{r7}
     dc6:	b083      	sub	sp, #12
     dc8:	af00      	add	r7, sp, #0
     dca:	4603      	mov	r3, r0
     dcc:	71fb      	strb	r3, [r7, #7]
                                                            /* Not configured */
}
     dce:	f107 070c 	add.w	r7, r7, #12
     dd2:	46bd      	mov	sp, r7
     dd4:	bc80      	pop	{r7}
     dd6:	4770      	bx	lr

00000dd8 <blpi2blpe>:

static void blpi2blpe(clockConfig_t cc)
{
     dd8:	b480      	push	{r7}
     dda:	b083      	sub	sp, #12
     ddc:	af00      	add	r7, sp, #0
     dde:	4603      	mov	r3, r0
     de0:	71fb      	strb	r3, [r7, #7]
                                                            /* Not configured */
}
     de2:	f107 070c 	add.w	r7, r7, #12
     de6:	46bd      	mov	sp, r7
     de8:	bc80      	pop	{r7}
     dea:	4770      	bx	lr

00000dec <blpe2fei>:


static void blpe2fei(clockConfig_t cc)
{
     dec:	b480      	push	{r7}
     dee:	b083      	sub	sp, #12
     df0:	af00      	add	r7, sp, #0
     df2:	4603      	mov	r3, r0
     df4:	71fb      	strb	r3, [r7, #7]
                                                            /* Not configured */
}
     df6:	f107 070c 	add.w	r7, r7, #12
     dfa:	46bd      	mov	sp, r7
     dfc:	bc80      	pop	{r7}
     dfe:	4770      	bx	lr

00000e00 <blpe2fee>:

static void blpe2fee(clockConfig_t cc)
{
     e00:	b480      	push	{r7}
     e02:	b083      	sub	sp, #12
     e04:	af00      	add	r7, sp, #0
     e06:	4603      	mov	r3, r0
     e08:	71fb      	strb	r3, [r7, #7]
                                                            /* Not configured */
}
     e0a:	f107 070c 	add.w	r7, r7, #12
     e0e:	46bd      	mov	sp, r7
     e10:	bc80      	pop	{r7}
     e12:	4770      	bx	lr

00000e14 <blpe2pee>:

static void blpe2pee(clockConfig_t cc)
{
     e14:	b480      	push	{r7}
     e16:	b083      	sub	sp, #12
     e18:	af00      	add	r7, sp, #0
     e1a:	4603      	mov	r3, r0
     e1c:	71fb      	strb	r3, [r7, #7]
                                                            /* Not configured */
}
     e1e:	f107 070c 	add.w	r7, r7, #12
     e22:	46bd      	mov	sp, r7
     e24:	bc80      	pop	{r7}
     e26:	4770      	bx	lr

00000e28 <blpe2blpi>:

static void blpe2blpi(clockConfig_t cc)
{
     e28:	b480      	push	{r7}
     e2a:	b083      	sub	sp, #12
     e2c:	af00      	add	r7, sp, #0
     e2e:	4603      	mov	r3, r0
     e30:	71fb      	strb	r3, [r7, #7]
                                                            /* Not configured */
}
     e32:	f107 070c 	add.w	r7, r7, #12
     e36:	46bd      	mov	sp, r7
     e38:	bc80      	pop	{r7}
     e3a:	4770      	bx	lr

00000e3c <clockSetDividers>:
* system, bus, flexbus, and flash clock frequencies.
*
*******************************************************************************/
void clockSetDividers(divider_t systemDiv, divider_t busDiv,
                                       divider_t flexBusDiv, divider_t flashDiv)
{
     e3c:	b580      	push	{r7, lr}
     e3e:	b084      	sub	sp, #16
     e40:	af00      	add	r7, sp, #0
     e42:	71f8      	strb	r0, [r7, #7]
     e44:	71b9      	strb	r1, [r7, #6]
     e46:	717a      	strb	r2, [r7, #5]
     e48:	713b      	strb	r3, [r7, #4]
    int mcgClock = clockFreq.mcgClockFreq;
     e4a:	f240 4324 	movw	r3, #1060	; 0x424
     e4e:	f2c2 0300 	movt	r3, #8192	; 0x2000
     e52:	681b      	ldr	r3, [r3, #0]
     e54:	60fb      	str	r3, [r7, #12]

    /*
     * The asserts are raised when the internal clock requirements (sec. 5.5)
     * are not met.
     */
    assert( (mcgClock / (systemDiv +1)) <= MAX_SYSTEM_FREQ);
     e56:	79fb      	ldrb	r3, [r7, #7]
     e58:	f103 0301 	add.w	r3, r3, #1
     e5c:	68fa      	ldr	r2, [r7, #12]
     e5e:	fb92 f2f3 	sdiv	r2, r2, r3
     e62:	f44f 4361 	mov.w	r3, #57600	; 0xe100
     e66:	f2c0 53f5 	movt	r3, #1525	; 0x5f5
     e6a:	429a      	cmp	r2, r3
     e6c:	dd07      	ble.n	e7e <clockSetDividers+0x42>
     e6e:	f642 403c 	movw	r0, #11324	; 0x2c3c
     e72:	f2c0 0000 	movt	r0, #0
     e76:	f240 1179 	movw	r1, #377	; 0x179
     e7a:	f7ff fb71 	bl	560 <assert_>

    assert( (mcgClock / (busDiv    +1)) <= MAX_BUS_FREQ &&
     e7e:	79bb      	ldrb	r3, [r7, #6]
     e80:	f103 0301 	add.w	r3, r3, #1
     e84:	68fa      	ldr	r2, [r7, #12]
     e86:	fb92 f2f3 	sdiv	r2, r2, r3
     e8a:	f24f 0380 	movw	r3, #61568	; 0xf080
     e8e:	f2c0 23fa 	movt	r3, #762	; 0x2fa
     e92:	429a      	cmp	r2, r3
     e94:	dc0d      	bgt.n	eb2 <clockSetDividers+0x76>
     e96:	79bb      	ldrb	r3, [r7, #6]
     e98:	f103 0301 	add.w	r3, r3, #1
     e9c:	68fa      	ldr	r2, [r7, #12]
     e9e:	fb92 f2f3 	sdiv	r2, r2, r3
     ea2:	79fb      	ldrb	r3, [r7, #7]
     ea4:	f103 0301 	add.w	r3, r3, #1
     ea8:	68f9      	ldr	r1, [r7, #12]
     eaa:	fb91 f3f3 	sdiv	r3, r1, r3
     eae:	429a      	cmp	r2, r3
     eb0:	dd07      	ble.n	ec2 <clockSetDividers+0x86>
     eb2:	f642 403c 	movw	r0, #11324	; 0x2c3c
     eb6:	f2c0 0000 	movt	r0, #0
     eba:	f44f 71be 	mov.w	r1, #380	; 0x17c
     ebe:	f7ff fb4f 	bl	560 <assert_>
            (mcgClock / (busDiv    +1)) <= (mcgClock / (systemDiv+1)));

    assert( (mcgClock / (flashDiv  +1)) <= MAX_FLASH_FREQ &&
     ec2:	793b      	ldrb	r3, [r7, #4]
     ec4:	f103 0301 	add.w	r3, r3, #1
     ec8:	68fa      	ldr	r2, [r7, #12]
     eca:	fb92 f2f3 	sdiv	r2, r2, r3
     ece:	f647 0340 	movw	r3, #30784	; 0x7840
     ed2:	f2c0 137d 	movt	r3, #381	; 0x17d
     ed6:	429a      	cmp	r2, r3
     ed8:	dc0d      	bgt.n	ef6 <clockSetDividers+0xba>
     eda:	793b      	ldrb	r3, [r7, #4]
     edc:	f103 0301 	add.w	r3, r3, #1
     ee0:	68fa      	ldr	r2, [r7, #12]
     ee2:	fb92 f2f3 	sdiv	r2, r2, r3
     ee6:	79bb      	ldrb	r3, [r7, #6]
     ee8:	f103 0301 	add.w	r3, r3, #1
     eec:	68f9      	ldr	r1, [r7, #12]
     eee:	fb91 f3f3 	sdiv	r3, r1, r3
     ef2:	429a      	cmp	r2, r3
     ef4:	dd07      	ble.n	f06 <clockSetDividers+0xca>
     ef6:	f642 403c 	movw	r0, #11324	; 0x2c3c
     efa:	f2c0 0000 	movt	r0, #0
     efe:	f240 117f 	movw	r1, #383	; 0x17f
     f02:	f7ff fb2d 	bl	560 <assert_>
            (mcgClock / (flashDiv  +1)) <= (mcgClock / (busDiv+1)));

    assert( (mcgClock / (flexBusDiv+1)) <= (mcgClock / (busDiv+1)));
     f06:	797b      	ldrb	r3, [r7, #5]
     f08:	f103 0301 	add.w	r3, r3, #1
     f0c:	68fa      	ldr	r2, [r7, #12]
     f0e:	fb92 f2f3 	sdiv	r2, r2, r3
     f12:	79bb      	ldrb	r3, [r7, #6]
     f14:	f103 0301 	add.w	r3, r3, #1
     f18:	68f9      	ldr	r1, [r7, #12]
     f1a:	fb91 f3f3 	sdiv	r3, r1, r3
     f1e:	429a      	cmp	r2, r3
     f20:	dd07      	ble.n	f32 <clockSetDividers+0xf6>
     f22:	f642 403c 	movw	r0, #11324	; 0x2c3c
     f26:	f2c0 0000 	movt	r0, #0
     f2a:	f240 1181 	movw	r1, #385	; 0x181
     f2e:	f7ff fb17 	bl	560 <assert_>

    /* Save the new dividers */
    clockFreq.systemDiv  = systemDiv;
     f32:	f240 4324 	movw	r3, #1060	; 0x424
     f36:	f2c2 0300 	movt	r3, #8192	; 0x2000
     f3a:	79fa      	ldrb	r2, [r7, #7]
     f3c:	711a      	strb	r2, [r3, #4]
    clockFreq.busDiv     = busDiv;
     f3e:	f240 4324 	movw	r3, #1060	; 0x424
     f42:	f2c2 0300 	movt	r3, #8192	; 0x2000
     f46:	79ba      	ldrb	r2, [r7, #6]
     f48:	715a      	strb	r2, [r3, #5]
    clockFreq.flexBusDiv = flexBusDiv;
     f4a:	f240 4324 	movw	r3, #1060	; 0x424
     f4e:	f2c2 0300 	movt	r3, #8192	; 0x2000
     f52:	797a      	ldrb	r2, [r7, #5]
     f54:	719a      	strb	r2, [r3, #6]
    clockFreq.flashDiv   = flashDiv;
     f56:	f240 4324 	movw	r3, #1060	; 0x424
     f5a:	f2c2 0300 	movt	r3, #8192	; 0x2000
     f5e:	793a      	ldrb	r2, [r7, #4]
     f60:	71da      	strb	r2, [r3, #7]

    /* Set the SIM clock dividers */
    SIM_CLKDIV1 = (systemDiv << 28)  |
     f62:	f248 0344 	movw	r3, #32836	; 0x8044
     f66:	f2c4 0304 	movt	r3, #16388	; 0x4004
     f6a:	79fa      	ldrb	r2, [r7, #7]
     f6c:	ea4f 7102 	mov.w	r1, r2, lsl #28
                  (busDiv << 24)     |
     f70:	79ba      	ldrb	r2, [r7, #6]
     f72:	ea4f 6202 	mov.w	r2, r2, lsl #24
    clockFreq.busDiv     = busDiv;
    clockFreq.flexBusDiv = flexBusDiv;
    clockFreq.flashDiv   = flashDiv;

    /* Set the SIM clock dividers */
    SIM_CLKDIV1 = (systemDiv << 28)  |
     f76:	4311      	orrs	r1, r2
                  (busDiv << 24)     |
                  (flexBusDiv << 20) |
     f78:	797a      	ldrb	r2, [r7, #5]
     f7a:	ea4f 5202 	mov.w	r2, r2, lsl #20
    clockFreq.flexBusDiv = flexBusDiv;
    clockFreq.flashDiv   = flashDiv;

    /* Set the SIM clock dividers */
    SIM_CLKDIV1 = (systemDiv << 28)  |
                  (busDiv << 24)     |
     f7e:	4311      	orrs	r1, r2
                  (flexBusDiv << 20) |
                  (flashDiv << 16);
     f80:	793a      	ldrb	r2, [r7, #4]
     f82:	ea4f 4202 	mov.w	r2, r2, lsl #16
    clockFreq.flashDiv   = flashDiv;

    /* Set the SIM clock dividers */
    SIM_CLKDIV1 = (systemDiv << 28)  |
                  (busDiv << 24)     |
                  (flexBusDiv << 20) |
     f86:	430a      	orrs	r2, r1
    clockFreq.busDiv     = busDiv;
    clockFreq.flexBusDiv = flexBusDiv;
    clockFreq.flashDiv   = flashDiv;

    /* Set the SIM clock dividers */
    SIM_CLKDIV1 = (systemDiv << 28)  |
     f88:	601a      	str	r2, [r3, #0]
                  (busDiv << 24)     |
                  (flexBusDiv << 20) |
                  (flashDiv << 16);
}
     f8a:	f107 0710 	add.w	r7, r7, #16
     f8e:	46bd      	mov	sp, r7
     f90:	bd80      	pop	{r7, pc}
     f92:	bf00      	nop

00000f94 <clockGetFreq>:
*
* Grab the clock frequency for a particular clock source in Hz.
*
*******************************************************************************/
uint32_t clockGetFreq(clockSource_t cs)
{
     f94:	b580      	push	{r7, lr}
     f96:	b084      	sub	sp, #16
     f98:	af00      	add	r7, sp, #0
     f9a:	4603      	mov	r3, r0
     f9c:	71fb      	strb	r3, [r7, #7]
    uint32_t clock;

    switch (cs) {
     f9e:	79fb      	ldrb	r3, [r7, #7]
     fa0:	f1a3 0302 	sub.w	r3, r3, #2
     fa4:	2b03      	cmp	r3, #3
     fa6:	d84b      	bhi.n	1040 <clockGetFreq+0xac>
     fa8:	a201      	add	r2, pc, #4	; (adr r2, fb0 <clockGetFreq+0x1c>)
     faa:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
     fae:	bf00      	nop
     fb0:	00000fc1 	andeq	r0, r0, r1, asr #31
     fb4:	00000fe1 	andeq	r0, r0, r1, ror #31
     fb8:	00001001 	andeq	r1, r0, r1
     fbc:	00001021 	andeq	r1, r0, r1, lsr #32
    case CLOCK_SYSTEM:
        clock = clockFreq.mcgClockFreq / (clockFreq.systemDiv + 1);
     fc0:	f240 4324 	movw	r3, #1060	; 0x424
     fc4:	f2c2 0300 	movt	r3, #8192	; 0x2000
     fc8:	681a      	ldr	r2, [r3, #0]
     fca:	f240 4324 	movw	r3, #1060	; 0x424
     fce:	f2c2 0300 	movt	r3, #8192	; 0x2000
     fd2:	791b      	ldrb	r3, [r3, #4]
     fd4:	f103 0301 	add.w	r3, r3, #1
     fd8:	fbb2 f3f3 	udiv	r3, r2, r3
     fdc:	60fb      	str	r3, [r7, #12]
        break;
     fde:	e037      	b.n	1050 <clockGetFreq+0xbc>
    case CLOCK_BUS:
        clock = clockFreq.mcgClockFreq / (clockFreq.busDiv + 1);
     fe0:	f240 4324 	movw	r3, #1060	; 0x424
     fe4:	f2c2 0300 	movt	r3, #8192	; 0x2000
     fe8:	681a      	ldr	r2, [r3, #0]
     fea:	f240 4324 	movw	r3, #1060	; 0x424
     fee:	f2c2 0300 	movt	r3, #8192	; 0x2000
     ff2:	795b      	ldrb	r3, [r3, #5]
     ff4:	f103 0301 	add.w	r3, r3, #1
     ff8:	fbb2 f3f3 	udiv	r3, r2, r3
     ffc:	60fb      	str	r3, [r7, #12]
        break;
     ffe:	e027      	b.n	1050 <clockGetFreq+0xbc>
    case CLOCK_FLEXBUS:
        clock = clockFreq.mcgClockFreq / (clockFreq.flexBusDiv + 1);
    1000:	f240 4324 	movw	r3, #1060	; 0x424
    1004:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1008:	681a      	ldr	r2, [r3, #0]
    100a:	f240 4324 	movw	r3, #1060	; 0x424
    100e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1012:	799b      	ldrb	r3, [r3, #6]
    1014:	f103 0301 	add.w	r3, r3, #1
    1018:	fbb2 f3f3 	udiv	r3, r2, r3
    101c:	60fb      	str	r3, [r7, #12]
        break;
    101e:	e017      	b.n	1050 <clockGetFreq+0xbc>
    case CLOCK_FLASH:
        clock = clockFreq.mcgClockFreq / (clockFreq.flashDiv + 1);
    1020:	f240 4324 	movw	r3, #1060	; 0x424
    1024:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1028:	681a      	ldr	r2, [r3, #0]
    102a:	f240 4324 	movw	r3, #1060	; 0x424
    102e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1032:	79db      	ldrb	r3, [r3, #7]
    1034:	f103 0301 	add.w	r3, r3, #1
    1038:	fbb2 f3f3 	udiv	r3, r2, r3
    103c:	60fb      	str	r3, [r7, #12]
        break;
    103e:	e007      	b.n	1050 <clockGetFreq+0xbc>
    default:
        assert(0);
    1040:	f642 403c 	movw	r0, #11324	; 0x2c3c
    1044:	f2c0 0000 	movt	r0, #0
    1048:	f240 11a9 	movw	r1, #425	; 0x1a9
    104c:	f7ff fa88 	bl	560 <assert_>
    }

    return clock;
    1050:	68fb      	ldr	r3, [r7, #12]
}
    1052:	4618      	mov	r0, r3
    1054:	f107 0710 	add.w	r7, r7, #16
    1058:	46bd      	mov	sp, r7
    105a:	bd80      	pop	{r7, pc}

0000105c <clockConfigMcgOut>:
*        ____ STOP ____ (Entered when MCU enters stop mode, and returns to
*                        previous active mode when exits stop mode )
*
*******************************************************************************/
void clockConfigMcgOut(clockConfig_t clockConfig)
{
    105c:	b580      	push	{r7, lr}
    105e:	b082      	sub	sp, #8
    1060:	af00      	add	r7, sp, #0
    1062:	4603      	mov	r3, r0
    1064:	71fb      	strb	r3, [r7, #7]
        {  pee2fei,  pee2fee,     NULL,  pee2blpi,  pee2blpe, },
        { blpi2fei, blpi2fee, blpi2pee,      NULL, blpi2blpe, },
        { blpe2fei, blpe2fee, blpe2pee, blpe2blpi,      NULL, },
    };

    assert(clockConfig < MAX_MCG_CLOCK_OPTIONS);
    1066:	79fb      	ldrb	r3, [r7, #7]
    1068:	2b02      	cmp	r3, #2
    106a:	d907      	bls.n	107c <clockConfigMcgOut+0x20>
    106c:	f642 403c 	movw	r0, #11324	; 0x2c3c
    1070:	f2c0 0000 	movt	r0, #0
    1074:	f44f 71ec 	mov.w	r1, #472	; 0x1d8
    1078:	f7ff fa72 	bl	560 <assert_>

    mcgState.nextMode = clockConfigParam[clockConfig].clockMode;
    107c:	79fa      	ldrb	r2, [r7, #7]
    107e:	f240 430c 	movw	r3, #1036	; 0x40c
    1082:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1086:	f813 2032 	ldrb.w	r2, [r3, r2, lsl #3]
    108a:	f240 53e8 	movw	r3, #1512	; 0x5e8
    108e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1092:	705a      	strb	r2, [r3, #1]

    jumpTable[mcgState.currentMode][mcgState.nextMode](clockConfig);
    1094:	f240 53e8 	movw	r3, #1512	; 0x5e8
    1098:	f2c2 0300 	movt	r3, #8192	; 0x2000
    109c:	781b      	ldrb	r3, [r3, #0]
    109e:	4619      	mov	r1, r3
    10a0:	f240 53e8 	movw	r3, #1512	; 0x5e8
    10a4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    10a8:	785b      	ldrb	r3, [r3, #1]
    10aa:	4618      	mov	r0, r3
    10ac:	f642 425c 	movw	r2, #11356	; 0x2c5c
    10b0:	f2c0 0200 	movt	r2, #0
    10b4:	460b      	mov	r3, r1
    10b6:	ea4f 0383 	mov.w	r3, r3, lsl #2
    10ba:	185b      	adds	r3, r3, r1
    10bc:	181b      	adds	r3, r3, r0
    10be:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    10c2:	79fa      	ldrb	r2, [r7, #7]
    10c4:	4610      	mov	r0, r2
    10c6:	4798      	blx	r3

    /* Store the new clock frequency for clockGetFreq() */
    clockFreq.mcgClockFreq = clockConfigParam[clockConfig].clockHz;
    10c8:	79fb      	ldrb	r3, [r7, #7]
    10ca:	f240 420c 	movw	r2, #1036	; 0x40c
    10ce:	f2c2 0200 	movt	r2, #8192	; 0x2000
    10d2:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    10d6:	18d3      	adds	r3, r2, r3
    10d8:	685a      	ldr	r2, [r3, #4]
    10da:	f240 4324 	movw	r3, #1060	; 0x424
    10de:	f2c2 0300 	movt	r3, #8192	; 0x2000
    10e2:	601a      	str	r2, [r3, #0]
}
    10e4:	f107 0708 	add.w	r7, r7, #8
    10e8:	46bd      	mov	sp, r7
    10ea:	bd80      	pop	{r7, pc}

000010ec <clockConfigMcgIr>:

/*******************************************************************************
* clockConfigMcgIr
*******************************************************************************/
void clockConfigMcgIr()
{
    10ec:	b480      	push	{r7}
    10ee:	af00      	add	r7, sp, #0
                                                            /* Not configured */
}
    10f0:	46bd      	mov	sp, r7
    10f2:	bc80      	pop	{r7}
    10f4:	4770      	bx	lr
    10f6:	bf00      	nop

000010f8 <clockConfigMcgFf>:

/*******************************************************************************
* clockConfigMcgFf
*******************************************************************************/
void clockConfigMcgFf()
{
    10f8:	b480      	push	{r7}
    10fa:	af00      	add	r7, sp, #0
                                                            /* Not configured */
}
    10fc:	46bd      	mov	sp, r7
    10fe:	bc80      	pop	{r7}
    1100:	4770      	bx	lr
    1102:	bf00      	nop

00001104 <clockConfigMcgFll>:

/*******************************************************************************
* clockConfigMcgFll
*******************************************************************************/
void clockConfigMcgFll()
{
    1104:	b480      	push	{r7}
    1106:	af00      	add	r7, sp, #0
                                                            /* Not configured */
}
    1108:	46bd      	mov	sp, r7
    110a:	bc80      	pop	{r7}
    110c:	4770      	bx	lr
    110e:	bf00      	nop

00001110 <clockConfigMcgPll>:

/*******************************************************************************
* clockConfigMcgPll
*******************************************************************************/
void clockConfigMcgPll()
{
    1110:	b480      	push	{r7}
    1112:	af00      	add	r7, sp, #0
                                                            /* Not configured */
}
    1114:	46bd      	mov	sp, r7
    1116:	bc80      	pop	{r7}
    1118:	4770      	bx	lr
    111a:	bf00      	nop

0000111c <clockConfigOsc>:

/*******************************************************************************
* clockConfigOsc
*******************************************************************************/
void clockConfigOsc()
{
    111c:	b480      	push	{r7}
    111e:	af00      	add	r7, sp, #0
                                                            /* Not configured */
}
    1120:	46bd      	mov	sp, r7
    1122:	bc80      	pop	{r7}
    1124:	4770      	bx	lr
    1126:	bf00      	nop

00001128 <clockConfigOsc32k>:

/*******************************************************************************
* clockConfigOsc32k
*******************************************************************************/
void clockConfigOsc32k()
{
    1128:	b480      	push	{r7}
    112a:	af00      	add	r7, sp, #0
                                                            /* Not configured */
}
    112c:	46bd      	mov	sp, r7
    112e:	bc80      	pop	{r7}
    1130:	4770      	bx	lr
    1132:	bf00      	nop

00001134 <clockConfigEr32k>:

/*******************************************************************************
* clockConfigEr32k
*******************************************************************************/
void clockConfigEr32k()
{
    1134:	b480      	push	{r7}
    1136:	af00      	add	r7, sp, #0
                                                            /* Not configured */
}
    1138:	46bd      	mov	sp, r7
    113a:	bc80      	pop	{r7}
    113c:	4770      	bx	lr
    113e:	bf00      	nop

00001140 <clockConfigRtc>:

/*******************************************************************************
* clockConfigRtc
*******************************************************************************/
void clockConfigRtc()
{
    1140:	b480      	push	{r7}
    1142:	af00      	add	r7, sp, #0
                                                            /* Not configured */
}
    1144:	46bd      	mov	sp, r7
    1146:	bc80      	pop	{r7}
    1148:	4770      	bx	lr
    114a:	bf00      	nop

0000114c <clockConfigLpo>:

/*******************************************************************************
* clockConfigLpo
*******************************************************************************/
void clockConfigLpo()
{
    114c:	b480      	push	{r7}
    114e:	af00      	add	r7, sp, #0
                                                            /* Not configured */
}
    1150:	46bd      	mov	sp, r7
    1152:	bc80      	pop	{r7}
    1154:	4770      	bx	lr
    1156:	bf00      	nop

00001158 <watchDogUnlock>:
*
* RETURNS: Nothing
*
*******************************************************************************/
void watchDogUnlock()
{
    1158:	b480      	push	{r7}
    115a:	af00      	add	r7, sp, #0
        " :
        /* No output */ :
        /* No input  */ :
        "r0", "r1" ); /* Specify which registers we destroy */
#else
    wdPtr->unlock = WDOG_UNLOCK_KEY_1;
    115c:	f240 432c 	movw	r3, #1068	; 0x42c
    1160:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1164:	681b      	ldr	r3, [r3, #0]
    1166:	f24c 5220 	movw	r2, #50464	; 0xc520
    116a:	81da      	strh	r2, [r3, #14]
    wdPtr->unlock = WDOG_UNLOCK_KEY_2;
    116c:	f240 432c 	movw	r3, #1068	; 0x42c
    1170:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1174:	681b      	ldr	r3, [r3, #0]
    1176:	f64d 1228 	movw	r2, #55592	; 0xd928
    117a:	81da      	strh	r2, [r3, #14]
#endif
    /* NOTE: Need to wait one clock cycle before updating any registers */
}
    117c:	46bd      	mov	sp, r7
    117e:	bc80      	pop	{r7}
    1180:	4770      	bx	lr
    1182:	bf00      	nop

00001184 <watchDogInit>:

/*******************************************************************************
* watchDogInit
*******************************************************************************/
void watchDogInit(const watchDogConfig_t *wdCfgPtr)
{
    1184:	b580      	push	{r7, lr}
    1186:	b082      	sub	sp, #8
    1188:	af00      	add	r7, sp, #0
    118a:	6078      	str	r0, [r7, #4]
    watchDogUnlock();
    118c:	f7ff ffe4 	bl	1158 <watchDogUnlock>
        " :
        /* No output */ :
        /* No input  */ :
        "r0", "r1", "r2" ); /* Specify which registers we destroy */
#else
    assert(wdCfgPtr->window < wdCfgPtr->timeout);
    1190:	687b      	ldr	r3, [r7, #4]
    1192:	689a      	ldr	r2, [r3, #8]
    1194:	687b      	ldr	r3, [r7, #4]
    1196:	685b      	ldr	r3, [r3, #4]
    1198:	429a      	cmp	r2, r3
    119a:	d307      	bcc.n	11ac <watchDogInit+0x28>
    119c:	f642 40c0 	movw	r0, #11456	; 0x2cc0
    11a0:	f2c0 0000 	movt	r0, #0
    11a4:	f04f 0183 	mov.w	r1, #131	; 0x83
    11a8:	f7ff f9da 	bl	560 <assert_>

    wdPtr->toValL  = wdCfgPtr->timeout;
    11ac:	f240 432c 	movw	r3, #1068	; 0x42c
    11b0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    11b4:	681b      	ldr	r3, [r3, #0]
    11b6:	687a      	ldr	r2, [r7, #4]
    11b8:	6852      	ldr	r2, [r2, #4]
    11ba:	b292      	uxth	r2, r2
    11bc:	80da      	strh	r2, [r3, #6]
    wdPtr->toValH  = wdCfgPtr->timeout >> 16;
    11be:	f240 432c 	movw	r3, #1068	; 0x42c
    11c2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    11c6:	681b      	ldr	r3, [r3, #0]
    11c8:	687a      	ldr	r2, [r7, #4]
    11ca:	6852      	ldr	r2, [r2, #4]
    11cc:	ea4f 4212 	mov.w	r2, r2, lsr #16
    11d0:	b292      	uxth	r2, r2
    11d2:	809a      	strh	r2, [r3, #4]
    wdPtr->stCtrlH = wdCfgPtr->stCtrlFlags;
    11d4:	f240 432c 	movw	r3, #1068	; 0x42c
    11d8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    11dc:	681b      	ldr	r3, [r3, #0]
    11de:	687a      	ldr	r2, [r7, #4]
    11e0:	8812      	ldrh	r2, [r2, #0]
    11e2:	801a      	strh	r2, [r3, #0]
    wdPtr->presc   = wdCfgPtr->prescaler;
    11e4:	f240 432c 	movw	r3, #1068	; 0x42c
    11e8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    11ec:	681b      	ldr	r3, [r3, #0]
    11ee:	687a      	ldr	r2, [r7, #4]
    11f0:	8852      	ldrh	r2, [r2, #2]
    11f2:	82da      	strh	r2, [r3, #22]
    wdPtr->winL    = wdCfgPtr->window;
    11f4:	f240 432c 	movw	r3, #1068	; 0x42c
    11f8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    11fc:	681b      	ldr	r3, [r3, #0]
    11fe:	687a      	ldr	r2, [r7, #4]
    1200:	6892      	ldr	r2, [r2, #8]
    1202:	b292      	uxth	r2, r2
    1204:	815a      	strh	r2, [r3, #10]
    wdPtr->winH    = wdCfgPtr->window >> 16;
    1206:	f240 432c 	movw	r3, #1068	; 0x42c
    120a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    120e:	681b      	ldr	r3, [r3, #0]
    1210:	687a      	ldr	r2, [r7, #4]
    1212:	6892      	ldr	r2, [r2, #8]
    1214:	ea4f 4212 	mov.w	r2, r2, lsr #16
    1218:	b292      	uxth	r2, r2
    121a:	811a      	strh	r2, [r3, #8]
    }
    if (wdCfgPtr->stCtrlFlags & WDOG_TEST) {
        /* TODO: If anyone cares let me know */
    }
#endif
}
    121c:	f107 0708 	add.w	r7, r7, #8
    1220:	46bd      	mov	sp, r7
    1222:	bd80      	pop	{r7, pc}

00001224 <interruptDisable>:

/* RFI: Could probably move these elsewhere for general consumption */
static void interruptDisable()
{
    1224:	b480      	push	{r7}
    1226:	af00      	add	r7, sp, #0
    asm volatile("\n\
    1228:	b672      	cpsid	i
        cpsid i\n\
        " :
        /* No output */ :
        /* No input  */ :
        ); /* Specify which registers we destroy */
}
    122a:	46bd      	mov	sp, r7
    122c:	bc80      	pop	{r7}
    122e:	4770      	bx	lr

00001230 <interruptEnable>:
static void interruptEnable()
{
    1230:	b480      	push	{r7}
    1232:	af00      	add	r7, sp, #0
    asm volatile("\n\
    1234:	b662      	cpsie	i
        cpsie i\n\
        " :
        /* No output */ :
        /* No input  */ :
        ); /* Specify which registers we destroy */
}
    1236:	46bd      	mov	sp, r7
    1238:	bc80      	pop	{r7}
    123a:	4770      	bx	lr

0000123c <watchDogKick>:

/*******************************************************************************
* watchDogKick
*******************************************************************************/
void watchDogKick()
{
    123c:	b580      	push	{r7, lr}
    123e:	af00      	add	r7, sp, #0
        " :
        /* No output */ :
        /* No input  */ :
        "r0", "r1" ); /* Specify which registers we destroy */
#else
    interruptDisable();
    1240:	f7ff fff0 	bl	1224 <interruptDisable>
    wdPtr->refresh = WDOG_REFRESH_KEY_1;
    1244:	f240 432c 	movw	r3, #1068	; 0x42c
    1248:	f2c2 0300 	movt	r3, #8192	; 0x2000
    124c:	681b      	ldr	r3, [r3, #0]
    124e:	f24a 6202 	movw	r2, #42498	; 0xa602
    1252:	819a      	strh	r2, [r3, #12]
    wdPtr->refresh = WDOG_REFRESH_KEY_2;
    1254:	f240 432c 	movw	r3, #1068	; 0x42c
    1258:	f2c2 0300 	movt	r3, #8192	; 0x2000
    125c:	681b      	ldr	r3, [r3, #0]
    125e:	f24b 4280 	movw	r2, #46208	; 0xb480
    1262:	819a      	strh	r2, [r3, #12]
    interruptEnable();
    1264:	f7ff ffe4 	bl	1230 <interruptEnable>
#endif
}
    1268:	bd80      	pop	{r7, pc}
    126a:	bf00      	nop

0000126c <watchDogDisable>:

/*******************************************************************************
* watchDogDisable
*******************************************************************************/
void watchDogDisable()
{
    126c:	b580      	push	{r7, lr}
    126e:	af00      	add	r7, sp, #0
    watchDogUnlock();
    1270:	f7ff ff72 	bl	1158 <watchDogUnlock>
        " :
        /* No output */ :
        /* No input  */ :
        "r0", "r1" ); /* Specify which registers we destroy */
#else
    wdPtr->stCtrlH = WDOG_STNDBYEN | WDOG_WAITEN | WDOG_STOPEN
    1274:	f240 432c 	movw	r3, #1068	; 0x42c
    1278:	f2c2 0300 	movt	r3, #8192	; 0x2000
    127c:	681b      	ldr	r3, [r3, #0]
    127e:	f44f 72e8 	mov.w	r2, #464	; 0x1d0
    1282:	801a      	strh	r2, [r3, #0]
                   | WDOG_ALLOWUPDATE;
#endif
}
    1284:	bd80      	pop	{r7, pc}
    1286:	bf00      	nop
	...

00001290 <_idle_thread>:
 *          that this thread is executed only if there are no other ready
 *          threads in the system.
 *
 * @param[in] p the thread parameter, unused in this scenario
 */
void _idle_thread(void *p) {
    1290:	b082      	sub	sp, #8
    1292:	9001      	str	r0, [sp, #4]

  (void)p;
  chRegSetThreadName("idle");
    1294:	f240 7308 	movw	r3, #1800	; 0x708
    1298:	f2c2 0300 	movt	r3, #8192	; 0x2000
    129c:	699a      	ldr	r2, [r3, #24]
    129e:	f642 43e0 	movw	r3, #11488	; 0x2ce0
    12a2:	f2c0 0300 	movt	r3, #0
    12a6:	6193      	str	r3, [r2, #24]
  while (TRUE) {
    port_wait_for_interrupt();
    IDLE_LOOP_HOOK();
  }
    12a8:	e7fe      	b.n	12a8 <_idle_thread+0x18>
    12aa:	bf00      	nop
    12ac:	f3af 8000 	nop.w

000012b0 <chSysInit>:
 * @note    This function has special, architecture-dependent, requirements,
 *          see the notes into the various port reference manuals.
 *
 * @special
 */
void chSysInit(void) {
    12b0:	b500      	push	{lr}
    12b2:	b083      	sub	sp, #12
  static Thread mainthread;
#if CH_DBG_ENABLE_STACK_CHECK
  extern stkalign_t __main_thread_stack_base__;
#endif

  port_init();
    12b4:	f001 f93c 	bl	2530 <_port_init>
  _scheduler_init();
    12b8:	f000 f9aa 	bl	1610 <_scheduler_init>
  _vt_init();
    12bc:	f000 f8b0 	bl	1420 <_vt_init>
#if CH_USE_MEMCORE
  _core_init();
    12c0:	f000 fe66 	bl	1f90 <_core_init>
#endif
#if CH_USE_HEAP
  _heap_init();
    12c4:	f000 fee4 	bl	2090 <_heap_init>
#if CH_DBG_ENABLE_TRACE
  _trace_init();
#endif

  /* Now this instructions flow becomes the main thread.*/
  setcurrp(_thread_init(&mainthread, NORMALPRIO));
    12c8:	f240 60b0 	movw	r0, #1712	; 0x6b0
    12cc:	f2c2 0000 	movt	r0, #8192	; 0x2000
    12d0:	f04f 0140 	mov.w	r1, #64	; 0x40
    12d4:	f000 fba4 	bl	1a20 <_thread_init>
    12d8:	4602      	mov	r2, r0
    12da:	f240 7308 	movw	r3, #1800	; 0x708
    12de:	f2c2 0300 	movt	r3, #8192	; 0x2000
    12e2:	619a      	str	r2, [r3, #24]
  currp->p_state = THD_STATE_CURRENT;
    12e4:	f240 7308 	movw	r3, #1800	; 0x708
    12e8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    12ec:	699b      	ldr	r3, [r3, #24]
    12ee:	f04f 0201 	mov.w	r2, #1
    12f2:	771a      	strb	r2, [r3, #28]
#if CH_DBG_ENABLE_STACK_CHECK
  /* This is a special case because the main thread Thread structure is not
     adjacent to its stack area.*/
  currp->p_stklimit = &__main_thread_stack_base__;
#endif
  chSysEnable();
    12f4:	f04f 0300 	mov.w	r3, #0
    12f8:	f383 8811 	msr	BASEPRI, r3
    12fc:	b662      	cpsie	i

  chRegSetThreadName("main");
    12fe:	f240 7308 	movw	r3, #1800	; 0x708
    1302:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1306:	699a      	ldr	r2, [r3, #24]
    1308:	f642 43e8 	movw	r3, #11496	; 0x2ce8
    130c:	f2c0 0300 	movt	r3, #0
    1310:	6193      	str	r3, [r2, #24]

#if !CH_NO_IDLE_THREAD
  /* This thread has the lowest priority in the system, its role is just to
     serve interrupts in its context while keeping the lowest energy saving
     mode compatible with the system status.*/
  chThdCreateStatic(_idle_thread_wa, sizeof(_idle_thread_wa), IDLEPRIO,
    1312:	f241 2391 	movw	r3, #4753	; 0x1291
    1316:	f2c0 0300 	movt	r3, #0
    131a:	f04f 0200 	mov.w	r2, #0
    131e:	9200      	str	r2, [sp, #0]
    1320:	f240 50f0 	movw	r0, #1520	; 0x5f0
    1324:	f2c2 0000 	movt	r0, #8192	; 0x2000
    1328:	f04f 01c0 	mov.w	r1, #192	; 0xc0
    132c:	f04f 0201 	mov.w	r2, #1
    1330:	f000 fc06 	bl	1b40 <chThdCreateStatic>
                    (tfunc_t)_idle_thread, NULL);
#endif
}
    1334:	b003      	add	sp, #12
    1336:	bd00      	pop	{pc}
    1338:	f3af 8000 	nop.w
    133c:	f3af 8000 	nop.w

00001340 <chSysTimerHandlerI>:
 *          and, together with the @p CH_TIME_QUANTUM macro, the round robin
 *          interval.
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {
    1340:	b500      	push	{lr}
    1342:	b083      	sub	sp, #12

  chDbgCheckClassI();

#if CH_TIME_QUANTUM > 0
  /* Running thread has not used up quantum yet? */
  if (currp->p_preempt > 0)
    1344:	f240 7308 	movw	r3, #1800	; 0x708
    1348:	f2c2 0300 	movt	r3, #8192	; 0x2000
    134c:	699b      	ldr	r3, [r3, #24]
    134e:	7fdb      	ldrb	r3, [r3, #31]
    1350:	2b00      	cmp	r3, #0
    1352:	d009      	beq.n	1368 <chSysTimerHandlerI+0x28>
    /* Decrement remaining quantum.*/
    currp->p_preempt--;
    1354:	f240 7308 	movw	r3, #1800	; 0x708
    1358:	f2c2 0300 	movt	r3, #8192	; 0x2000
    135c:	699b      	ldr	r3, [r3, #24]
    135e:	7fda      	ldrb	r2, [r3, #31]
    1360:	f102 32ff 	add.w	r2, r2, #4294967295
    1364:	b2d2      	uxtb	r2, r2
    1366:	77da      	strb	r2, [r3, #31]
#endif
#if CH_DBG_THREADS_PROFILING
  currp->p_time++;
    1368:	f240 7308 	movw	r3, #1800	; 0x708
    136c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1370:	699b      	ldr	r3, [r3, #24]
    1372:	6a1a      	ldr	r2, [r3, #32]
    1374:	f102 0201 	add.w	r2, r2, #1
    1378:	621a      	str	r2, [r3, #32]
#endif
  chVTDoTickI();
    137a:	f240 63f8 	movw	r3, #1784	; 0x6f8
    137e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1382:	68db      	ldr	r3, [r3, #12]
    1384:	f103 0201 	add.w	r2, r3, #1
    1388:	f240 63f8 	movw	r3, #1784	; 0x6f8
    138c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1390:	60da      	str	r2, [r3, #12]
    1392:	f240 63f8 	movw	r3, #1784	; 0x6f8
    1396:	f2c2 0300 	movt	r3, #8192	; 0x2000
    139a:	681a      	ldr	r2, [r3, #0]
    139c:	f240 63f8 	movw	r3, #1784	; 0x6f8
    13a0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    13a4:	429a      	cmp	r2, r3
    13a6:	d035      	beq.n	1414 <chSysTimerHandlerI+0xd4>
    13a8:	f240 63f8 	movw	r3, #1784	; 0x6f8
    13ac:	f2c2 0300 	movt	r3, #8192	; 0x2000
    13b0:	681b      	ldr	r3, [r3, #0]
    13b2:	689a      	ldr	r2, [r3, #8]
    13b4:	f102 32ff 	add.w	r2, r2, #4294967295
    13b8:	609a      	str	r2, [r3, #8]
    13ba:	e021      	b.n	1400 <chSysTimerHandlerI+0xc0>
    13bc:	9b01      	ldr	r3, [sp, #4]
    13be:	68db      	ldr	r3, [r3, #12]
    13c0:	9300      	str	r3, [sp, #0]
    13c2:	9b01      	ldr	r3, [sp, #4]
    13c4:	f04f 0200 	mov.w	r2, #0
    13c8:	60da      	str	r2, [r3, #12]
    13ca:	9b01      	ldr	r3, [sp, #4]
    13cc:	681a      	ldr	r2, [r3, #0]
    13ce:	f240 63f8 	movw	r3, #1784	; 0x6f8
    13d2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    13d6:	6053      	str	r3, [r2, #4]
    13d8:	9b01      	ldr	r3, [sp, #4]
    13da:	681a      	ldr	r2, [r3, #0]
    13dc:	f240 63f8 	movw	r3, #1784	; 0x6f8
    13e0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    13e4:	601a      	str	r2, [r3, #0]
    13e6:	f04f 0300 	mov.w	r3, #0
    13ea:	f383 8811 	msr	BASEPRI, r3
    13ee:	9b01      	ldr	r3, [sp, #4]
    13f0:	691a      	ldr	r2, [r3, #16]
    13f2:	9b00      	ldr	r3, [sp, #0]
    13f4:	4610      	mov	r0, r2
    13f6:	4798      	blx	r3
    13f8:	f04f 0320 	mov.w	r3, #32
    13fc:	f383 8811 	msr	BASEPRI, r3
    1400:	f240 63f8 	movw	r3, #1784	; 0x6f8
    1404:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1408:	681b      	ldr	r3, [r3, #0]
    140a:	9301      	str	r3, [sp, #4]
    140c:	9b01      	ldr	r3, [sp, #4]
    140e:	689b      	ldr	r3, [r3, #8]
    1410:	2b00      	cmp	r3, #0
    1412:	d0d3      	beq.n	13bc <chSysTimerHandlerI+0x7c>
#if defined(SYSTEM_TICK_EVENT_HOOK)
  SYSTEM_TICK_EVENT_HOOK();
#endif
}
    1414:	b003      	add	sp, #12
    1416:	bd00      	pop	{pc}
    1418:	f3af 8000 	nop.w
    141c:	f3af 8000 	nop.w

00001420 <_vt_init>:
 *
 * @notapi
 */
void _vt_init(void) {

  vtlist.vt_next = vtlist.vt_prev = (void *)&vtlist;
    1420:	f240 63f8 	movw	r3, #1784	; 0x6f8
    1424:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1428:	f240 62f8 	movw	r2, #1784	; 0x6f8
    142c:	f2c2 0200 	movt	r2, #8192	; 0x2000
    1430:	605a      	str	r2, [r3, #4]
    1432:	f240 63f8 	movw	r3, #1784	; 0x6f8
    1436:	f2c2 0300 	movt	r3, #8192	; 0x2000
    143a:	685a      	ldr	r2, [r3, #4]
    143c:	f240 63f8 	movw	r3, #1784	; 0x6f8
    1440:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1444:	601a      	str	r2, [r3, #0]
  vtlist.vt_time = (systime_t)-1;
    1446:	f240 63f8 	movw	r3, #1784	; 0x6f8
    144a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    144e:	f04f 32ff 	mov.w	r2, #4294967295
    1452:	609a      	str	r2, [r3, #8]
  vtlist.vt_systime = 0;
    1454:	f240 63f8 	movw	r3, #1784	; 0x6f8
    1458:	f2c2 0300 	movt	r3, #8192	; 0x2000
    145c:	f04f 0200 	mov.w	r2, #0
    1460:	60da      	str	r2, [r3, #12]
}
    1462:	4770      	bx	lr
    1464:	f3af 8000 	nop.w
    1468:	f3af 8000 	nop.w
    146c:	f3af 8000 	nop.w

00001470 <chVTSetI>:
 * @param[in] par       a parameter that will be passed to the callback
 *                      function
 *
 * @iclass
 */
void chVTSetI(VirtualTimer *vtp, systime_t time, vtfunc_t vtfunc, void *par) {
    1470:	b086      	sub	sp, #24
    1472:	9003      	str	r0, [sp, #12]
    1474:	9102      	str	r1, [sp, #8]
    1476:	9201      	str	r2, [sp, #4]
    1478:	9300      	str	r3, [sp, #0]
  VirtualTimer *p;

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (time != TIME_IMMEDIATE),
    147a:	9b03      	ldr	r3, [sp, #12]
    147c:	2b00      	cmp	r3, #0
    147e:	d004      	beq.n	148a <chVTSetI+0x1a>
    1480:	9b01      	ldr	r3, [sp, #4]
    1482:	2b00      	cmp	r3, #0
    1484:	d001      	beq.n	148a <chVTSetI+0x1a>
    1486:	9b02      	ldr	r3, [sp, #8]
    1488:	2b00      	cmp	r3, #0
             "chVTSetI");

  vtp->vt_par = par;
    148a:	9b03      	ldr	r3, [sp, #12]
    148c:	9a00      	ldr	r2, [sp, #0]
    148e:	611a      	str	r2, [r3, #16]
  vtp->vt_func = vtfunc;
    1490:	9b03      	ldr	r3, [sp, #12]
    1492:	9a01      	ldr	r2, [sp, #4]
    1494:	60da      	str	r2, [r3, #12]
  p = vtlist.vt_next;
    1496:	f240 63f8 	movw	r3, #1784	; 0x6f8
    149a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    149e:	681b      	ldr	r3, [r3, #0]
    14a0:	9305      	str	r3, [sp, #20]
  while (p->vt_time < time) {
    14a2:	e007      	b.n	14b4 <chVTSetI+0x44>
    time -= p->vt_time;
    14a4:	9b05      	ldr	r3, [sp, #20]
    14a6:	689b      	ldr	r3, [r3, #8]
    14a8:	9a02      	ldr	r2, [sp, #8]
    14aa:	1ad3      	subs	r3, r2, r3
    14ac:	9302      	str	r3, [sp, #8]
    p = p->vt_next;
    14ae:	9b05      	ldr	r3, [sp, #20]
    14b0:	681b      	ldr	r3, [r3, #0]
    14b2:	9305      	str	r3, [sp, #20]
             "chVTSetI");

  vtp->vt_par = par;
  vtp->vt_func = vtfunc;
  p = vtlist.vt_next;
  while (p->vt_time < time) {
    14b4:	9b05      	ldr	r3, [sp, #20]
    14b6:	689a      	ldr	r2, [r3, #8]
    14b8:	9b02      	ldr	r3, [sp, #8]
    14ba:	429a      	cmp	r2, r3
    14bc:	d3f2      	bcc.n	14a4 <chVTSetI+0x34>
    time -= p->vt_time;
    p = p->vt_next;
  }

  vtp->vt_prev = (vtp->vt_next = p)->vt_prev;
    14be:	9b03      	ldr	r3, [sp, #12]
    14c0:	9a05      	ldr	r2, [sp, #20]
    14c2:	601a      	str	r2, [r3, #0]
    14c4:	9b03      	ldr	r3, [sp, #12]
    14c6:	681b      	ldr	r3, [r3, #0]
    14c8:	685a      	ldr	r2, [r3, #4]
    14ca:	9b03      	ldr	r3, [sp, #12]
    14cc:	605a      	str	r2, [r3, #4]
  vtp->vt_prev->vt_next = p->vt_prev = vtp;
    14ce:	9b03      	ldr	r3, [sp, #12]
    14d0:	685b      	ldr	r3, [r3, #4]
    14d2:	9a05      	ldr	r2, [sp, #20]
    14d4:	9903      	ldr	r1, [sp, #12]
    14d6:	6051      	str	r1, [r2, #4]
    14d8:	9a05      	ldr	r2, [sp, #20]
    14da:	6852      	ldr	r2, [r2, #4]
    14dc:	601a      	str	r2, [r3, #0]
  vtp->vt_time = time;
    14de:	9b03      	ldr	r3, [sp, #12]
    14e0:	9a02      	ldr	r2, [sp, #8]
    14e2:	609a      	str	r2, [r3, #8]
  if (p != (void *)&vtlist)
    14e4:	9a05      	ldr	r2, [sp, #20]
    14e6:	f240 63f8 	movw	r3, #1784	; 0x6f8
    14ea:	f2c2 0300 	movt	r3, #8192	; 0x2000
    14ee:	429a      	cmp	r2, r3
    14f0:	d005      	beq.n	14fe <chVTSetI+0x8e>
    p->vt_time -= time;
    14f2:	9b05      	ldr	r3, [sp, #20]
    14f4:	689a      	ldr	r2, [r3, #8]
    14f6:	9b02      	ldr	r3, [sp, #8]
    14f8:	1ad2      	subs	r2, r2, r3
    14fa:	9b05      	ldr	r3, [sp, #20]
    14fc:	609a      	str	r2, [r3, #8]
}
    14fe:	b006      	add	sp, #24
    1500:	4770      	bx	lr
    1502:	bf00      	nop
    1504:	f3af 8000 	nop.w
    1508:	f3af 8000 	nop.w
    150c:	f3af 8000 	nop.w

00001510 <chVTResetI>:
 *
 * @param[in] vtp       the @p VirtualTimer structure pointer
 *
 * @iclass
 */
void chVTResetI(VirtualTimer *vtp) {
    1510:	b082      	sub	sp, #8
    1512:	9001      	str	r0, [sp, #4]
  chDbgCheck(vtp != NULL, "chVTResetI");
  chDbgAssert(vtp->vt_func != NULL,
              "chVTResetI(), #1",
              "timer not set or already triggered");

  if (vtp->vt_next != (void *)&vtlist)
    1514:	9b01      	ldr	r3, [sp, #4]
    1516:	681a      	ldr	r2, [r3, #0]
    1518:	f240 63f8 	movw	r3, #1784	; 0x6f8
    151c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1520:	429a      	cmp	r2, r3
    1522:	d008      	beq.n	1536 <chVTResetI+0x26>
    vtp->vt_next->vt_time += vtp->vt_time;
    1524:	9b01      	ldr	r3, [sp, #4]
    1526:	681b      	ldr	r3, [r3, #0]
    1528:	9a01      	ldr	r2, [sp, #4]
    152a:	6812      	ldr	r2, [r2, #0]
    152c:	6891      	ldr	r1, [r2, #8]
    152e:	9a01      	ldr	r2, [sp, #4]
    1530:	6892      	ldr	r2, [r2, #8]
    1532:	188a      	adds	r2, r1, r2
    1534:	609a      	str	r2, [r3, #8]
  vtp->vt_prev->vt_next = vtp->vt_next;
    1536:	9b01      	ldr	r3, [sp, #4]
    1538:	685b      	ldr	r3, [r3, #4]
    153a:	9a01      	ldr	r2, [sp, #4]
    153c:	6812      	ldr	r2, [r2, #0]
    153e:	601a      	str	r2, [r3, #0]
  vtp->vt_next->vt_prev = vtp->vt_prev;
    1540:	9b01      	ldr	r3, [sp, #4]
    1542:	681b      	ldr	r3, [r3, #0]
    1544:	9a01      	ldr	r2, [sp, #4]
    1546:	6852      	ldr	r2, [r2, #4]
    1548:	605a      	str	r2, [r3, #4]
  vtp->vt_func = (vtfunc_t)NULL;
    154a:	9b01      	ldr	r3, [sp, #4]
    154c:	f04f 0200 	mov.w	r2, #0
    1550:	60da      	str	r2, [r3, #12]
}
    1552:	b002      	add	sp, #8
    1554:	4770      	bx	lr
    1556:	bf00      	nop
    1558:	f3af 8000 	nop.w
    155c:	f3af 8000 	nop.w

00001560 <chTimeIsWithin>:
 * @retval TRUE         current time within the specified time window.
 * @retval FALSE        current time not within the specified time window.
 *
 * @api
 */
bool_t chTimeIsWithin(systime_t start, systime_t end) {
    1560:	b084      	sub	sp, #16
    1562:	9001      	str	r0, [sp, #4]
    1564:	9100      	str	r1, [sp, #0]

  systime_t time = chTimeNow();
    1566:	f240 63f8 	movw	r3, #1784	; 0x6f8
    156a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    156e:	68db      	ldr	r3, [r3, #12]
    1570:	9303      	str	r3, [sp, #12]
  return end > start ? (time >= start) && (time < end) :
    1572:	9a00      	ldr	r2, [sp, #0]
    1574:	9b01      	ldr	r3, [sp, #4]
    1576:	429a      	cmp	r2, r3
    1578:	d90d      	bls.n	1596 <chTimeIsWithin+0x36>
    157a:	9a03      	ldr	r2, [sp, #12]
    157c:	9b01      	ldr	r3, [sp, #4]
    157e:	429a      	cmp	r2, r3
    1580:	d306      	bcc.n	1590 <chTimeIsWithin+0x30>
    1582:	9a03      	ldr	r2, [sp, #12]
    1584:	9b00      	ldr	r3, [sp, #0]
    1586:	429a      	cmp	r2, r3
    1588:	d202      	bcs.n	1590 <chTimeIsWithin+0x30>
    158a:	f04f 0301 	mov.w	r3, #1
    158e:	e001      	b.n	1594 <chTimeIsWithin+0x34>
    1590:	f04f 0300 	mov.w	r3, #0
    1594:	e00c      	b.n	15b0 <chTimeIsWithin+0x50>
    1596:	9a03      	ldr	r2, [sp, #12]
    1598:	9b01      	ldr	r3, [sp, #4]
    159a:	429a      	cmp	r2, r3
    159c:	d203      	bcs.n	15a6 <chTimeIsWithin+0x46>
                       (time >= start) || (time < end);
    159e:	9a03      	ldr	r2, [sp, #12]
    15a0:	9b00      	ldr	r3, [sp, #0]
    15a2:	429a      	cmp	r2, r3
    15a4:	d202      	bcs.n	15ac <chTimeIsWithin+0x4c>
 * @api
 */
bool_t chTimeIsWithin(systime_t start, systime_t end) {

  systime_t time = chTimeNow();
  return end > start ? (time >= start) && (time < end) :
    15a6:	f04f 0301 	mov.w	r3, #1
    15aa:	e001      	b.n	15b0 <chTimeIsWithin+0x50>
    15ac:	f04f 0300 	mov.w	r3, #0
                       (time >= start) || (time < end);
}
    15b0:	4618      	mov	r0, r3
    15b2:	b004      	add	sp, #16
    15b4:	4770      	bx	lr
    15b6:	bf00      	nop
    15b8:	f3af 8000 	nop.w
    15bc:	f3af 8000 	nop.w

000015c0 <fifo_remove>:
  tp->p_next = (Thread *)tqp;
  tp->p_prev = tqp->p_prev;
  tp->p_prev->p_next = tqp->p_prev = tp;
}

static INLINE Thread *fifo_remove(ThreadsQueue *tqp) {
    15c0:	b084      	sub	sp, #16
    15c2:	9001      	str	r0, [sp, #4]
  Thread *tp = tqp->p_next;
    15c4:	9b01      	ldr	r3, [sp, #4]
    15c6:	681b      	ldr	r3, [r3, #0]
    15c8:	9303      	str	r3, [sp, #12]

  (tqp->p_next = tp->p_next)->p_prev = (Thread *)tqp;
    15ca:	9b03      	ldr	r3, [sp, #12]
    15cc:	681a      	ldr	r2, [r3, #0]
    15ce:	9b01      	ldr	r3, [sp, #4]
    15d0:	601a      	str	r2, [r3, #0]
    15d2:	9b01      	ldr	r3, [sp, #4]
    15d4:	681b      	ldr	r3, [r3, #0]
    15d6:	9a01      	ldr	r2, [sp, #4]
    15d8:	605a      	str	r2, [r3, #4]
  return tp;
    15da:	9b03      	ldr	r3, [sp, #12]
}
    15dc:	4618      	mov	r0, r3
    15de:	b004      	add	sp, #16
    15e0:	4770      	bx	lr
    15e2:	bf00      	nop
    15e4:	f3af 8000 	nop.w
    15e8:	f3af 8000 	nop.w
    15ec:	f3af 8000 	nop.w

000015f0 <dequeue>:

  (tqp->p_prev = tp->p_prev)->p_next = (Thread *)tqp;
  return tp;
}

static INLINE Thread *dequeue(Thread *tp) {
    15f0:	b082      	sub	sp, #8
    15f2:	9001      	str	r0, [sp, #4]

  tp->p_prev->p_next = tp->p_next;
    15f4:	9b01      	ldr	r3, [sp, #4]
    15f6:	685b      	ldr	r3, [r3, #4]
    15f8:	9a01      	ldr	r2, [sp, #4]
    15fa:	6812      	ldr	r2, [r2, #0]
    15fc:	601a      	str	r2, [r3, #0]
  tp->p_next->p_prev = tp->p_prev;
    15fe:	9b01      	ldr	r3, [sp, #4]
    1600:	681b      	ldr	r3, [r3, #0]
    1602:	9a01      	ldr	r2, [sp, #4]
    1604:	6852      	ldr	r2, [r2, #4]
    1606:	605a      	str	r2, [r3, #4]
  return tp;
    1608:	9b01      	ldr	r3, [sp, #4]
}
    160a:	4618      	mov	r0, r3
    160c:	b002      	add	sp, #8
    160e:	4770      	bx	lr

00001610 <_scheduler_init>:
 *
 * @notapi
 */
void _scheduler_init(void) {

  queue_init(&rlist.r_queue);
    1610:	f240 7308 	movw	r3, #1800	; 0x708
    1614:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1618:	f240 7208 	movw	r2, #1800	; 0x708
    161c:	f2c2 0200 	movt	r2, #8192	; 0x2000
    1620:	605a      	str	r2, [r3, #4]
    1622:	f240 7308 	movw	r3, #1800	; 0x708
    1626:	f2c2 0300 	movt	r3, #8192	; 0x2000
    162a:	685a      	ldr	r2, [r3, #4]
    162c:	f240 7308 	movw	r3, #1800	; 0x708
    1630:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1634:	601a      	str	r2, [r3, #0]
  rlist.r_prio = NOPRIO;
    1636:	f240 7308 	movw	r3, #1800	; 0x708
    163a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    163e:	f04f 0200 	mov.w	r2, #0
    1642:	609a      	str	r2, [r3, #8]
#if CH_USE_REGISTRY
  rlist.r_newer = rlist.r_older = (Thread *)&rlist;
    1644:	f240 7308 	movw	r3, #1800	; 0x708
    1648:	f2c2 0300 	movt	r3, #8192	; 0x2000
    164c:	f240 7208 	movw	r2, #1800	; 0x708
    1650:	f2c2 0200 	movt	r2, #8192	; 0x2000
    1654:	615a      	str	r2, [r3, #20]
    1656:	f240 7308 	movw	r3, #1800	; 0x708
    165a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    165e:	695a      	ldr	r2, [r3, #20]
    1660:	f240 7308 	movw	r3, #1800	; 0x708
    1664:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1668:	611a      	str	r2, [r3, #16]
#endif
}
    166a:	4770      	bx	lr
    166c:	f3af 8000 	nop.w

00001670 <chSchReadyI>:
 * @return              The thread pointer.
 *
 * @iclass
 */
#if !defined(PORT_OPTIMIZED_READYI) || defined(__DOXYGEN__)
Thread *chSchReadyI(Thread *tp) {
    1670:	b084      	sub	sp, #16
    1672:	9001      	str	r0, [sp, #4]
  Thread *cp;

  chDbgCheckClassI();

  /* Integrity checks.*/
  chDbgAssert((tp->p_state != THD_STATE_READY) &&
    1674:	9b01      	ldr	r3, [sp, #4]
    1676:	7f1b      	ldrb	r3, [r3, #28]
 * @return              The thread pointer.
 *
 * @iclass
 */
#if !defined(PORT_OPTIMIZED_READYI) || defined(__DOXYGEN__)
Thread *chSchReadyI(Thread *tp) {
    1678:	2b00      	cmp	r3, #0
    167a:	d003      	beq.n	1684 <chSchReadyI+0x14>
  Thread *cp;

  chDbgCheckClassI();

  /* Integrity checks.*/
  chDbgAssert((tp->p_state != THD_STATE_READY) &&
    167c:	9b01      	ldr	r3, [sp, #4]
    167e:	7f1b      	ldrb	r3, [r3, #28]
    1680:	2b0e      	cmp	r3, #14
 * @return              The thread pointer.
 *
 * @iclass
 */
#if !defined(PORT_OPTIMIZED_READYI) || defined(__DOXYGEN__)
Thread *chSchReadyI(Thread *tp) {
    1682:	bf00      	nop
  chDbgAssert((tp->p_state != THD_STATE_READY) &&
              (tp->p_state != THD_STATE_FINAL),
              "chSchReadyI(), #1",
              "invalid state");

  tp->p_state = THD_STATE_READY;
    1684:	9b01      	ldr	r3, [sp, #4]
    1686:	f04f 0200 	mov.w	r2, #0
    168a:	771a      	strb	r2, [r3, #28]
  cp = (Thread *)&rlist.r_queue;
    168c:	f240 7308 	movw	r3, #1800	; 0x708
    1690:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1694:	9303      	str	r3, [sp, #12]
  do {
    cp = cp->p_next;
    1696:	9b03      	ldr	r3, [sp, #12]
    1698:	681b      	ldr	r3, [r3, #0]
    169a:	9303      	str	r3, [sp, #12]
  } while (cp->p_prio >= tp->p_prio);
    169c:	9b03      	ldr	r3, [sp, #12]
    169e:	689a      	ldr	r2, [r3, #8]
    16a0:	9b01      	ldr	r3, [sp, #4]
    16a2:	689b      	ldr	r3, [r3, #8]
    16a4:	429a      	cmp	r2, r3
    16a6:	d2f6      	bcs.n	1696 <chSchReadyI+0x26>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
    16a8:	9b01      	ldr	r3, [sp, #4]
    16aa:	9a03      	ldr	r2, [sp, #12]
    16ac:	601a      	str	r2, [r3, #0]
  tp->p_prev = cp->p_prev;
    16ae:	9b03      	ldr	r3, [sp, #12]
    16b0:	685a      	ldr	r2, [r3, #4]
    16b2:	9b01      	ldr	r3, [sp, #4]
    16b4:	605a      	str	r2, [r3, #4]
  tp->p_prev->p_next = cp->p_prev = tp;
    16b6:	9b01      	ldr	r3, [sp, #4]
    16b8:	685b      	ldr	r3, [r3, #4]
    16ba:	9a03      	ldr	r2, [sp, #12]
    16bc:	9901      	ldr	r1, [sp, #4]
    16be:	6051      	str	r1, [r2, #4]
    16c0:	9a03      	ldr	r2, [sp, #12]
    16c2:	6852      	ldr	r2, [r2, #4]
    16c4:	601a      	str	r2, [r3, #0]
  return tp;
    16c6:	9b01      	ldr	r3, [sp, #4]
}
    16c8:	4618      	mov	r0, r3
    16ca:	b004      	add	sp, #16
    16cc:	4770      	bx	lr
    16ce:	bf00      	nop

000016d0 <chSchGoSleepS>:
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
#if !defined(PORT_OPTIMIZED_GOSLEEPS) || defined(__DOXYGEN__)
void chSchGoSleepS(tstate_t newstate) {
    16d0:	b500      	push	{lr}
    16d2:	b085      	sub	sp, #20
    16d4:	4603      	mov	r3, r0
    16d6:	f88d 3007 	strb.w	r3, [sp, #7]
  Thread *otp;

  chDbgCheckClassS();

  (otp = currp)->p_state = newstate;
    16da:	f240 7308 	movw	r3, #1800	; 0x708
    16de:	f2c2 0300 	movt	r3, #8192	; 0x2000
    16e2:	699b      	ldr	r3, [r3, #24]
    16e4:	9303      	str	r3, [sp, #12]
    16e6:	9b03      	ldr	r3, [sp, #12]
    16e8:	f89d 2007 	ldrb.w	r2, [sp, #7]
    16ec:	771a      	strb	r2, [r3, #28]
#if CH_TIME_QUANTUM > 0
  /* The thread is renouncing its remaining time slices so it will have a new
     time quantum when it will wakeup.*/
  otp->p_preempt = CH_TIME_QUANTUM;
    16ee:	9b03      	ldr	r3, [sp, #12]
    16f0:	f04f 0214 	mov.w	r2, #20
    16f4:	77da      	strb	r2, [r3, #31]
#endif
  setcurrp(fifo_remove(&rlist.r_queue));
    16f6:	f240 7008 	movw	r0, #1800	; 0x708
    16fa:	f2c2 0000 	movt	r0, #8192	; 0x2000
    16fe:	f7ff ff5f 	bl	15c0 <fifo_remove>
    1702:	4602      	mov	r2, r0
    1704:	f240 7308 	movw	r3, #1800	; 0x708
    1708:	f2c2 0300 	movt	r3, #8192	; 0x2000
    170c:	619a      	str	r2, [r3, #24]
  currp->p_state = THD_STATE_CURRENT;
    170e:	f240 7308 	movw	r3, #1800	; 0x708
    1712:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1716:	699b      	ldr	r3, [r3, #24]
    1718:	f04f 0201 	mov.w	r2, #1
    171c:	771a      	strb	r2, [r3, #28]
  chSysSwitch(currp, otp);
    171e:	f240 7308 	movw	r3, #1800	; 0x708
    1722:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1726:	699b      	ldr	r3, [r3, #24]
    1728:	4618      	mov	r0, r3
    172a:	9903      	ldr	r1, [sp, #12]
    172c:	f000 ff90 	bl	2650 <_port_switch>
}
    1730:	b005      	add	sp, #20
    1732:	bd00      	pop	{pc}
    1734:	f3af 8000 	nop.w
    1738:	f3af 8000 	nop.w
    173c:	f3af 8000 	nop.w

00001740 <wakeup>:

#if !defined(PORT_OPTIMIZED_GOSLEEPTIMEOUTS) || defined(__DOXYGEN__)
/*
 * Timeout wakeup callback.
 */
static void wakeup(void *p) {
    1740:	b500      	push	{lr}
    1742:	b085      	sub	sp, #20
    1744:	9001      	str	r0, [sp, #4]
  Thread *tp = (Thread *)p;
    1746:	9b01      	ldr	r3, [sp, #4]
    1748:	9303      	str	r3, [sp, #12]

  chSysLockFromIsr();
    174a:	f04f 0320 	mov.w	r3, #32
    174e:	f383 8811 	msr	BASEPRI, r3
  switch (tp->p_state) {
    1752:	9b03      	ldr	r3, [sp, #12]
    1754:	7f1b      	ldrb	r3, [r3, #28]
    1756:	2b0d      	cmp	r3, #13
    1758:	d82c      	bhi.n	17b4 <wakeup+0x74>
    175a:	a201      	add	r2, pc, #4	; (adr r2, 1760 <wakeup+0x20>)
    175c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    1760:	00001799 	muleq	r0, r9, r7
    1764:	000017b5 			; <UNDEFINED> instruction: 0x000017b5
    1768:	000017b5 			; <UNDEFINED> instruction: 0x000017b5
    176c:	000017a3 	andeq	r1, r0, r3, lsr #15
    1770:	000017b5 			; <UNDEFINED> instruction: 0x000017b5
    1774:	000017af 	andeq	r1, r0, pc, lsr #15
    1778:	000017b5 			; <UNDEFINED> instruction: 0x000017b5
    177c:	000017b5 			; <UNDEFINED> instruction: 0x000017b5
    1780:	000017b5 			; <UNDEFINED> instruction: 0x000017b5
    1784:	000017b5 			; <UNDEFINED> instruction: 0x000017b5
    1788:	000017b5 			; <UNDEFINED> instruction: 0x000017b5
    178c:	000017b5 			; <UNDEFINED> instruction: 0x000017b5
    1790:	000017b5 			; <UNDEFINED> instruction: 0x000017b5
    1794:	000017af 	andeq	r1, r0, pc, lsr #15
  case THD_STATE_READY:
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromIsr();
    1798:	f04f 0300 	mov.w	r3, #0
    179c:	f383 8811 	msr	BASEPRI, r3
    return;
    17a0:	e013      	b.n	17ca <wakeup+0x8a>
#if CH_USE_SEMAPHORES || CH_USE_QUEUES ||                                   \
    (CH_USE_CONDVARS && CH_USE_CONDVARS_TIMEOUT)
#if CH_USE_SEMAPHORES
  case THD_STATE_WTSEM:
    chSemFastSignalI((Semaphore *)tp->p_u.wtobjp);
    17a2:	9b03      	ldr	r3, [sp, #12]
    17a4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    17a6:	689a      	ldr	r2, [r3, #8]
    17a8:	f102 0201 	add.w	r2, r2, #1
    17ac:	609a      	str	r2, [r3, #8]
#endif
#if CH_USE_CONDVARS && CH_USE_CONDVARS_TIMEOUT
  case THD_STATE_WTCOND:
#endif
    /* States requiring dequeuing.*/
    dequeue(tp);
    17ae:	9803      	ldr	r0, [sp, #12]
    17b0:	f7ff ff1e 	bl	15f0 <dequeue>
#endif
  }
  tp->p_u.rdymsg = RDY_TIMEOUT;
    17b4:	9b03      	ldr	r3, [sp, #12]
    17b6:	f04f 32ff 	mov.w	r2, #4294967295
    17ba:	625a      	str	r2, [r3, #36]	; 0x24
  chSchReadyI(tp);
    17bc:	9803      	ldr	r0, [sp, #12]
    17be:	f7ff ff57 	bl	1670 <chSchReadyI>
  chSysUnlockFromIsr();
    17c2:	f04f 0300 	mov.w	r3, #0
    17c6:	f383 8811 	msr	BASEPRI, r3
}
    17ca:	b005      	add	sp, #20
    17cc:	bd00      	pop	{pc}
    17ce:	bf00      	nop

000017d0 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval RDY_TIMEOUT if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
    17d0:	b500      	push	{lr}
    17d2:	b089      	sub	sp, #36	; 0x24
    17d4:	4603      	mov	r3, r0
    17d6:	9100      	str	r1, [sp, #0]
    17d8:	f88d 3007 	strb.w	r3, [sp, #7]

  chDbgCheckClassS();

  if (TIME_INFINITE != time) {
    17dc:	9b00      	ldr	r3, [sp, #0]
    17de:	f1b3 3fff 	cmp.w	r3, #4294967295
    17e2:	d01a      	beq.n	181a <chSchGoSleepTimeoutS+0x4a>
    VirtualTimer vt;

    chVTSetI(&vt, time, wakeup, currp);
    17e4:	f240 7308 	movw	r3, #1800	; 0x708
    17e8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    17ec:	699b      	ldr	r3, [r3, #24]
    17ee:	aa03      	add	r2, sp, #12
    17f0:	4610      	mov	r0, r2
    17f2:	9900      	ldr	r1, [sp, #0]
    17f4:	f241 7241 	movw	r2, #5953	; 0x1741
    17f8:	f2c0 0200 	movt	r2, #0
    17fc:	f7ff fe38 	bl	1470 <chVTSetI>
    chSchGoSleepS(newstate);
    1800:	f89d 3007 	ldrb.w	r3, [sp, #7]
    1804:	4618      	mov	r0, r3
    1806:	f7ff ff63 	bl	16d0 <chSchGoSleepS>
    if (chVTIsArmedI(&vt))
    180a:	9b06      	ldr	r3, [sp, #24]
    180c:	2b00      	cmp	r3, #0
    180e:	d009      	beq.n	1824 <chSchGoSleepTimeoutS+0x54>
      chVTResetI(&vt);
    1810:	ab03      	add	r3, sp, #12
    1812:	4618      	mov	r0, r3
    1814:	f7ff fe7c 	bl	1510 <chVTResetI>
    1818:	e004      	b.n	1824 <chSchGoSleepTimeoutS+0x54>
  }
  else
    chSchGoSleepS(newstate);
    181a:	f89d 3007 	ldrb.w	r3, [sp, #7]
    181e:	4618      	mov	r0, r3
    1820:	f7ff ff56 	bl	16d0 <chSchGoSleepS>
  return currp->p_u.rdymsg;
    1824:	f240 7308 	movw	r3, #1800	; 0x708
    1828:	f2c2 0300 	movt	r3, #8192	; 0x2000
    182c:	699b      	ldr	r3, [r3, #24]
    182e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
    1830:	4618      	mov	r0, r3
    1832:	b009      	add	sp, #36	; 0x24
    1834:	bd00      	pop	{pc}
    1836:	bf00      	nop
    1838:	f3af 8000 	nop.w
    183c:	f3af 8000 	nop.w

00001840 <chSchWakeupS>:
 * @param[in] msg       message to the awakened thread
 *
 * @sclass
 */
#if !defined(PORT_OPTIMIZED_WAKEUPS) || defined(__DOXYGEN__)
void chSchWakeupS(Thread *ntp, msg_t msg) {
    1840:	b500      	push	{lr}
    1842:	b085      	sub	sp, #20
    1844:	9001      	str	r0, [sp, #4]
    1846:	9100      	str	r1, [sp, #0]

  chDbgCheckClassS();

  ntp->p_u.rdymsg = msg;
    1848:	9b01      	ldr	r3, [sp, #4]
    184a:	9a00      	ldr	r2, [sp, #0]
    184c:	625a      	str	r2, [r3, #36]	; 0x24
  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio)
    184e:	9b01      	ldr	r3, [sp, #4]
    1850:	689a      	ldr	r2, [r3, #8]
    1852:	f240 7308 	movw	r3, #1800	; 0x708
    1856:	f2c2 0300 	movt	r3, #8192	; 0x2000
    185a:	699b      	ldr	r3, [r3, #24]
    185c:	689b      	ldr	r3, [r3, #8]
    185e:	429a      	cmp	r2, r3
    1860:	d803      	bhi.n	186a <chSchWakeupS+0x2a>
    chSchReadyI(ntp);
    1862:	9801      	ldr	r0, [sp, #4]
    1864:	f7ff ff04 	bl	1670 <chSchReadyI>
    1868:	e016      	b.n	1898 <chSchWakeupS+0x58>
  else {
    Thread *otp = chSchReadyI(currp);
    186a:	f240 7308 	movw	r3, #1800	; 0x708
    186e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1872:	699b      	ldr	r3, [r3, #24]
    1874:	4618      	mov	r0, r3
    1876:	f7ff fefb 	bl	1670 <chSchReadyI>
    187a:	9003      	str	r0, [sp, #12]
    setcurrp(ntp);
    187c:	f240 7308 	movw	r3, #1800	; 0x708
    1880:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1884:	9a01      	ldr	r2, [sp, #4]
    1886:	619a      	str	r2, [r3, #24]
    ntp->p_state = THD_STATE_CURRENT;
    1888:	9b01      	ldr	r3, [sp, #4]
    188a:	f04f 0201 	mov.w	r2, #1
    188e:	771a      	strb	r2, [r3, #28]
    chSysSwitch(ntp, otp);
    1890:	9801      	ldr	r0, [sp, #4]
    1892:	9903      	ldr	r1, [sp, #12]
    1894:	f000 fedc 	bl	2650 <_port_switch>
  }
}
    1898:	b005      	add	sp, #20
    189a:	bd00      	pop	{pc}
    189c:	f3af 8000 	nop.w

000018a0 <chSchRescheduleS>:
 *          the ready list then make the higher priority thread running.
 *
 * @sclass
 */
#if !defined(PORT_OPTIMIZED_RESCHEDULES) || defined(__DOXYGEN__)
void chSchRescheduleS(void) {
    18a0:	b508      	push	{r3, lr}

  chDbgCheckClassS();

  if (chSchIsRescRequiredI())
    18a2:	f240 7308 	movw	r3, #1800	; 0x708
    18a6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    18aa:	681b      	ldr	r3, [r3, #0]
    18ac:	689a      	ldr	r2, [r3, #8]
    18ae:	f240 7308 	movw	r3, #1800	; 0x708
    18b2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    18b6:	699b      	ldr	r3, [r3, #24]
    18b8:	689b      	ldr	r3, [r3, #8]
    18ba:	429a      	cmp	r2, r3
    18bc:	d901      	bls.n	18c2 <chSchRescheduleS+0x22>
    chSchDoRescheduleAhead();
    18be:	f000 f837 	bl	1930 <chSchDoRescheduleAhead>
}
    18c2:	bd08      	pop	{r3, pc}
    18c4:	f3af 8000 	nop.w
    18c8:	f3af 8000 	nop.w
    18cc:	f3af 8000 	nop.w

000018d0 <chSchDoRescheduleBehind>:
 *          itself or from within the port layer.
 *
 * @special
 */
#if !defined(PORT_OPTIMIZED_DORESCHEDULEBEHIND) || defined(__DOXYGEN__)
void chSchDoRescheduleBehind(void) {
    18d0:	b500      	push	{lr}
    18d2:	b083      	sub	sp, #12
  Thread *otp;

  otp = currp;
    18d4:	f240 7308 	movw	r3, #1800	; 0x708
    18d8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    18dc:	699b      	ldr	r3, [r3, #24]
    18de:	9301      	str	r3, [sp, #4]
  /* Picks the first thread from the ready queue and makes it current.*/
  setcurrp(fifo_remove(&rlist.r_queue));
    18e0:	f240 7008 	movw	r0, #1800	; 0x708
    18e4:	f2c2 0000 	movt	r0, #8192	; 0x2000
    18e8:	f7ff fe6a 	bl	15c0 <fifo_remove>
    18ec:	4602      	mov	r2, r0
    18ee:	f240 7308 	movw	r3, #1800	; 0x708
    18f2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    18f6:	619a      	str	r2, [r3, #24]
  currp->p_state = THD_STATE_CURRENT;
    18f8:	f240 7308 	movw	r3, #1800	; 0x708
    18fc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1900:	699b      	ldr	r3, [r3, #24]
    1902:	f04f 0201 	mov.w	r2, #1
    1906:	771a      	strb	r2, [r3, #28]
#if CH_TIME_QUANTUM > 0
  otp->p_preempt = CH_TIME_QUANTUM;
    1908:	9b01      	ldr	r3, [sp, #4]
    190a:	f04f 0214 	mov.w	r2, #20
    190e:	77da      	strb	r2, [r3, #31]
#endif
  chSchReadyI(otp);
    1910:	9801      	ldr	r0, [sp, #4]
    1912:	f7ff fead 	bl	1670 <chSchReadyI>
  chSysSwitch(currp, otp);
    1916:	f240 7308 	movw	r3, #1800	; 0x708
    191a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    191e:	699b      	ldr	r3, [r3, #24]
    1920:	4618      	mov	r0, r3
    1922:	9901      	ldr	r1, [sp, #4]
    1924:	f000 fe94 	bl	2650 <_port_switch>
}
    1928:	b003      	add	sp, #12
    192a:	bd00      	pop	{pc}
    192c:	f3af 8000 	nop.w

00001930 <chSchDoRescheduleAhead>:
 *          itself or from within the port layer.
 *
 * @special
 */
#if !defined(PORT_OPTIMIZED_DORESCHEDULEAHEAD) || defined(__DOXYGEN__)
void chSchDoRescheduleAhead(void) {
    1930:	b500      	push	{lr}
    1932:	b083      	sub	sp, #12
  Thread *otp, *cp;

  otp = currp;
    1934:	f240 7308 	movw	r3, #1800	; 0x708
    1938:	f2c2 0300 	movt	r3, #8192	; 0x2000
    193c:	699b      	ldr	r3, [r3, #24]
    193e:	9300      	str	r3, [sp, #0]
  /* Picks the first thread from the ready queue and makes it current.*/
  setcurrp(fifo_remove(&rlist.r_queue));
    1940:	f240 7008 	movw	r0, #1800	; 0x708
    1944:	f2c2 0000 	movt	r0, #8192	; 0x2000
    1948:	f7ff fe3a 	bl	15c0 <fifo_remove>
    194c:	4602      	mov	r2, r0
    194e:	f240 7308 	movw	r3, #1800	; 0x708
    1952:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1956:	619a      	str	r2, [r3, #24]
  currp->p_state = THD_STATE_CURRENT;
    1958:	f240 7308 	movw	r3, #1800	; 0x708
    195c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1960:	699b      	ldr	r3, [r3, #24]
    1962:	f04f 0201 	mov.w	r2, #1
    1966:	771a      	strb	r2, [r3, #28]

  otp->p_state = THD_STATE_READY;
    1968:	9b00      	ldr	r3, [sp, #0]
    196a:	f04f 0200 	mov.w	r2, #0
    196e:	771a      	strb	r2, [r3, #28]
  cp = (Thread *)&rlist.r_queue;
    1970:	f240 7308 	movw	r3, #1800	; 0x708
    1974:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1978:	9301      	str	r3, [sp, #4]
  do {
    cp = cp->p_next;
    197a:	9b01      	ldr	r3, [sp, #4]
    197c:	681b      	ldr	r3, [r3, #0]
    197e:	9301      	str	r3, [sp, #4]
  } while (cp->p_prio > otp->p_prio);
    1980:	9b01      	ldr	r3, [sp, #4]
    1982:	689a      	ldr	r2, [r3, #8]
    1984:	9b00      	ldr	r3, [sp, #0]
    1986:	689b      	ldr	r3, [r3, #8]
    1988:	429a      	cmp	r2, r3
    198a:	d8f6      	bhi.n	197a <chSchDoRescheduleAhead+0x4a>
  /* Insertion on p_prev.*/
  otp->p_next = cp;
    198c:	9b00      	ldr	r3, [sp, #0]
    198e:	9a01      	ldr	r2, [sp, #4]
    1990:	601a      	str	r2, [r3, #0]
  otp->p_prev = cp->p_prev;
    1992:	9b01      	ldr	r3, [sp, #4]
    1994:	685a      	ldr	r2, [r3, #4]
    1996:	9b00      	ldr	r3, [sp, #0]
    1998:	605a      	str	r2, [r3, #4]
  otp->p_prev->p_next = cp->p_prev = otp;
    199a:	9b00      	ldr	r3, [sp, #0]
    199c:	685b      	ldr	r3, [r3, #4]
    199e:	9a01      	ldr	r2, [sp, #4]
    19a0:	9900      	ldr	r1, [sp, #0]
    19a2:	6051      	str	r1, [r2, #4]
    19a4:	9a01      	ldr	r2, [sp, #4]
    19a6:	6852      	ldr	r2, [r2, #4]
    19a8:	601a      	str	r2, [r3, #0]

  chSysSwitch(currp, otp);
    19aa:	f240 7308 	movw	r3, #1800	; 0x708
    19ae:	f2c2 0300 	movt	r3, #8192	; 0x2000
    19b2:	699b      	ldr	r3, [r3, #24]
    19b4:	4618      	mov	r0, r3
    19b6:	9900      	ldr	r1, [sp, #0]
    19b8:	f000 fe4a 	bl	2650 <_port_switch>
}
    19bc:	b003      	add	sp, #12
    19be:	bd00      	pop	{pc}

000019c0 <chSchDoReschedule>:
 *          itself or from within the port layer.
 *
 * @special
 */
#if !defined(PORT_OPTIMIZED_DORESCHEDULE) || defined(__DOXYGEN__)
void chSchDoReschedule(void) {
    19c0:	b508      	push	{r3, lr}

#if CH_TIME_QUANTUM > 0
  /* If CH_TIME_QUANTUM is enabled then there are two different scenarios to
     handle on preemption: time quantum elapsed or not.*/
  if (currp->p_preempt == 0) {
    19c2:	f240 7308 	movw	r3, #1800	; 0x708
    19c6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    19ca:	699b      	ldr	r3, [r3, #24]
    19cc:	7fdb      	ldrb	r3, [r3, #31]
    19ce:	2b00      	cmp	r3, #0
    19d0:	d102      	bne.n	19d8 <chSchDoReschedule+0x18>
    /* The thread consumed its time quantum so it is enqueued behind threads
       with same priority level, however, it acquires a new time quantum.*/
    chSchDoRescheduleBehind();
    19d2:	f7ff ff7d 	bl	18d0 <chSchDoRescheduleBehind>
    19d6:	e001      	b.n	19dc <chSchDoReschedule+0x1c>
  }
  else {
    /* The thread didn't consume all its time quantum so it is put ahead of
       threads with equal priority and does not acquire a new time quantum.*/
    chSchDoRescheduleAhead();
    19d8:	f7ff ffaa 	bl	1930 <chSchDoRescheduleAhead>
#else /* !(CH_TIME_QUANTUM > 0) */
  /* If the round-robin mechanism is disabled then the thread goes always
     ahead of its peers.*/
  chSchDoRescheduleAhead();
#endif /* !(CH_TIME_QUANTUM > 0) */
}
    19dc:	bd08      	pop	{r3, pc}
    19de:	bf00      	nop

000019e0 <list_insert>:

static INLINE void list_insert(Thread *tp, ThreadsList *tlp) {
    19e0:	b082      	sub	sp, #8
    19e2:	9001      	str	r0, [sp, #4]
    19e4:	9100      	str	r1, [sp, #0]

  tp->p_next = tlp->p_next;
    19e6:	9b00      	ldr	r3, [sp, #0]
    19e8:	681a      	ldr	r2, [r3, #0]
    19ea:	9b01      	ldr	r3, [sp, #4]
    19ec:	601a      	str	r2, [r3, #0]
  tlp->p_next = tp;
    19ee:	9b00      	ldr	r3, [sp, #0]
    19f0:	9a01      	ldr	r2, [sp, #4]
    19f2:	601a      	str	r2, [r3, #0]
}
    19f4:	b002      	add	sp, #8
    19f6:	4770      	bx	lr
    19f8:	f3af 8000 	nop.w
    19fc:	f3af 8000 	nop.w

00001a00 <list_remove>:

static INLINE Thread *list_remove(ThreadsList *tlp) {
    1a00:	b084      	sub	sp, #16
    1a02:	9001      	str	r0, [sp, #4]

  Thread *tp = tlp->p_next;
    1a04:	9b01      	ldr	r3, [sp, #4]
    1a06:	681b      	ldr	r3, [r3, #0]
    1a08:	9303      	str	r3, [sp, #12]
  tlp->p_next = tp->p_next;
    1a0a:	9b03      	ldr	r3, [sp, #12]
    1a0c:	681a      	ldr	r2, [r3, #0]
    1a0e:	9b01      	ldr	r3, [sp, #4]
    1a10:	601a      	str	r2, [r3, #0]
  return tp;
    1a12:	9b03      	ldr	r3, [sp, #12]
}
    1a14:	4618      	mov	r0, r3
    1a16:	b004      	add	sp, #16
    1a18:	4770      	bx	lr
    1a1a:	bf00      	nop
    1a1c:	f3af 8000 	nop.w

00001a20 <_thread_init>:
 * @param[in] prio      the priority level for the new thread
 * @return              The same thread pointer passed as parameter.
 *
 * @notapi
 */
Thread *_thread_init(Thread *tp, tprio_t prio) {
    1a20:	b082      	sub	sp, #8
    1a22:	9001      	str	r0, [sp, #4]
    1a24:	9100      	str	r1, [sp, #0]

  tp->p_prio = prio;
    1a26:	9b01      	ldr	r3, [sp, #4]
    1a28:	9a00      	ldr	r2, [sp, #0]
    1a2a:	609a      	str	r2, [r3, #8]
  tp->p_state = THD_STATE_SUSPENDED;
    1a2c:	9b01      	ldr	r3, [sp, #4]
    1a2e:	f04f 0202 	mov.w	r2, #2
    1a32:	771a      	strb	r2, [r3, #28]
  tp->p_flags = THD_MEM_MODE_STATIC;
    1a34:	9b01      	ldr	r3, [sp, #4]
    1a36:	f04f 0200 	mov.w	r2, #0
    1a3a:	775a      	strb	r2, [r3, #29]
#if CH_TIME_QUANTUM > 0
  tp->p_preempt = CH_TIME_QUANTUM;
    1a3c:	9b01      	ldr	r3, [sp, #4]
    1a3e:	f04f 0214 	mov.w	r2, #20
    1a42:	77da      	strb	r2, [r3, #31]
#endif
#if CH_USE_MUTEXES
  tp->p_realprio = prio;
    1a44:	9b01      	ldr	r3, [sp, #4]
    1a46:	9a00      	ldr	r2, [sp, #0]
    1a48:	641a      	str	r2, [r3, #64]	; 0x40
  tp->p_mtxlist = NULL;
    1a4a:	9b01      	ldr	r3, [sp, #4]
    1a4c:	f04f 0200 	mov.w	r2, #0
    1a50:	63da      	str	r2, [r3, #60]	; 0x3c
#endif
#if CH_USE_EVENTS
  tp->p_epending = 0;
    1a52:	9b01      	ldr	r3, [sp, #4]
    1a54:	f04f 0200 	mov.w	r2, #0
    1a58:	639a      	str	r2, [r3, #56]	; 0x38
#endif
#if CH_DBG_THREADS_PROFILING
  tp->p_time = 0;
    1a5a:	9b01      	ldr	r3, [sp, #4]
    1a5c:	f04f 0200 	mov.w	r2, #0
    1a60:	621a      	str	r2, [r3, #32]
#endif
#if CH_USE_DYNAMIC
  tp->p_refs = 1;
    1a62:	9b01      	ldr	r3, [sp, #4]
    1a64:	f04f 0201 	mov.w	r2, #1
    1a68:	779a      	strb	r2, [r3, #30]
#endif
#if CH_USE_REGISTRY
  tp->p_name = NULL;
    1a6a:	9b01      	ldr	r3, [sp, #4]
    1a6c:	f04f 0200 	mov.w	r2, #0
    1a70:	619a      	str	r2, [r3, #24]
  REG_INSERT(tp);
    1a72:	9a01      	ldr	r2, [sp, #4]
    1a74:	f240 7308 	movw	r3, #1800	; 0x708
    1a78:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1a7c:	6113      	str	r3, [r2, #16]
    1a7e:	f240 7308 	movw	r3, #1800	; 0x708
    1a82:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1a86:	695a      	ldr	r2, [r3, #20]
    1a88:	9b01      	ldr	r3, [sp, #4]
    1a8a:	615a      	str	r2, [r3, #20]
    1a8c:	9b01      	ldr	r3, [sp, #4]
    1a8e:	695a      	ldr	r2, [r3, #20]
    1a90:	f240 7308 	movw	r3, #1800	; 0x708
    1a94:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1a98:	9901      	ldr	r1, [sp, #4]
    1a9a:	6159      	str	r1, [r3, #20]
    1a9c:	f240 7308 	movw	r3, #1800	; 0x708
    1aa0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1aa4:	695b      	ldr	r3, [r3, #20]
    1aa6:	6113      	str	r3, [r2, #16]
#endif
#if CH_USE_WAITEXIT
  list_init(&tp->p_waiting);
    1aa8:	9b01      	ldr	r3, [sp, #4]
    1aaa:	f103 0228 	add.w	r2, r3, #40	; 0x28
    1aae:	9b01      	ldr	r3, [sp, #4]
    1ab0:	629a      	str	r2, [r3, #40]	; 0x28
#endif
#if CH_USE_MESSAGES
  queue_init(&tp->p_msgqueue);
    1ab2:	9b01      	ldr	r3, [sp, #4]
    1ab4:	f103 022c 	add.w	r2, r3, #44	; 0x2c
    1ab8:	9b01      	ldr	r3, [sp, #4]
    1aba:	631a      	str	r2, [r3, #48]	; 0x30
    1abc:	9b01      	ldr	r3, [sp, #4]
    1abe:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    1ac0:	9b01      	ldr	r3, [sp, #4]
    1ac2:	62da      	str	r2, [r3, #44]	; 0x2c
  tp->p_stklimit = (stkalign_t *)(tp + 1);
#endif
#if defined(THREAD_EXT_INIT_HOOK)
  THREAD_EXT_INIT_HOOK(tp);
#endif
  return tp;
    1ac4:	9b01      	ldr	r3, [sp, #4]
}
    1ac6:	4618      	mov	r0, r3
    1ac8:	b002      	add	sp, #8
    1aca:	4770      	bx	lr
    1acc:	f3af 8000 	nop.w

00001ad0 <chThdCreateI>:
 *                      the thread into the working space area.
 *
 * @iclass
 */
Thread *chThdCreateI(void *wsp, size_t size,
                     tprio_t prio, tfunc_t pf, void *arg) {
    1ad0:	b500      	push	{lr}
    1ad2:	b087      	sub	sp, #28
    1ad4:	9003      	str	r0, [sp, #12]
    1ad6:	9102      	str	r1, [sp, #8]
    1ad8:	9201      	str	r2, [sp, #4]
    1ada:	9300      	str	r3, [sp, #0]
  /* Thread structure is layed out in the lower part of the thread workspace.*/
  Thread *tp = wsp;
    1adc:	9b03      	ldr	r3, [sp, #12]
    1ade:	9305      	str	r3, [sp, #20]

  chDbgCheckClassI();

  chDbgCheck((wsp != NULL) && (size >= THD_WA_SIZE(0)) &&
    1ae0:	9b03      	ldr	r3, [sp, #12]
    1ae2:	2b00      	cmp	r3, #0
    1ae4:	d007      	beq.n	1af6 <chThdCreateI+0x26>
    1ae6:	9b02      	ldr	r3, [sp, #8]
    1ae8:	2baf      	cmp	r3, #175	; 0xaf
    1aea:	d904      	bls.n	1af6 <chThdCreateI+0x26>
    1aec:	9b01      	ldr	r3, [sp, #4]
    1aee:	2b7f      	cmp	r3, #127	; 0x7f
    1af0:	d801      	bhi.n	1af6 <chThdCreateI+0x26>
    1af2:	9b00      	ldr	r3, [sp, #0]
    1af4:	2b00      	cmp	r3, #0
             (prio <= HIGHPRIO) && (pf != NULL),
             "chThdCreateI");
  SETUP_CONTEXT(wsp, size, pf, arg);
    1af6:	9b02      	ldr	r3, [sp, #8]
    1af8:	f1a3 0324 	sub.w	r3, r3, #36	; 0x24
    1afc:	9a03      	ldr	r2, [sp, #12]
    1afe:	18d2      	adds	r2, r2, r3
    1b00:	9b05      	ldr	r3, [sp, #20]
    1b02:	60da      	str	r2, [r3, #12]
    1b04:	9b05      	ldr	r3, [sp, #20]
    1b06:	68db      	ldr	r3, [r3, #12]
    1b08:	9a00      	ldr	r2, [sp, #0]
    1b0a:	601a      	str	r2, [r3, #0]
    1b0c:	9b05      	ldr	r3, [sp, #20]
    1b0e:	68db      	ldr	r3, [r3, #12]
    1b10:	9a08      	ldr	r2, [sp, #32]
    1b12:	605a      	str	r2, [r3, #4]
    1b14:	9b05      	ldr	r3, [sp, #20]
    1b16:	68da      	ldr	r2, [r3, #12]
    1b18:	f242 6371 	movw	r3, #9841	; 0x2671
    1b1c:	f2c0 0300 	movt	r3, #0
    1b20:	6213      	str	r3, [r2, #32]
  return _thread_init(tp, prio);
    1b22:	9805      	ldr	r0, [sp, #20]
    1b24:	9901      	ldr	r1, [sp, #4]
    1b26:	f7ff ff7b 	bl	1a20 <_thread_init>
    1b2a:	4603      	mov	r3, r0
}
    1b2c:	4618      	mov	r0, r3
    1b2e:	b007      	add	sp, #28
    1b30:	bd00      	pop	{pc}
    1b32:	bf00      	nop
    1b34:	f3af 8000 	nop.w
    1b38:	f3af 8000 	nop.w
    1b3c:	f3af 8000 	nop.w

00001b40 <chThdCreateStatic>:
 *                      the thread into the working space area.
 *
 * @api
 */
Thread *chThdCreateStatic(void *wsp, size_t size,
                          tprio_t prio, tfunc_t pf, void *arg) {
    1b40:	b500      	push	{lr}
    1b42:	b089      	sub	sp, #36	; 0x24
    1b44:	9005      	str	r0, [sp, #20]
    1b46:	9104      	str	r1, [sp, #16]
    1b48:	9203      	str	r2, [sp, #12]
    1b4a:	9302      	str	r3, [sp, #8]
                  CH_THREAD_FILL_VALUE);
  _thread_memfill((uint8_t *)wsp + sizeof(Thread),
                  (uint8_t *)wsp + size,
                  CH_STACK_FILL_VALUE);
#endif
  chSysLock();
    1b4c:	f04f 0320 	mov.w	r3, #32
    1b50:	f383 8811 	msr	BASEPRI, r3
  chSchWakeupS(tp = chThdCreateI(wsp, size, prio, pf, arg), RDY_OK);
    1b54:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    1b56:	9300      	str	r3, [sp, #0]
    1b58:	9805      	ldr	r0, [sp, #20]
    1b5a:	9904      	ldr	r1, [sp, #16]
    1b5c:	9a03      	ldr	r2, [sp, #12]
    1b5e:	9b02      	ldr	r3, [sp, #8]
    1b60:	f7ff ffb6 	bl	1ad0 <chThdCreateI>
    1b64:	9007      	str	r0, [sp, #28]
    1b66:	9807      	ldr	r0, [sp, #28]
    1b68:	f04f 0100 	mov.w	r1, #0
    1b6c:	f7ff fe68 	bl	1840 <chSchWakeupS>
  chSysUnlock();
    1b70:	f04f 0300 	mov.w	r3, #0
    1b74:	f383 8811 	msr	BASEPRI, r3
  return tp;
    1b78:	9b07      	ldr	r3, [sp, #28]
}
    1b7a:	4618      	mov	r0, r3
    1b7c:	b009      	add	sp, #36	; 0x24
    1b7e:	bd00      	pop	{pc}

00001b80 <chThdSetPriority>:
 * @param[in] newprio   the new priority level of the running thread
 * @return              The old priority level.
 *
 * @api
 */
tprio_t chThdSetPriority(tprio_t newprio) {
    1b80:	b500      	push	{lr}
    1b82:	b085      	sub	sp, #20
    1b84:	9001      	str	r0, [sp, #4]
  tprio_t oldprio;

  chDbgCheck(newprio <= HIGHPRIO, "chThdSetPriority");

  chSysLock();
    1b86:	f04f 0320 	mov.w	r3, #32
    1b8a:	f383 8811 	msr	BASEPRI, r3
#if CH_USE_MUTEXES
  oldprio = currp->p_realprio;
    1b8e:	f240 7308 	movw	r3, #1800	; 0x708
    1b92:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1b96:	699b      	ldr	r3, [r3, #24]
    1b98:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    1b9a:	9303      	str	r3, [sp, #12]
  if ((currp->p_prio == currp->p_realprio) || (newprio > currp->p_prio))
    1b9c:	f240 7308 	movw	r3, #1800	; 0x708
    1ba0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1ba4:	699b      	ldr	r3, [r3, #24]
    1ba6:	689a      	ldr	r2, [r3, #8]
    1ba8:	f240 7308 	movw	r3, #1800	; 0x708
    1bac:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1bb0:	699b      	ldr	r3, [r3, #24]
    1bb2:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    1bb4:	429a      	cmp	r2, r3
    1bb6:	d008      	beq.n	1bca <chThdSetPriority+0x4a>
    1bb8:	f240 7308 	movw	r3, #1800	; 0x708
    1bbc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1bc0:	699b      	ldr	r3, [r3, #24]
    1bc2:	689a      	ldr	r2, [r3, #8]
    1bc4:	9b01      	ldr	r3, [sp, #4]
    1bc6:	429a      	cmp	r2, r3
    1bc8:	d206      	bcs.n	1bd8 <chThdSetPriority+0x58>
    currp->p_prio = newprio;
    1bca:	f240 7308 	movw	r3, #1800	; 0x708
    1bce:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1bd2:	699b      	ldr	r3, [r3, #24]
    1bd4:	9a01      	ldr	r2, [sp, #4]
    1bd6:	609a      	str	r2, [r3, #8]
  currp->p_realprio = newprio;
    1bd8:	f240 7308 	movw	r3, #1800	; 0x708
    1bdc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1be0:	699b      	ldr	r3, [r3, #24]
    1be2:	9a01      	ldr	r2, [sp, #4]
    1be4:	641a      	str	r2, [r3, #64]	; 0x40
#else
  oldprio = currp->p_prio;
  currp->p_prio = newprio;
#endif
  chSchRescheduleS();
    1be6:	f7ff fe5b 	bl	18a0 <chSchRescheduleS>
  chSysUnlock();
    1bea:	f04f 0300 	mov.w	r3, #0
    1bee:	f383 8811 	msr	BASEPRI, r3
  return oldprio;
    1bf2:	9b03      	ldr	r3, [sp, #12]
}
    1bf4:	4618      	mov	r0, r3
    1bf6:	b005      	add	sp, #20
    1bf8:	bd00      	pop	{pc}
    1bfa:	bf00      	nop
    1bfc:	f3af 8000 	nop.w

00001c00 <chThdResume>:
 * @param[in] tp        pointer to the thread
 * @return              The pointer to the thread.
 *
 * @api
 */
Thread *chThdResume(Thread *tp) {
    1c00:	b500      	push	{lr}
    1c02:	b083      	sub	sp, #12
    1c04:	9001      	str	r0, [sp, #4]

  chSysLock();
    1c06:	f04f 0320 	mov.w	r3, #32
    1c0a:	f383 8811 	msr	BASEPRI, r3
  chDbgAssert(tp->p_state == THD_STATE_SUSPENDED,
              "chThdResume(), #1",
              "thread not in THD_STATE_SUSPENDED state");
  chSchWakeupS(tp, RDY_OK);
    1c0e:	9801      	ldr	r0, [sp, #4]
    1c10:	f04f 0100 	mov.w	r1, #0
    1c14:	f7ff fe14 	bl	1840 <chSchWakeupS>
  chSysUnlock();
    1c18:	f04f 0300 	mov.w	r3, #0
    1c1c:	f383 8811 	msr	BASEPRI, r3
  return tp;
    1c20:	9b01      	ldr	r3, [sp, #4]
}
    1c22:	4618      	mov	r0, r3
    1c24:	b003      	add	sp, #12
    1c26:	bd00      	pop	{pc}
    1c28:	f3af 8000 	nop.w
    1c2c:	f3af 8000 	nop.w

00001c30 <chThdTerminate>:
 *
 * @param[in] tp        pointer to the thread
 *
 * @api
 */
void chThdTerminate(Thread *tp) {
    1c30:	b082      	sub	sp, #8
    1c32:	9001      	str	r0, [sp, #4]

  chSysLock();
    1c34:	f04f 0320 	mov.w	r3, #32
    1c38:	f383 8811 	msr	BASEPRI, r3
  tp->p_flags |= THD_TERMINATE;
    1c3c:	9b01      	ldr	r3, [sp, #4]
    1c3e:	7f5b      	ldrb	r3, [r3, #29]
    1c40:	f043 0304 	orr.w	r3, r3, #4
    1c44:	b2da      	uxtb	r2, r3
    1c46:	9b01      	ldr	r3, [sp, #4]
    1c48:	775a      	strb	r2, [r3, #29]
  chSysUnlock();
    1c4a:	f04f 0300 	mov.w	r3, #0
    1c4e:	f383 8811 	msr	BASEPRI, r3
}
    1c52:	b002      	add	sp, #8
    1c54:	4770      	bx	lr
    1c56:	bf00      	nop
    1c58:	f3af 8000 	nop.w
    1c5c:	f3af 8000 	nop.w

00001c60 <chThdSleep>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
void chThdSleep(systime_t time) {
    1c60:	b500      	push	{lr}
    1c62:	b083      	sub	sp, #12
    1c64:	9001      	str	r0, [sp, #4]

  chDbgCheck(time != TIME_IMMEDIATE, "chThdSleep");

  chSysLock();
    1c66:	f04f 0320 	mov.w	r3, #32
    1c6a:	f383 8811 	msr	BASEPRI, r3
  chThdSleepS(time);
    1c6e:	f04f 0006 	mov.w	r0, #6
    1c72:	9901      	ldr	r1, [sp, #4]
    1c74:	f7ff fdac 	bl	17d0 <chSchGoSleepTimeoutS>
  chSysUnlock();
    1c78:	f04f 0300 	mov.w	r3, #0
    1c7c:	f383 8811 	msr	BASEPRI, r3
}
    1c80:	b003      	add	sp, #12
    1c82:	bd00      	pop	{pc}
    1c84:	f3af 8000 	nop.w
    1c88:	f3af 8000 	nop.w
    1c8c:	f3af 8000 	nop.w

00001c90 <chThdSleepUntil>:
 *
 * @param[in] time      absolute system time
 *
 * @api
 */
void chThdSleepUntil(systime_t time) {
    1c90:	b500      	push	{lr}
    1c92:	b083      	sub	sp, #12
    1c94:	9001      	str	r0, [sp, #4]

  chSysLock();
    1c96:	f04f 0320 	mov.w	r3, #32
    1c9a:	f383 8811 	msr	BASEPRI, r3
  if ((time -= chTimeNow()) > 0)
    1c9e:	f240 63f8 	movw	r3, #1784	; 0x6f8
    1ca2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1ca6:	68db      	ldr	r3, [r3, #12]
    1ca8:	9a01      	ldr	r2, [sp, #4]
    1caa:	1ad3      	subs	r3, r2, r3
    1cac:	9301      	str	r3, [sp, #4]
    1cae:	9b01      	ldr	r3, [sp, #4]
    1cb0:	2b00      	cmp	r3, #0
    1cb2:	d004      	beq.n	1cbe <chThdSleepUntil+0x2e>
    chThdSleepS(time);
    1cb4:	f04f 0006 	mov.w	r0, #6
    1cb8:	9901      	ldr	r1, [sp, #4]
    1cba:	f7ff fd89 	bl	17d0 <chSchGoSleepTimeoutS>
  chSysUnlock();
    1cbe:	f04f 0300 	mov.w	r3, #0
    1cc2:	f383 8811 	msr	BASEPRI, r3
}
    1cc6:	b003      	add	sp, #12
    1cc8:	bd00      	pop	{pc}
    1cca:	bf00      	nop
    1ccc:	f3af 8000 	nop.w

00001cd0 <chThdYield>:
 * @details Yields the CPU control to the next thread in the ready list with
 *          equal priority, if any.
 *
 * @api
 */
void chThdYield(void) {
    1cd0:	b508      	push	{r3, lr}

  chSysLock();
    1cd2:	f04f 0320 	mov.w	r3, #32
    1cd6:	f383 8811 	msr	BASEPRI, r3
  chSchDoYieldS();
    1cda:	f240 7308 	movw	r3, #1800	; 0x708
    1cde:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1ce2:	681b      	ldr	r3, [r3, #0]
    1ce4:	689a      	ldr	r2, [r3, #8]
    1ce6:	f240 7308 	movw	r3, #1800	; 0x708
    1cea:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1cee:	699b      	ldr	r3, [r3, #24]
    1cf0:	689b      	ldr	r3, [r3, #8]
    1cf2:	429a      	cmp	r2, r3
    1cf4:	d301      	bcc.n	1cfa <chThdYield+0x2a>
    1cf6:	f7ff fdeb 	bl	18d0 <chSchDoRescheduleBehind>
  chSysUnlock();
    1cfa:	f04f 0300 	mov.w	r3, #0
    1cfe:	f383 8811 	msr	BASEPRI, r3
}
    1d02:	bd08      	pop	{r3, pc}
    1d04:	f3af 8000 	nop.w
    1d08:	f3af 8000 	nop.w
    1d0c:	f3af 8000 	nop.w

00001d10 <chThdExit>:
 *
 * @param[in] msg       thread exit code
 *
 * @api
 */
void chThdExit(msg_t msg) {
    1d10:	b500      	push	{lr}
    1d12:	b083      	sub	sp, #12
    1d14:	9001      	str	r0, [sp, #4]

  chSysLock();
    1d16:	f04f 0320 	mov.w	r3, #32
    1d1a:	f383 8811 	msr	BASEPRI, r3
  chThdExitS(msg);
    1d1e:	9801      	ldr	r0, [sp, #4]
    1d20:	f000 f806 	bl	1d30 <chThdExitS>
  /* The thread never returns here.*/
}
    1d24:	b003      	add	sp, #12
    1d26:	bd00      	pop	{pc}
    1d28:	f3af 8000 	nop.w
    1d2c:	f3af 8000 	nop.w

00001d30 <chThdExitS>:
 *
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
    1d30:	b500      	push	{lr}
    1d32:	b085      	sub	sp, #20
    1d34:	9001      	str	r0, [sp, #4]
  Thread *tp = currp;
    1d36:	f240 7308 	movw	r3, #1800	; 0x708
    1d3a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1d3e:	699b      	ldr	r3, [r3, #24]
    1d40:	9303      	str	r3, [sp, #12]

  tp->p_u.exitcode = msg;
    1d42:	9b03      	ldr	r3, [sp, #12]
    1d44:	9a01      	ldr	r2, [sp, #4]
    1d46:	625a      	str	r2, [r3, #36]	; 0x24
#if defined(THREAD_EXT_EXIT_HOOK)
  THREAD_EXT_EXIT_HOOK(tp);
#endif
#if CH_USE_WAITEXIT
  while (notempty(&tp->p_waiting))
    1d48:	e009      	b.n	1d5e <chThdExitS+0x2e>
    chSchReadyI(list_remove(&tp->p_waiting));
    1d4a:	9b03      	ldr	r3, [sp, #12]
    1d4c:	f103 0328 	add.w	r3, r3, #40	; 0x28
    1d50:	4618      	mov	r0, r3
    1d52:	f7ff fe55 	bl	1a00 <list_remove>
    1d56:	4603      	mov	r3, r0
    1d58:	4618      	mov	r0, r3
    1d5a:	f7ff fc89 	bl	1670 <chSchReadyI>
  tp->p_u.exitcode = msg;
#if defined(THREAD_EXT_EXIT_HOOK)
  THREAD_EXT_EXIT_HOOK(tp);
#endif
#if CH_USE_WAITEXIT
  while (notempty(&tp->p_waiting))
    1d5e:	9b03      	ldr	r3, [sp, #12]
    1d60:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    1d62:	9b03      	ldr	r3, [sp, #12]
    1d64:	f103 0328 	add.w	r3, r3, #40	; 0x28
    1d68:	429a      	cmp	r2, r3
    1d6a:	d1ee      	bne.n	1d4a <chThdExitS+0x1a>
    chSchReadyI(list_remove(&tp->p_waiting));
#endif
#if CH_USE_REGISTRY
  /* Static threads are immediately removed from the registry because
     there is no memory to recover.*/
  if ((tp->p_flags & THD_MEM_MODE_MASK) == THD_MEM_MODE_STATIC)
    1d6c:	9b03      	ldr	r3, [sp, #12]
    1d6e:	7f5b      	ldrb	r3, [r3, #29]
    1d70:	f003 0303 	and.w	r3, r3, #3
    1d74:	2b00      	cmp	r3, #0
    1d76:	d109      	bne.n	1d8c <chThdExitS+0x5c>
    REG_REMOVE(tp);
    1d78:	9b03      	ldr	r3, [sp, #12]
    1d7a:	695b      	ldr	r3, [r3, #20]
    1d7c:	9a03      	ldr	r2, [sp, #12]
    1d7e:	6912      	ldr	r2, [r2, #16]
    1d80:	611a      	str	r2, [r3, #16]
    1d82:	9b03      	ldr	r3, [sp, #12]
    1d84:	691b      	ldr	r3, [r3, #16]
    1d86:	9a03      	ldr	r2, [sp, #12]
    1d88:	6952      	ldr	r2, [r2, #20]
    1d8a:	615a      	str	r2, [r3, #20]
#endif
  chSchGoSleepS(THD_STATE_FINAL);
    1d8c:	f04f 000e 	mov.w	r0, #14
    1d90:	f7ff fc9e 	bl	16d0 <chSchGoSleepS>
  /* The thread never returns here.*/
  chDbgAssert(FALSE, "chThdExitS(), #1", "zombies apocalypse");
}
    1d94:	b005      	add	sp, #20
    1d96:	bd00      	pop	{pc}
    1d98:	f3af 8000 	nop.w
    1d9c:	f3af 8000 	nop.w

00001da0 <chThdWait>:
 * @param[in] tp        pointer to the thread
 * @return              The exit code from the terminated thread.
 *
 * @api
 */
msg_t chThdWait(Thread *tp) {
    1da0:	b500      	push	{lr}
    1da2:	b085      	sub	sp, #20
    1da4:	9001      	str	r0, [sp, #4]
  msg_t msg;

  chDbgCheck(tp != NULL, "chThdWait");

  chSysLock();
    1da6:	f04f 0320 	mov.w	r3, #32
    1daa:	f383 8811 	msr	BASEPRI, r3
  chDbgAssert(tp != currp, "chThdWait(), #1", "waiting self");
#if CH_USE_DYNAMIC
  chDbgAssert(tp->p_refs > 0, "chThdWait(), #2", "not referenced");
#endif
  if (tp->p_state != THD_STATE_FINAL) {
    1dae:	9b01      	ldr	r3, [sp, #4]
    1db0:	7f1b      	ldrb	r3, [r3, #28]
    1db2:	2b0e      	cmp	r3, #14
    1db4:	d00f      	beq.n	1dd6 <chThdWait+0x36>
    list_insert(currp, &tp->p_waiting);
    1db6:	f240 7308 	movw	r3, #1800	; 0x708
    1dba:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1dbe:	699a      	ldr	r2, [r3, #24]
    1dc0:	9b01      	ldr	r3, [sp, #4]
    1dc2:	f103 0328 	add.w	r3, r3, #40	; 0x28
    1dc6:	4610      	mov	r0, r2
    1dc8:	4619      	mov	r1, r3
    1dca:	f7ff fe09 	bl	19e0 <list_insert>
    chSchGoSleepS(THD_STATE_WTEXIT);
    1dce:	f04f 0007 	mov.w	r0, #7
    1dd2:	f7ff fc7d 	bl	16d0 <chSchGoSleepS>
  }
  msg = tp->p_u.exitcode;
    1dd6:	9b01      	ldr	r3, [sp, #4]
    1dd8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    1dda:	9303      	str	r3, [sp, #12]
  chSysUnlock();
    1ddc:	f04f 0300 	mov.w	r3, #0
    1de0:	f383 8811 	msr	BASEPRI, r3
#if CH_USE_DYNAMIC
  chThdRelease(tp);
    1de4:	9801      	ldr	r0, [sp, #4]
    1de6:	f000 f823 	bl	1e30 <chThdRelease>
#endif
  return msg;
    1dea:	9b03      	ldr	r3, [sp, #12]
}
    1dec:	4618      	mov	r0, r3
    1dee:	b005      	add	sp, #20
    1df0:	bd00      	pop	{pc}
    1df2:	bf00      	nop
    1df4:	f3af 8000 	nop.w
    1df8:	f3af 8000 	nop.w
    1dfc:	f3af 8000 	nop.w

00001e00 <chThdAddRef>:
 * @return              The same thread pointer passed as parameter
 *                      representing the new reference.
 *
 * @api
 */
Thread *chThdAddRef(Thread *tp) {
    1e00:	b082      	sub	sp, #8
    1e02:	9001      	str	r0, [sp, #4]

  chSysLock();
    1e04:	f04f 0320 	mov.w	r3, #32
    1e08:	f383 8811 	msr	BASEPRI, r3
  chDbgAssert(tp->p_refs < 255, "chThdAddRef(), #1", "too many references");
  tp->p_refs++;
    1e0c:	9b01      	ldr	r3, [sp, #4]
    1e0e:	7f9b      	ldrb	r3, [r3, #30]
    1e10:	f103 0301 	add.w	r3, r3, #1
    1e14:	b2da      	uxtb	r2, r3
    1e16:	9b01      	ldr	r3, [sp, #4]
    1e18:	779a      	strb	r2, [r3, #30]
  chSysUnlock();
    1e1a:	f04f 0300 	mov.w	r3, #0
    1e1e:	f383 8811 	msr	BASEPRI, r3
  return tp;
    1e22:	9b01      	ldr	r3, [sp, #4]
}
    1e24:	4618      	mov	r0, r3
    1e26:	b002      	add	sp, #8
    1e28:	4770      	bx	lr
    1e2a:	bf00      	nop
    1e2c:	f3af 8000 	nop.w

00001e30 <chThdRelease>:
 *
 * @param[in] tp        pointer to the thread
 *
 * @api
 */
void chThdRelease(Thread *tp) {
    1e30:	b500      	push	{lr}
    1e32:	b085      	sub	sp, #20
    1e34:	9001      	str	r0, [sp, #4]
  trefs_t refs;

  chSysLock();
    1e36:	f04f 0320 	mov.w	r3, #32
    1e3a:	f383 8811 	msr	BASEPRI, r3
  chDbgAssert(tp->p_refs > 0, "chThdRelease(), #1", "not referenced");
  refs = --tp->p_refs;
    1e3e:	9b01      	ldr	r3, [sp, #4]
    1e40:	7f9b      	ldrb	r3, [r3, #30]
    1e42:	f103 33ff 	add.w	r3, r3, #4294967295
    1e46:	b2da      	uxtb	r2, r3
    1e48:	9b01      	ldr	r3, [sp, #4]
    1e4a:	779a      	strb	r2, [r3, #30]
    1e4c:	9b01      	ldr	r3, [sp, #4]
    1e4e:	7f9b      	ldrb	r3, [r3, #30]
    1e50:	f88d 300f 	strb.w	r3, [sp, #15]
  chSysUnlock();
    1e54:	f04f 0300 	mov.w	r3, #0
    1e58:	f383 8811 	msr	BASEPRI, r3

  /* If the references counter reaches zero and the thread is in its
     terminated state then the memory can be returned to the proper
     allocator. Of course static threads are not affected.*/
  if ((refs == 0) && (tp->p_state == THD_STATE_FINAL)) {
    1e5c:	f89d 300f 	ldrb.w	r3, [sp, #15]
    1e60:	2b00      	cmp	r3, #0
    1e62:	d12b      	bne.n	1ebc <chThdRelease+0x8c>
    1e64:	9b01      	ldr	r3, [sp, #4]
    1e66:	7f1b      	ldrb	r3, [r3, #28]
    1e68:	2b0e      	cmp	r3, #14
    1e6a:	d127      	bne.n	1ebc <chThdRelease+0x8c>
    switch (tp->p_flags & THD_MEM_MODE_MASK) {
    1e6c:	9b01      	ldr	r3, [sp, #4]
    1e6e:	7f5b      	ldrb	r3, [r3, #29]
    1e70:	f003 0303 	and.w	r3, r3, #3
    1e74:	2b01      	cmp	r3, #1
    1e76:	d002      	beq.n	1e7e <chThdRelease+0x4e>
    1e78:	2b02      	cmp	r3, #2
    1e7a:	d00e      	beq.n	1e9a <chThdRelease+0x6a>
    1e7c:	e01e      	b.n	1ebc <chThdRelease+0x8c>
#if CH_USE_HEAP
    case THD_MEM_MODE_HEAP:
#if CH_USE_REGISTRY
      REG_REMOVE(tp);
    1e7e:	9b01      	ldr	r3, [sp, #4]
    1e80:	695b      	ldr	r3, [r3, #20]
    1e82:	9a01      	ldr	r2, [sp, #4]
    1e84:	6912      	ldr	r2, [r2, #16]
    1e86:	611a      	str	r2, [r3, #16]
    1e88:	9b01      	ldr	r3, [sp, #4]
    1e8a:	691b      	ldr	r3, [r3, #16]
    1e8c:	9a01      	ldr	r2, [sp, #4]
    1e8e:	6952      	ldr	r2, [r2, #20]
    1e90:	615a      	str	r2, [r3, #20]
#endif
      chHeapFree(tp);
    1e92:	9801      	ldr	r0, [sp, #4]
    1e94:	f000 f9cc 	bl	2230 <chHeapFree>
      break;
    1e98:	e010      	b.n	1ebc <chThdRelease+0x8c>
#endif
#if CH_USE_MEMPOOLS
    case THD_MEM_MODE_MEMPOOL:
#if CH_USE_REGISTRY
      REG_REMOVE(tp);
    1e9a:	9b01      	ldr	r3, [sp, #4]
    1e9c:	695b      	ldr	r3, [r3, #20]
    1e9e:	9a01      	ldr	r2, [sp, #4]
    1ea0:	6912      	ldr	r2, [r2, #16]
    1ea2:	611a      	str	r2, [r3, #16]
    1ea4:	9b01      	ldr	r3, [sp, #4]
    1ea6:	691b      	ldr	r3, [r3, #16]
    1ea8:	9a01      	ldr	r2, [sp, #4]
    1eaa:	6952      	ldr	r2, [r2, #20]
    1eac:	615a      	str	r2, [r3, #20]
#endif
      chPoolFree(tp->p_mpool, tp);
    1eae:	9b01      	ldr	r3, [sp, #4]
    1eb0:	6c5b      	ldr	r3, [r3, #68]	; 0x44
    1eb2:	4618      	mov	r0, r3
    1eb4:	9901      	ldr	r1, [sp, #4]
    1eb6:	f000 fafb 	bl	24b0 <chPoolFree>
      break;
    1eba:	bf00      	nop
#endif
    }
  }
}
    1ebc:	b005      	add	sp, #20
    1ebe:	bd00      	pop	{pc}

00001ec0 <chThdCreateFromHeap>:
 * @retval NULL         if the memory cannot be allocated.
 *
 * @api
 */
Thread *chThdCreateFromHeap(MemoryHeap *heapp, size_t size,
                            tprio_t prio, tfunc_t pf, void *arg) {
    1ec0:	b500      	push	{lr}
    1ec2:	b089      	sub	sp, #36	; 0x24
    1ec4:	9005      	str	r0, [sp, #20]
    1ec6:	9104      	str	r1, [sp, #16]
    1ec8:	9203      	str	r2, [sp, #12]
    1eca:	9302      	str	r3, [sp, #8]
  void *wsp;
  Thread *tp;

  wsp = chHeapAlloc(heapp, size);
    1ecc:	9805      	ldr	r0, [sp, #20]
    1ece:	9904      	ldr	r1, [sp, #16]
    1ed0:	f000 f92e 	bl	2130 <chHeapAlloc>
    1ed4:	9007      	str	r0, [sp, #28]
  if (wsp == NULL)
    1ed6:	9b07      	ldr	r3, [sp, #28]
    1ed8:	2b00      	cmp	r3, #0
    1eda:	d102      	bne.n	1ee2 <chThdCreateFromHeap+0x22>
    return NULL;
    1edc:	f04f 0300 	mov.w	r3, #0
    1ee0:	e01a      	b.n	1f18 <chThdCreateFromHeap+0x58>
  _thread_memfill((uint8_t *)wsp + sizeof(Thread),
                  (uint8_t *)wsp + size,
                  CH_STACK_FILL_VALUE);
#endif
  
  chSysLock();
    1ee2:	f04f 0320 	mov.w	r3, #32
    1ee6:	f383 8811 	msr	BASEPRI, r3
  tp = chThdCreateI(wsp, size, prio, pf, arg);
    1eea:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    1eec:	9300      	str	r3, [sp, #0]
    1eee:	9807      	ldr	r0, [sp, #28]
    1ef0:	9904      	ldr	r1, [sp, #16]
    1ef2:	9a03      	ldr	r2, [sp, #12]
    1ef4:	9b02      	ldr	r3, [sp, #8]
    1ef6:	f7ff fdeb 	bl	1ad0 <chThdCreateI>
    1efa:	9006      	str	r0, [sp, #24]
  tp->p_flags = THD_MEM_MODE_HEAP;
    1efc:	9b06      	ldr	r3, [sp, #24]
    1efe:	f04f 0201 	mov.w	r2, #1
    1f02:	775a      	strb	r2, [r3, #29]
  chSchWakeupS(tp, RDY_OK);
    1f04:	9806      	ldr	r0, [sp, #24]
    1f06:	f04f 0100 	mov.w	r1, #0
    1f0a:	f7ff fc99 	bl	1840 <chSchWakeupS>
  chSysUnlock();
    1f0e:	f04f 0300 	mov.w	r3, #0
    1f12:	f383 8811 	msr	BASEPRI, r3
  return tp;
    1f16:	9b06      	ldr	r3, [sp, #24]
}
    1f18:	4618      	mov	r0, r3
    1f1a:	b009      	add	sp, #36	; 0x24
    1f1c:	bd00      	pop	{pc}
    1f1e:	bf00      	nop

00001f20 <chThdCreateFromMemoryPool>:
 * @retval  NULL        if the memory pool is empty.
 *
 * @api
 */
Thread *chThdCreateFromMemoryPool(MemoryPool *mp, tprio_t prio,
                                  tfunc_t pf, void *arg) {
    1f20:	b500      	push	{lr}
    1f22:	b089      	sub	sp, #36	; 0x24
    1f24:	9005      	str	r0, [sp, #20]
    1f26:	9104      	str	r1, [sp, #16]
    1f28:	9203      	str	r2, [sp, #12]
    1f2a:	9302      	str	r3, [sp, #8]
  void *wsp;
  Thread *tp;

  chDbgCheck(mp != NULL, "chThdCreateFromMemoryPool");

  wsp = chPoolAlloc(mp);
    1f2c:	9805      	ldr	r0, [sp, #20]
    1f2e:	f000 fa8f 	bl	2450 <chPoolAlloc>
    1f32:	9007      	str	r0, [sp, #28]
  if (wsp == NULL)
    1f34:	9b07      	ldr	r3, [sp, #28]
    1f36:	2b00      	cmp	r3, #0
    1f38:	d102      	bne.n	1f40 <chThdCreateFromMemoryPool+0x20>
    return NULL;
    1f3a:	f04f 0300 	mov.w	r3, #0
    1f3e:	e01f      	b.n	1f80 <chThdCreateFromMemoryPool+0x60>
  _thread_memfill((uint8_t *)wsp + sizeof(Thread),
                  (uint8_t *)wsp + mp->mp_object_size,
                  CH_STACK_FILL_VALUE);
#endif

  chSysLock();
    1f40:	f04f 0320 	mov.w	r3, #32
    1f44:	f383 8811 	msr	BASEPRI, r3
  tp = chThdCreateI(wsp, mp->mp_object_size, prio, pf, arg);
    1f48:	9b05      	ldr	r3, [sp, #20]
    1f4a:	685b      	ldr	r3, [r3, #4]
    1f4c:	9a02      	ldr	r2, [sp, #8]
    1f4e:	9200      	str	r2, [sp, #0]
    1f50:	9807      	ldr	r0, [sp, #28]
    1f52:	4619      	mov	r1, r3
    1f54:	9a04      	ldr	r2, [sp, #16]
    1f56:	9b03      	ldr	r3, [sp, #12]
    1f58:	f7ff fdba 	bl	1ad0 <chThdCreateI>
    1f5c:	9006      	str	r0, [sp, #24]
  tp->p_flags = THD_MEM_MODE_MEMPOOL;
    1f5e:	9b06      	ldr	r3, [sp, #24]
    1f60:	f04f 0202 	mov.w	r2, #2
    1f64:	775a      	strb	r2, [r3, #29]
  tp->p_mpool = mp;
    1f66:	9b06      	ldr	r3, [sp, #24]
    1f68:	9a05      	ldr	r2, [sp, #20]
    1f6a:	645a      	str	r2, [r3, #68]	; 0x44
  chSchWakeupS(tp, RDY_OK);
    1f6c:	9806      	ldr	r0, [sp, #24]
    1f6e:	f04f 0100 	mov.w	r1, #0
    1f72:	f7ff fc65 	bl	1840 <chSchWakeupS>
  chSysUnlock();
    1f76:	f04f 0300 	mov.w	r3, #0
    1f7a:	f383 8811 	msr	BASEPRI, r3
  return tp;
    1f7e:	9b06      	ldr	r3, [sp, #24]
}
    1f80:	4618      	mov	r0, r3
    1f82:	b009      	add	sp, #36	; 0x24
    1f84:	bd00      	pop	{pc}
    1f86:	bf00      	nop
    1f88:	f3af 8000 	nop.w
    1f8c:	f3af 8000 	nop.w

00001f90 <_core_init>:
 */
void _core_init(void) {
#if CH_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];
  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
    1f90:	f240 7350 	movw	r3, #1872	; 0x750
    1f94:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1f98:	f103 0307 	add.w	r3, r3, #7
    1f9c:	f023 0307 	bic.w	r3, r3, #7
    1fa0:	461a      	mov	r2, r3
    1fa2:	f240 7324 	movw	r3, #1828	; 0x724
    1fa6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1faa:	601a      	str	r2, [r3, #0]
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
    1fac:	f24f 0300 	movw	r3, #61440	; 0xf000
    1fb0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1fb4:	f023 0307 	bic.w	r3, r3, #7
    1fb8:	461a      	mov	r2, r3
    1fba:	f240 7328 	movw	r3, #1832	; 0x728
    1fbe:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1fc2:	601a      	str	r2, [r3, #0]
#else
  static stkalign_t buffer[MEM_ALIGN_NEXT(CH_MEMCORE_SIZE)/MEM_ALIGN_SIZE];
  nextmem = (uint8_t *)&buffer[0];
  endmem = (uint8_t *)&buffer[MEM_ALIGN_NEXT(CH_MEMCORE_SIZE)/MEM_ALIGN_SIZE];
#endif
}
    1fc4:	4770      	bx	lr
    1fc6:	bf00      	nop
    1fc8:	f3af 8000 	nop.w
    1fcc:	f3af 8000 	nop.w

00001fd0 <chCoreAlloc>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
void *chCoreAlloc(size_t size) {
    1fd0:	b500      	push	{lr}
    1fd2:	b085      	sub	sp, #20
    1fd4:	9001      	str	r0, [sp, #4]
  void *p;

  chSysLock();
    1fd6:	f04f 0320 	mov.w	r3, #32
    1fda:	f383 8811 	msr	BASEPRI, r3
  p = chCoreAllocI(size);
    1fde:	9801      	ldr	r0, [sp, #4]
    1fe0:	f000 f80e 	bl	2000 <chCoreAllocI>
    1fe4:	9003      	str	r0, [sp, #12]
  chSysUnlock();
    1fe6:	f04f 0300 	mov.w	r3, #0
    1fea:	f383 8811 	msr	BASEPRI, r3
  return p;
    1fee:	9b03      	ldr	r3, [sp, #12]
}
    1ff0:	4618      	mov	r0, r3
    1ff2:	b005      	add	sp, #20
    1ff4:	bd00      	pop	{pc}
    1ff6:	bf00      	nop
    1ff8:	f3af 8000 	nop.w
    1ffc:	f3af 8000 	nop.w

00002000 <chCoreAllocI>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @iclass
 */
void *chCoreAllocI(size_t size) {
    2000:	b084      	sub	sp, #16
    2002:	9001      	str	r0, [sp, #4]
  void *p;

  chDbgCheckClassI();

  size = MEM_ALIGN_NEXT(size);
    2004:	9b01      	ldr	r3, [sp, #4]
    2006:	f103 0307 	add.w	r3, r3, #7
    200a:	f023 0307 	bic.w	r3, r3, #7
    200e:	9301      	str	r3, [sp, #4]
  if ((size_t)(endmem - nextmem) < size)
    2010:	f240 7328 	movw	r3, #1832	; 0x728
    2014:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2018:	681b      	ldr	r3, [r3, #0]
    201a:	461a      	mov	r2, r3
    201c:	f240 7324 	movw	r3, #1828	; 0x724
    2020:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2024:	681b      	ldr	r3, [r3, #0]
    2026:	1ad3      	subs	r3, r2, r3
    2028:	461a      	mov	r2, r3
    202a:	9b01      	ldr	r3, [sp, #4]
    202c:	429a      	cmp	r2, r3
    202e:	d202      	bcs.n	2036 <chCoreAllocI+0x36>
    return NULL;
    2030:	f04f 0300 	mov.w	r3, #0
    2034:	e012      	b.n	205c <chCoreAllocI+0x5c>
  p = nextmem;
    2036:	f240 7324 	movw	r3, #1828	; 0x724
    203a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    203e:	681b      	ldr	r3, [r3, #0]
    2040:	9303      	str	r3, [sp, #12]
  nextmem += size;
    2042:	f240 7324 	movw	r3, #1828	; 0x724
    2046:	f2c2 0300 	movt	r3, #8192	; 0x2000
    204a:	681a      	ldr	r2, [r3, #0]
    204c:	9b01      	ldr	r3, [sp, #4]
    204e:	18d2      	adds	r2, r2, r3
    2050:	f240 7324 	movw	r3, #1828	; 0x724
    2054:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2058:	601a      	str	r2, [r3, #0]
  return p;
    205a:	9b03      	ldr	r3, [sp, #12]
}
    205c:	4618      	mov	r0, r3
    205e:	b004      	add	sp, #16
    2060:	4770      	bx	lr
    2062:	bf00      	nop
    2064:	f3af 8000 	nop.w
    2068:	f3af 8000 	nop.w
    206c:	f3af 8000 	nop.w

00002070 <chCoreStatus>:
 *
 * @api
 */
size_t chCoreStatus(void) {

  return (size_t)(endmem - nextmem);
    2070:	f240 7328 	movw	r3, #1832	; 0x728
    2074:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2078:	681b      	ldr	r3, [r3, #0]
    207a:	461a      	mov	r2, r3
    207c:	f240 7324 	movw	r3, #1828	; 0x724
    2080:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2084:	681b      	ldr	r3, [r3, #0]
    2086:	1ad3      	subs	r3, r2, r3
}
    2088:	4618      	mov	r0, r3
    208a:	4770      	bx	lr
    208c:	f3af 8000 	nop.w

00002090 <_heap_init>:
/**
 * @brief   Initializes the default heap.
 *
 * @notapi
 */
void _heap_init(void) {
    2090:	b508      	push	{r3, lr}
  default_heap.h_provider = chCoreAlloc;
    2092:	f240 7330 	movw	r3, #1840	; 0x730
    2096:	f2c2 0300 	movt	r3, #8192	; 0x2000
    209a:	f641 72d1 	movw	r2, #8145	; 0x1fd1
    209e:	f2c0 0200 	movt	r2, #0
    20a2:	601a      	str	r2, [r3, #0]
  default_heap.h_free.h.u.next = (union heap_header *)NULL;
    20a4:	f240 7330 	movw	r3, #1840	; 0x730
    20a8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    20ac:	f04f 0200 	mov.w	r2, #0
    20b0:	609a      	str	r2, [r3, #8]
  default_heap.h_free.h.size = 0;
    20b2:	f240 7330 	movw	r3, #1840	; 0x730
    20b6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    20ba:	f04f 0200 	mov.w	r2, #0
    20be:	60da      	str	r2, [r3, #12]
#if CH_USE_MUTEXES || defined(__DOXYGEN__)
  chMtxInit(&default_heap.h_mtx);
    20c0:	4801      	ldr	r0, [pc, #4]	; (20c8 <_heap_init+0x38>)
    20c2:	f000 fbfd 	bl	28c0 <chMtxInit>
#else
  chSemInit(&default_heap.h_sem, 1);
#endif
}
    20c6:	bd08      	pop	{r3, pc}
    20c8:	20000740 	andcs	r0, r0, r0, asr #14
    20cc:	f3af 8000 	nop.w

000020d0 <chHeapInit>:
 * @param[in] buf       heap buffer base
 * @param[in] size      heap size
 *
 * @init
 */
void chHeapInit(MemoryHeap *heapp, void *buf, size_t size) {
    20d0:	b500      	push	{lr}
    20d2:	b087      	sub	sp, #28
    20d4:	9003      	str	r0, [sp, #12]
    20d6:	9102      	str	r1, [sp, #8]
    20d8:	9201      	str	r2, [sp, #4]
  union heap_header *hp;

  chDbgCheck(MEM_IS_ALIGNED(buf) && MEM_IS_ALIGNED(size), "chHeapInit");
    20da:	9b02      	ldr	r3, [sp, #8]
    20dc:	f003 0307 	and.w	r3, r3, #7
    20e0:	2b00      	cmp	r3, #0
    20e2:	d103      	bne.n	20ec <chHeapInit+0x1c>
    20e4:	9b01      	ldr	r3, [sp, #4]
    20e6:	f003 0307 	and.w	r3, r3, #7
    20ea:	2b00      	cmp	r3, #0

  heapp->h_provider = (memgetfunc_t)NULL;
    20ec:	9b03      	ldr	r3, [sp, #12]
    20ee:	f04f 0200 	mov.w	r2, #0
    20f2:	601a      	str	r2, [r3, #0]
  heapp->h_free.h.u.next = hp = buf;
    20f4:	9b02      	ldr	r3, [sp, #8]
    20f6:	9305      	str	r3, [sp, #20]
    20f8:	9b03      	ldr	r3, [sp, #12]
    20fa:	9a05      	ldr	r2, [sp, #20]
    20fc:	609a      	str	r2, [r3, #8]
  heapp->h_free.h.size = 0;
    20fe:	9b03      	ldr	r3, [sp, #12]
    2100:	f04f 0200 	mov.w	r2, #0
    2104:	60da      	str	r2, [r3, #12]
  hp->h.u.next = NULL;
    2106:	9b05      	ldr	r3, [sp, #20]
    2108:	f04f 0200 	mov.w	r2, #0
    210c:	601a      	str	r2, [r3, #0]
  hp->h.size = size - sizeof(union heap_header);
    210e:	9b01      	ldr	r3, [sp, #4]
    2110:	f1a3 0208 	sub.w	r2, r3, #8
    2114:	9b05      	ldr	r3, [sp, #20]
    2116:	605a      	str	r2, [r3, #4]
#if CH_USE_MUTEXES || defined(__DOXYGEN__)
  chMtxInit(&heapp->h_mtx);
    2118:	9b03      	ldr	r3, [sp, #12]
    211a:	f103 0310 	add.w	r3, r3, #16
    211e:	4618      	mov	r0, r3
    2120:	f000 fbce 	bl	28c0 <chMtxInit>
#else
  chSemInit(&heapp->h_sem, 1);
#endif
}
    2124:	b007      	add	sp, #28
    2126:	bd00      	pop	{pc}
    2128:	f3af 8000 	nop.w
    212c:	f3af 8000 	nop.w

00002130 <chHeapAlloc>:
 * @return              A pointer to the allocated block.
 * @retval NULL         if the block cannot be allocated.
 *
 * @api
 */
void *chHeapAlloc(MemoryHeap *heapp, size_t size) {
    2130:	b500      	push	{lr}
    2132:	b087      	sub	sp, #28
    2134:	9001      	str	r0, [sp, #4]
    2136:	9100      	str	r1, [sp, #0]
  union heap_header *qp, *hp, *fp;

  if (heapp == NULL)
    2138:	9b01      	ldr	r3, [sp, #4]
    213a:	2b00      	cmp	r3, #0
    213c:	d104      	bne.n	2148 <chHeapAlloc+0x18>
    heapp = &default_heap;
    213e:	f240 7330 	movw	r3, #1840	; 0x730
    2142:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2146:	9301      	str	r3, [sp, #4]

  size = MEM_ALIGN_NEXT(size);
    2148:	9b00      	ldr	r3, [sp, #0]
    214a:	f103 0307 	add.w	r3, r3, #7
    214e:	f023 0307 	bic.w	r3, r3, #7
    2152:	9300      	str	r3, [sp, #0]
  qp = &heapp->h_free;
    2154:	9b01      	ldr	r3, [sp, #4]
    2156:	f103 0308 	add.w	r3, r3, #8
    215a:	9305      	str	r3, [sp, #20]
  H_LOCK(heapp);
    215c:	9b01      	ldr	r3, [sp, #4]
    215e:	f103 0310 	add.w	r3, r3, #16
    2162:	4618      	mov	r0, r3
    2164:	f000 fbbc 	bl	28e0 <chMtxLock>

  while (qp->h.u.next != NULL) {
    2168:	e036      	b.n	21d8 <chHeapAlloc+0xa8>
    hp = qp->h.u.next;
    216a:	9b05      	ldr	r3, [sp, #20]
    216c:	681b      	ldr	r3, [r3, #0]
    216e:	9304      	str	r3, [sp, #16]
    if (hp->h.size >= size) {
    2170:	9b04      	ldr	r3, [sp, #16]
    2172:	685a      	ldr	r2, [r3, #4]
    2174:	9b00      	ldr	r3, [sp, #0]
    2176:	429a      	cmp	r2, r3
    2178:	d32c      	bcc.n	21d4 <chHeapAlloc+0xa4>
      if (hp->h.size < size + sizeof(union heap_header)) {
    217a:	9b04      	ldr	r3, [sp, #16]
    217c:	685a      	ldr	r2, [r3, #4]
    217e:	9b00      	ldr	r3, [sp, #0]
    2180:	f103 0308 	add.w	r3, r3, #8
    2184:	429a      	cmp	r2, r3
    2186:	d204      	bcs.n	2192 <chHeapAlloc+0x62>
        /* Gets the whole block even if it is slightly bigger than the
           requested size because the fragment would be too small to be
           useful.*/
        qp->h.u.next = hp->h.u.next;
    2188:	9b04      	ldr	r3, [sp, #16]
    218a:	681a      	ldr	r2, [r3, #0]
    218c:	9b05      	ldr	r3, [sp, #20]
    218e:	601a      	str	r2, [r3, #0]
    2190:	e017      	b.n	21c2 <chHeapAlloc+0x92>
      }
      else {
        /* Block bigger enough, must split it.*/
        fp = (void *)((uint8_t *)(hp) + sizeof(union heap_header) + size);
    2192:	9b00      	ldr	r3, [sp, #0]
    2194:	f103 0308 	add.w	r3, r3, #8
    2198:	9a04      	ldr	r2, [sp, #16]
    219a:	18d3      	adds	r3, r2, r3
    219c:	9303      	str	r3, [sp, #12]
        fp->h.u.next = hp->h.u.next;
    219e:	9b04      	ldr	r3, [sp, #16]
    21a0:	681a      	ldr	r2, [r3, #0]
    21a2:	9b03      	ldr	r3, [sp, #12]
    21a4:	601a      	str	r2, [r3, #0]
        fp->h.size = hp->h.size - sizeof(union heap_header) - size;
    21a6:	9b04      	ldr	r3, [sp, #16]
    21a8:	685a      	ldr	r2, [r3, #4]
    21aa:	9b00      	ldr	r3, [sp, #0]
    21ac:	1ad3      	subs	r3, r2, r3
    21ae:	f1a3 0208 	sub.w	r2, r3, #8
    21b2:	9b03      	ldr	r3, [sp, #12]
    21b4:	605a      	str	r2, [r3, #4]
        qp->h.u.next = fp;
    21b6:	9b05      	ldr	r3, [sp, #20]
    21b8:	9a03      	ldr	r2, [sp, #12]
    21ba:	601a      	str	r2, [r3, #0]
        hp->h.size = size;
    21bc:	9b04      	ldr	r3, [sp, #16]
    21be:	9a00      	ldr	r2, [sp, #0]
    21c0:	605a      	str	r2, [r3, #4]
      }
      hp->h.u.heap = heapp;
    21c2:	9b04      	ldr	r3, [sp, #16]
    21c4:	9a01      	ldr	r2, [sp, #4]
    21c6:	601a      	str	r2, [r3, #0]

      H_UNLOCK(heapp);
    21c8:	f000 fc3a 	bl	2a40 <chMtxUnlock>
      return (void *)(hp + 1);
    21cc:	9b04      	ldr	r3, [sp, #16]
    21ce:	f103 0308 	add.w	r3, r3, #8
    21d2:	e024      	b.n	221e <chHeapAlloc+0xee>
    }
    qp = hp;
    21d4:	9b04      	ldr	r3, [sp, #16]
    21d6:	9305      	str	r3, [sp, #20]

  size = MEM_ALIGN_NEXT(size);
  qp = &heapp->h_free;
  H_LOCK(heapp);

  while (qp->h.u.next != NULL) {
    21d8:	9b05      	ldr	r3, [sp, #20]
    21da:	681b      	ldr	r3, [r3, #0]
    21dc:	2b00      	cmp	r3, #0
    21de:	d1c4      	bne.n	216a <chHeapAlloc+0x3a>
      return (void *)(hp + 1);
    }
    qp = hp;
  }

  H_UNLOCK(heapp);
    21e0:	f000 fc2e 	bl	2a40 <chMtxUnlock>

  /* More memory is required, tries to get it from the associated provider
     else fails.*/
  if (heapp->h_provider) {
    21e4:	9b01      	ldr	r3, [sp, #4]
    21e6:	681b      	ldr	r3, [r3, #0]
    21e8:	2b00      	cmp	r3, #0
    21ea:	d016      	beq.n	221a <chHeapAlloc+0xea>
    hp = heapp->h_provider(size + sizeof(union heap_header));
    21ec:	9b01      	ldr	r3, [sp, #4]
    21ee:	681b      	ldr	r3, [r3, #0]
    21f0:	9a00      	ldr	r2, [sp, #0]
    21f2:	f102 0208 	add.w	r2, r2, #8
    21f6:	4610      	mov	r0, r2
    21f8:	4798      	blx	r3
    21fa:	9004      	str	r0, [sp, #16]
    if (hp != NULL) {
    21fc:	9b04      	ldr	r3, [sp, #16]
    21fe:	2b00      	cmp	r3, #0
    2200:	d00b      	beq.n	221a <chHeapAlloc+0xea>
      hp->h.u.heap = heapp;
    2202:	9b04      	ldr	r3, [sp, #16]
    2204:	9a01      	ldr	r2, [sp, #4]
    2206:	601a      	str	r2, [r3, #0]
      hp->h.size = size;
    2208:	9b04      	ldr	r3, [sp, #16]
    220a:	9a00      	ldr	r2, [sp, #0]
    220c:	605a      	str	r2, [r3, #4]
      hp++;
    220e:	9b04      	ldr	r3, [sp, #16]
    2210:	f103 0308 	add.w	r3, r3, #8
    2214:	9304      	str	r3, [sp, #16]
      return (void *)hp;
    2216:	9b04      	ldr	r3, [sp, #16]
    2218:	e001      	b.n	221e <chHeapAlloc+0xee>
    }
  }
  return NULL;
    221a:	f04f 0300 	mov.w	r3, #0
}
    221e:	4618      	mov	r0, r3
    2220:	b007      	add	sp, #28
    2222:	bd00      	pop	{pc}
    2224:	f3af 8000 	nop.w
    2228:	f3af 8000 	nop.w
    222c:	f3af 8000 	nop.w

00002230 <chHeapFree>:
 *
 * @param[in] p         pointer to the memory block to be freed
 *
 * @api
 */
void chHeapFree(void *p) {
    2230:	b500      	push	{lr}
    2232:	b087      	sub	sp, #28
    2234:	9001      	str	r0, [sp, #4]
  union heap_header *qp, *hp;
  MemoryHeap *heapp;

  chDbgCheck(p != NULL, "chHeapFree");

  hp = (union heap_header *)p - 1;
    2236:	9b01      	ldr	r3, [sp, #4]
    2238:	f1a3 0308 	sub.w	r3, r3, #8
    223c:	9304      	str	r3, [sp, #16]
  heapp = hp->h.u.heap;
    223e:	9b04      	ldr	r3, [sp, #16]
    2240:	681b      	ldr	r3, [r3, #0]
    2242:	9303      	str	r3, [sp, #12]
  qp = &heapp->h_free;
    2244:	9b03      	ldr	r3, [sp, #12]
    2246:	f103 0308 	add.w	r3, r3, #8
    224a:	9305      	str	r3, [sp, #20]
  H_LOCK(heapp);
    224c:	9b03      	ldr	r3, [sp, #12]
    224e:	f103 0310 	add.w	r3, r3, #16
    2252:	4618      	mov	r0, r3
    2254:	f000 fb44 	bl	28e0 <chMtxLock>
 *
 * @param[in] p         pointer to the memory block to be freed
 *
 * @api
 */
void chHeapFree(void *p) {
    2258:	9a04      	ldr	r2, [sp, #16]
    225a:	9b05      	ldr	r3, [sp, #20]
    225c:	429a      	cmp	r2, r3
    225e:	d307      	bcc.n	2270 <chHeapFree+0x40>
  heapp = hp->h.u.heap;
  qp = &heapp->h_free;
  H_LOCK(heapp);

  while (TRUE) {
    chDbgAssert((hp < qp) || (hp >= LIMIT(qp)),
    2260:	9b05      	ldr	r3, [sp, #20]
    2262:	685b      	ldr	r3, [r3, #4]
    2264:	f103 0308 	add.w	r3, r3, #8
    2268:	9a05      	ldr	r2, [sp, #20]
    226a:	18d2      	adds	r2, r2, r3
    226c:	9b04      	ldr	r3, [sp, #16]
    226e:	429a      	cmp	r2, r3
 *
 * @param[in] p         pointer to the memory block to be freed
 *
 * @api
 */
void chHeapFree(void *p) {
    2270:	bf00      	nop
  while (TRUE) {
    chDbgAssert((hp < qp) || (hp >= LIMIT(qp)),
                "chHeapFree(), #1",
                "within free block");

    if (((qp == &heapp->h_free) || (hp > qp)) &&
    2272:	9b03      	ldr	r3, [sp, #12]
    2274:	f103 0208 	add.w	r2, r3, #8
    2278:	9b05      	ldr	r3, [sp, #20]
    227a:	429a      	cmp	r2, r3
    227c:	d003      	beq.n	2286 <chHeapFree+0x56>
    227e:	9a04      	ldr	r2, [sp, #16]
    2280:	9b05      	ldr	r3, [sp, #20]
    2282:	429a      	cmp	r2, r3
    2284:	d93f      	bls.n	2306 <chHeapFree+0xd6>
        ((qp->h.u.next == NULL) || (hp < qp->h.u.next))) {
    2286:	9b05      	ldr	r3, [sp, #20]
    2288:	681b      	ldr	r3, [r3, #0]
  while (TRUE) {
    chDbgAssert((hp < qp) || (hp >= LIMIT(qp)),
                "chHeapFree(), #1",
                "within free block");

    if (((qp == &heapp->h_free) || (hp > qp)) &&
    228a:	2b00      	cmp	r3, #0
    228c:	d004      	beq.n	2298 <chHeapFree+0x68>
        ((qp->h.u.next == NULL) || (hp < qp->h.u.next))) {
    228e:	9b05      	ldr	r3, [sp, #20]
    2290:	681a      	ldr	r2, [r3, #0]
    2292:	9b04      	ldr	r3, [sp, #16]
    2294:	429a      	cmp	r2, r3
    2296:	d936      	bls.n	2306 <chHeapFree+0xd6>
      /* Insertion after qp.*/
      hp->h.u.next = qp->h.u.next;
    2298:	9b05      	ldr	r3, [sp, #20]
    229a:	681a      	ldr	r2, [r3, #0]
    229c:	9b04      	ldr	r3, [sp, #16]
    229e:	601a      	str	r2, [r3, #0]
      qp->h.u.next = hp;
    22a0:	9b05      	ldr	r3, [sp, #20]
    22a2:	9a04      	ldr	r2, [sp, #16]
    22a4:	601a      	str	r2, [r3, #0]
      /* Verifies if the newly inserted block should be merged.*/
      if (LIMIT(hp) == hp->h.u.next) {
    22a6:	9b04      	ldr	r3, [sp, #16]
    22a8:	685b      	ldr	r3, [r3, #4]
    22aa:	f103 0308 	add.w	r3, r3, #8
    22ae:	9a04      	ldr	r2, [sp, #16]
    22b0:	18d2      	adds	r2, r2, r3
    22b2:	9b04      	ldr	r3, [sp, #16]
    22b4:	681b      	ldr	r3, [r3, #0]
    22b6:	429a      	cmp	r2, r3
    22b8:	d10e      	bne.n	22d8 <chHeapFree+0xa8>
        /* Merge with the next block.*/
        hp->h.size += hp->h.u.next->h.size + sizeof(union heap_header);
    22ba:	9b04      	ldr	r3, [sp, #16]
    22bc:	685a      	ldr	r2, [r3, #4]
    22be:	9b04      	ldr	r3, [sp, #16]
    22c0:	681b      	ldr	r3, [r3, #0]
    22c2:	685b      	ldr	r3, [r3, #4]
    22c4:	18d3      	adds	r3, r2, r3
    22c6:	f103 0208 	add.w	r2, r3, #8
    22ca:	9b04      	ldr	r3, [sp, #16]
    22cc:	605a      	str	r2, [r3, #4]
        hp->h.u.next = hp->h.u.next->h.u.next;
    22ce:	9b04      	ldr	r3, [sp, #16]
    22d0:	681b      	ldr	r3, [r3, #0]
    22d2:	681a      	ldr	r2, [r3, #0]
    22d4:	9b04      	ldr	r3, [sp, #16]
    22d6:	601a      	str	r2, [r3, #0]
      }
      if ((LIMIT(qp) == hp)) {
    22d8:	9b05      	ldr	r3, [sp, #20]
    22da:	685b      	ldr	r3, [r3, #4]
    22dc:	f103 0308 	add.w	r3, r3, #8
    22e0:	9a05      	ldr	r2, [sp, #20]
    22e2:	18d2      	adds	r2, r2, r3
    22e4:	9b04      	ldr	r3, [sp, #16]
    22e6:	429a      	cmp	r2, r3
    22e8:	d111      	bne.n	230e <chHeapFree+0xde>
        /* Merge with the previous block.*/
        qp->h.size += hp->h.size + sizeof(union heap_header);
    22ea:	9b05      	ldr	r3, [sp, #20]
    22ec:	685a      	ldr	r2, [r3, #4]
    22ee:	9b04      	ldr	r3, [sp, #16]
    22f0:	685b      	ldr	r3, [r3, #4]
    22f2:	18d3      	adds	r3, r2, r3
    22f4:	f103 0208 	add.w	r2, r3, #8
    22f8:	9b05      	ldr	r3, [sp, #20]
    22fa:	605a      	str	r2, [r3, #4]
        qp->h.u.next = hp->h.u.next;
    22fc:	9b04      	ldr	r3, [sp, #16]
    22fe:	681a      	ldr	r2, [r3, #0]
    2300:	9b05      	ldr	r3, [sp, #20]
    2302:	601a      	str	r2, [r3, #0]
      }
      break;
    2304:	e003      	b.n	230e <chHeapFree+0xde>
    }
    qp = qp->h.u.next;
    2306:	9b05      	ldr	r3, [sp, #20]
    2308:	681b      	ldr	r3, [r3, #0]
    230a:	9305      	str	r3, [sp, #20]
  }
    230c:	e7a4      	b.n	2258 <chHeapFree+0x28>
      if ((LIMIT(qp) == hp)) {
        /* Merge with the previous block.*/
        qp->h.size += hp->h.size + sizeof(union heap_header);
        qp->h.u.next = hp->h.u.next;
      }
      break;
    230e:	bf00      	nop
    }
    qp = qp->h.u.next;
  }

  H_UNLOCK(heapp);
    2310:	f000 fb96 	bl	2a40 <chMtxUnlock>
  return;
}
    2314:	b007      	add	sp, #28
    2316:	bd00      	pop	{pc}
    2318:	f3af 8000 	nop.w
    231c:	f3af 8000 	nop.w

00002320 <chHeapStatus>:
 *                      fragmented free space
 * @return              The number of fragments in the heap.
 *
 * @api
 */
size_t chHeapStatus(MemoryHeap *heapp, size_t *sizep) {
    2320:	b500      	push	{lr}
    2322:	b087      	sub	sp, #28
    2324:	9001      	str	r0, [sp, #4]
    2326:	9100      	str	r1, [sp, #0]
  union heap_header *qp;
  size_t n, sz;

  if (heapp == NULL)
    2328:	9b01      	ldr	r3, [sp, #4]
    232a:	2b00      	cmp	r3, #0
    232c:	d104      	bne.n	2338 <chHeapStatus+0x18>
    heapp = &default_heap;
    232e:	f240 7330 	movw	r3, #1840	; 0x730
    2332:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2336:	9301      	str	r3, [sp, #4]

  H_LOCK(heapp);
    2338:	9b01      	ldr	r3, [sp, #4]
    233a:	f103 0310 	add.w	r3, r3, #16
    233e:	4618      	mov	r0, r3
    2340:	f000 face 	bl	28e0 <chMtxLock>

  sz = 0;
    2344:	f04f 0300 	mov.w	r3, #0
    2348:	9303      	str	r3, [sp, #12]
  for (n = 0, qp = &heapp->h_free; qp->h.u.next; n++, qp = qp->h.u.next)
    234a:	f04f 0300 	mov.w	r3, #0
    234e:	9304      	str	r3, [sp, #16]
    2350:	9b01      	ldr	r3, [sp, #4]
    2352:	f103 0308 	add.w	r3, r3, #8
    2356:	9305      	str	r3, [sp, #20]
    2358:	e00c      	b.n	2374 <chHeapStatus+0x54>
    sz += qp->h.u.next->h.size;
    235a:	9b05      	ldr	r3, [sp, #20]
    235c:	681b      	ldr	r3, [r3, #0]
    235e:	685b      	ldr	r3, [r3, #4]
    2360:	9a03      	ldr	r2, [sp, #12]
    2362:	18d3      	adds	r3, r2, r3
    2364:	9303      	str	r3, [sp, #12]
    heapp = &default_heap;

  H_LOCK(heapp);

  sz = 0;
  for (n = 0, qp = &heapp->h_free; qp->h.u.next; n++, qp = qp->h.u.next)
    2366:	9b04      	ldr	r3, [sp, #16]
    2368:	f103 0301 	add.w	r3, r3, #1
    236c:	9304      	str	r3, [sp, #16]
    236e:	9b05      	ldr	r3, [sp, #20]
    2370:	681b      	ldr	r3, [r3, #0]
    2372:	9305      	str	r3, [sp, #20]
    2374:	9b05      	ldr	r3, [sp, #20]
    2376:	681b      	ldr	r3, [r3, #0]
    2378:	2b00      	cmp	r3, #0
    237a:	d1ee      	bne.n	235a <chHeapStatus+0x3a>
    sz += qp->h.u.next->h.size;
  if (sizep)
    237c:	9b00      	ldr	r3, [sp, #0]
    237e:	2b00      	cmp	r3, #0
    2380:	d002      	beq.n	2388 <chHeapStatus+0x68>
    *sizep = sz;
    2382:	9b00      	ldr	r3, [sp, #0]
    2384:	9a03      	ldr	r2, [sp, #12]
    2386:	601a      	str	r2, [r3, #0]

  H_UNLOCK(heapp);
    2388:	f000 fb5a 	bl	2a40 <chMtxUnlock>
  return n;
    238c:	9b04      	ldr	r3, [sp, #16]
}
    238e:	4618      	mov	r0, r3
    2390:	b007      	add	sp, #28
    2392:	bd00      	pop	{pc}
    2394:	f3af 8000 	nop.w
    2398:	f3af 8000 	nop.w
    239c:	f3af 8000 	nop.w

000023a0 <chPoolInit>:
 *                      @p NULL if the pool is not allowed to grow
 *                      automatically
 *
 * @init
 */
void chPoolInit(MemoryPool *mp, size_t size, memgetfunc_t provider) {
    23a0:	b084      	sub	sp, #16
    23a2:	9003      	str	r0, [sp, #12]
    23a4:	9102      	str	r1, [sp, #8]
    23a6:	9201      	str	r2, [sp, #4]

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)), "chPoolInit");
    23a8:	9b03      	ldr	r3, [sp, #12]
    23aa:	2b00      	cmp	r3, #0
    23ac:	d001      	beq.n	23b2 <chPoolInit+0x12>
    23ae:	9b02      	ldr	r3, [sp, #8]
    23b0:	2b03      	cmp	r3, #3

  mp->mp_next = NULL;
    23b2:	9b03      	ldr	r3, [sp, #12]
    23b4:	f04f 0200 	mov.w	r2, #0
    23b8:	601a      	str	r2, [r3, #0]
  mp->mp_object_size = size;
    23ba:	9b03      	ldr	r3, [sp, #12]
    23bc:	9a02      	ldr	r2, [sp, #8]
    23be:	605a      	str	r2, [r3, #4]
  mp->mp_provider = provider;
    23c0:	9b03      	ldr	r3, [sp, #12]
    23c2:	9a01      	ldr	r2, [sp, #4]
    23c4:	609a      	str	r2, [r3, #8]
}
    23c6:	b004      	add	sp, #16
    23c8:	4770      	bx	lr
    23ca:	bf00      	nop
    23cc:	f3af 8000 	nop.w

000023d0 <chPoolLoadArray>:
 * @param[in] p         pointer to the array first element
 * @param[in] n         number of elements in the array
 *
 * @api
 */
void chPoolLoadArray(MemoryPool *mp, void *p, size_t n) {
    23d0:	b500      	push	{lr}
    23d2:	b085      	sub	sp, #20
    23d4:	9003      	str	r0, [sp, #12]
    23d6:	9102      	str	r1, [sp, #8]
    23d8:	9201      	str	r2, [sp, #4]

  chDbgCheck((mp != NULL) && (n != 0), "chPoolLoadArray");
    23da:	9b03      	ldr	r3, [sp, #12]
    23dc:	2b00      	cmp	r3, #0
    23de:	d00f      	beq.n	2400 <chPoolLoadArray+0x30>
    23e0:	9b01      	ldr	r3, [sp, #4]
    23e2:	2b00      	cmp	r3, #0

  while (n) {
    23e4:	e00c      	b.n	2400 <chPoolLoadArray+0x30>
    chPoolAdd(mp, p);
    23e6:	9803      	ldr	r0, [sp, #12]
    23e8:	9902      	ldr	r1, [sp, #8]
    23ea:	f000 f861 	bl	24b0 <chPoolFree>
    p = (void *)(((uint8_t *)p) + mp->mp_object_size);
    23ee:	9b03      	ldr	r3, [sp, #12]
    23f0:	685b      	ldr	r3, [r3, #4]
    23f2:	9a02      	ldr	r2, [sp, #8]
    23f4:	18d3      	adds	r3, r2, r3
    23f6:	9302      	str	r3, [sp, #8]
    n--;
    23f8:	9b01      	ldr	r3, [sp, #4]
    23fa:	f103 33ff 	add.w	r3, r3, #4294967295
    23fe:	9301      	str	r3, [sp, #4]
 */
void chPoolLoadArray(MemoryPool *mp, void *p, size_t n) {

  chDbgCheck((mp != NULL) && (n != 0), "chPoolLoadArray");

  while (n) {
    2400:	9b01      	ldr	r3, [sp, #4]
    2402:	2b00      	cmp	r3, #0
    2404:	d1ef      	bne.n	23e6 <chPoolLoadArray+0x16>
    chPoolAdd(mp, p);
    p = (void *)(((uint8_t *)p) + mp->mp_object_size);
    n--;
  }
}
    2406:	b005      	add	sp, #20
    2408:	bd00      	pop	{pc}
    240a:	bf00      	nop
    240c:	f3af 8000 	nop.w

00002410 <chPoolAllocI>:
 * @return              The pointer to the allocated object.
 * @retval NULL         if pool is empty.
 *
 * @iclass
 */
void *chPoolAllocI(MemoryPool *mp) {
    2410:	b500      	push	{lr}
    2412:	b085      	sub	sp, #20
    2414:	9001      	str	r0, [sp, #4]
  void *objp;

  chDbgCheckClassI();
  chDbgCheck(mp != NULL, "chPoolAllocI");

  if ((objp = mp->mp_next) != NULL)
    2416:	9b01      	ldr	r3, [sp, #4]
    2418:	681b      	ldr	r3, [r3, #0]
    241a:	9303      	str	r3, [sp, #12]
    241c:	9b03      	ldr	r3, [sp, #12]
    241e:	2b00      	cmp	r3, #0
    2420:	d005      	beq.n	242e <chPoolAllocI+0x1e>
    mp->mp_next = mp->mp_next->ph_next;
    2422:	9b01      	ldr	r3, [sp, #4]
    2424:	681b      	ldr	r3, [r3, #0]
    2426:	681a      	ldr	r2, [r3, #0]
    2428:	9b01      	ldr	r3, [sp, #4]
    242a:	601a      	str	r2, [r3, #0]
    242c:	e00a      	b.n	2444 <chPoolAllocI+0x34>
  else if (mp->mp_provider != NULL)
    242e:	9b01      	ldr	r3, [sp, #4]
    2430:	689b      	ldr	r3, [r3, #8]
    2432:	2b00      	cmp	r3, #0
    2434:	d006      	beq.n	2444 <chPoolAllocI+0x34>
    objp = mp->mp_provider(mp->mp_object_size);
    2436:	9b01      	ldr	r3, [sp, #4]
    2438:	689b      	ldr	r3, [r3, #8]
    243a:	9a01      	ldr	r2, [sp, #4]
    243c:	6852      	ldr	r2, [r2, #4]
    243e:	4610      	mov	r0, r2
    2440:	4798      	blx	r3
    2442:	9003      	str	r0, [sp, #12]
  return objp;
    2444:	9b03      	ldr	r3, [sp, #12]
}
    2446:	4618      	mov	r0, r3
    2448:	b005      	add	sp, #20
    244a:	bd00      	pop	{pc}
    244c:	f3af 8000 	nop.w

00002450 <chPoolAlloc>:
 * @return              The pointer to the allocated object.
 * @retval NULL         if pool is empty.
 *
 * @api
 */
void *chPoolAlloc(MemoryPool *mp) {
    2450:	b500      	push	{lr}
    2452:	b085      	sub	sp, #20
    2454:	9001      	str	r0, [sp, #4]
  void *objp;

  chSysLock();
    2456:	f04f 0320 	mov.w	r3, #32
    245a:	f383 8811 	msr	BASEPRI, r3
  objp = chPoolAllocI(mp);
    245e:	9801      	ldr	r0, [sp, #4]
    2460:	f7ff ffd6 	bl	2410 <chPoolAllocI>
    2464:	9003      	str	r0, [sp, #12]
  chSysUnlock();
    2466:	f04f 0300 	mov.w	r3, #0
    246a:	f383 8811 	msr	BASEPRI, r3
  return objp;
    246e:	9b03      	ldr	r3, [sp, #12]
}
    2470:	4618      	mov	r0, r3
    2472:	b005      	add	sp, #20
    2474:	bd00      	pop	{pc}
    2476:	bf00      	nop
    2478:	f3af 8000 	nop.w
    247c:	f3af 8000 	nop.w

00002480 <chPoolFreeI>:
 * @param[in] mp        pointer to a @p MemoryPool structure
 * @param[in] objp      the pointer to the object to be released
 *
 * @iclass
 */
void chPoolFreeI(MemoryPool *mp, void *objp) {
    2480:	b084      	sub	sp, #16
    2482:	9001      	str	r0, [sp, #4]
    2484:	9100      	str	r1, [sp, #0]
  struct pool_header *php = objp;
    2486:	9b00      	ldr	r3, [sp, #0]
    2488:	9303      	str	r3, [sp, #12]

  chDbgCheckClassI();
  chDbgCheck((mp != NULL) && (objp != NULL), "chPoolFreeI");
    248a:	9b01      	ldr	r3, [sp, #4]
    248c:	2b00      	cmp	r3, #0
    248e:	d001      	beq.n	2494 <chPoolFreeI+0x14>
    2490:	9b00      	ldr	r3, [sp, #0]
    2492:	2b00      	cmp	r3, #0

  php->ph_next = mp->mp_next;
    2494:	9b01      	ldr	r3, [sp, #4]
    2496:	681a      	ldr	r2, [r3, #0]
    2498:	9b03      	ldr	r3, [sp, #12]
    249a:	601a      	str	r2, [r3, #0]
  mp->mp_next = php;
    249c:	9b01      	ldr	r3, [sp, #4]
    249e:	9a03      	ldr	r2, [sp, #12]
    24a0:	601a      	str	r2, [r3, #0]
}
    24a2:	b004      	add	sp, #16
    24a4:	4770      	bx	lr
    24a6:	bf00      	nop
    24a8:	f3af 8000 	nop.w
    24ac:	f3af 8000 	nop.w

000024b0 <chPoolFree>:
 * @param[in] mp        pointer to a @p MemoryPool structure
 * @param[in] objp      the pointer to the object to be released
 *
 * @api
 */
void chPoolFree(MemoryPool *mp, void *objp) {
    24b0:	b500      	push	{lr}
    24b2:	b083      	sub	sp, #12
    24b4:	9001      	str	r0, [sp, #4]
    24b6:	9100      	str	r1, [sp, #0]

  chSysLock();
    24b8:	f04f 0320 	mov.w	r3, #32
    24bc:	f383 8811 	msr	BASEPRI, r3
  chPoolFreeI(mp, objp);
    24c0:	9801      	ldr	r0, [sp, #4]
    24c2:	9900      	ldr	r1, [sp, #0]
    24c4:	f7ff ffdc 	bl	2480 <chPoolFreeI>
  chSysUnlock();
    24c8:	f04f 0300 	mov.w	r3, #0
    24cc:	f383 8811 	msr	BASEPRI, r3
}
    24d0:	b003      	add	sp, #12
    24d2:	bd00      	pop	{pc}
    24d4:	f3af 8000 	nop.w
    24d8:	f3af 8000 	nop.w
    24dc:	f3af 8000 	nop.w

000024e0 <SysTickVector>:
/**
 * @brief   System Timer vector.
 * @details This interrupt is used as system tick.
 * @note    The timer must be initialized in the startup code.
 */
CH_IRQ_HANDLER(SysTickVector) {
    24e0:	b508      	push	{r3, lr}

  CH_IRQ_PROLOGUE();

  chSysLockFromIsr();
    24e2:	f04f 0320 	mov.w	r3, #32
    24e6:	f383 8811 	msr	BASEPRI, r3
  chSysTimerHandlerI();
    24ea:	f7fe ff29 	bl	1340 <chSysTimerHandlerI>
  chSysUnlockFromIsr();
    24ee:	f04f 0300 	mov.w	r3, #0
    24f2:	f383 8811 	msr	BASEPRI, r3

  CH_IRQ_EPILOGUE();
    24f6:	f000 f843 	bl	2580 <_port_irq_epilogue>
}
    24fa:	bd08      	pop	{r3, pc}
    24fc:	f3af 8000 	nop.w

00002500 <SVCallVector>:
 * @brief   SVC vector.
 * @details The SVC vector is used for exception mode re-entering after a
 *          context switch.
 * @note    The PendSV vector is only used in advanced kernel mode.
 */
void SVCallVector(void) {
    2500:	b410      	push	{r4}
    2502:	b083      	sub	sp, #12
  struct extctx *ctxp;

  /* Current PSP value.*/
  asm volatile ("mrs     %0, PSP" : "=r" (ctxp) : : "memory");
    2504:	f3ef 8409 	mrs	r4, PSP
    2508:	9401      	str	r4, [sp, #4]

  /* Discarding the current exception context and positioning the stack to
     point to the real one.*/
  ctxp++;
    250a:	9b01      	ldr	r3, [sp, #4]
    250c:	f103 0320 	add.w	r3, r3, #32
    2510:	9301      	str	r3, [sp, #4]
#if CORTEX_USE_FPU
  /* Restoring the special register SCB_FPCCR.*/
  SCB_FPCCR = (uint32_t)ctxp->fpccr;
  SCB_FPCAR = SCB_FPCAR + sizeof (struct extctx);
#endif
  asm volatile ("msr     PSP, %0" : : "r" (ctxp) : "memory");
    2512:	9b01      	ldr	r3, [sp, #4]
    2514:	f383 8809 	msr	PSP, r3
  port_unlock_from_isr();
    2518:	f04f 0300 	mov.w	r3, #0
    251c:	f383 8811 	msr	BASEPRI, r3
}
    2520:	b003      	add	sp, #12
    2522:	bc10      	pop	{r4}
    2524:	4770      	bx	lr
    2526:	bf00      	nop
    2528:	f3af 8000 	nop.w
    252c:	f3af 8000 	nop.w

00002530 <_port_init>:
/*===========================================================================*/

/**
 * @brief   Port-related initialization code.
 */
void _port_init(void) {
    2530:	b508      	push	{r3, lr}

  /* Initialization of the vector table and priority related settings.*/
  SCB_VTOR = CORTEX_VTOR_INIT;
    2532:	f44f 436d 	mov.w	r3, #60672	; 0xed00
    2536:	f2ce 0300 	movt	r3, #57344	; 0xe000
    253a:	f04f 0200 	mov.w	r2, #0
    253e:	609a      	str	r2, [r3, #8]
  SCB_AIRCR = AIRCR_VECTKEY | AIRCR_PRIGROUP(CORTEX_PRIGROUP_INIT);
    2540:	f44f 436d 	mov.w	r3, #60672	; 0xed00
    2544:	f2ce 0300 	movt	r3, #57344	; 0xe000
    2548:	f44f 7240 	mov.w	r2, #768	; 0x300
    254c:	f2c0 52fa 	movt	r2, #1530	; 0x5fa
    2550:	60da      	str	r2, [r3, #12]

  /* Initialization of the system vectors used by the port.*/
  nvicSetSystemHandlerPriority(HANDLER_SVCALL,
    2552:	f04f 0007 	mov.w	r0, #7
    2556:	f04f 0110 	mov.w	r1, #16
    255a:	f000 f931 	bl	27c0 <nvicSetSystemHandlerPriority>
    CORTEX_PRIORITY_MASK(CORTEX_PRIORITY_SVCALL));
  nvicSetSystemHandlerPriority(HANDLER_PENDSV,
    255e:	f04f 000a 	mov.w	r0, #10
    2562:	f44f 7100 	mov.w	r1, #512	; 0x200
    2566:	f000 f92b 	bl	27c0 <nvicSetSystemHandlerPriority>
    CORTEX_PRIORITY_MASK(CORTEX_PRIORITY_PENDSV));
  nvicSetSystemHandlerPriority(HANDLER_SYSTICK,
    256a:	f04f 000b 	mov.w	r0, #11
    256e:	f04f 0180 	mov.w	r1, #128	; 0x80
    2572:	f000 f925 	bl	27c0 <nvicSetSystemHandlerPriority>
    CORTEX_PRIORITY_MASK(CORTEX_PRIORITY_SYSTICK));
}
    2576:	bd08      	pop	{r3, pc}
    2578:	f3af 8000 	nop.w
    257c:	f3af 8000 	nop.w

00002580 <_port_irq_epilogue>:
#endif

/**
 * @brief   Exception exit redirection to _port_switch_from_isr().
 */
void _port_irq_epilogue(void) {
    2580:	b410      	push	{r4}
    2582:	b083      	sub	sp, #12

  port_lock_from_isr();
    2584:	f04f 0320 	mov.w	r3, #32
    2588:	f383 8811 	msr	BASEPRI, r3
  if ((SCB_ICSR & ICSR_RETTOBASE) != 0) {
    258c:	f44f 436d 	mov.w	r3, #60672	; 0xed00
    2590:	f2ce 0300 	movt	r3, #57344	; 0xe000
    2594:	685b      	ldr	r3, [r3, #4]
    2596:	f403 6300 	and.w	r3, r3, #2048	; 0x800
    259a:	2b00      	cmp	r3, #0
    259c:	d048      	beq.n	2630 <_port_irq_epilogue+0xb0>
    struct extctx *ctxp;

    /* Current PSP value.*/
    asm volatile ("mrs     %0, PSP" : "=r" (ctxp) : : "memory");
    259e:	f3ef 8409 	mrs	r4, PSP
    25a2:	9401      	str	r4, [sp, #4]

    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;
    25a4:	9b01      	ldr	r3, [sp, #4]
    25a6:	f1a3 0320 	sub.w	r3, r3, #32
    25aa:	9301      	str	r3, [sp, #4]
    asm volatile ("msr     PSP, %0" : : "r" (ctxp) : "memory");
    25ac:	9b01      	ldr	r3, [sp, #4]
    25ae:	f383 8809 	msr	PSP, r3
    ctxp->xpsr = (regarm_t)0x01000000;
    25b2:	9b01      	ldr	r3, [sp, #4]
    25b4:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
    25b8:	61da      	str	r2, [r3, #28]

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
    25ba:	f240 7308 	movw	r3, #1800	; 0x708
    25be:	f2c2 0300 	movt	r3, #8192	; 0x2000
    25c2:	699b      	ldr	r3, [r3, #24]
    25c4:	7fdb      	ldrb	r3, [r3, #31]
    25c6:	2b00      	cmp	r3, #0
    25c8:	d011      	beq.n	25ee <_port_irq_epilogue+0x6e>
    25ca:	f240 7308 	movw	r3, #1800	; 0x708
    25ce:	f2c2 0300 	movt	r3, #8192	; 0x2000
    25d2:	681b      	ldr	r3, [r3, #0]
    25d4:	689a      	ldr	r2, [r3, #8]
    25d6:	f240 7308 	movw	r3, #1800	; 0x708
    25da:	f2c2 0300 	movt	r3, #8192	; 0x2000
    25de:	699b      	ldr	r3, [r3, #24]
    25e0:	689b      	ldr	r3, [r3, #8]
    25e2:	429a      	cmp	r2, r3
    25e4:	bf94      	ite	ls
    25e6:	2300      	movls	r3, #0
    25e8:	2301      	movhi	r3, #1
    25ea:	b2db      	uxtb	r3, r3
    25ec:	e010      	b.n	2610 <_port_irq_epilogue+0x90>
    25ee:	f240 7308 	movw	r3, #1800	; 0x708
    25f2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    25f6:	681b      	ldr	r3, [r3, #0]
    25f8:	689a      	ldr	r2, [r3, #8]
    25fa:	f240 7308 	movw	r3, #1800	; 0x708
    25fe:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2602:	699b      	ldr	r3, [r3, #24]
    2604:	689b      	ldr	r3, [r3, #8]
    2606:	429a      	cmp	r2, r3
    2608:	bf34      	ite	cc
    260a:	2300      	movcc	r3, #0
    260c:	2301      	movcs	r3, #1
    260e:	b2db      	uxtb	r3, r3
    2610:	2b00      	cmp	r3, #0
    2612:	d006      	beq.n	2622 <_port_irq_epilogue+0xa2>
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (void *)_port_switch_from_isr;
    2614:	9a01      	ldr	r2, [sp, #4]
    2616:	f242 6341 	movw	r3, #9793	; 0x2641
    261a:	f2c0 0300 	movt	r3, #0
    261e:	6193      	str	r3, [r2, #24]
    }
#endif

    /* Note, returning without unlocking is intentional, this is done in
       order to keep the rest of the context switching atomic.*/
    return;
    2620:	e00a      	b.n	2638 <_port_irq_epilogue+0xb8>
#endif
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ctxp->pc = (void *)_port_exit_from_isr;
    2622:	9a01      	ldr	r2, [sp, #4]
    2624:	f242 6344 	movw	r3, #9796	; 0x2644
    2628:	f2c0 0300 	movt	r3, #0
    262c:	6193      	str	r3, [r2, #24]
    }
#endif

    /* Note, returning without unlocking is intentional, this is done in
       order to keep the rest of the context switching atomic.*/
    return;
    262e:	e003      	b.n	2638 <_port_irq_epilogue+0xb8>
  }
  port_unlock_from_isr();
    2630:	f04f 0300 	mov.w	r3, #0
    2634:	f383 8811 	msr	BASEPRI, r3
}
    2638:	b003      	add	sp, #12
    263a:	bc10      	pop	{r4}
    263c:	4770      	bx	lr
    263e:	bf00      	nop

00002640 <_port_switch_from_isr>:
__attribute__((naked))
#endif
void _port_switch_from_isr(void) {

  dbg_check_lock();
  chSchDoReschedule();
    2640:	f7ff f9be 	bl	19c0 <chSchDoReschedule>

00002644 <_port_exit_from_isr>:
  dbg_check_unlock();
  asm volatile ("_port_exit_from_isr:" : : : "memory");
#if !CORTEX_SIMPLIFIED_PRIORITY || defined(__DOXYGEN__)
  asm volatile ("svc     #0");
    2644:	df00      	svc	0
    2646:	bf00      	nop
    2648:	f3af 8000 	nop.w
    264c:	f3af 8000 	nop.w

00002650 <_port_switch>:
 * @param[in] otp       the thread to be switched out
 */
#if !defined(__DOXYGEN__)
__attribute__((naked))
#endif
void _port_switch(Thread *ntp, Thread *otp) {
    2650:	4603      	mov	r3, r0
    2652:	460a      	mov	r2, r1

  asm volatile ("push    {r4, r5, r6, r7, r8, r9, r10, r11, lr}"
    2654:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
                : : : "memory");
#if CORTEX_USE_FPU
  asm volatile ("vpush   {s16-s31}" : : : "memory");
#endif

  asm volatile ("str     sp, [%1, #12]                          \n\t"
    2658:	f8c2 d00c 	str.w	sp, [r2, #12]
    265c:	f8d3 d00c 	ldr.w	sp, [r3, #12]
                "ldr     sp, [%0, #12]" : : "r" (ntp), "r" (otp));

#if CORTEX_USE_FPU
  asm volatile ("vpop    {s16-s31}" : : : "memory");
#endif
  asm volatile ("pop     {r4, r5, r6, r7, r8, r9, r10, r11, pc}"
    2660:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    2664:	f3af 8000 	nop.w
    2668:	f3af 8000 	nop.w
    266c:	f3af 8000 	nop.w

00002670 <_port_thread_start>:
 * @details If the work function returns @p chThdExit() is automatically
 *          invoked.
 */
void _port_thread_start(void) {

  chSysUnlock();
    2670:	f04f 0300 	mov.w	r3, #0
    2674:	f383 8811 	msr	BASEPRI, r3
  asm volatile ("mov     r0, r5                                 \n\t"
    2678:	4628      	mov	r0, r5
    267a:	47a0      	blx	r4
    267c:	f7ff fb48 	bl	1d10 <chThdExit>
                "blx     r4                                     \n\t"
                "bl      chThdExit");
}
    2680:	4770      	bx	lr
    2682:	bf00      	nop
    2684:	f3af 8000 	nop.w
    2688:	f3af 8000 	nop.w
    268c:	f3af 8000 	nop.w

00002690 <nvicEnableVector>:
 * @note    The parameters are not tested for correctness.
 *
 * @param[in] n         the interrupt number
 * @param[in] prio      the interrupt priority mask
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {
    2690:	b410      	push	{r4}
    2692:	b085      	sub	sp, #20
    2694:	9001      	str	r0, [sp, #4]
    2696:	9100      	str	r1, [sp, #0]
  unsigned sh = (n & 3) << 3;
    2698:	9b01      	ldr	r3, [sp, #4]
    269a:	f003 0303 	and.w	r3, r3, #3
    269e:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    26a2:	9303      	str	r3, [sp, #12]

  NVIC_IPR(n >> 2) = (NVIC_IPR(n >> 2) & ~(0xFF << sh)) | (prio << sh);
    26a4:	f44f 4361 	mov.w	r3, #57600	; 0xe100
    26a8:	f2ce 0300 	movt	r3, #57344	; 0xe000
    26ac:	9a01      	ldr	r2, [sp, #4]
    26ae:	ea4f 0092 	mov.w	r0, r2, lsr #2
    26b2:	f44f 4261 	mov.w	r2, #57600	; 0xe100
    26b6:	f2ce 0200 	movt	r2, #57344	; 0xe000
    26ba:	9901      	ldr	r1, [sp, #4]
    26bc:	ea4f 0191 	mov.w	r1, r1, lsr #2
    26c0:	f101 01c0 	add.w	r1, r1, #192	; 0xc0
    26c4:	f852 1021 	ldr.w	r1, [r2, r1, lsl #2]
    26c8:	9a03      	ldr	r2, [sp, #12]
    26ca:	f04f 04ff 	mov.w	r4, #255	; 0xff
    26ce:	fa04 f202 	lsl.w	r2, r4, r2
    26d2:	ea6f 0202 	mvn.w	r2, r2
    26d6:	4011      	ands	r1, r2
    26d8:	9a03      	ldr	r2, [sp, #12]
    26da:	9c00      	ldr	r4, [sp, #0]
    26dc:	fa04 f202 	lsl.w	r2, r4, r2
    26e0:	4311      	orrs	r1, r2
    26e2:	f100 02c0 	add.w	r2, r0, #192	; 0xc0
    26e6:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
  NVIC_ICPR(n >> 5) = 1 << (n & 0x1F);
    26ea:	f44f 4361 	mov.w	r3, #57600	; 0xe100
    26ee:	f2ce 0300 	movt	r3, #57344	; 0xe000
    26f2:	9a01      	ldr	r2, [sp, #4]
    26f4:	ea4f 1252 	mov.w	r2, r2, lsr #5
    26f8:	9901      	ldr	r1, [sp, #4]
    26fa:	f001 011f 	and.w	r1, r1, #31
    26fe:	f04f 0001 	mov.w	r0, #1
    2702:	fa00 f101 	lsl.w	r1, r0, r1
    2706:	f102 0260 	add.w	r2, r2, #96	; 0x60
    270a:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
  NVIC_ISER(n >> 5) = 1 << (n & 0x1F);
    270e:	f44f 4361 	mov.w	r3, #57600	; 0xe100
    2712:	f2ce 0300 	movt	r3, #57344	; 0xe000
    2716:	9a01      	ldr	r2, [sp, #4]
    2718:	ea4f 1252 	mov.w	r2, r2, lsr #5
    271c:	9901      	ldr	r1, [sp, #4]
    271e:	f001 011f 	and.w	r1, r1, #31
    2722:	f04f 0001 	mov.w	r0, #1
    2726:	fa00 f101 	lsl.w	r1, r0, r1
    272a:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
    272e:	b005      	add	sp, #20
    2730:	bc10      	pop	{r4}
    2732:	4770      	bx	lr
    2734:	f3af 8000 	nop.w
    2738:	f3af 8000 	nop.w
    273c:	f3af 8000 	nop.w

00002740 <nvicDisableVector>:
 * @brief   Disables an interrupt handler.
 * @note    The parameters are not tested for correctness.
 *
 * @param[in] n         the interrupt number
 */
void nvicDisableVector(uint32_t n) {
    2740:	b410      	push	{r4}
    2742:	b085      	sub	sp, #20
    2744:	9001      	str	r0, [sp, #4]
  unsigned sh = (n & 3) << 3;
    2746:	9b01      	ldr	r3, [sp, #4]
    2748:	f003 0303 	and.w	r3, r3, #3
    274c:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    2750:	9303      	str	r3, [sp, #12]

  NVIC_ICER(n >> 5) = 1 << (n & 0x1F);
    2752:	f44f 4361 	mov.w	r3, #57600	; 0xe100
    2756:	f2ce 0300 	movt	r3, #57344	; 0xe000
    275a:	9a01      	ldr	r2, [sp, #4]
    275c:	ea4f 1252 	mov.w	r2, r2, lsr #5
    2760:	9901      	ldr	r1, [sp, #4]
    2762:	f001 011f 	and.w	r1, r1, #31
    2766:	f04f 0001 	mov.w	r0, #1
    276a:	fa00 f101 	lsl.w	r1, r0, r1
    276e:	f102 0220 	add.w	r2, r2, #32
    2772:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
  NVIC_IPR(n >> 2) = NVIC_IPR(n >> 2) & ~(0xFF << sh);
    2776:	f44f 4361 	mov.w	r3, #57600	; 0xe100
    277a:	f2ce 0300 	movt	r3, #57344	; 0xe000
    277e:	9a01      	ldr	r2, [sp, #4]
    2780:	ea4f 0092 	mov.w	r0, r2, lsr #2
    2784:	f44f 4261 	mov.w	r2, #57600	; 0xe100
    2788:	f2ce 0200 	movt	r2, #57344	; 0xe000
    278c:	9901      	ldr	r1, [sp, #4]
    278e:	ea4f 0191 	mov.w	r1, r1, lsr #2
    2792:	f101 01c0 	add.w	r1, r1, #192	; 0xc0
    2796:	f852 1021 	ldr.w	r1, [r2, r1, lsl #2]
    279a:	9a03      	ldr	r2, [sp, #12]
    279c:	f04f 04ff 	mov.w	r4, #255	; 0xff
    27a0:	fa04 f202 	lsl.w	r2, r4, r2
    27a4:	ea6f 0202 	mvn.w	r2, r2
    27a8:	4011      	ands	r1, r2
    27aa:	f100 02c0 	add.w	r2, r0, #192	; 0xc0
    27ae:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
    27b2:	b005      	add	sp, #20
    27b4:	bc10      	pop	{r4}
    27b6:	4770      	bx	lr
    27b8:	f3af 8000 	nop.w
    27bc:	f3af 8000 	nop.w

000027c0 <nvicSetSystemHandlerPriority>:
 * @note    The parameters are not tested for correctness.
 *
 * @param[in] handler   the system handler number
 * @param[in] prio      the system handler priority mask
 */
void nvicSetSystemHandlerPriority(uint32_t handler, uint32_t prio) {
    27c0:	b410      	push	{r4}
    27c2:	b085      	sub	sp, #20
    27c4:	9001      	str	r0, [sp, #4]
    27c6:	9100      	str	r1, [sp, #0]
  unsigned sh = (handler & 3) * 8;
    27c8:	9b01      	ldr	r3, [sp, #4]
    27ca:	f003 0303 	and.w	r3, r3, #3
    27ce:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    27d2:	9303      	str	r3, [sp, #12]

  SCB_SHPR(handler >> 2) = (SCB_SHPR(handler >> 2) &
    27d4:	f44f 436d 	mov.w	r3, #60672	; 0xed00
    27d8:	f2ce 0300 	movt	r3, #57344	; 0xe000
    27dc:	9a01      	ldr	r2, [sp, #4]
    27de:	ea4f 0092 	mov.w	r0, r2, lsr #2
    27e2:	f44f 426d 	mov.w	r2, #60672	; 0xed00
    27e6:	f2ce 0200 	movt	r2, #57344	; 0xe000
    27ea:	9901      	ldr	r1, [sp, #4]
    27ec:	ea4f 0191 	mov.w	r1, r1, lsr #2
    27f0:	f101 0106 	add.w	r1, r1, #6
    27f4:	f852 1021 	ldr.w	r1, [r2, r1, lsl #2]
                           ~(0xFF << sh)) | (prio << sh);
    27f8:	9a03      	ldr	r2, [sp, #12]
    27fa:	f04f 04ff 	mov.w	r4, #255	; 0xff
    27fe:	fa04 f202 	lsl.w	r2, r4, r2
    2802:	ea6f 0202 	mvn.w	r2, r2
 * @param[in] prio      the system handler priority mask
 */
void nvicSetSystemHandlerPriority(uint32_t handler, uint32_t prio) {
  unsigned sh = (handler & 3) * 8;

  SCB_SHPR(handler >> 2) = (SCB_SHPR(handler >> 2) &
    2806:	4011      	ands	r1, r2
                           ~(0xFF << sh)) | (prio << sh);
    2808:	9a03      	ldr	r2, [sp, #12]
    280a:	9c00      	ldr	r4, [sp, #0]
    280c:	fa04 f202 	lsl.w	r2, r4, r2
    2810:	4311      	orrs	r1, r2
 * @param[in] prio      the system handler priority mask
 */
void nvicSetSystemHandlerPriority(uint32_t handler, uint32_t prio) {
  unsigned sh = (handler & 3) * 8;

  SCB_SHPR(handler >> 2) = (SCB_SHPR(handler >> 2) &
    2812:	f100 0206 	add.w	r2, r0, #6
    2816:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
                           ~(0xFF << sh)) | (prio << sh);
}
    281a:	b005      	add	sp, #20
    281c:	bc10      	pop	{r4}
    281e:	4770      	bx	lr

00002820 <prio_insert>:
#define _CHINLINE_H_

/* If the performance code path has been chosen then all the following
   functions are inlined into the various kernel modules.*/
#if CH_OPTIMIZE_SPEED
static INLINE void prio_insert(Thread *tp, ThreadsQueue *tqp) {
    2820:	b084      	sub	sp, #16
    2822:	9001      	str	r0, [sp, #4]
    2824:	9100      	str	r1, [sp, #0]

  Thread *cp = (Thread *)tqp;
    2826:	9b00      	ldr	r3, [sp, #0]
    2828:	9303      	str	r3, [sp, #12]
  do {
    cp = cp->p_next;
    282a:	9b03      	ldr	r3, [sp, #12]
    282c:	681b      	ldr	r3, [r3, #0]
    282e:	9303      	str	r3, [sp, #12]
  } while ((cp != (Thread *)tqp) && (cp->p_prio >= tp->p_prio));
    2830:	9a03      	ldr	r2, [sp, #12]
    2832:	9b00      	ldr	r3, [sp, #0]
    2834:	429a      	cmp	r2, r3
    2836:	d005      	beq.n	2844 <prio_insert+0x24>
    2838:	9b03      	ldr	r3, [sp, #12]
    283a:	689a      	ldr	r2, [r3, #8]
    283c:	9b01      	ldr	r3, [sp, #4]
    283e:	689b      	ldr	r3, [r3, #8]
    2840:	429a      	cmp	r2, r3
    2842:	d2f2      	bcs.n	282a <prio_insert+0xa>
  tp->p_next = cp;
    2844:	9b01      	ldr	r3, [sp, #4]
    2846:	9a03      	ldr	r2, [sp, #12]
    2848:	601a      	str	r2, [r3, #0]
  tp->p_prev = cp->p_prev;
    284a:	9b03      	ldr	r3, [sp, #12]
    284c:	685a      	ldr	r2, [r3, #4]
    284e:	9b01      	ldr	r3, [sp, #4]
    2850:	605a      	str	r2, [r3, #4]
  tp->p_prev->p_next = cp->p_prev = tp;
    2852:	9b01      	ldr	r3, [sp, #4]
    2854:	685b      	ldr	r3, [r3, #4]
    2856:	9a03      	ldr	r2, [sp, #12]
    2858:	9901      	ldr	r1, [sp, #4]
    285a:	6051      	str	r1, [r2, #4]
    285c:	9a03      	ldr	r2, [sp, #12]
    285e:	6852      	ldr	r2, [r2, #4]
    2860:	601a      	str	r2, [r3, #0]
}
    2862:	b004      	add	sp, #16
    2864:	4770      	bx	lr
    2866:	bf00      	nop
    2868:	f3af 8000 	nop.w
    286c:	f3af 8000 	nop.w

00002870 <fifo_remove>:
  tp->p_next = (Thread *)tqp;
  tp->p_prev = tqp->p_prev;
  tp->p_prev->p_next = tqp->p_prev = tp;
}

static INLINE Thread *fifo_remove(ThreadsQueue *tqp) {
    2870:	b084      	sub	sp, #16
    2872:	9001      	str	r0, [sp, #4]
  Thread *tp = tqp->p_next;
    2874:	9b01      	ldr	r3, [sp, #4]
    2876:	681b      	ldr	r3, [r3, #0]
    2878:	9303      	str	r3, [sp, #12]

  (tqp->p_next = tp->p_next)->p_prev = (Thread *)tqp;
    287a:	9b03      	ldr	r3, [sp, #12]
    287c:	681a      	ldr	r2, [r3, #0]
    287e:	9b01      	ldr	r3, [sp, #4]
    2880:	601a      	str	r2, [r3, #0]
    2882:	9b01      	ldr	r3, [sp, #4]
    2884:	681b      	ldr	r3, [r3, #0]
    2886:	9a01      	ldr	r2, [sp, #4]
    2888:	605a      	str	r2, [r3, #4]
  return tp;
    288a:	9b03      	ldr	r3, [sp, #12]
}
    288c:	4618      	mov	r0, r3
    288e:	b004      	add	sp, #16
    2890:	4770      	bx	lr
    2892:	bf00      	nop
    2894:	f3af 8000 	nop.w
    2898:	f3af 8000 	nop.w
    289c:	f3af 8000 	nop.w

000028a0 <dequeue>:

  (tqp->p_prev = tp->p_prev)->p_next = (Thread *)tqp;
  return tp;
}

static INLINE Thread *dequeue(Thread *tp) {
    28a0:	b082      	sub	sp, #8
    28a2:	9001      	str	r0, [sp, #4]

  tp->p_prev->p_next = tp->p_next;
    28a4:	9b01      	ldr	r3, [sp, #4]
    28a6:	685b      	ldr	r3, [r3, #4]
    28a8:	9a01      	ldr	r2, [sp, #4]
    28aa:	6812      	ldr	r2, [r2, #0]
    28ac:	601a      	str	r2, [r3, #0]
  tp->p_next->p_prev = tp->p_prev;
    28ae:	9b01      	ldr	r3, [sp, #4]
    28b0:	681b      	ldr	r3, [r3, #0]
    28b2:	9a01      	ldr	r2, [sp, #4]
    28b4:	6852      	ldr	r2, [r2, #4]
    28b6:	605a      	str	r2, [r3, #4]
  return tp;
    28b8:	9b01      	ldr	r3, [sp, #4]
}
    28ba:	4618      	mov	r0, r3
    28bc:	b002      	add	sp, #8
    28be:	4770      	bx	lr

000028c0 <chMtxInit>:
 *
 * @param[out] mp       pointer to a @p Mutex structure
 *
 * @init
 */
void chMtxInit(Mutex *mp) {
    28c0:	b082      	sub	sp, #8
    28c2:	9001      	str	r0, [sp, #4]

  chDbgCheck(mp != NULL, "chMtxInit");

  queue_init(&mp->m_queue);
    28c4:	9a01      	ldr	r2, [sp, #4]
    28c6:	9b01      	ldr	r3, [sp, #4]
    28c8:	605a      	str	r2, [r3, #4]
    28ca:	9b01      	ldr	r3, [sp, #4]
    28cc:	685a      	ldr	r2, [r3, #4]
    28ce:	9b01      	ldr	r3, [sp, #4]
    28d0:	601a      	str	r2, [r3, #0]
  mp->m_owner = NULL;
    28d2:	9b01      	ldr	r3, [sp, #4]
    28d4:	f04f 0200 	mov.w	r2, #0
    28d8:	609a      	str	r2, [r3, #8]
}
    28da:	b002      	add	sp, #8
    28dc:	4770      	bx	lr
    28de:	bf00      	nop

000028e0 <chMtxLock>:
 *
 * @param[in] mp        pointer to the @p Mutex structure
 *
 * @api
 */
void chMtxLock(Mutex *mp) {
    28e0:	b500      	push	{lr}
    28e2:	b083      	sub	sp, #12
    28e4:	9001      	str	r0, [sp, #4]

  chSysLock();
    28e6:	f04f 0320 	mov.w	r3, #32
    28ea:	f383 8811 	msr	BASEPRI, r3

  chMtxLockS(mp);
    28ee:	9801      	ldr	r0, [sp, #4]
    28f0:	f000 f806 	bl	2900 <chMtxLockS>

  chSysUnlock();
    28f4:	f04f 0300 	mov.w	r3, #0
    28f8:	f383 8811 	msr	BASEPRI, r3
}
    28fc:	b003      	add	sp, #12
    28fe:	bd00      	pop	{pc}

00002900 <chMtxLockS>:
 *
 * @param[in] mp        pointer to the @p Mutex structure
 *
 * @sclass
 */
void chMtxLockS(Mutex *mp) {
    2900:	b500      	push	{lr}
    2902:	b085      	sub	sp, #20
    2904:	9001      	str	r0, [sp, #4]
  Thread *ctp = currp;
    2906:	f240 7308 	movw	r3, #1800	; 0x708
    290a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    290e:	699b      	ldr	r3, [r3, #24]
    2910:	9302      	str	r3, [sp, #8]

  chDbgCheckClassS();
  chDbgCheck(mp != NULL, "chMtxLockS");

  /* Is the mutex already locked? */
  if (mp->m_owner != NULL) {
    2912:	9b01      	ldr	r3, [sp, #4]
    2914:	689b      	ldr	r3, [r3, #8]
    2916:	2b00      	cmp	r3, #0
    2918:	d046      	beq.n	29a8 <chMtxLockS+0xa8>
    /* Priority inheritance protocol; explores the thread-mutex dependencies
       boosting the priority of all the affected threads to equal the priority
       of the running thread requesting the mutex.*/
    Thread *tp = mp->m_owner;
    291a:	9b01      	ldr	r3, [sp, #4]
    291c:	689b      	ldr	r3, [r3, #8]
    291e:	9303      	str	r3, [sp, #12]
    /* Does the running thread have higher priority than the mutex
       owning thread? */
    while (tp->p_prio < ctp->p_prio) {
    2920:	e02f      	b.n	2982 <chMtxLockS+0x82>
      /* Make priority of thread tp match the running thread's priority.*/
      tp->p_prio = ctp->p_prio;
    2922:	9b02      	ldr	r3, [sp, #8]
    2924:	689a      	ldr	r2, [r3, #8]
    2926:	9b03      	ldr	r3, [sp, #12]
    2928:	609a      	str	r2, [r3, #8]
      /* The following states need priority queues reordering.*/
      switch (tp->p_state) {
    292a:	9b03      	ldr	r3, [sp, #12]
    292c:	7f1b      	ldrb	r3, [r3, #28]
    292e:	2b04      	cmp	r3, #4
    2930:	d004      	beq.n	293c <chMtxLockS+0x3c>
    2932:	2b05      	cmp	r3, #5
    2934:	d011      	beq.n	295a <chMtxLockS+0x5a>
    2936:	2b00      	cmp	r3, #0
    2938:	d01a      	beq.n	2970 <chMtxLockS+0x70>
    293a:	e021      	b.n	2980 <chMtxLockS+0x80>
      case THD_STATE_WTMTX:
        /* Re-enqueues the mutex owner with its new priority.*/
        prio_insert(dequeue(tp), (ThreadsQueue *)tp->p_u.wtobjp);
    293c:	9803      	ldr	r0, [sp, #12]
    293e:	f7ff ffaf 	bl	28a0 <dequeue>
    2942:	4602      	mov	r2, r0
    2944:	9b03      	ldr	r3, [sp, #12]
    2946:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    2948:	4610      	mov	r0, r2
    294a:	4619      	mov	r1, r3
    294c:	f7ff ff68 	bl	2820 <prio_insert>
        tp = ((Mutex *)tp->p_u.wtobjp)->m_owner;
    2950:	9b03      	ldr	r3, [sp, #12]
    2952:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    2954:	689b      	ldr	r3, [r3, #8]
    2956:	9303      	str	r3, [sp, #12]
        continue;
    2958:	e013      	b.n	2982 <chMtxLockS+0x82>
#endif
#if CH_USE_MESSAGES && CH_USE_MESSAGES_PRIORITY
      case THD_STATE_SNDMSGQ:
#endif
        /* Re-enqueues tp with its new priority on the queue.*/
        prio_insert(dequeue(tp), (ThreadsQueue *)tp->p_u.wtobjp);
    295a:	9803      	ldr	r0, [sp, #12]
    295c:	f7ff ffa0 	bl	28a0 <dequeue>
    2960:	4602      	mov	r2, r0
    2962:	9b03      	ldr	r3, [sp, #12]
    2964:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    2966:	4610      	mov	r0, r2
    2968:	4619      	mov	r1, r3
    296a:	f7ff ff59 	bl	2820 <prio_insert>
        break;
    296e:	e007      	b.n	2980 <chMtxLockS+0x80>
#if CH_DBG_ENABLE_ASSERTS
        /* Prevents an assertion in chSchReadyI().*/
        tp->p_state = THD_STATE_CURRENT;
#endif
        /* Re-enqueues tp with its new priority on the ready list.*/
        chSchReadyI(dequeue(tp));
    2970:	9803      	ldr	r0, [sp, #12]
    2972:	f7ff ff95 	bl	28a0 <dequeue>
    2976:	4603      	mov	r3, r0
    2978:	4618      	mov	r0, r3
    297a:	f7fe fe79 	bl	1670 <chSchReadyI>
        break;
    297e:	bf00      	nop
      }
      break;
    2980:	e005      	b.n	298e <chMtxLockS+0x8e>
       boosting the priority of all the affected threads to equal the priority
       of the running thread requesting the mutex.*/
    Thread *tp = mp->m_owner;
    /* Does the running thread have higher priority than the mutex
       owning thread? */
    while (tp->p_prio < ctp->p_prio) {
    2982:	9b03      	ldr	r3, [sp, #12]
    2984:	689a      	ldr	r2, [r3, #8]
    2986:	9b02      	ldr	r3, [sp, #8]
    2988:	689b      	ldr	r3, [r3, #8]
    298a:	429a      	cmp	r2, r3
    298c:	d3c9      	bcc.n	2922 <chMtxLockS+0x22>
        break;
      }
      break;
    }
    /* Sleep on the mutex.*/
    prio_insert(ctp, &mp->m_queue);
    298e:	9b01      	ldr	r3, [sp, #4]
    2990:	9802      	ldr	r0, [sp, #8]
    2992:	4619      	mov	r1, r3
    2994:	f7ff ff44 	bl	2820 <prio_insert>
    ctp->p_u.wtobjp = mp;
    2998:	9b02      	ldr	r3, [sp, #8]
    299a:	9a01      	ldr	r2, [sp, #4]
    299c:	625a      	str	r2, [r3, #36]	; 0x24
    chSchGoSleepS(THD_STATE_WTMTX);
    299e:	f04f 0004 	mov.w	r0, #4
    29a2:	f7fe fe95 	bl	16d0 <chSchGoSleepS>
    29a6:	e009      	b.n	29bc <chMtxLockS+0xbc>
    chDbgAssert(mp->m_owner == ctp, "chMtxLockS(), #1", "not owner");
    chDbgAssert(ctp->p_mtxlist == mp, "chMtxLockS(), #2", "not owned");
  }
  else {
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->m_owner = ctp;
    29a8:	9b01      	ldr	r3, [sp, #4]
    29aa:	9a02      	ldr	r2, [sp, #8]
    29ac:	609a      	str	r2, [r3, #8]
    mp->m_next = ctp->p_mtxlist;
    29ae:	9b02      	ldr	r3, [sp, #8]
    29b0:	6bda      	ldr	r2, [r3, #60]	; 0x3c
    29b2:	9b01      	ldr	r3, [sp, #4]
    29b4:	60da      	str	r2, [r3, #12]
    ctp->p_mtxlist = mp;
    29b6:	9b02      	ldr	r3, [sp, #8]
    29b8:	9a01      	ldr	r2, [sp, #4]
    29ba:	63da      	str	r2, [r3, #60]	; 0x3c
  }
}
    29bc:	b005      	add	sp, #20
    29be:	bd00      	pop	{pc}

000029c0 <chMtxTryLock>:
 * @retval TRUE         if the mutex has been successfully acquired
 * @retval FALSE        if the lock attempt failed.
 *
 * @api
 */
bool_t chMtxTryLock(Mutex *mp) {
    29c0:	b500      	push	{lr}
    29c2:	b085      	sub	sp, #20
    29c4:	9001      	str	r0, [sp, #4]
  bool_t b;

  chSysLock();
    29c6:	f04f 0320 	mov.w	r3, #32
    29ca:	f383 8811 	msr	BASEPRI, r3

  b = chMtxTryLockS(mp);
    29ce:	9801      	ldr	r0, [sp, #4]
    29d0:	f000 f80e 	bl	29f0 <chMtxTryLockS>
    29d4:	9003      	str	r0, [sp, #12]

  chSysUnlock();
    29d6:	f04f 0300 	mov.w	r3, #0
    29da:	f383 8811 	msr	BASEPRI, r3
  return b;
    29de:	9b03      	ldr	r3, [sp, #12]
}
    29e0:	4618      	mov	r0, r3
    29e2:	b005      	add	sp, #20
    29e4:	bd00      	pop	{pc}
    29e6:	bf00      	nop
    29e8:	f3af 8000 	nop.w
    29ec:	f3af 8000 	nop.w

000029f0 <chMtxTryLockS>:
 * @retval TRUE         if the mutex has been successfully acquired
 * @retval FALSE        if the lock attempt failed.
 *
 * @sclass
 */
bool_t chMtxTryLockS(Mutex *mp) {
    29f0:	b082      	sub	sp, #8
    29f2:	9001      	str	r0, [sp, #4]

  chDbgCheckClassS();
  chDbgCheck(mp != NULL, "chMtxTryLockS");

  if (mp->m_owner != NULL)
    29f4:	9b01      	ldr	r3, [sp, #4]
    29f6:	689b      	ldr	r3, [r3, #8]
    29f8:	2b00      	cmp	r3, #0
    29fa:	d002      	beq.n	2a02 <chMtxTryLockS+0x12>
    return FALSE;
    29fc:	f04f 0300 	mov.w	r3, #0
    2a00:	e017      	b.n	2a32 <chMtxTryLockS+0x42>
  mp->m_owner = currp;
    2a02:	f240 7308 	movw	r3, #1800	; 0x708
    2a06:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2a0a:	699a      	ldr	r2, [r3, #24]
    2a0c:	9b01      	ldr	r3, [sp, #4]
    2a0e:	609a      	str	r2, [r3, #8]
  mp->m_next = currp->p_mtxlist;
    2a10:	f240 7308 	movw	r3, #1800	; 0x708
    2a14:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2a18:	699b      	ldr	r3, [r3, #24]
    2a1a:	6bda      	ldr	r2, [r3, #60]	; 0x3c
    2a1c:	9b01      	ldr	r3, [sp, #4]
    2a1e:	60da      	str	r2, [r3, #12]
  currp->p_mtxlist = mp;
    2a20:	f240 7308 	movw	r3, #1800	; 0x708
    2a24:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2a28:	699b      	ldr	r3, [r3, #24]
    2a2a:	9a01      	ldr	r2, [sp, #4]
    2a2c:	63da      	str	r2, [r3, #60]	; 0x3c
  return TRUE;
    2a2e:	f04f 0301 	mov.w	r3, #1
}
    2a32:	4618      	mov	r0, r3
    2a34:	b002      	add	sp, #8
    2a36:	4770      	bx	lr
    2a38:	f3af 8000 	nop.w
    2a3c:	f3af 8000 	nop.w

00002a40 <chMtxUnlock>:
 *
 * @return              A pointer to the unlocked mutex.
 *
 * @api
 */
Mutex *chMtxUnlock(void) {
    2a40:	b500      	push	{lr}
    2a42:	b087      	sub	sp, #28
  Thread *ctp = currp;
    2a44:	f240 7308 	movw	r3, #1800	; 0x708
    2a48:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2a4c:	699b      	ldr	r3, [r3, #24]
    2a4e:	9303      	str	r3, [sp, #12]
  Mutex *ump, *mp;

  chSysLock();
    2a50:	f04f 0320 	mov.w	r3, #32
    2a54:	f383 8811 	msr	BASEPRI, r3
  chDbgAssert(ctp->p_mtxlist->m_owner == ctp,
              "chMtxUnlock(), #2",
              "ownership failure");
  /* Removes the top Mutex from the Thread's owned mutexes list and marks it
     as not owned.*/
  ump = ctp->p_mtxlist;
    2a58:	9b03      	ldr	r3, [sp, #12]
    2a5a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    2a5c:	9302      	str	r3, [sp, #8]
  ctp->p_mtxlist = ump->m_next;
    2a5e:	9b02      	ldr	r3, [sp, #8]
    2a60:	68da      	ldr	r2, [r3, #12]
    2a62:	9b03      	ldr	r3, [sp, #12]
    2a64:	63da      	str	r2, [r3, #60]	; 0x3c
  /* If a thread is waiting on the mutex then the fun part begins.*/
  if (chMtxQueueNotEmptyS(ump)) {
    2a66:	9b02      	ldr	r3, [sp, #8]
    2a68:	681a      	ldr	r2, [r3, #0]
    2a6a:	9b02      	ldr	r3, [sp, #8]
    2a6c:	429a      	cmp	r2, r3
    2a6e:	d033      	beq.n	2ad8 <chMtxUnlock+0x98>
    Thread *tp;

    /* Recalculates the optimal thread priority by scanning the owned
       mutexes list.*/
    tprio_t newprio = ctp->p_realprio;
    2a70:	9b03      	ldr	r3, [sp, #12]
    2a72:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    2a74:	9304      	str	r3, [sp, #16]
    mp = ctp->p_mtxlist;
    2a76:	9b03      	ldr	r3, [sp, #12]
    2a78:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    2a7a:	9305      	str	r3, [sp, #20]
    while (mp != NULL) {
    2a7c:	e011      	b.n	2aa2 <chMtxUnlock+0x62>
      /* If the highest priority thread waiting in the mutexes list has a
         greater priority than the current thread base priority then the final
         priority will have at least that priority.*/
      if (chMtxQueueNotEmptyS(mp) && (mp->m_queue.p_next->p_prio > newprio))
    2a7e:	9b05      	ldr	r3, [sp, #20]
    2a80:	681a      	ldr	r2, [r3, #0]
    2a82:	9b05      	ldr	r3, [sp, #20]
    2a84:	429a      	cmp	r2, r3
    2a86:	d009      	beq.n	2a9c <chMtxUnlock+0x5c>
    2a88:	9b05      	ldr	r3, [sp, #20]
    2a8a:	681b      	ldr	r3, [r3, #0]
    2a8c:	689a      	ldr	r2, [r3, #8]
    2a8e:	9b04      	ldr	r3, [sp, #16]
    2a90:	429a      	cmp	r2, r3
    2a92:	d903      	bls.n	2a9c <chMtxUnlock+0x5c>
        newprio = mp->m_queue.p_next->p_prio;
    2a94:	9b05      	ldr	r3, [sp, #20]
    2a96:	681b      	ldr	r3, [r3, #0]
    2a98:	689b      	ldr	r3, [r3, #8]
    2a9a:	9304      	str	r3, [sp, #16]
      mp = mp->m_next;
    2a9c:	9b05      	ldr	r3, [sp, #20]
    2a9e:	68db      	ldr	r3, [r3, #12]
    2aa0:	9305      	str	r3, [sp, #20]

    /* Recalculates the optimal thread priority by scanning the owned
       mutexes list.*/
    tprio_t newprio = ctp->p_realprio;
    mp = ctp->p_mtxlist;
    while (mp != NULL) {
    2aa2:	9b05      	ldr	r3, [sp, #20]
    2aa4:	2b00      	cmp	r3, #0
    2aa6:	d1ea      	bne.n	2a7e <chMtxUnlock+0x3e>
        newprio = mp->m_queue.p_next->p_prio;
      mp = mp->m_next;
    }
    /* Assigns to the current thread the highest priority among all the
       waiting threads.*/
    ctp->p_prio = newprio;
    2aa8:	9b03      	ldr	r3, [sp, #12]
    2aaa:	9a04      	ldr	r2, [sp, #16]
    2aac:	609a      	str	r2, [r3, #8]
    /* Awakens the highest priority thread waiting for the unlocked mutex and
       assigns the mutex to it.*/
    tp = fifo_remove(&ump->m_queue);
    2aae:	9b02      	ldr	r3, [sp, #8]
    2ab0:	4618      	mov	r0, r3
    2ab2:	f7ff fedd 	bl	2870 <fifo_remove>
    2ab6:	9001      	str	r0, [sp, #4]
    ump->m_owner = tp;
    2ab8:	9b02      	ldr	r3, [sp, #8]
    2aba:	9a01      	ldr	r2, [sp, #4]
    2abc:	609a      	str	r2, [r3, #8]
    ump->m_next = tp->p_mtxlist;
    2abe:	9b01      	ldr	r3, [sp, #4]
    2ac0:	6bda      	ldr	r2, [r3, #60]	; 0x3c
    2ac2:	9b02      	ldr	r3, [sp, #8]
    2ac4:	60da      	str	r2, [r3, #12]
    tp->p_mtxlist = ump;
    2ac6:	9b01      	ldr	r3, [sp, #4]
    2ac8:	9a02      	ldr	r2, [sp, #8]
    2aca:	63da      	str	r2, [r3, #60]	; 0x3c
    chSchWakeupS(tp, RDY_OK);
    2acc:	9801      	ldr	r0, [sp, #4]
    2ace:	f04f 0100 	mov.w	r1, #0
    2ad2:	f7fe feb5 	bl	1840 <chSchWakeupS>
    2ad6:	e003      	b.n	2ae0 <chMtxUnlock+0xa0>
  }
  else
    ump->m_owner = NULL;
    2ad8:	9b02      	ldr	r3, [sp, #8]
    2ada:	f04f 0200 	mov.w	r2, #0
    2ade:	609a      	str	r2, [r3, #8]
  chSysUnlock();
    2ae0:	f04f 0300 	mov.w	r3, #0
    2ae4:	f383 8811 	msr	BASEPRI, r3
  return ump;
    2ae8:	9b02      	ldr	r3, [sp, #8]
}
    2aea:	4618      	mov	r0, r3
    2aec:	b007      	add	sp, #28
    2aee:	bd00      	pop	{pc}

00002af0 <chMtxUnlockS>:
 *
 * @return              A pointer to the unlocked mutex.
 *
 * @sclass
 */
Mutex *chMtxUnlockS(void) {
    2af0:	b500      	push	{lr}
    2af2:	b087      	sub	sp, #28
  Thread *ctp = currp;
    2af4:	f240 7308 	movw	r3, #1800	; 0x708
    2af8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2afc:	699b      	ldr	r3, [r3, #24]
    2afe:	9303      	str	r3, [sp, #12]
              "chMtxUnlockS(), #2",
              "ownership failure");

  /* Removes the top Mutex from the owned mutexes list and marks it as not
     owned.*/
  ump = ctp->p_mtxlist;
    2b00:	9b03      	ldr	r3, [sp, #12]
    2b02:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    2b04:	9302      	str	r3, [sp, #8]
  ctp->p_mtxlist = ump->m_next;
    2b06:	9b02      	ldr	r3, [sp, #8]
    2b08:	68da      	ldr	r2, [r3, #12]
    2b0a:	9b03      	ldr	r3, [sp, #12]
    2b0c:	63da      	str	r2, [r3, #60]	; 0x3c
  /* If a thread is waiting on the mutex then the fun part begins.*/
  if (chMtxQueueNotEmptyS(ump)) {
    2b0e:	9b02      	ldr	r3, [sp, #8]
    2b10:	681a      	ldr	r2, [r3, #0]
    2b12:	9b02      	ldr	r3, [sp, #8]
    2b14:	429a      	cmp	r2, r3
    2b16:	d031      	beq.n	2b7c <chMtxUnlockS+0x8c>
    Thread *tp;

    /* Recalculates the optimal thread priority by scanning the owned
       mutexes list.*/
    tprio_t newprio = ctp->p_realprio;
    2b18:	9b03      	ldr	r3, [sp, #12]
    2b1a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    2b1c:	9304      	str	r3, [sp, #16]
    mp = ctp->p_mtxlist;
    2b1e:	9b03      	ldr	r3, [sp, #12]
    2b20:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    2b22:	9305      	str	r3, [sp, #20]
    while (mp != NULL) {
    2b24:	e011      	b.n	2b4a <chMtxUnlockS+0x5a>
      /* If the highest priority thread waiting in the mutexes list has a
         greater priority than the current thread base priority then the final
         priority will have at least that priority.*/
      if (chMtxQueueNotEmptyS(mp) && (mp->m_queue.p_next->p_prio > newprio))
    2b26:	9b05      	ldr	r3, [sp, #20]
    2b28:	681a      	ldr	r2, [r3, #0]
    2b2a:	9b05      	ldr	r3, [sp, #20]
    2b2c:	429a      	cmp	r2, r3
    2b2e:	d009      	beq.n	2b44 <chMtxUnlockS+0x54>
    2b30:	9b05      	ldr	r3, [sp, #20]
    2b32:	681b      	ldr	r3, [r3, #0]
    2b34:	689a      	ldr	r2, [r3, #8]
    2b36:	9b04      	ldr	r3, [sp, #16]
    2b38:	429a      	cmp	r2, r3
    2b3a:	d903      	bls.n	2b44 <chMtxUnlockS+0x54>
        newprio = mp->m_queue.p_next->p_prio;
    2b3c:	9b05      	ldr	r3, [sp, #20]
    2b3e:	681b      	ldr	r3, [r3, #0]
    2b40:	689b      	ldr	r3, [r3, #8]
    2b42:	9304      	str	r3, [sp, #16]
      mp = mp->m_next;
    2b44:	9b05      	ldr	r3, [sp, #20]
    2b46:	68db      	ldr	r3, [r3, #12]
    2b48:	9305      	str	r3, [sp, #20]

    /* Recalculates the optimal thread priority by scanning the owned
       mutexes list.*/
    tprio_t newprio = ctp->p_realprio;
    mp = ctp->p_mtxlist;
    while (mp != NULL) {
    2b4a:	9b05      	ldr	r3, [sp, #20]
    2b4c:	2b00      	cmp	r3, #0
    2b4e:	d1ea      	bne.n	2b26 <chMtxUnlockS+0x36>
         priority will have at least that priority.*/
      if (chMtxQueueNotEmptyS(mp) && (mp->m_queue.p_next->p_prio > newprio))
        newprio = mp->m_queue.p_next->p_prio;
      mp = mp->m_next;
    }
    ctp->p_prio = newprio;
    2b50:	9b03      	ldr	r3, [sp, #12]
    2b52:	9a04      	ldr	r2, [sp, #16]
    2b54:	609a      	str	r2, [r3, #8]
    /* Awakens the highest priority thread waiting for the unlocked mutex and
       assigns the mutex to it.*/
    tp = fifo_remove(&ump->m_queue);
    2b56:	9b02      	ldr	r3, [sp, #8]
    2b58:	4618      	mov	r0, r3
    2b5a:	f7ff fe89 	bl	2870 <fifo_remove>
    2b5e:	9001      	str	r0, [sp, #4]
    ump->m_owner = tp;
    2b60:	9b02      	ldr	r3, [sp, #8]
    2b62:	9a01      	ldr	r2, [sp, #4]
    2b64:	609a      	str	r2, [r3, #8]
    ump->m_next = tp->p_mtxlist;
    2b66:	9b01      	ldr	r3, [sp, #4]
    2b68:	6bda      	ldr	r2, [r3, #60]	; 0x3c
    2b6a:	9b02      	ldr	r3, [sp, #8]
    2b6c:	60da      	str	r2, [r3, #12]
    tp->p_mtxlist = ump;
    2b6e:	9b01      	ldr	r3, [sp, #4]
    2b70:	9a02      	ldr	r2, [sp, #8]
    2b72:	63da      	str	r2, [r3, #60]	; 0x3c
    chSchReadyI(tp);
    2b74:	9801      	ldr	r0, [sp, #4]
    2b76:	f7fe fd7b 	bl	1670 <chSchReadyI>
    2b7a:	e003      	b.n	2b84 <chMtxUnlockS+0x94>
  }
  else
    ump->m_owner = NULL;
    2b7c:	9b02      	ldr	r3, [sp, #8]
    2b7e:	f04f 0200 	mov.w	r2, #0
    2b82:	609a      	str	r2, [r3, #8]
  return ump;
    2b84:	9b02      	ldr	r3, [sp, #8]
}
    2b86:	4618      	mov	r0, r3
    2b88:	b007      	add	sp, #28
    2b8a:	bd00      	pop	{pc}
    2b8c:	f3af 8000 	nop.w

00002b90 <chMtxUnlockAll>:
 *          this function does not have any overhead related to the priority
 *          inheritance mechanism.
 *
 * @api
 */
void chMtxUnlockAll(void) {
    2b90:	b500      	push	{lr}
    2b92:	b085      	sub	sp, #20
  Thread *ctp = currp;
    2b94:	f240 7308 	movw	r3, #1800	; 0x708
    2b98:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2b9c:	699b      	ldr	r3, [r3, #24]
    2b9e:	9303      	str	r3, [sp, #12]

  chSysLock();
    2ba0:	f04f 0320 	mov.w	r3, #32
    2ba4:	f383 8811 	msr	BASEPRI, r3
  if (ctp->p_mtxlist != NULL) {
    2ba8:	9b03      	ldr	r3, [sp, #12]
    2baa:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    2bac:	2b00      	cmp	r3, #0
    2bae:	d02c      	beq.n	2c0a <chMtxUnlockAll+0x7a>
    do {
      Mutex *ump = ctp->p_mtxlist;
    2bb0:	9b03      	ldr	r3, [sp, #12]
    2bb2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    2bb4:	9302      	str	r3, [sp, #8]
      ctp->p_mtxlist = ump->m_next;
    2bb6:	9b02      	ldr	r3, [sp, #8]
    2bb8:	68da      	ldr	r2, [r3, #12]
    2bba:	9b03      	ldr	r3, [sp, #12]
    2bbc:	63da      	str	r2, [r3, #60]	; 0x3c
      if (chMtxQueueNotEmptyS(ump)) {
    2bbe:	9b02      	ldr	r3, [sp, #8]
    2bc0:	681a      	ldr	r2, [r3, #0]
    2bc2:	9b02      	ldr	r3, [sp, #8]
    2bc4:	429a      	cmp	r2, r3
    2bc6:	d012      	beq.n	2bee <chMtxUnlockAll+0x5e>
        Thread *tp = fifo_remove(&ump->m_queue);
    2bc8:	9b02      	ldr	r3, [sp, #8]
    2bca:	4618      	mov	r0, r3
    2bcc:	f7ff fe50 	bl	2870 <fifo_remove>
    2bd0:	9001      	str	r0, [sp, #4]
        ump->m_owner = tp;
    2bd2:	9b02      	ldr	r3, [sp, #8]
    2bd4:	9a01      	ldr	r2, [sp, #4]
    2bd6:	609a      	str	r2, [r3, #8]
        ump->m_next = tp->p_mtxlist;
    2bd8:	9b01      	ldr	r3, [sp, #4]
    2bda:	6bda      	ldr	r2, [r3, #60]	; 0x3c
    2bdc:	9b02      	ldr	r3, [sp, #8]
    2bde:	60da      	str	r2, [r3, #12]
        tp->p_mtxlist = ump;
    2be0:	9b01      	ldr	r3, [sp, #4]
    2be2:	9a02      	ldr	r2, [sp, #8]
    2be4:	63da      	str	r2, [r3, #60]	; 0x3c
        chSchReadyI(tp);
    2be6:	9801      	ldr	r0, [sp, #4]
    2be8:	f7fe fd42 	bl	1670 <chSchReadyI>
    2bec:	e003      	b.n	2bf6 <chMtxUnlockAll+0x66>
      }
      else
        ump->m_owner = NULL;
    2bee:	9b02      	ldr	r3, [sp, #8]
    2bf0:	f04f 0200 	mov.w	r2, #0
    2bf4:	609a      	str	r2, [r3, #8]
    } while (ctp->p_mtxlist != NULL);
    2bf6:	9b03      	ldr	r3, [sp, #12]
    2bf8:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    2bfa:	2b00      	cmp	r3, #0
    2bfc:	d1d8      	bne.n	2bb0 <chMtxUnlockAll+0x20>
    ctp->p_prio = ctp->p_realprio;
    2bfe:	9b03      	ldr	r3, [sp, #12]
    2c00:	6c1a      	ldr	r2, [r3, #64]	; 0x40
    2c02:	9b03      	ldr	r3, [sp, #12]
    2c04:	609a      	str	r2, [r3, #8]
    chSchRescheduleS();
    2c06:	f7fe fe4b 	bl	18a0 <chSchRescheduleS>
  }
  chSysUnlock();
    2c0a:	f04f 0300 	mov.w	r3, #0
    2c0e:	f383 8811 	msr	BASEPRI, r3
}
    2c12:	b005      	add	sp, #20
    2c14:	bd00      	pop	{pc}
    2c16:	bf00      	nop
    2c18:	f3af 8000 	nop.w
    2c1c:	f3af 8000 	nop.w

00002c20 <.LC0>:
    2c20:	702f2e2e 	eorvc	r2, pc, lr, lsr #28
    2c24:	65736168 	ldrbvs	r6, [r3, #-360]!	; 0xfffffe98
    2c28:	6d655f32 	stclvs	15, cr5, [r5, #-200]!	; 0xffffff38
    2c2c:	64646562 	strbtvs	r6, [r4], #-1378	; 0xfffffa9e
    2c30:	635f6465 	cmpvs	pc, #1694498816	; 0x65000000
    2c34:	6970672f 	ldmdbvs	r0!, {r0, r1, r2, r3, r5, r8, r9, sl, sp, lr}^
    2c38:	00632e6f 	rsbeq	r2, r3, pc, ror #28

00002c3c <.LC0>:
    2c3c:	702f2e2e 	eorvc	r2, pc, lr, lsr #28
    2c40:	65736168 	ldrbvs	r6, [r3, #-360]!	; 0xfffffe98
    2c44:	6d655f32 	stclvs	15, cr5, [r5, #-200]!	; 0xffffff38
    2c48:	64646562 	strbtvs	r6, [r4], #-1378	; 0xfffffa9e
    2c4c:	635f6465 	cmpvs	pc, #1694498816	; 0x65000000
    2c50:	6f6c632f 	svcvs	0x006c632f
    2c54:	2e736b63 	vsubcs.f64	d22, d3, d19
    2c58:	00000063 	andeq	r0, r0, r3, rrx

00002c5c <jumpTable.7294>:
    2c5c:	00000000 	andeq	r0, r0, r0
    2c60:	00000a29 	andeq	r0, r0, r9, lsr #20
    2c64:	00000a3d 	andeq	r0, r0, sp, lsr sl
    2c68:	00000c09 	andeq	r0, r0, r9, lsl #24
    2c6c:	00000c1d 	andeq	r0, r0, sp, lsl ip
    2c70:	00000c31 	andeq	r0, r0, r1, lsr ip
    2c74:	00000000 	andeq	r0, r0, r0
    2c78:	00000c45 	andeq	r0, r0, r5, asr #24
    2c7c:	00000c59 	andeq	r0, r0, r9, asr ip
    2c80:	00000c6d 	andeq	r0, r0, sp, ror #24
    2c84:	00000c81 	andeq	r0, r0, r1, lsl #25
    2c88:	00000d61 	andeq	r0, r0, r1, ror #26
    2c8c:	00000000 	andeq	r0, r0, r0
    2c90:	00000d75 	andeq	r0, r0, r5, ror sp
    2c94:	00000d89 	andeq	r0, r0, r9, lsl #27
    2c98:	00000d9d 	muleq	r0, sp, sp
    2c9c:	00000db1 			; <UNDEFINED> instruction: 0x00000db1
    2ca0:	00000dc5 	andeq	r0, r0, r5, asr #27
    2ca4:	00000000 	andeq	r0, r0, r0
    2ca8:	00000dd9 	ldrdeq	r0, [r0], -r9
    2cac:	00000ded 	andeq	r0, r0, sp, ror #27
    2cb0:	00000e01 	andeq	r0, r0, r1, lsl #28
    2cb4:	00000e15 	andeq	r0, r0, r5, lsl lr
    2cb8:	00000e29 	andeq	r0, r0, r9, lsr #28
    2cbc:	00000000 	andeq	r0, r0, r0

00002cc0 <.LC0>:
    2cc0:	702f2e2e 	eorvc	r2, pc, lr, lsr #28
    2cc4:	65736168 	ldrbvs	r6, [r3, #-360]!	; 0xfffffe98
    2cc8:	6d655f32 	stclvs	15, cr5, [r5, #-200]!	; 0xffffff38
    2ccc:	64646562 	strbtvs	r6, [r4], #-1378	; 0xfffffa9e
    2cd0:	635f6465 	cmpvs	pc, #1694498816	; 0x65000000
    2cd4:	7461772f 	strbtvc	r7, [r1], #-1839	; 0xfffff8d1
    2cd8:	6f446863 	svcvs	0x00446863
    2cdc:	00632e67 	rsbeq	r2, r3, r7, ror #28

00002ce0 <.LC0>:
    2ce0:	656c6469 	strbvs	r6, [ip, #-1129]!	; 0xfffffb97
    2ce4:	00000000 	andeq	r0, r0, r0

00002ce8 <.LC1>:
    2ce8:	6e69616d 	powvsez	f6, f1, #5.0
    2cec:	00000000 	andeq	r0, r0, r0

Disassembly of section .ramvect:

20000000 <_vector_ram_start>:
	...

Disassembly of section .data:

20000400 <_data_start>:
20000400:	40064000 	andmi	r4, r6, r0
20000404:	40065000 	andmi	r5, r6, r0
20000408:	4003d000 	andmi	sp, r3, r0

2000040c <clockConfigParam>:
2000040c:	001a1802 	andseq	r1, sl, r2, lsl #16
20000410:	05f5e100 	ldrbeq	lr, [r5, #256]!	; 0x100
20000414:	00001802 	andeq	r1, r0, r2, lsl #16
20000418:	02dc6c00 	sbcseq	r6, ip, #0, 24
2000041c:	01800000 	orreq	r0, r0, r0
20000420:	016e0000 	cmneq	lr, r0

20000424 <clockFreq>:
20000424:	01388000 	teqeq	r8, r0
20000428:	01010000 	mrseq	r0, (UNDEF: 1)

2000042c <wdPtr>:
2000042c:	40052000 	andmi	r2, r5, r0

Disassembly of section .bss:

20000430 <_bss_start>:
	...

200005e8 <mcgState>:
	...

200005f0 <_idle_thread_wa>:
	...

200006b0 <mainthread.4648>:
	...

200006f8 <vtlist>:
	...

20000708 <rlist>:
	...

20000724 <nextmem>:
20000724:	00000000 	andeq	r0, r0, r0

20000728 <endmem>:
	...

20000730 <default_heap>:
	...

Disassembly of section .ARM.attributes:

00000000 <.ARM.attributes>:
   0:	00002e41 	andeq	r2, r0, r1, asr #28
   4:	61656100 	cmnvs	r5, r0, lsl #2
   8:	01006962 	tsteq	r0, r2, ror #18
   c:	00000024 	andeq	r0, r0, r4, lsr #32
  10:	726f4305 	rsbvc	r4, pc, #335544320	; 0x14000000
  14:	2d786574 	cfldr64cs	mvdx6, [r8, #-464]!	; 0xfffffe30
  18:	0600344d 	streq	r3, [r0], -sp, asr #8
  1c:	094d070d 	stmdbeq	sp, {r0, r2, r3, r8, r9, sl}^
  20:	14041202 	strne	r1, [r4], #-514	; 0xfffffdfe
  24:	17011501 	strne	r1, [r1, -r1, lsl #10]
  28:	1a011803 	bne	4603c <_flash_swap_addr+0x683c>
  2c:	Address 0x0000002c is out of bounds.


Disassembly of section .comment:

00000000 <.comment>:
   0:	3a434347 	bcc	10d0d24 <_flash_swap_addr+0x1091524>
   4:	6f532820 	svcvs	0x00532820
   8:	65637275 	strbvs	r7, [r3, #-629]!	; 0xfffffd8b
   c:	43207972 	teqmi	r0, #1867776	; 0x1c8000
  10:	4265646f 	rsbmi	r6, r5, #1862270976	; 0x6f000000
  14:	68636e65 	stmdavs	r3!, {r0, r2, r5, r6, r9, sl, fp, sp, lr}^
  18:	74694c20 	strbtvc	r4, [r9], #-3104	; 0xfffff3e0
  1c:	30322065 	eorscc	r2, r2, r5, rrx
  20:	302e3131 	eorcc	r3, lr, r1, lsr r1
  24:	39362d39 	ldmdbcc	r6!, {r0, r3, r4, r5, r8, sl, fp, sp}
  28:	2e342029 	cdpcs	0, 3, cr2, cr4, cr9, {1}
  2c:	00312e36 	eorseq	r2, r1, r6, lsr lr

Disassembly of section .debug_line:

00000000 <.debug_line>:
       0:	000000c1 	andeq	r0, r0, r1, asr #1
       4:	00220002 	eoreq	r0, r2, r2
       8:	01020000 	mrseq	r0, (UNDEF: 2)
       c:	000d0efb 	strdeq	r0, [sp], -fp
      10:	01010101 	tsteq	r1, r1, lsl #2
      14:	01000000 	mrseq	r0, (UNDEF: 0)
      18:	00010000 	andeq	r0, r1, r0
      1c:	72617473 	rsbvc	r7, r1, #1929379840	; 0x73000000
      20:	646f6374 	strbtvs	r6, [pc], #-884	; 28 <_vector_rom+0x28>
      24:	00732e65 	rsbseq	r2, r3, r5, ror #28
      28:	00000000 	andeq	r0, r0, r0
      2c:	10020500 	andne	r0, r2, r0, lsl #10
      30:	03000004 	movweq	r0, #4
      34:	210103ff 	strdcs	r0, [r1, -pc]
      38:	23212121 	teqcs	r1, #1073741832	; 0x40000008
      3c:	13032121 	movwne	r2, #12577	; 0x3121
      40:	26212120 	strtcs	r2, [r1], -r0, lsr #2
      44:	2f213421 	svccs	0x00213421
      48:	212e0a03 	teqcs	lr, r3, lsl #20
      4c:	30212221 	eorcc	r2, r1, r1, lsr #4
      50:	2f2f2121 	svccs	0x002f2121
      54:	23212136 	teqcs	r1, #-2147483635	; 0x8000000d
      58:	2f2f2121 	svccs	0x002f2121
      5c:	22212134 	eorcs	r2, r1, #52, 2
      60:	2f2f2121 	svccs	0x002f2121
      64:	03212134 	teqeq	r1, #52, 2
      68:	21212016 	teqcs	r1, r6, lsl r0
      6c:	2f212123 	svccs	0x00212123
      70:	2121342f 	teqcs	r1, pc, lsr #8
      74:	2f212123 	svccs	0x00212123
      78:	21232134 	teqcs	r3, r4, lsr r1
      7c:	0d032f21 	stceq	15, cr2, [r3, #-132]	; 0xffffff7c
      80:	2321212e 	teqcs	r1, #-2147483637	; 0x8000000b
      84:	312f2121 	teqcc	pc, r1, lsr #2
      88:	3c220335 	stccc	3, cr0, [r2], #-212	; 0xffffff2c
      8c:	90033434 	andls	r3, r3, r4, lsr r4
      90:	302f2e7e 	eorcc	r2, pc, lr, ror lr	; <UNPREDICTABLE>
      94:	14032f32 	strne	r2, [r3], #-3890	; 0xfffff0ce
      98:	0335362e 	teqeq	r5, #48234496	; 0x2e00000
      9c:	2f2f2e0c 	svccs	0x002f2e0c
      a0:	2f2e1103 	svccs	0x002e1103
      a4:	2e0d032f 	cdpcs	3, 0, cr0, cr13, cr15, {1}
      a8:	0c032f2f 	stceq	15, cr2, [r3], {47}	; 0x2f
      ac:	2e18032e 	cdpcs	3, 1, cr0, cr8, cr14, {1}
      b0:	0d032f2f 	stceq	15, cr2, [r3, #-188]	; 0xffffff44
      b4:	032f2f2e 	teqeq	pc, #46, 30	; 0xb8
      b8:	032f2e0c 	teqeq	pc, #12, 28	; 0xc0
      bc:	2f2f2e13 	svccs	0x002f2e13
      c0:	01000202 	tsteq	r0, r2, lsl #4
      c4:	00016301 	andeq	r6, r1, r1, lsl #6
      c8:	19000200 	stmdbne	r0, {r9}
      cc:	02000001 	andeq	r0, r0, #1
      d0:	0d0efb01 	vstreq	d15, [lr, #-4]
      d4:	01010100 	mrseq	r0, (UNDEF: 17)
      d8:	00000001 	andeq	r0, r0, r1
      dc:	01000001 	tsteq	r0, r1
      e0:	74706f2f 	ldrbtvc	r6, [r0], #-3887	; 0xfffff0d1
      e4:	646f432f 	strbtvs	r4, [pc], #-815	; ec <_vector_rom+0xec>
      e8:	756f5365 	strbvc	r5, [pc, #-869]!	; fffffd8b <_stack_start+0xdffefd8b>
      ec:	72656372 	rsbvc	r6, r5, #-939524095	; 0xc8000001
      f0:	6f532f79 	svcvs	0x00532f79
      f4:	65637275 	strbvs	r7, [r3, #-629]!	; 0xfffffd8b
      f8:	435f7972 	cmpmi	pc, #1867776	; 0x1c8000
      fc:	4265646f 	rsbmi	r6, r5, #1862270976	; 0x6f000000
     100:	68636e65 	stmdavs	r3!, {r0, r2, r5, r6, r9, sl, fp, sp, lr}^
     104:	74694c5f 	strbtvc	r4, [r9], #-3167	; 0xfffff3a1
     108:	6f665f65 	svcvs	0x00665f65
     10c:	52415f72 	subpl	r5, r1, #456	; 0x1c8
     110:	41455f4d 	cmpmi	r5, sp, asr #30
     114:	622f4942 	eorvs	r4, pc, #1081344	; 0x108000
     118:	2e2f6e69 	cdpcs	14, 2, cr6, cr15, cr9, {3}
     11c:	696c2f2e 	stmdbvs	ip!, {r1, r2, r3, r5, r8, r9, sl, fp, sp}^
     120:	63672f62 	cmnvs	r7, #392	; 0x188
     124:	72612f63 	rsbvc	r2, r1, #396	; 0x18c
     128:	6f6e2d6d 	svcvs	0x006e2d6d
     12c:	652d656e 	strvs	r6, [sp, #-1390]!	; 0xfffffa92
     130:	2f696261 	svccs	0x00696261
     134:	2e362e34 	mrccs	14, 1, r2, cr6, cr4, {1}
     138:	2e2e2f31 	mcrcs	15, 1, r2, cr14, cr1, {1}
     13c:	2f2e2e2f 	svccs	0x002e2e2f
     140:	2e2f2e2e 	cdpcs	14, 2, cr2, cr15, cr14, {1}
     144:	72612f2e 	rsbvc	r2, r1, #46, 30	; 0xb8
     148:	6f6e2d6d 	svcvs	0x006e2d6d
     14c:	652d656e 	strvs	r6, [sp, #-1390]!	; 0xfffffa92
     150:	2f696261 	svccs	0x00696261
     154:	6c636e69 	stclvs	14, cr6, [r3], #-420	; 0xfffffe5c
     158:	00656475 	rsbeq	r6, r5, r5, ror r4
     15c:	2e2f2e2e 	cdpcs	14, 2, cr2, cr15, cr14, {1}
     160:	68432f2e 	stmdavs	r3, {r1, r2, r3, r5, r8, r9, sl, fp, sp}^
     164:	4f696269 	svcmi	0x00696269
     168:	736f2f53 	cmnvc	pc, #332	; 0x14c
     16c:	726f702f 	rsbvc	r7, pc, #47	; 0x2f
     170:	472f7374 			; <UNDEFINED> instruction: 0x472f7374
     174:	412f4343 	teqmi	pc, r3, asr #6
     178:	4d434d52 	stclmi	13, cr4, [r3, #-328]	; 0xfffffeb8
     17c:	2e2e0078 	mcrcs	0, 1, r0, cr14, cr8, {3}
     180:	6168702f 	cmnvs	r8, pc, lsr #32
     184:	5f326573 	svcpl	0x00326573
     188:	65626d65 	strbvs	r6, [r2, #-3429]!	; 0xfffff29b
     18c:	64656464 	strbtvs	r6, [r5], #-1124	; 0xfffffb9c
     190:	0000635f 	andeq	r6, r0, pc, asr r3
     194:	6f6d6564 	svcvs	0x006d6564
     198:	62696843 	rsbvs	r6, r9, #4390912	; 0x430000
     19c:	00632e69 	rsbeq	r2, r3, r9, ror #28
     1a0:	73000000 	movwvc	r0, #0
     1a4:	6e696474 	mcrvs	4, 3, r6, cr9, cr4, {3}
     1a8:	00682e74 	rsbeq	r2, r8, r4, ror lr
     1ac:	63000001 	movwvs	r0, #1
     1b0:	70797468 	rsbsvc	r7, r9, r8, ror #8
     1b4:	682e7365 	stmdavs	lr!, {r0, r2, r5, r6, r8, r9, ip, sp, lr}
     1b8:	00000200 	andeq	r0, r0, r0, lsl #4
     1bc:	6f636863 	svcvs	0x00636863
     1c0:	765f6572 			; <UNDEFINED> instruction: 0x765f6572
     1c4:	682e6d37 	stmdavs	lr!, {r0, r1, r2, r4, r5, r8, sl, fp, sp, lr}
     1c8:	00000200 	andeq	r0, r0, r0, lsl #4
     1cc:	656e696b 	strbvs	r6, [lr, #-2411]!	; 0xfffff695
     1d0:	2e736974 	mrccs	9, 3, r6, cr3, cr4, {3}
     1d4:	00030068 	andeq	r0, r3, r8, rrx
     1d8:	72616800 	rsbvc	r6, r1, #0, 16
     1dc:	72617764 	rsbvc	r7, r1, #100, 14	; 0x1900000
     1e0:	00682e65 	rsbeq	r2, r8, r5, ror #28
     1e4:	00000003 	andeq	r0, r0, r3
     1e8:	60020500 	andvs	r0, r2, r0, lsl #10
     1ec:	03000005 	movweq	r0, #5
     1f0:	5b58010a 	blpl	1600620 <_flash_swap_addr+0x15c0e20>
     1f4:	01040200 	mrseq	r0, R12_usr
     1f8:	0402004c 	streq	r0, [r2], #-76	; 0xffffffb4
     1fc:	02004b01 	andeq	r4, r0, #1024	; 0x400
     200:	34830104 	strcc	r0, [r3], #260	; 0x104
     204:	9f2e0c03 	svcls	0x002e0c03
     208:	5a3d314b 	bpl	f4c73c <_flash_swap_addr+0xf0cf3c>
     20c:	4d7775f3 	cfldr64mi	mvdx7, [r7, #-972]!	; 0xfffffc34
     210:	302f2f3d 	eorcc	r2, pc, sp, lsr pc	; <UNPREDICTABLE>
     214:	1408a09f 	strne	sl, [r8], #-159	; 0xffffff61
     218:	01040200 	mrseq	r0, R12_usr
     21c:	04020023 	streq	r0, [r2], #-35	; 0xffffffdd
     220:	02004b01 	andeq	r4, r0, #1024	; 0x400
     224:	02830104 	addeq	r0, r3, #4, 2
     228:	01010001 	tsteq	r1, r1
     22c:	000000c7 	andeq	r0, r0, r7, asr #1
     230:	005d0002 	subseq	r0, sp, r2
     234:	01020000 	mrseq	r0, (UNDEF: 2)
     238:	000d0efb 	strdeq	r0, [sp], -fp
     23c:	01010101 	tsteq	r1, r1, lsl #2
     240:	01000000 	mrseq	r0, (UNDEF: 0)
     244:	2e010000 	cdpcs	0, 0, cr0, cr1, cr0, {0}
     248:	68702f2e 	ldmdavs	r0!, {r1, r2, r3, r5, r8, r9, sl, fp, sp}^
     24c:	32657361 	rsbcc	r7, r5, #-2080374783	; 0x84000001
     250:	626d655f 	rsbvs	r6, sp, #398458880	; 0x17c00000
     254:	65646465 	strbvs	r6, [r4, #-1125]!	; 0xfffffb9b
     258:	00635f64 	rsbeq	r5, r3, r4, ror #30
     25c:	69706700 	ldmdbvs	r0!, {r8, r9, sl, sp, lr}^
     260:	00632e6f 	rsbeq	r2, r3, pc, ror #28
     264:	6b000001 	blvs	270 <_vector_rom+0x270>
     268:	74656e69 	strbtvc	r6, [r5], #-3689	; 0xfffff197
     26c:	682e7369 	stmdavs	lr!, {r0, r3, r5, r6, r8, r9, ip, sp, lr}
     270:	00000100 	andeq	r0, r0, r0, lsl #2
     274:	626f6c67 	rsbvs	r6, pc, #26368	; 0x6700
     278:	65446c61 	strbvs	r6, [r4, #-3169]	; 0xfffff39f
     27c:	682e7366 	stmdavs	lr!, {r1, r2, r5, r6, r8, r9, ip, sp, lr}
     280:	00000100 	andeq	r0, r0, r0, lsl #2
     284:	64726168 	ldrbtvs	r6, [r2], #-360	; 0xfffffe98
     288:	65726177 	ldrbvs	r6, [r2, #-375]!	; 0xfffffe89
     28c:	0100682e 	tsteq	r0, lr, lsr #16
     290:	00000000 	andeq	r0, r0, r0
     294:	06880205 	streq	r0, [r8], r5, lsl #4
     298:	23030000 	movwcs	r0, #12288	; 0x3000
     29c:	27024d01 	strcs	r4, [r2, -r1, lsl #26]
     2a0:	67676713 			; <UNDEFINED> instruction: 0x67676713
     2a4:	3f836867 	svccc	0x00836867
     2a8:	580d0321 	stmdapl	sp, {r0, r5, r8, r9}
     2ac:	0402006b 	streq	r0, [r2], #-107	; 0xffffff95
     2b0:	063c0601 	ldrteq	r0, [ip], -r1, lsl #12
     2b4:	13270288 	teqne	r7, #136, 4	; 0x80000008
     2b8:	c9c9c9c9 	stmibgt	r9, {r0, r3, r6, r7, r8, fp, lr, pc}^
     2bc:	3e2783ca 	cdpcc	3, 2, cr8, cr7, cr10, {6}
     2c0:	595a5959 	ldmdbpl	sl, {r0, r3, r4, r6, r8, fp, ip, lr}^
     2c4:	5b59675b 	blpl	165a038 <_flash_swap_addr+0x161a838>
     2c8:	59592383 	ldmdbpl	r9, {r0, r1, r7, r8, r9, sp}^
     2cc:	4b7a4c59 	blmi	1e93438 <_flash_swap_addr+0x1e53c38>
     2d0:	59675968 	stmdbpl	r7!, {r3, r5, r6, r8, fp, ip, lr}^
     2d4:	5e685975 	mcrpl	9, 3, r5, cr8, cr5, {3}
     2d8:	5e834b59 	mcrpl	11, 4, r4, cr3, cr9, {2}
     2dc:	5e834b59 	mcrpl	11, 4, r4, cr3, cr9, {2}
     2e0:	03834b59 	orreq	r4, r3, #91136	; 0x16400
     2e4:	0367580c 	cmneq	r7, #12, 16	; 0xc0000
     2e8:	2f4b660c 	svccs	0x004b660c
     2ec:	59660c03 	stmdbpl	r6!, {r0, r1, sl, fp}^
     2f0:	0502bb4b 	streq	fp, [r2, #-2891]	; 0xfffff4b5
     2f4:	70010100 	andvc	r0, r1, r0, lsl #2
     2f8:	02000001 	andeq	r0, r0, #1
     2fc:	00005f00 	andeq	r5, r0, r0, lsl #30
     300:	fb010200 	blx	40b0a <_flash_swap_addr+0x130a>
     304:	01000d0e 	tsteq	r0, lr, lsl #26
     308:	00010101 	andeq	r0, r1, r1, lsl #2
     30c:	00010000 	andeq	r0, r1, r0
     310:	2e2e0100 	sufcse	f0, f6, f0
     314:	6168702f 	cmnvs	r8, pc, lsr #32
     318:	5f326573 	svcpl	0x00326573
     31c:	65626d65 	strbvs	r6, [r2, #-3429]!	; 0xfffff29b
     320:	64656464 	strbtvs	r6, [r5], #-1124	; 0xfffffb9c
     324:	0000635f 	andeq	r6, r0, pc, asr r3
     328:	636f6c63 	cmnvs	pc, #25344	; 0x6300
     32c:	632e736b 	teqvs	lr, #-1409286143	; 0xac000001
     330:	00000100 	andeq	r0, r0, r0, lsl #2
     334:	626f6c67 	rsbvs	r6, pc, #26368	; 0x6700
     338:	65446c61 	strbvs	r6, [r4, #-3169]	; 0xfffff39f
     33c:	682e7366 	stmdavs	lr!, {r1, r2, r5, r6, r8, r9, ip, sp, lr}
     340:	00000100 	andeq	r0, r0, r0, lsl #2
     344:	656e696b 	strbvs	r6, [lr, #-2411]!	; 0xfffff695
     348:	2e736974 	mrccs	9, 3, r6, cr3, cr4, {3}
     34c:	00010068 	andeq	r0, r1, r8, rrx
     350:	72616800 	rsbvc	r6, r1, #0, 16
     354:	72617764 	rsbvc	r7, r1, #100, 14	; 0x1900000
     358:	00682e65 	rsbeq	r2, r8, r5, ror #28
     35c:	00000001 	andeq	r0, r0, r1
     360:	28020500 	stmdacs	r2, {r8, sl}
     364:	0300000a 	movweq	r0, #10
     368:	0301019a 	movweq	r0, #4506	; 0x119a
     36c:	5b5b580e 	blpl	16d63ac <_flash_swap_addr+0x1696bac>
     370:	820f03c2 	andhi	r0, pc, #134217731	; 0x8000003
     374:	04020088 	streq	r0, [r2], #-136	; 0xffffff78
     378:	06200601 	strteq	r0, [r0], -r1, lsl #12
     37c:	040200ae 	streq	r0, [r2], #-174	; 0xffffff52
     380:	06200601 	strteq	r0, [r0], -r1, lsl #12
     384:	040200ae 	streq	r0, [r2], #-174	; 0xffffff52
     388:	06200601 	strteq	r0, [r0], -r1, lsl #12
     38c:	7508f3af 	strvc	pc, [r8, #-943]	; 0xfffffc51
     390:	f67708f3 			; <UNDEFINED> instruction: 0xf67708f3
     394:	01040200 	mrseq	r0, R12_usr
     398:	ae062006 	cdpge	0, 0, cr2, cr6, cr6, {0}
     39c:	01040200 	mrseq	r0, R12_usr
     3a0:	b0062006 	andlt	r2, r6, r6
     3a4:	040200f6 	streq	r0, [r2], #-246	; 0xffffff0a
     3a8:	06200601 	strteq	r0, [r0], -r1, lsl #12
     3ac:	5a6975ae 	bpl	1a5da6c <_flash_swap_addr+0x1a1e26c>
     3b0:	5a5c5a5b 	bpl	1716d24 <_flash_swap_addr+0x16d7524>
     3b4:	5a5b5a5b 	bpl	16d6d28 <_flash_swap_addr+0x1697528>
     3b8:	5b5c5a5b 	blpl	1716d2c <_flash_swap_addr+0x16d752c>
     3bc:	04020085 	streq	r0, [r2], #-133	; 0xffffff7b
     3c0:	06200601 	strteq	r0, [r0], -r1, lsl #12
     3c4:	0200f6b2 	andeq	pc, r0, #186646528	; 0xb200000
     3c8:	20060104 	andcs	r0, r6, r4, lsl #2
     3cc:	87e7af06 	strbhi	sl, [r7, r6, lsl #30]!
     3d0:	01040200 	mrseq	r0, R12_usr
     3d4:	ae062006 	cdpge	0, 0, cr2, cr6, cr6, {0}
     3d8:	01040200 	mrseq	r0, R12_usr
     3dc:	ae062006 	cdpge	0, 0, cr2, cr6, cr6, {0}
     3e0:	5b5a5b75 	blpl	16971bc <_flash_swap_addr+0x16579bc>
     3e4:	5c5a5b5a 	mrrcpl	11, 5, r5, sl, cr10
     3e8:	5b5a5b5a 	blpl	1697158 <_flash_swap_addr+0x1657958>
     3ec:	5c5a5b5a 	mrrcpl	11, 5, r5, sl, cr10
     3f0:	5b5a5b5a 	blpl	1697160 <_flash_swap_addr+0x1657960>
     3f4:	035a5b5a 	cmpeq	sl, #92160	; 0x16800
     3f8:	6c75580c 	ldclvs	8, cr5, [r5], #-48	; 0xffffffd0
     3fc:	01040200 	mrseq	r0, R12_usr
     400:	8406ba06 	strhi	fp, [r6], #-2566	; 0xfffff5fa
     404:	02040200 	andeq	r0, r4, #0, 4
     408:	0200ba06 	andeq	fp, r0, #24576	; 0x6000
     40c:	06d60104 	ldrbeq	r0, [r6], r4, lsl #2
    .thumb_func

_default_reset_handler:

unlock_watchdog:
    ldr r6, =0x4005200e
     410:	04020085 	streq	r0, [r2], #-133	; 0xffffff7b
    ldr r0, =0xc520
    strh r0, [r6]
     414:	00ba0602 	adcseq	r0, sl, r2, lsl #12
    ldr r0, =0xd928
    strh r0, [r6]
     418:	d6010402 	strle	r0, [r1], -r2, lsl #8

disable_watchdog:
    ldr r6, =0x40052000
    ldr r0, =0x01d2
     41c:	02008506 	andeq	r8, r0, #25165824	; 0x1800000
     * address 0x00000000 (which is the first element in the vector_table) by
     * the hardware. The next three lines are required in case this image
     * is not located at 0x0 (i.e. it is being launched from a bootloader).
     */

    ldr r1, =_vector_table
     420:	d6060104 	strle	r0, [r6], -r4, lsl #2
    ldr r2, [r1]
    mov	sp,r2
     424:	67678506 	strbvs	r8, [r7, -r6, lsl #10]!
chibi_setup:
    /*
     * ChibiOS requires a process stack to be initialized.
     */
    ldr r1, =_process_stack_start
    msr PSP, r1
     428:	3b756967 	blcc	1d5a9cc <_flash_swap_addr+0x1d1b1cc>

    /* TODO: FPU register initialization per crt0.c */
    /*
     * Set up system to run in privileged mode using the PSP stack
     */
    ldr r1, =0x00000002
     42c:	3b223b22 	blcc	88f0bc <_flash_swap_addr+0x84f8bc>
    msr CONTROL, r1
     430:	0a03241e 	beq	c94b0 <_flash_swap_addr+0x89cb0>
    isb
     434:	14085b58 	strne	r5, [r8], #-2904	; 0xfffff4a8
     * address and the start address are not the same. This code supports
     * running an entire image out of SRAM.
     */

    ldr r0, =_text_start
    ldr r1, =_text_end
     438:	22e522e5 	rsccs	r2, r5, #1342177294	; 0x5000000e
    ldr r2, =_text_load

    cmp r0, r2
     43c:	22e522e5 	rsccs	r2, r5, #1342177294	; 0x5000000e
    beq end_text_loop
     440:	1d032185 	stfnes	f2, [r3, #-532]	; 0xfffffdec
text_loop:
    cmp r0, r1
    ittt    lt
     444:	580e0358 	stmdapl	lr, {r3, r4, r6, r8, r9}
    ldrlt   r3, [r2], #4
     448:	01040200 	mrseq	r0, R12_usr
    strlt   r3, [r0], #4
     44c:	84063c06 	strhi	r3, [r6], #-3078	; 0xfffff3fa
    blt     text_loop
     450:	d79308bc 			; <UNDEFINED> instruction: 0xd79308bc
    /*
     * Relocate the .ramcode section from FLASH to SRAM.
     */

    ldr r0, =_ramcode_start
    ldr r1, =_ramcode_end
     454:	30503050 	subscc	r3, r0, r0, asr r0
    ldr r2, =_ramcode_load

ramcode_loop:
    cmp r0, r1
     458:	30503050 	subscc	r3, r0, r0, asr r0
    ittt    lt
    ldrlt   r3, [r2], #4
     45c:	30503050 	subscc	r3, r0, r0, asr r0
    strlt   r3, [r0], #4
     460:	30503050 	subscc	r3, r0, r0, asr r0
    blt     ramcode_loop
     464:	03023050 	movweq	r3, #8272	; 0x2050

    /*
     * Relocate vector table to SRAM.
     */

     ldr r0, =_vector_ram_start
     468:	97010100 	strls	r0, [r1, -r0, lsl #2]
     ldr r1, =_vector_ram_end
     ldr r2, =_vector_rom
     46c:	02000000 	andeq	r0, r0, #0
vector_loop:
    cmp r0, r1
    ittt    lt
     470:	00005300 	andeq	r5, r0, r0, lsl #6
    ldrlt   r3, [r2], #4
     474:	fb010200 	blx	40c7e <_flash_swap_addr+0x147e>
    strlt   r3, [r0], #4
     478:	01000d0e 	tsteq	r0, lr, lsl #26
    blt     vector_loop
     47c:	00010101 	andeq	r0, r1, r1, lsl #2
    /*
     * Point to the SRAM vector table.
     */

    ldr r1,=0xe000ed08
    ldr r0,=_vector_ram_start
     480:	00010000 	andeq	r0, r1, r0
     * Note: _data_start contains the SRAM (destination) address and
     *       _text_end contains the (source) address of the .data section
     *       in FLASH.
     */

    ldr r0, =_data_start
     484:	2e2e0100 	sufcse	f0, f6, f0
    ldr r1, =_data_end
    ldr r2, =_data_load
     488:	6168702f 	cmnvs	r8, pc, lsr #32

data_loop:
    cmp r0, r1
    ittt    lt
     48c:	5f326573 	svcpl	0x00326573
    ldrlt   r3, [r2], #4
     490:	65626d65 	strbvs	r6, [r2, #-3429]!	; 0xfffff29b
    strlt   r3, [r0], #4
     494:	64656464 	strbtvs	r6, [r5], #-1124	; 0xfffffb9c
    blt     data_loop
     498:	0000635f 	andeq	r6, r0, pc, asr r3
    /*
     * Zero out the .bss section in SRAM.
     */

    ldr r0, =_bss_start
    ldr r1, =_bss_end
     49c:	63746177 	cmnvs	r4, #-1073741795	; 0xc000001d
    ldr r2, =0x00000000

bss_loop:
    cmp r0, r1
     4a0:	676f4468 	strbvs	r4, [pc, -r8, ror #8]!
    itt     lt
    strlt   r2, [r0], #4
     4a4:	0100632e 	tsteq	r0, lr, lsr #6
    blt     bss_loop
     4a8:	6c670000 	stclvs	0, cr0, [r7], #-0

    /*
     * Zero out heap.
     */

    ldr r0, =_heap_start
     4ac:	6c61626f 	sfmvs	f6, 2, [r1], #-444	; 0xfffffe44
    ldr r1, =_heap_end

heap_loop:
    cmp r0, r1
     4b0:	73666544 	cmnvc	r6, #68, 10	; 0x11000000
    itt     lt
    strlt   r2, [r0], #4
     4b4:	0100682e 	tsteq	r0, lr, lsr #16
    blt     heap_loop
     4b8:	696b0000 	stmdbvs	fp!, {}^	; <UNPREDICTABLE>
    ldr r0, =_stack_start
    ldr r1, =_stack_end
    ldr r2, =0xefefefef
*/

    ldr r0, =_stack_end
     4bc:	6974656e 	ldmdbvs	r4!, {r1, r2, r3, r5, r6, r8, sl, sp, lr}^
    ldr r1, =_stack_start
    ldr r2, =0xefefefef
     4c0:	00682e73 	rsbeq	r2, r8, r3, ror lr

stack_loop:
    cmp r0, r1
    itt     lt
     4c4:	00000001 	andeq	r0, r0, r1
    strlt   r2, [r0], #4
     4c8:	58020500 	stmdapl	r2, {r8, sl}
    blt     stack_loop
     4cc:	03000011 	movweq	r0, #17

call_user_asm_code:
    bl main
     4d0:	030100d1 	movweq	r0, #4305	; 0x10d1
    /*
     * Epilogue processing would go here.
     */

end_loop:
    b end_loop
     4d4:	85832e0f 	strhi	r2, [r3, #3599]	; 0xe0f

    .align 2
    .thumb_func

_default_nmi_handler:
    b _default_nmi_handler
     4d8:	17034b50 	smlsdne	r3, r0, fp, r4

    .align 2
    .thumb_func

_default_fault_handler:
    b _default_fault_handler
     4dc:	0402002e 	streq	r0, [r2], #-46	; 0xffffffd2

    .align 2
    .thumb_func

_default_irq_handler:
    b _default_irq_handler
     4e0:	06660601 	strbteq	r0, [r6], -r1, lsl #12
    .thumb_func

_default_reset_handler:

unlock_watchdog:
    ldr r6, =0x4005200e
     4e4:	83ad9184 			; <UNDEFINED> instruction: 0x83ad9184
    ldr r0, =0xc520
     4e8:	09039183 	stmdbeq	r3, {r0, r1, r7, r8, ip, pc}
    strh r0, [r6]
    ldr r0, =0xd928
     4ec:	262f4eac 	strtcs	r4, [pc], -ip, lsr #29
    strh r0, [r6]

disable_watchdog:
    ldr r6, =0x40052000
     4f0:	42262f3e 	eormi	r2, r6, #62, 30	; 0xf8
    ldr r0, =0x01d2
     4f4:	2f2e0f03 	svccs	0x002e0f03
     * address 0x00000000 (which is the first element in the vector_table) by
     * the hardware. The next three lines are required in case this image
     * is not located at 0x0 (i.e. it is being launched from a bootloader).
     */

    ldr r1, =_vector_table
     4f8:	34308383 	ldrtcc	r8, [r0], #-899	; 0xfffffc7d

chibi_setup:
    /*
     * ChibiOS requires a process stack to be initialized.
     */
    ldr r1, =_process_stack_start
     4fc:	2e0c032f 	cdpcs	3, 0, cr0, cr12, cr15, {1}

    /* TODO: FPU register initialization per crt0.c */
    /*
     * Set up system to run in privileged mode using the PSP stack
     */
    ldr r1, =0x00000002
     500:	00010285 	andeq	r0, r1, r5, lsl #5
     * Relocate the .text section from FLASH to SRAM only if the load
     * address and the start address are not the same. This code supports
     * running an entire image out of SRAM.
     */

    ldr r0, =_text_start
     504:	01c60101 	biceq	r0, r6, r1, lsl #2
    ldr r1, =_text_end
     508:	00020000 	andeq	r0, r2, r0
    ldr r2, =_text_load
     50c:	00000166 	andeq	r0, r0, r6, ror #2

    /*
     * Relocate the .ramcode section from FLASH to SRAM.
     */

    ldr r0, =_ramcode_start
     510:	0efb0102 	cdpeq	1, 15, cr0, cr11, cr2, {0}
    ldr r1, =_ramcode_end
     514:	0101000d 	tsteq	r1, sp
    ldr r2, =_ramcode_load
     518:	00000101 	andeq	r0, r0, r1, lsl #2

    /*
     * Relocate vector table to SRAM.
     */

     ldr r0, =_vector_ram_start
     51c:	00000100 	andeq	r0, r0, r0, lsl #2
     ldr r1, =_vector_ram_end
     520:	2f2e2e01 	svccs	0x002e2e01
     ldr r2, =_vector_rom
     524:	432f2e2e 	teqmi	pc, #736	; 0x2e0

    /*
     * Point to the SRAM vector table.
     */

    ldr r1,=0xe000ed08
     528:	69626968 	stmdbvs	r2!, {r3, r5, r6, r8, fp, sp, lr}^
     * Note: _data_start contains the SRAM (destination) address and
     *       _text_end contains the (source) address of the .data section
     *       in FLASH.
     */

    ldr r0, =_data_start
     52c:	6f2f534f 	svcvs	0x002f534f
    ldr r1, =_data_end
     530:	656b2f73 	strbvs	r2, [fp, #-3955]!	; 0xfffff08d
    ldr r2, =_data_load
     534:	6c656e72 	stclvs	14, cr6, [r5], #-456	; 0xfffffe38

    /*
     * Zero out the .bss section in SRAM.
     */

    ldr r0, =_bss_start
     538:	6372732f 	cmnvs	r2, #-1140850688	; 0xbc000000
    ldr r1, =_bss_end
     53c:	706f2f00 	rsbvc	r2, pc, r0, lsl #30
    ldr r2, =0x00000000
     540:	6f432f74 	svcvs	0x00432f74

    /*
     * Zero out heap.
     */

    ldr r0, =_heap_start
     544:	6f536564 	svcvs	0x00536564
    ldr r1, =_heap_end
     548:	65637275 	strbvs	r7, [r3, #-629]!	; 0xfffffd8b
    ldr r0, =_stack_start
    ldr r1, =_stack_end
    ldr r2, =0xefefefef
*/

    ldr r0, =_stack_end
     54c:	532f7972 	teqpl	pc, #1867776	; 0x1c8000
    ldr r1, =_stack_start
     550:	6372756f 	cmnvs	r2, #465567744	; 0x1bc00000
    ldr r2, =0xefefefef
     554:	5f797265 	svcpl	0x00797265
     558:	65646f43 	strbvs	r6, [r4, #-3907]!	; 0xfffff0bd
     55c:	636e6542 	cmnvs	lr, #276824064	; 0x10800000
#define TSI_ORANGE_BIT    BIT_5

#define TSI_YELLOW_INDEX  8
#define TSI_YELLOW_BIT    BIT_8

void assert_(const char *file, const int line) { }
     560:	694c5f68 	stmdbvs	ip, {r3, r5, r6, r8, r9, sl, fp, ip, lr}^
     564:	665f6574 			; <UNDEFINED> instruction: 0x665f6574
     568:	415f726f 	cmpmi	pc, pc, ror #4
     56c:	455f4d52 	ldrbmi	r4, [pc, #-3410]	; fffff822 <_stack_start+0xdffef822>
     570:	2f494241 	svccs	0x00494241

static WORKING_AREA(waThread1, 128);
static msg_t Thread1(void *arg) {
     574:	2f6e6962 	svccs	0x006e6962
     578:	6c2f2e2e 	stcvs	14, cr2, [pc], #-184	; 4c8 <stack_loop+0x6>
    while (TRUE) {
        chThdSleepMilliseconds(500);
     57c:	672f6269 	strvs	r6, [pc, -r9, ror #4]!
     580:	612f6363 	teqvs	pc, r3, ror #6
        gpioToggle(N_LED_YELLOW_PORT, N_LED_YELLOW_PIN);
     584:	6e2d6d72 	mcrvs	13, 1, r6, cr13, cr2, {3}
     588:	2d656e6f 	stclcs	14, cr6, [r5, #-444]!	; 0xfffffe44
     58c:	69626165 	stmdbvs	r2!, {r0, r2, r5, r6, r8, sp, lr}^
     590:	362e342f 	strtcc	r3, [lr], -pc, lsr #8
    }
     594:	2e2f312e 	sufcsep	f3, f7, #0.5

    return 0;
}

static void clocksInit(void)
{
     598:	2e2e2f2e 	cdpcs	15, 2, cr2, cr14, cr14, {1}
     * System:  100 MHz
     * Bus:      50 MHz
     * Flexbus:  50 MHz
     * Flash:    25 MHz
     */
    clockSetDividers(DIVIDE_BY_1, DIVIDE_BY_2, DIVIDE_BY_4, DIVIDE_BY_4);
     59c:	2f2e2e2f 	svccs	0x002e2e2f
     5a0:	612f2e2e 	teqvs	pc, lr, lsr #28
     5a4:	6e2d6d72 	mcrvs	13, 1, r6, cr13, cr2, {3}
     5a8:	2d656e6f 	stclcs	14, cr6, [r5, #-444]!	; 0xfffffe44
     5ac:	69626165 	stmdbvs	r2!, {r0, r2, r5, r6, r8, sp, lr}^
    clockConfigMcgOut(MCG_PLL_EXTERNAL_100MHZ);
     5b0:	636e692f 	cmnvs	lr, #770048	; 0xbc000
     5b4:	6564756c 	strbvs	r7, [r4, #-1388]!	; 0xfffffa94
}
     5b8:	2f2e2e00 	svccs	0x002e2e00

static void systickInit(void)
{
     5bc:	432f2e2e 	teqmi	pc, #736	; 0x2e0
     5c0:	69626968 	stmdbvs	r2!, {r3, r5, r6, r8, fp, sp, lr}^
    uint32_t freq = clockGetFreq(CLOCK_CORE);
     5c4:	6f2f534f 	svcvs	0x002f534f
     5c8:	6f702f73 	svcvs	0x00702f73

    NVIC_SYSTICK_RELOAD = freq / CH_FREQUENCY - 1;
     5cc:	2f737472 	svccs	0x00737472
     5d0:	2f434347 	svccs	0x00434347
     5d4:	434d5241 	movtmi	r5, #53825	; 0xd241
     5d8:	2e00784d 	cdpcs	8, 0, cr7, cr0, cr13, {2}
     5dc:	2e2e2f2e 	cdpcs	15, 2, cr2, cr14, cr14, {1}
     5e0:	6968432f 	stmdbvs	r8!, {r0, r1, r2, r3, r5, r8, r9, lr}^
     5e4:	534f6962 	movtpl	r6, #63842	; 0xf962
     5e8:	2f736f2f 	svccs	0x00736f2f
    NVIC_SYSTICK_VALUE = 0;
     5ec:	6e72656b 	cdpvs	5, 7, cr6, cr2, cr11, {3}
     5f0:	692f6c65 	stmdbvs	pc!, {r0, r2, r5, r6, sl, fp, sp, lr}	; <UNPREDICTABLE>
     5f4:	756c636e 	strbvc	r6, [ip, #-878]!	; 0xfffffc92
     5f8:	00006564 	andeq	r6, r0, r4, ror #10
    NVIC_SYSTICK_CONTROL = NVIC_SYSTICK_CONTROL_ENABLE
     5fc:	79736863 	ldmdbvc	r3!, {r0, r1, r5, r6, fp, sp, lr}^
     600:	00632e73 	rsbeq	r2, r3, r3, ror lr
     604:	73000001 	movwvc	r0, #1
                         | NVIC_SYSTICK_CONTROL_TICKINT
                         | NVIC_SYSTICK_CONTROL_CLKSOURCE;
}
     608:	6e696474 	mcrvs	4, 3, r6, cr9, cr4, {3}
     60c:	00682e74 	rsbeq	r2, r8, r4, ror lr

int main(void)
{
     610:	63000002 	movwvs	r0, #2
     614:	70797468 	rsbsvc	r7, r9, r8, ror #8
    clocksInit();
     618:	682e7365 	stmdavs	lr!, {r0, r2, r5, r6, r8, r9, ip, sp, lr}
    systickInit();
     61c:	00000300 	andeq	r0, r0, r0, lsl #6
    chSysInit();
     620:	696c6863 	stmdbvs	ip!, {r0, r1, r5, r6, fp, sp, lr}^

    gpioConfig(N_LED_ORANGE_PORT, N_LED_ORANGE_PIN, GPIO_OUTPUT | GPIO_LOW);
     624:	2e737473 	mrccs	4, 3, r7, cr3, cr3, {3}
     628:	00040068 	andeq	r0, r4, r8, rrx
     62c:	74686300 	strbtvc	r6, [r8], #-768	; 0xfffffd00
     630:	61657268 	cmnvs	r5, r8, ror #4
     634:	682e7364 	stmdavs	lr!, {r2, r5, r6, r8, r9, ip, sp, lr}
    gpioConfig(N_LED_YELLOW_PORT, N_LED_YELLOW_PIN, GPIO_OUTPUT | GPIO_LOW);
     638:	00000400 	andeq	r0, r0, r0, lsl #8
     63c:	6f636863 	svcvs	0x00636863
     640:	765f6572 			; <UNDEFINED> instruction: 0x765f6572
     644:	682e6d37 	stmdavs	lr!, {r0, r1, r2, r4, r5, r8, sl, fp, sp, lr}
     648:	00000300 	andeq	r0, r0, r0, lsl #6

    chThdCreateStatic(waThread1, sizeof(waThread1), NORMALPRIO, Thread1, NULL);
     64c:	74766863 	ldrbtvc	r6, [r6], #-2147	; 0xfffff79d
     650:	0400682e 	streq	r6, [r0], #-2094	; 0xfffff7d2
     654:	68630000 	stmdavs	r3!, {}^	; <UNPREDICTABLE>
     658:	64686373 	strbtvs	r6, [r8], #-883	; 0xfffffc8d
     65c:	0400682e 	streq	r6, [r0], #-2094	; 0xfffff7d2
     660:	68630000 	stmdavs	r3!, {}^	; <UNPREDICTABLE>
     664:	2e78746d 	cdpcs	4, 7, cr7, cr8, cr13, {3}
     668:	00040068 	andeq	r0, r4, r8, rrx

    hwInterruptsEnable();
     66c:	2e686300 	cdpcs	3, 6, cr6, cr8, cr0, {0}

    while (TRUE) {
        chThdSleepMilliseconds(123);
     670:	00040068 	andeq	r0, r4, r8, rrx
     674:	05000000 	streq	r0, [r0, #-0]
        gpioToggle(N_LED_ORANGE_PORT, N_LED_ORANGE_PIN);
     678:	00129002 	andseq	r9, r2, r2
     67c:	01350300 	teqeq	r5, r0, lsl #6
     680:	04020031 	streq	r0, [r2], #-49	; 0xffffffcf
     684:	0102a201 	tsteq	r2, r1, lsl #4
*
* RETURNS: The corresponding GPIO_BASE_ADDR.
*
*******************************************************************************/
static volatile gpioPort_t *gpioPortGet(uint32_t port)
{
     688:	00010100 	andeq	r0, r1, r0, lsl #2
     68c:	12b00205 	adcsne	r0, r0, #1342177280	; 0x50000000
    uint32_t addr;

    switch (port) {
     690:	cc030000 	stcgt	0, cr0, [r3], {-0}
     694:	2f340100 	svccs	0x00340100
     698:	3531302f 	ldrcc	r3, [r1, #-47]!	; 0xffffffd1
     69c:	a45a88d7 	ldrbge	r8, [sl], #-2263	; 0xfffff729
     6a0:	02021508 	andeq	r1, r2, #8, 10	; 0x2000000
     6a4:	00010100 	andeq	r0, r1, r0, lsl #2
     6a8:	13400205 	movtne	r0, #517	; 0x205
     6ac:	ff030000 			; <UNDEFINED> instruction: 0xff030000
     6b0:	84340100 	ldrthi	r0, [r4], #-256	; 0xffffff00
     6b4:	020092a1 	andeq	r9, r0, #268435466	; 0x1000000a
     6b8:	08060104 	stmdaeq	r6, {r2, r8}
     6bc:	04020066 	streq	r0, [r2], #-102	; 0xffffff9a
     6c0:	02009e03 	andeq	r9, r0, #3, 28	; 0x30
     6c4:	22020204 	andcs	r0, r2, #4, 4	; 0x40000000
     6c8:	02a20612 	adceq	r0, r2, #18874368	; 0x1200000
     6cc:	01010002 	tsteq	r1, r2
     6d0:	000001b3 			; <UNDEFINED> instruction: 0x000001b3
     6d4:	011a0002 	tsteq	sl, r2
     6d8:	01020000 	mrseq	r0, (UNDEF: 2)
     6dc:	000d0efb 	strdeq	r0, [sp], -fp
    case PORTA: addr = GPIOA_BASE_ADDR; break;
     6e0:	01010101 	tsteq	r1, r1, lsl #2
     6e4:	01000000 	mrseq	r0, (UNDEF: 0)
     6e8:	2e010000 	cdpcs	0, 0, cr0, cr1, cr0, {0}
    case PORTB: addr = GPIOB_BASE_ADDR; break;
     6ec:	2e2e2f2e 	cdpcs	15, 2, cr2, cr14, cr14, {1}
     6f0:	6968432f 	stmdbvs	r8!, {r0, r1, r2, r3, r5, r8, r9, lr}^
     6f4:	534f6962 	movtpl	r6, #63842	; 0xf962
    case PORTC: addr = GPIOC_BASE_ADDR; break;
     6f8:	2f736f2f 	svccs	0x00736f2f
     6fc:	6e72656b 	cdpvs	5, 7, cr6, cr2, cr11, {3}
     700:	732f6c65 	teqvc	pc, #25856	; 0x6500
    case PORTD: addr = GPIOD_BASE_ADDR; break;
     704:	2f006372 	svccs	0x00006372
     708:	2f74706f 	svccs	0x0074706f
     70c:	65646f43 	strbvs	r6, [r4, #-3907]!	; 0xfffff0bd
    case PORTE: addr = GPIOE_BASE_ADDR; break;
     710:	72756f53 	rsbsvc	r6, r5, #332	; 0x14c
     714:	79726563 	ldmdbvc	r2!, {r0, r1, r5, r6, r8, sl, sp, lr}^
     718:	756f532f 	strbvc	r5, [pc, #-815]!	; 3f1 <_vector_rom+0x3f1>
    default:
        assert(0);
     71c:	72656372 	rsbvc	r6, r5, #-939524095	; 0xc8000001
     720:	6f435f79 	svcvs	0x00435f79
     724:	65426564 	strbvs	r6, [r2, #-1380]	; 0xfffffa9c
     728:	5f68636e 	svcpl	0x0068636e
        return 0;
     72c:	6574694c 	ldrbvs	r6, [r4, #-2380]!	; 0xfffff6b4
    }

    return ((volatile gpioPort_t *) addr);
     730:	726f665f 	rsbvc	r6, pc, #99614720	; 0x5f00000
}
     734:	4d52415f 	ldfmie	f4, [r2, #-380]	; 0xfffffe84
     738:	4241455f 	submi	r4, r1, #398458880	; 0x17c00000
*
* RETURNS: Nothing
*
*******************************************************************************/
void gpioConfig(uint32_t port, uint32_t pin, uint32_t opt)
{
     73c:	69622f49 	stmdbvs	r2!, {r0, r3, r6, r8, r9, sl, fp, sp}^
     740:	2e2e2f6e 	cdpcs	15, 2, cr2, cr14, cr14, {3}
     744:	62696c2f 	rsbvs	r6, r9, #12032	; 0x2f00
    /*
     * Ensure pin number is legal
     */

    assert((pin < 32));
     748:	6363672f 	cmnvs	r3, #12320768	; 0xbc0000
     74c:	6d72612f 	ldfvse	f6, [r2, #-188]!	; 0xffffff44
     750:	6e6f6e2d 	cdpvs	14, 6, cr6, cr15, cr13, {1}
     754:	61652d65 	cmnvs	r5, r5, ror #26
     758:	342f6962 	strtcc	r6, [pc], #-2402	; 760 <gpioConfig+0x24>
     75c:	312e362e 	teqcc	lr, lr, lsr #12

    /*
     * Config the SIM Clock Gate
     */

    switch (port) {
     760:	2f2e2e2f 	svccs	0x002e2e2f
     764:	2e2f2e2e 	cdpcs	14, 2, cr2, cr15, cr14, {1}
     768:	2e2e2f2e 	cdpcs	15, 2, cr2, cr14, cr14, {1}
     76c:	6d72612f 	ldfvse	f6, [r2, #-188]!	; 0xffffff44
     770:	6e6f6e2d 	cdpvs	14, 6, cr6, cr15, cr13, {1}
     774:	61652d65 	cmnvs	r5, r5, ror #26
     778:	692f6962 	stmdbvs	pc!, {r1, r5, r6, r8, fp, sp, lr}	; <UNPREDICTABLE>
     77c:	756c636e 	strbvc	r6, [ip, #-878]!	; 0xfffffc92
     780:	2e006564 	cfsh32cs	mvfx6, mvfx0, #52
     784:	2e2e2f2e 	cdpcs	15, 2, cr2, cr14, cr14, {1}
     788:	6968432f 	stmdbvs	r8!, {r0, r1, r2, r3, r5, r8, r9, lr}^
     78c:	534f6962 	movtpl	r6, #63842	; 0xf962
     790:	2f736f2f 	svccs	0x00736f2f
     794:	74726f70 	ldrbtvc	r6, [r2], #-3952	; 0xfffff090
     798:	43472f73 	movtmi	r2, #32627	; 0x7f73
     79c:	52412f43 	subpl	r2, r1, #268	; 0x10c
     7a0:	784d434d 	stmdavc	sp, {r0, r2, r3, r6, r8, r9, lr}^
     7a4:	2f2e2e00 	svccs	0x002e2e00
     7a8:	432f2e2e 	teqmi	pc, #736	; 0x2e0
    case PORTA: SIM_SCGC5 |= SIM_SCGC5_PORTA_ENABLE; break;
     7ac:	69626968 	stmdbvs	r2!, {r3, r5, r6, r8, fp, sp, lr}^
     7b0:	6f2f534f 	svcvs	0x002f534f
     7b4:	656b2f73 	strbvs	r2, [fp, #-3955]!	; 0xfffff08d
     7b8:	6c656e72 	stclvs	14, cr6, [r5], #-456	; 0xfffffe38
     7bc:	636e692f 	cmnvs	lr, #770048	; 0xbc000
     7c0:	6564756c 	strbvs	r7, [r4, #-1388]!	; 0xfffffa94
     7c4:	68630000 	stmdavs	r3!, {}^	; <UNPREDICTABLE>
    case PORTB: SIM_SCGC5 |= SIM_SCGC5_PORTB_ENABLE; break;
     7c8:	632e7476 	teqvs	lr, #1979711488	; 0x76000000
     7cc:	00000100 	andeq	r0, r0, r0, lsl #2
     7d0:	69647473 	stmdbvs	r4!, {r0, r1, r4, r5, r6, sl, ip, sp, lr}^
     7d4:	682e746e 	stmdavs	lr!, {r1, r2, r3, r5, r6, sl, ip, sp, lr}
     7d8:	00000200 	andeq	r0, r0, r0, lsl #4
     7dc:	79746863 	ldmdbvc	r4!, {r0, r1, r5, r6, fp, sp, lr}^
    case PORTC: SIM_SCGC5 |= SIM_SCGC5_PORTC_ENABLE; break;
     7e0:	2e736570 	mrccs	5, 3, r6, cr3, cr0, {3}
     7e4:	00030068 	andeq	r0, r3, r8, rrx
     7e8:	76686300 	strbtvc	r6, [r8], -r0, lsl #6
     7ec:	00682e74 	rsbeq	r2, r8, r4, ror lr
     7f0:	00000004 	andeq	r0, r0, r4
     7f4:	20020500 	andcs	r0, r2, r0, lsl #10
     7f8:	03000014 	movweq	r0, #20
    case PORTD: SIM_SCGC5 |= SIM_SCGC5_PORTD_ENABLE; break;
     7fc:	0814012a 	ldmdaeq	r4, {r1, r3, r5, r8}
     800:	0275752f 	rsbseq	r7, r5, #197132288	; 0xbc00000
     804:	01010001 	tsteq	r1, r1
     808:	70020500 	andvc	r0, r2, r0, lsl #10
     80c:	03000014 	movweq	r0, #20
     810:	5c0100c4 	stcpl	0, cr0, [r1], {196}	; 0xc4
    case PORTE: SIM_SCGC5 |= SIM_SCGC5_PORTE_ENABLE; break;
     814:	01040200 	mrseq	r0, R12_usr
     818:	02003c06 	andeq	r3, r0, #1536	; 0x600
     81c:	063c0304 	ldrteq	r0, [ip], -r4, lsl #6
     820:	673d3d31 			; <UNDEFINED> instruction: 0x673d3d31
     824:	02005921 	andeq	r5, r0, #540672	; 0x84000
     828:	5d3a0104 	ldfpls	f0, [sl, #-16]!
     82c:	753d8383 	ldrvc	r8, [sp, #-899]!	; 0xfffffc7d
    default:
        assert(0);
     830:	00020267 	andeq	r0, r2, r7, ror #4
     834:	05000101 	streq	r0, [r0, #-257]	; 0xfffffeff
     838:	00151002 	andseq	r1, r5, r2
     83c:	00e20300 	rsceq	r0, r2, r0, lsl #6

    /*
     * Configure the Port Controller
     */

    uint32_t portCtrlBits = PORT_MUX_GPIO;
     840:	91833601 	orrls	r3, r3, r1, lsl #12
     844:	024b5959 	subeq	r5, fp, #1458176	; 0x164000

    if (opt & GPIO_OUTPUT) {
     848:	01010002 	tsteq	r1, r2
     84c:	60020500 	andvs	r0, r2, r0, lsl #10
        if (opt & GPIO_ODE) {
     850:	03000015 	movweq	r0, #21
     854:	3e0100fe 	mcrcc	0, 0, r0, cr1, cr14, {7}
     858:	04020067 	streq	r0, [r2], #-103	; 0xffffff99
            portCtrlBits |= PORT_ODE;
     85c:	004a0601 	subeq	r0, sl, r1, lsl #12
     860:	4a030402 	bmi	c1870 <_flash_swap_addr+0x82070>
        } else {
            if (opt & GPIO_DSE)
     864:	01040200 	mrseq	r0, R12_usr
     868:	0402004a 	streq	r0, [r2], #-74	; 0xffffffb6
     86c:	02003c04 	andeq	r3, r0, #4, 24	; 0x400
                portCtrlBits |= PORT_DSE;
     870:	063c0204 	ldrteq	r0, [ip], -r4, lsl #4
     874:	0402004b 	streq	r0, [r2], #-75	; 0xffffffb5
        }

    } else if (opt & GPIO_INPUT) {
     878:	3c064906 	stccc	9, cr4, [r6], {6}
     87c:	08040200 	stmdaeq	r4, {r9}
     880:	03023006 	movweq	r3, #8198	; 0x2006
        if (opt & GPIO_PFE)
     884:	c0010100 	andgt	r0, r1, r0, lsl #2
     888:	02000002 	andeq	r0, r0, #2
     88c:	00017800 	andeq	r7, r1, r0, lsl #16
            portCtrlBits |= PORT_PFE;
     890:	fb010200 	blx	4109a <_flash_swap_addr+0x189a>
     894:	01000d0e 	tsteq	r0, lr, lsl #26

    } else {
        assert(0);
     898:	00010101 	andeq	r0, r1, r1, lsl #2
     89c:	00010000 	andeq	r0, r1, r0
     8a0:	2e2e0100 	sufcse	f0, f6, f0
     8a4:	2f2e2e2f 	svccs	0x002e2e2f
        return;
     8a8:	62696843 	rsbvs	r6, r9, #4390912	; 0x430000
    }

    if (opt & GPIO_PULLUP)
     8ac:	2f534f69 	svccs	0x00534f69
     8b0:	6b2f736f 	blvs	bdd674 <_flash_swap_addr+0xb9de74>
        portCtrlBits |= PORT_PULLUP_ENABLE;
     8b4:	656e7265 	strbvs	r7, [lr, #-613]!	; 0xfffffd9b
     8b8:	6e692f6c 	cdpvs	15, 6, cr2, cr9, cr12, {3}
     8bc:	64756c63 	ldrbtvs	r6, [r5], #-3171	; 0xfffff39d
    else if (opt & GPIO_PULLDOWN)
     8c0:	2e2e0065 	cdpcs	0, 2, cr0, cr14, cr5, {3}
     8c4:	2f2e2e2f 	svccs	0x002e2e2f
        portCtrlBits |= PORT_PULLDOWN_ENABLE;
     8c8:	62696843 	rsbvs	r6, r9, #4390912	; 0x430000
     8cc:	2f534f69 	svccs	0x00534f69

    PORT_PCR(port, pin) = portCtrlBits;
     8d0:	6b2f736f 	blvs	bdd694 <_flash_swap_addr+0xb9de94>
     8d4:	656e7265 	strbvs	r7, [lr, #-613]!	; 0xfffffd9b
     8d8:	72732f6c 	rsbsvc	r2, r3, #108, 30	; 0x1b0
     8dc:	6f2f0063 	svcvs	0x002f0063

    /*
     * Configure the GPIO Controller
     */

    volatile gpioPort_t *gpioPort = gpioPortGet(port);
     8e0:	432f7470 	teqmi	pc, #112, 8	; 0x70000000
     8e4:	5365646f 	cmnpl	r5, #1862270976	; 0x6f000000
    uint32_t pinBit = 1 << pin;
     8e8:	6372756f 	cmnvs	r2, #465567744	; 0x1bc00000
     8ec:	2f797265 	svccs	0x00797265
     8f0:	72756f53 	rsbsvc	r6, r5, #332	; 0x14c

    if (opt & GPIO_OUTPUT) {
     8f4:	79726563 	ldmdbvc	r2!, {r0, r1, r5, r6, r8, sl, sp, lr}^
     8f8:	646f435f 	strbtvs	r4, [pc], #-863	; 900 <STACK_SIZE+0x100>
        gpioPort->pddr |= pinBit;
     8fc:	6e654265 	cdpvs	2, 6, cr4, cr5, cr5, {3}
     900:	4c5f6863 	mrrcmi	8, 6, r6, pc, cr3	; <UNPREDICTABLE>
     904:	5f657469 	svcpl	0x00657469
        if (opt & GPIO_HIGH)
     908:	5f726f66 	svcpl	0x00726f66
     90c:	5f4d5241 	svcpl	0x004d5241
     910:	49424145 	stmdbmi	r2, {r0, r2, r6, r8, lr}^
            gpioPort->psor |= pinBit;
     914:	6e69622f 	cdpvs	2, 6, cr6, cr9, cr15, {1}
     918:	2f2e2e2f 	svccs	0x002e2e2f
     91c:	2f62696c 	svccs	0x0062696c
        else if (opt & GPIO_LOW)
     920:	2f636367 	svccs	0x00636367
     924:	2d6d7261 	sfmcs	f7, 2, [sp, #-388]!	; 0xfffffe7c
     928:	656e6f6e 	strbvs	r6, [lr, #-3950]!	; 0xfffff092
            gpioPort->pcor |= pinBit;
     92c:	6261652d 	rsbvs	r6, r1, #188743680	; 0xb400000
     930:	2e342f69 	cdpcs	15, 3, cr2, cr4, cr9, {3}
     934:	2f312e36 	svccs	0x00312e36
    }
}
     938:	2e2f2e2e 	cdpcs	14, 2, cr2, cr15, cr14, {1}
     93c:	2e2e2f2e 	cdpcs	15, 2, cr2, cr14, cr14, {1}

/*******************************************************************************
* gpioSet
*******************************************************************************/
void gpioSet(uint32_t port, uint32_t pin)
{
     940:	2f2e2e2f 	svccs	0x002e2e2f
     944:	2d6d7261 	sfmcs	f7, 2, [sp, #-388]!	; 0xfffffe7c
     948:	656e6f6e 	strbvs	r6, [lr, #-3950]!	; 0xfffff092
    volatile gpioPort_t *gpioPort = gpioPortGet(port);
     94c:	6261652d 	rsbvs	r6, r1, #188743680	; 0xb400000
     950:	6e692f69 	cdpvs	15, 6, cr2, cr9, cr9, {3}
    gpioPort->psor = 1 << pin;
     954:	64756c63 	ldrbtvs	r6, [r5], #-3171	; 0xfffff39d
     958:	2e2e0065 	cdpcs	0, 2, cr0, cr14, cr5, {3}
     95c:	2f2e2e2f 	svccs	0x002e2e2f
     960:	62696843 	rsbvs	r6, r9, #4390912	; 0x430000
}
     964:	2f534f69 	svccs	0x00534f69
     968:	702f736f 	eorvc	r7, pc, pc, ror #6

/*******************************************************************************
* gpioClear
*******************************************************************************/
void gpioClear(uint32_t port, uint32_t pin)
{
     96c:	7374726f 	cmnvc	r4, #-268435450	; 0xf0000006
     970:	4343472f 	movtmi	r4, #14127	; 0x372f
     974:	4d52412f 	ldfmie	f4, [r2, #-188]	; 0xffffff44
    volatile gpioPort_t *gpioPort = gpioPortGet(port);
     978:	00784d43 	rsbseq	r4, r8, r3, asr #26
     97c:	69686300 	stmdbvs	r8!, {r8, r9, sp, lr}^
    gpioPort->pcor = 1 << pin;
     980:	6e696c6e 	cdpvs	12, 6, cr6, cr9, cr14, {3}
     984:	00682e65 	rsbeq	r2, r8, r5, ror #28
     988:	63000001 	movwvs	r0, #1
     98c:	68637368 	stmdavs	r3!, {r3, r5, r6, r8, r9, ip, sp, lr}^
}
     990:	00632e64 	rsbeq	r2, r3, r4, ror #28
     994:	73000002 	movwvc	r0, #2

/*******************************************************************************
* gpioToggle
*******************************************************************************/
void gpioToggle(uint32_t port, uint32_t pin)
{
     998:	6e696474 	mcrvs	4, 3, r6, cr9, cr4, {3}
     99c:	00682e74 	rsbeq	r2, r8, r4, ror lr
     9a0:	63000003 	movwvs	r0, #3
    volatile gpioPort_t *gpioPort = gpioPortGet(port);
     9a4:	70797468 	rsbsvc	r7, r9, r8, ror #8
     9a8:	682e7365 	stmdavs	lr!, {r0, r2, r5, r6, r8, r9, ip, sp, lr}
    gpioPort->ptor = 1 << pin;
     9ac:	00000400 	andeq	r0, r0, r0, lsl #8
     9b0:	696c6863 	stmdbvs	ip!, {r0, r1, r5, r6, fp, sp, lr}^
     9b4:	2e737473 	mrccs	4, 3, r7, cr3, cr3, {3}
     9b8:	00010068 	andeq	r0, r1, r8, rrx
}
     9bc:	74686300 	strbtvc	r6, [r8], #-768	; 0xfffffd00
     9c0:	61657268 	cmnvs	r5, r8, ror #4
*
* RETURNS:
*
*******************************************************************************/
void gpioPortWrite(uint32_t port, uint32_t mask, uint32_t value)
{
     9c4:	682e7364 	stmdavs	lr!, {r2, r5, r6, r8, r9, ip, sp, lr}
     9c8:	00000100 	andeq	r0, r0, r0, lsl #2
     9cc:	6f636863 	svcvs	0x00636863
}
     9d0:	765f6572 			; <UNDEFINED> instruction: 0x765f6572
     9d4:	682e6d37 	stmdavs	lr!, {r0, r1, r2, r4, r5, r8, sl, fp, sp, lr}
     9d8:	00000400 	andeq	r0, r0, r0, lsl #8
*
* RETURNS:
*
*******************************************************************************/
uint32_t gpioPortRead(uint32_t port)
{
     9dc:	74766863 	ldrbtvc	r6, [r6], #-2147	; 0xfffff79d
     9e0:	0100682e 	tsteq	r0, lr, lsr #16
    return 0;
     9e4:	68630000 	stmdavs	r3!, {}^	; <UNPREDICTABLE>
}
     9e8:	64686373 	strbtvs	r6, [r8], #-883	; 0xfffffc8d
     9ec:	0100682e 	tsteq	r0, lr, lsr #16
     9f0:	68630000 	stmdavs	r3!, {}^	; <UNPREDICTABLE>
*
* RETURNS:
*
*******************************************************************************/
uint32_t gpioRead(uint32_t port, uint32_t pin)
{
     9f4:	2e6d6573 	mcrcs	5, 3, r6, cr13, cr3, {3}
     9f8:	00010068 	andeq	r0, r1, r8, rrx
     9fc:	6d686300 	stclvs	3, cr6, [r8, #-0]
    volatile gpioPort_t *gpioPort = gpioPortGet(port);
     a00:	682e7874 	stmdavs	lr!, {r2, r4, r5, r6, fp, ip, sp, lr}
     a04:	00000100 	andeq	r0, r0, r0, lsl #2
    return ((gpioPort->pdir & (1 << pin)) ? TRUE : FALSE);
     a08:	02050000 	andeq	r0, r5, #0
     a0c:	000015c0 	andeq	r1, r0, r0, asr #11
     a10:	2f013303 	svccs	0x00013303
     a14:	0221833e 	eoreq	r8, r1, #-134217728	; 0xf8000000
     a18:	01010003 	tsteq	r1, r3
     a1c:	f0020500 			; <UNDEFINED> instruction: 0xf0020500
}
     a20:	03000015 	movweq	r0, #21
     a24:	300100c1 	andcc	r0, r1, r1, asr #1
    .flashDiv     = FLASH_DIVIDER_DFLT,
};


static void fei2fee(clockConfig_t cc)
{
     a28:	02215959 	eoreq	r5, r1, #1458176	; 0x164000
     a2c:	01010003 	tsteq	r1, r3
     a30:	05000204 	streq	r0, [r0, #-516]	; 0xfffffdfc
     * Uno problemo: The largest divide factor available by FRDIV is 1024... And
     * 50MHz / 1024 = 48.3 kHz, which exceeds the 39.0625 kHz range. With our
     * setup, it doesn't seem that we can reach a FEE mode (and I don't want to
     * risk the tower to see what could happen if I did!)
     */
}
     a34:	00161002 	andseq	r1, r6, r2
     a38:	012f0300 	teqeq	pc, r0, lsl #6

static void fei2pee(clockConfig_t cc)
{
     a3c:	762f0814 			; <UNDEFINED> instruction: 0x762f0814
     a40:	01023008 	tsteq	r2, r8
     a44:	04010100 	streq	r0, [r1], #-256	; 0xffffff00
                                                    /* External crystal setup */
    /* Select the OSCCLK */
    SIM_SOPT2 &= ~SIM_SOPT2_MCGCLKSEL;
     a48:	02050002 	andeq	r0, r5, #2
     a4c:	00001670 	andeq	r1, r0, r0, ror r6
     a50:	0100c903 	tsteq	r0, r3, lsl #18
     a54:	2e7a0334 	mrccs	3, 3, r0, cr10, cr4, {1}
     a58:	3c7a0334 	ldclcc	3, cr0, [sl], #-208	; 0xffffff30
     a5c:	4b200b03 	blmi	803670 <_flash_swap_addr+0x7c3e70>
     * Enabling the XTAL for 50MHz
     * RANGE=1, match the frequency of the crystal being used
     * HGO=1,   set for high gain operation (best against noise)
     * EREFS=1, enable the external oscillator
     */
    clock.mcg->c2 = (MCG_C2_RANGE_MASK & (0x1 << 4)) |
     a60:	01040200 	mrseq	r0, R12_usr
     a64:	0402005a 	streq	r0, [r2], #-90	; 0xffffffa6
     a68:	3d683d01 	stclcc	13, cr3, [r8, #-4]!
     a6c:	0221834b 	eoreq	r8, r1, #738197505	; 0x2c000001
     * mode from FBE (here we are going to PEE)
     *
     * IREFS=0, select external reference clock and enable the external
     * oscillator.
     */
    clock.mcg->c1 = ((MCG_C1_CLKS_MASK & (0x2 << 6)) |
     a70:	01010003 	tsteq	r1, r3
     a74:	05000204 	streq	r0, [r0, #-516]	; 0xfffffdfc
     a78:	0016d002 	andseq	sp, r6, r2
     a7c:	00eb0300 	rsceq	r0, fp, r0, lsl #6
                    (MCG_C1_FRDIV_MASK & (0x3 << 3))) &
                    (~MCG_C1_IREFS);

                                                    /* Wait for status update */
    /* Wait for oscillator to initialize */
    while (!(clock.mcg->s & MCG_S_OSCINIT)) {}
     a80:	4ca25d01 	stcmi	13, cr5, [r2], #4
     a84:	029183bb 	addseq	r8, r1, #-335544318	; 0xec000002
     a88:	01010002 	tsteq	r1, r2
     a8c:	05000204 	streq	r0, [r0, #-516]	; 0xfffffdfc
     a90:	00174002 	andseq	r4, r7, r2
     a94:	01800300 	orreq	r0, r0, r0, lsl #6
    /* Wait for reference clock's to become the external reference */
    while (clock.mcg->s & MCG_S_IREFST) {}
     a98:	4b303d01 	blmi	c0fea4 <_flash_swap_addr+0xbd06a4>
     a9c:	4b162302 	blmi	5896ac <_flash_swap_addr+0x549eac>
     aa0:	660a0325 	strvs	r0, [sl], -r5, lsr #6
     aa4:	4b3d4b3f 	blmi	f537a8 <_flash_swap_addr+0xf13fa8>
     aa8:	01000202 	tsteq	r0, r2, lsl #4
     aac:	00020401 	andeq	r0, r2, r1, lsl #8
    /* Wait for the indicator that MCGOTUCLK is fed by the external ref clock */
    while ((clock.mcg->s & MCG_S_CLKST_MASK) != (0x2 << 2)) {}
     ab0:	17d00205 	ldrbne	r0, [r0, r5, lsl #4]
     ab4:	b5030000 	strlt	r0, [r3, #-0]
     ab8:	4d6a0101 	stfmie	f0, [sl, #-4]!
     abc:	5b3d59d7 	blpl	f57220 <_flash_swap_addr+0xf17a20>
     ac0:	03026759 	movweq	r6, #10073	; 0x2759
     ac4:	04010100 	streq	r0, [r1], #-256	; 0xffffff00

                                            /* Generate correct PLL frequency */
    clock.mcg->c5 &= 0xE0; /* clear bits */
     ac8:	02050002 	andeq	r0, r5, #2
     acc:	00001840 	andeq	r1, r0, r0, asr #16
     ad0:	0101d903 	tsteq	r1, r3, lsl #18
     ad4:	4c9f414e 	ldfmis	f4, [pc], {78}	; 0x4e
     ad8:	4c4b6791 	mcrrmi	7, 9, r6, fp, cr1
     adc:	01000202 	tsteq	r0, r2, lsl #4
     ae0:	00020401 	andeq	r0, r2, r1, lsl #8
     ae4:	18a00205 	stmiane	r0!, {r0, r2, r9}
    clock.mcg->c5 |= clockConfigParam[cc].divider;
     ae8:	f5030000 			; <UNDEFINED> instruction: 0xf5030000
     aec:	d7240101 	strle	r0, [r4, -r1, lsl #2]!
     af0:	0001022f 	andeq	r0, r1, pc, lsr #4
     af4:	02040101 	andeq	r0, r4, #1073741824	; 0x40000000
     af8:	d0020500 	andle	r0, r2, r0, lsl #10
     afc:	03000018 	movweq	r0, #24
     b00:	310102a8 	smlatbcc	r1, r8, r2, r0
     b04:	4c84bb68 	vstmiami	r4, {d11-<overflow reg d62>}
     b08:	0202913d 	andeq	r9, r2, #1073741839	; 0x4000000f
     b0c:	04010100 	streq	r0, [r1], #-256	; 0xffffff00
     b10:	02050002 	andeq	r0, r5, #2
     b14:	00001930 	andeq	r1, r0, r0, lsr r9
    clock.mcg->c6 &= 0xE0;
     b18:	0102c103 	tsteq	r2, r3, lsl #2
     b1c:	84bb6831 	ldrthi	r6, [fp], #2097	; 0x831
     b20:	0402004b 	streq	r0, [r2], #-75	; 0xffffffb5
     b24:	02005a01 	andeq	r5, r0, #4096	; 0x1000
     b28:	683d0104 	ldmdavs	sp!, {r2, r8}
     b2c:	91844b3d 	orrls	r4, r4, sp, lsr fp
     b30:	01000202 	tsteq	r0, r2, lsl #4
     b34:	00020401 	andeq	r0, r2, r1, lsl #8
    clock.mcg->c6 |= clockConfigParam[cc].multiplier;
     b38:	19c00205 	stmibne	r0, {r0, r2, r9}^
     b3c:	e2030000 	and	r0, r3, #0
     b40:	85250102 	strhi	r0, [r5, #-258]!	; 0xfffffefe
     b44:	01023541 	tsteq	r2, r1, asr #10
     b48:	57010100 	strpl	r0, [r1, -r0, lsl #2]
     b4c:	02000003 	andeq	r0, r0, #3
     b50:	0001de00 	andeq	sp, r1, r0, lsl #28
     b54:	fb010200 	blx	4135e <_flash_swap_addr+0x1b5e>
     b58:	01000d0e 	tsteq	r0, lr, lsl #26
     b5c:	00010101 	andeq	r0, r1, r1, lsl #2
     b60:	00010000 	andeq	r0, r1, r0
     b64:	2e2e0100 	sufcse	f0, f6, f0
                                                            /* Enter PBE mode */
    /* PLLS=1, select the PLL. */
    clock.mcg->c6 |= MCG_C6_PLLS;
     b68:	2f2e2e2f 	svccs	0x002e2e2f
     b6c:	62696843 	rsbvs	r6, r9, #4390912	; 0x430000
     b70:	2f534f69 	svccs	0x00534f69
     b74:	6b2f736f 	blvs	bdd938 <_flash_swap_addr+0xb9e138>
     b78:	656e7265 	strbvs	r7, [lr, #-613]!	; 0xfffffd9b
     b7c:	6e692f6c 	cdpvs	15, 6, cr2, cr9, cr12, {3}
     b80:	64756c63 	ldrbtvs	r6, [r5], #-3171	; 0xfffff39d
     b84:	2e2e0065 	cdpcs	0, 2, cr0, cr14, cr5, {3}

                                                    /* Wait for status update */
    /* Wait for the PLL to be the clock source */
    while (!(clock.mcg->s & MCG_S_PLLST)) {}
     b88:	2f2e2e2f 	svccs	0x002e2e2f
     b8c:	62696843 	rsbvs	r6, r9, #4390912	; 0x430000
     b90:	2f534f69 	svccs	0x00534f69
     b94:	6b2f736f 	blvs	bdd958 <_flash_swap_addr+0xb9e158>
     b98:	656e7265 	strbvs	r7, [lr, #-613]!	; 0xfffffd9b
     b9c:	72732f6c 	rsbsvc	r2, r3, #108, 30	; 0x1b0
    /* Wait until the PLL has acquired lock on the external frequency */
    while (!(clock.mcg->s & MCG_S_LOCK)) {}
     ba0:	6f2f0063 	svcvs	0x002f0063
     ba4:	432f7470 	teqmi	pc, #112, 8	; 0x70000000
     ba8:	5365646f 	cmnpl	r5, #1862270976	; 0x6f000000
     bac:	6372756f 	cmnvs	r2, #465567744	; 0x1bc00000
     bb0:	2f797265 	svccs	0x00797265
     bb4:	72756f53 	rsbsvc	r6, r5, #332	; 0x14c

                                                            /* Enter PEE mode */
    /* Select the output of the PLL */
    clock.mcg->c1 &= ~MCG_C1_CLKS_MASK;
     bb8:	79726563 	ldmdbvc	r2!, {r0, r1, r5, r6, r8, sl, sp, lr}^
     bbc:	646f435f 	strbtvs	r4, [pc], #-863	; bc4 <fei2pee+0x188>
     bc0:	6e654265 	cdpvs	2, 6, cr4, cr5, cr5, {3}
     bc4:	4c5f6863 	mrrcmi	8, 6, r6, pc, cr3	; <UNPREDICTABLE>
     bc8:	5f657469 	svcpl	0x00657469
     bcc:	5f726f66 	svcpl	0x00726f66
     bd0:	5f4d5241 	svcpl	0x004d5241
     bd4:	49424145 	stmdbmi	r2, {r0, r2, r6, r8, lr}^

                                                    /* Wait for status update */
    /* Wait until output of the PLL is selected */
    while ((clock.mcg->s & MCG_S_CLKST_MASK) != (0x3 << 2)) {}
     bd8:	6e69622f 	cdpvs	2, 6, cr6, cr9, cr15, {1}
     bdc:	2f2e2e2f 	svccs	0x002e2e2f
     be0:	2f62696c 	svccs	0x0062696c
     be4:	2f636367 	svccs	0x00636367
     be8:	2d6d7261 	sfmcs	f7, 2, [sp, #-388]!	; 0xfffffe7c
     bec:	656e6f6e 	strbvs	r6, [lr, #-3950]!	; 0xfffff092

    mcgState.currentMode = MODE_PEE;
     bf0:	6261652d 	rsbvs	r6, r1, #188743680	; 0xb400000
     bf4:	2e342f69 	cdpcs	15, 3, cr2, cr4, cr9, {3}
     bf8:	2f312e36 	svccs	0x00312e36
}
     bfc:	6c636e69 	stclvs	14, cr6, [r3], #-420	; 0xfffffe5c
     c00:	00656475 	rsbeq	r6, r5, r5, ror r4
     c04:	74706f2f 	ldrbtvc	r6, [r0], #-3887	; 0xfffff0d1

static void fei2blpi(clockConfig_t cc)
{
     c08:	646f432f 	strbtvs	r4, [pc], #-815	; c10 <fei2blpi+0x8>
     c0c:	756f5365 	strbvc	r5, [pc, #-869]!	; 8af <STACK_SIZE+0xaf>
     c10:	72656372 	rsbvc	r6, r5, #-939524095	; 0xc8000001
                                                            /* Not configured */
}
     c14:	6f532f79 	svcvs	0x00532f79
     c18:	65637275 	strbvs	r7, [r3, #-629]!	; 0xfffffd8b

static void fei2blpe(clockConfig_t cc)
{
     c1c:	435f7972 	cmpmi	pc, #1867776	; 0x1c8000
     c20:	4265646f 	rsbmi	r6, r5, #1862270976	; 0x6f000000
     c24:	68636e65 	stmdavs	r3!, {r0, r2, r5, r6, r9, sl, fp, sp, lr}^
                                                            /* Not configured */
}
     c28:	74694c5f 	strbtvc	r4, [r9], #-3167	; 0xfffff3a1
     c2c:	6f665f65 	svcvs	0x00665f65


static void fee2fei(clockConfig_t cc)
{
     c30:	52415f72 	subpl	r5, r1, #456	; 0x1c8
     c34:	41455f4d 	cmpmi	r5, sp, asr #30
     c38:	622f4942 	eorvs	r4, pc, #1081344	; 0x108000
                                                            /* Not configured */
}
     c3c:	2e2f6e69 	cdpcs	14, 2, cr6, cr15, cr9, {3}
     c40:	696c2f2e 	stmdbvs	ip!, {r1, r2, r3, r5, r8, r9, sl, fp, sp}^

static void fee2pee(clockConfig_t cc)
{
     c44:	63672f62 	cmnvs	r7, #392	; 0x188
     c48:	72612f63 	rsbvc	r2, r1, #396	; 0x18c
     c4c:	6f6e2d6d 	svcvs	0x006e2d6d
                                                            /* Not configured */
}
     c50:	652d656e 	strvs	r6, [sp, #-1390]!	; 0xfffffa92
     c54:	2f696261 	svccs	0x00696261

static void fee2blpi(clockConfig_t cc)
{
     c58:	2e362e34 	mrccs	14, 1, r2, cr6, cr4, {1}
     c5c:	2e2e2f31 	mcrcs	15, 1, r2, cr14, cr1, {1}
     c60:	2f2e2e2f 	svccs	0x002e2e2f
                                                            /* Not configured */
}
     c64:	2e2f2e2e 	cdpcs	14, 2, cr2, cr15, cr14, {1}
     c68:	72612f2e 	rsbvc	r2, r1, #46, 30	; 0xb8

static void fee2blpe(clockConfig_t cc)
{
     c6c:	6f6e2d6d 	svcvs	0x006e2d6d
     c70:	652d656e 	strvs	r6, [sp, #-1390]!	; 0xfffffa92
     c74:	2f696261 	svccs	0x00696261
                                                            /* Not configured */
}
     c78:	6c636e69 	stclvs	14, cr6, [r3], #-420	; 0xfffffe5c
     c7c:	00656475 	rsbeq	r6, r5, r5, ror r4


static void pee2fei(clockConfig_t cc)
{
     c80:	2e2f2e2e 	cdpcs	14, 2, cr2, cr15, cr14, {1}
     c84:	68432f2e 	stmdavs	r3, {r1, r2, r3, r5, r8, r9, sl, fp, sp}^
     c88:	4f696269 	svcmi	0x00696269

                                                            /* Enter PBE mode */
    clock.mcg->c1 = (MCG_C1_CLKS_MASK & (0x2 << 6)); /* Select external clock */
     c8c:	736f2f53 	cmnvc	pc, #332	; 0x14c
     c90:	726f702f 	rsbvc	r7, pc, #47	; 0x2f
     c94:	472f7374 			; <UNDEFINED> instruction: 0x472f7374
     c98:	412f4343 	teqmi	pc, r3, asr #6

                                                    /* Wait for status update */
    while ((clock.mcg->s & MCG_S_CLKST_MASK) != (0x2 << 2)) {}
     c9c:	4d434d52 	stclmi	13, cr4, [r3, #-328]	; 0xfffffeb8
     ca0:	63000078 	movwvs	r0, #120	; 0x78
     ca4:	6c6e6968 	stclvs	9, cr6, [lr], #-416	; 0xfffffe60
     ca8:	2e656e69 	cdpcs	14, 6, cr6, cr5, cr9, {3}
     cac:	00010068 	andeq	r0, r1, r8, rrx
     cb0:	74686300 	strbtvc	r6, [r8], #-768	; 0xfffffd00

                                                            /* Enter FBE mode */
    /*
     * With the FLL frequency valid, we can now clear the PLLS bit to select FLL
     */
    clock.mcg->c6 &= ~MCG_C6_PLLS;
     cb4:	61657268 	cmnvs	r5, r8, ror #4
     cb8:	632e7364 	teqvs	lr, #100, 6	; 0x90000001
     cbc:	00000200 	andeq	r0, r0, r0, lsl #4
     cc0:	64647473 	strbtvs	r7, [r4], #-1139	; 0xfffffb8d
     cc4:	682e6665 	stmdavs	lr!, {r0, r2, r5, r6, r9, sl, sp, lr}
     cc8:	00000300 	andeq	r0, r0, r0, lsl #6
     ccc:	69647473 	stmdbvs	r4!, {r0, r1, r4, r5, r6, sl, ip, sp, lr}^
     cd0:	682e746e 	stmdavs	lr!, {r1, r2, r3, r5, r6, sl, ip, sp, lr}

                                                    /* Wait for status update */
    /* Wait until the current source is FLL */
    while (clock.mcg->s & MCG_S_PLLST) {}
     cd4:	00000400 	andeq	r0, r0, r0, lsl #8
     cd8:	79746863 	ldmdbvc	r4!, {r0, r1, r5, r6, fp, sp, lr}^
     cdc:	2e736570 	mrccs	5, 3, r6, cr3, cr0, {3}
     ce0:	00050068 	andeq	r0, r5, r8, rrx
     ce4:	6c686300 	stclvs	3, cr6, [r8], #-0
     ce8:	73747369 	cmnvc	r4, #-1543503871	; 0xa4000001

                                            /* Generate correct FLL frequency */
    clock.mcg->c4 = clockConfigParam[cc].multiplier;
     cec:	0100682e 	tsteq	r0, lr, lsr #16
     cf0:	68630000 	stmdavs	r3!, {}^	; <UNPREDICTABLE>
     cf4:	65726874 	ldrbvs	r6, [r2, #-2164]!	; 0xfffff78c
     cf8:	2e736461 	cdpcs	4, 7, cr6, cr3, cr1, {3}
     cfc:	00010068 	andeq	r0, r1, r8, rrx
     d00:	63686300 	cmnvs	r8, #0, 6
     d04:	5f65726f 	svcpl	0x0065726f

                                                            /* Enter FEI mode */
    clock.mcg->c1 = (MCG_C1_CLKS_MASK & (0x0 << 6)) |
     d08:	2e6d3776 	mcrcs	7, 3, r3, cr13, cr6, {3}
     d0c:	00050068 	andeq	r0, r5, r8, rrx
     d10:	76686300 	strbtvc	r6, [r8], -r0, lsl #6
     d14:	00682e74 	rsbeq	r2, r8, r4, ror lr
                    (MCG_C1_IREFS);

                                                    /* Wait for status update */
    /* Wait for reference clock's to become the internal reference */
    while (!(clock.mcg->s & MCG_S_IREFST)) {}
     d18:	63000001 	movwvs	r0, #1
     d1c:	68637368 	stmdavs	r3!, {r3, r5, r6, r8, r9, ip, sp, lr}^
     d20:	00682e64 	rsbeq	r2, r8, r4, ror #28
     d24:	63000001 	movwvs	r0, #1
     d28:	78746d68 	ldmdavc	r4!, {r3, r5, r6, r8, sl, fp, sp, lr}^
     d2c:	0100682e 	tsteq	r0, lr, lsr #16
    /* Wait until the output of the FLL is selected */
    while ((clock.mcg->s & MCG_S_CLKST_MASK) != (0x0 << 2)) {}
     d30:	00000000 	andeq	r0, r0, r0
     d34:	19e00205 	stmibne	r0!, {r0, r2, r9}^
     d38:	c8030000 	stmdagt	r3, {}	; <UNPREDICTABLE>
     d3c:	4b3e0100 	blmi	f81144 <_flash_swap_addr+0xf41944>
     d40:	0002023d 	andeq	r0, r2, sp, lsr r2
     d44:	05000101 	streq	r0, [r0, #-257]	; 0xfffffeff

    mcgState.currentMode = MODE_FEI;
     d48:	001a0002 	andseq	r0, sl, r2
     d4c:	00ce0300 	sbceq	r0, lr, r0, lsl #6
     d50:	4b3d3001 	blmi	f4cd5c <_flash_swap_addr+0xf0d55c>
     d54:	00030221 	andeq	r0, r3, r1, lsr #4
}
     d58:	02040101 	andeq	r0, r4, #1073741824	; 0x40000000
     d5c:	20020500 	andcs	r0, r2, r0, lsl #10

static void pee2fee(clockConfig_t cc)
{
     d60:	0300001a 	movweq	r0, #26
     d64:	3e0100c4 	cdpcc	0, 0, cr0, cr1, cr4, {6}
     d68:	4d4c4b3d 	vstrmi	d20, [ip, #-244]	; 0xffffff0c
                                                            /* Not configured */
}
     d6c:	4d4d4d3d 	stclmi	13, cr4, [sp, #-244]	; 0xffffff0c
     d70:	a1084b4d 	tstge	r8, sp, asr #22

static void pee2blpi(clockConfig_t cc)
{
     d74:	0221985b 	eoreq	r9, r1, #5963776	; 0x5b0000
     d78:	01010003 	tsteq	r1, r3
     d7c:	05000204 	streq	r0, [r0, #-516]	; 0xfffffdfc
                                                            /* Not configured */
}
     d80:	001ad002 	andseq	sp, sl, r2
     d84:	01960300 	orrseq	r0, r6, r0, lsl #6

static void pee2blpe(clockConfig_t cc)
{
     d88:	00326801 	eorseq	r6, r2, r1, lsl #16
     d8c:	06010402 	streq	r0, [r1], -r2, lsl #8
     d90:	0402003c 	streq	r0, [r2], #-60	; 0xffffffc4
                                                            /* Not configured */
}
     d94:	02003c03 	andeq	r3, r0, #768	; 0x300
     d98:	063c0404 	ldrteq	r0, [ip], -r4, lsl #8


static void blpi2fei(clockConfig_t cc)
{
     d9c:	59590831 	ldmdbpl	r9, {r0, r4, r5, fp}^
     da0:	01000302 	tsteq	r0, r2, lsl #6
     da4:	00020401 	andeq	r0, r2, r1, lsl #8
                                                            /* Not configured */
}
     da8:	1b400205 	blne	10015c4 <_flash_swap_addr+0xfc1dc4>
     dac:	b4030000 	strlt	r0, [r3], #-0

static void blpi2fee(clockConfig_t cc)
{
     db0:	0b030101 	bleq	c11bc <_flash_swap_addr+0x819bc>
     db4:	4bd74b66 	blmi	ff5d3b54 <_stack_start+0xdf5c3b54>
     db8:	00030221 	andeq	r0, r3, r1, lsr #4
                                                            /* Not configured */
}
     dbc:	02040101 	andeq	r0, r4, #1073741824	; 0x40000000
     dc0:	80020500 	andhi	r0, r2, r0, lsl #10

static void blpi2pee(clockConfig_t cc)
{
     dc4:	0300001b 	movweq	r0, #27
     dc8:	410101d1 	ldrdmi	r0, [r1, -r1]
     dcc:	0200754c 	andeq	r7, r0, #76, 10	; 0x13000000
                                                            /* Not configured */
}
     dd0:	d6060104 	strle	r0, [r6], -r4, lsl #2
     dd4:	79759106 	ldmdbvc	r5!, {r1, r2, r8, ip, pc}^

static void blpi2blpe(clockConfig_t cc)
{
     dd8:	02214b2f 	eoreq	r4, r1, #48128	; 0xbc00
     ddc:	01010003 	tsteq	r1, r3
     de0:	05000204 	streq	r0, [r0, #-516]	; 0xfffffdfc
                                                            /* Not configured */
}
     de4:	001c0002 	andseq	r0, ip, r2
     de8:	01f20300 	mvnseq	r0, r0, lsl #6


static void blpe2fei(clockConfig_t cc)
{
     dec:	594e3e01 	stmdbpl	lr, {r0, r9, sl, fp, ip, sp}^
     df0:	0302214b 	movweq	r2, #8523	; 0x214b
     df4:	04010100 	streq	r0, [r1], #-256	; 0xffffff00
                                                            /* Not configured */
}
     df8:	02050002 	andeq	r0, r5, #2
     dfc:	00001c30 	andeq	r1, r0, r0, lsr ip

static void blpe2fee(clockConfig_t cc)
{
     e00:	01028903 	tsteq	r2, r3, lsl #18
     e04:	4b754b30 	blmi	1d53acc <_flash_swap_addr+0x1d142cc>
     e08:	01000202 	tsteq	r0, r2, lsl #4
                                                            /* Not configured */
}
     e0c:	00020401 	andeq	r0, r2, r1, lsl #8
     e10:	1c600205 	sfmne	f0, 2, [r0], #-20	; 0xffffffec

static void blpe2pee(clockConfig_t cc)
{
     e14:	9c030000 	stcls	0, cr0, [r3], {-0}
     e18:	4b400102 	blmi	1001228 <_flash_swap_addr+0xfc1a28>
     e1c:	02024b59 	andeq	r4, r2, #91136	; 0x16400
                                                            /* Not configured */
}
     e20:	04010100 	streq	r0, [r1], #-256	; 0xffffff00
     e24:	02050002 	andeq	r0, r5, #2

static void blpe2blpi(clockConfig_t cc)
{
     e28:	00001c90 	muleq	r0, r0, ip
     e2c:	0102ad03 	tsteq	r2, r3, lsl #26
     e30:	59ad4b3e 	stmibpl	sp!, {r1, r2, r3, r4, r5, r8, r9, fp, lr}
                                                            /* Not configured */
}
     e34:	0002024b 	andeq	r0, r2, fp, asr #4
     e38:	02040101 	andeq	r0, r4, #1073741824	; 0x40000000
* system, bus, flexbus, and flash clock frequencies.
*
*******************************************************************************/
void clockSetDividers(divider_t systemDiv, divider_t busDiv,
                                       divider_t flexBusDiv, divider_t flashDiv)
{
     e3c:	d0020500 	andle	r0, r2, r0, lsl #10
     e40:	0300001c 	movweq	r0, #28
     e44:	220102bc 	andcs	r0, r1, #188, 4	; 0xc000000b
     e48:	0402004b 	streq	r0, [r2], #-75	; 0xffffffb5
    int mcgClock = clockFreq.mcgClockFreq;
     e4c:	06d60601 	ldrbeq	r0, [r6], r1, lsl #12
     e50:	01024b2f 	tsteq	r2, pc, lsr #22
     e54:	04010100 	streq	r0, [r1], #-256	; 0xffffff00

    /*
     * The asserts are raised when the internal clock requirements (sec. 5.5)
     * are not met.
     */
    assert( (mcgClock / (systemDiv +1)) <= MAX_SYSTEM_FREQ);
     e58:	02050002 	andeq	r0, r5, #2
     e5c:	00001d10 	andeq	r1, r0, r0, lsl sp
     e60:	0102d103 	tsteq	r2, r3, lsl #2
     e64:	023e4b3e 	eorseq	r4, lr, #63488	; 0xf800
     e68:	01010002 	tsteq	r1, r2
     e6c:	05000204 	streq	r0, [r0, #-516]	; 0xfffffdfc
     e70:	001d3002 	andseq	r3, sp, r2
     e74:	02e60300 	rsceq	r0, r6, #0, 6
     e78:	41683d01 	cmnmi	r8, r1, lsl #26
     e7c:	04020021 	streq	r0, [r2], #-33	; 0xffffffdf

    assert( (mcgClock / (busDiv    +1)) <= MAX_BUS_FREQ &&
     e80:	677a9d01 	ldrbvs	r9, [sl, -r1, lsl #26]!
     e84:	02024da0 	andeq	r4, r2, #160, 26	; 0x2800
     e88:	04010100 	streq	r0, [r1], #-256	; 0xffffff00
     e8c:	02050002 	andeq	r0, r5, #2
     e90:	00001da0 	andeq	r1, r0, r0, lsr #27
     e94:	01039c03 	tsteq	r3, r3, lsl #24
     e98:	bb4b4f41 	bllt	12d4ba4 <_flash_swap_addr+0x12953a4>
     e9c:	3e4c3d4c 	cdpcc	13, 4, cr3, cr12, cr12, {2}
     ea0:	00030221 	andeq	r0, r3, r1, lsr #4
     ea4:	025b0101 	subseq	r0, fp, #1073741824	; 0x40000000
     ea8:	00020000 	andeq	r0, r2, r0
     eac:	000001e5 	andeq	r0, r0, r5, ror #3
     eb0:	0efb0102 	cdpeq	1, 15, cr0, cr11, cr2, {0}
     eb4:	0101000d 	tsteq	r1, sp
     eb8:	00000101 	andeq	r0, r0, r1, lsl #2
     ebc:	00000100 	andeq	r0, r0, r0, lsl #2
     ec0:	2f2e2e01 	svccs	0x002e2e01
            (mcgClock / (busDiv    +1)) <= (mcgClock / (systemDiv+1)));

    assert( (mcgClock / (flashDiv  +1)) <= MAX_FLASH_FREQ &&
     ec4:	432f2e2e 	teqmi	pc, #736	; 0x2e0
     ec8:	69626968 	stmdbvs	r2!, {r3, r5, r6, r8, fp, sp, lr}^
     ecc:	6f2f534f 	svcvs	0x002f534f
     ed0:	656b2f73 	strbvs	r2, [fp, #-3955]!	; 0xfffff08d
     ed4:	6c656e72 	stclvs	14, cr6, [r5], #-456	; 0xfffffe38
     ed8:	6372732f 	cmnvs	r2, #-1140850688	; 0xbc000000
     edc:	706f2f00 	rsbvc	r2, pc, r0, lsl #30
     ee0:	6f432f74 	svcvs	0x00432f74
     ee4:	6f536564 	svcvs	0x00536564
     ee8:	65637275 	strbvs	r7, [r3, #-629]!	; 0xfffffd8b
     eec:	532f7972 	teqpl	pc, #1867776	; 0x1c8000
     ef0:	6372756f 	cmnvs	r2, #465567744	; 0x1bc00000
     ef4:	5f797265 	svcpl	0x00797265
     ef8:	65646f43 	strbvs	r6, [r4, #-3907]!	; 0xfffff0bd
     efc:	636e6542 	cmnvs	lr, #276824064	; 0x10800000
     f00:	694c5f68 	stmdbvs	ip, {r3, r5, r6, r8, r9, sl, fp, ip, lr}^
     f04:	665f6574 			; <UNDEFINED> instruction: 0x665f6574
            (mcgClock / (flashDiv  +1)) <= (mcgClock / (busDiv+1)));

    assert( (mcgClock / (flexBusDiv+1)) <= (mcgClock / (busDiv+1)));
     f08:	415f726f 	cmpmi	pc, pc, ror #4
     f0c:	455f4d52 	ldrbmi	r4, [pc, #-3410]	; 1c2 <_vector_rom+0x1c2>
     f10:	2f494241 	svccs	0x00494241
     f14:	2f6e6962 	svccs	0x006e6962
     f18:	6c2f2e2e 	stcvs	14, cr2, [pc], #-184	; e68 <clockSetDividers+0x2c>
     f1c:	672f6269 	strvs	r6, [pc, -r9, ror #4]!
     f20:	612f6363 	teqvs	pc, r3, ror #6
     f24:	6e2d6d72 	mcrvs	13, 1, r6, cr13, cr2, {3}
     f28:	2d656e6f 	stclcs	14, cr6, [r5, #-444]!	; 0xfffffe44
     f2c:	69626165 	stmdbvs	r2!, {r0, r2, r5, r6, r8, sp, lr}^
     f30:	362e342f 	strtcc	r3, [lr], -pc, lsr #8

    /* Save the new dividers */
    clockFreq.systemDiv  = systemDiv;
     f34:	692f312e 	stmdbvs	pc!, {r1, r2, r3, r5, r8, ip, sp}	; <UNPREDICTABLE>
     f38:	756c636e 	strbvc	r6, [ip, #-878]!	; 0xfffffc92
     f3c:	2f006564 	svccs	0x00006564
    clockFreq.busDiv     = busDiv;
     f40:	2f74706f 	svccs	0x0074706f
     f44:	65646f43 	strbvs	r6, [r4, #-3907]!	; 0xfffff0bd
     f48:	72756f53 	rsbsvc	r6, r5, #332	; 0x14c
    clockFreq.flexBusDiv = flexBusDiv;
     f4c:	79726563 	ldmdbvc	r2!, {r0, r1, r5, r6, r8, sl, sp, lr}^
     f50:	756f532f 	strbvc	r5, [pc, #-815]!	; c29 <fei2blpe+0xd>
     f54:	72656372 	rsbvc	r6, r5, #-939524095	; 0xc8000001
    clockFreq.flashDiv   = flashDiv;
     f58:	6f435f79 	svcvs	0x00435f79
     f5c:	65426564 	strbvs	r6, [r2, #-1380]	; 0xfffffa9c
     f60:	5f68636e 	svcpl	0x0068636e

    /* Set the SIM clock dividers */
    SIM_CLKDIV1 = (systemDiv << 28)  |
     f64:	6574694c 	ldrbvs	r6, [r4, #-2380]!	; 0xfffff6b4
     f68:	726f665f 	rsbvc	r6, pc, #99614720	; 0x5f00000
     f6c:	4d52415f 	ldfmie	f4, [r2, #-380]	; 0xfffffe84
                  (busDiv << 24)     |
     f70:	4241455f 	submi	r4, r1, #398458880	; 0x17c00000
     f74:	69622f49 	stmdbvs	r2!, {r0, r3, r6, r8, r9, sl, fp, sp}^
                  (flexBusDiv << 20) |
     f78:	2e2e2f6e 	cdpcs	15, 2, cr2, cr14, cr14, {3}
     f7c:	62696c2f 	rsbvs	r6, r9, #12032	; 0x2f00
                  (flashDiv << 16);
     f80:	6363672f 	cmnvs	r3, #12320768	; 0xbc0000
     f84:	6d72612f 	ldfvse	f6, [r2, #-188]!	; 0xffffff44
    clockFreq.busDiv     = busDiv;
    clockFreq.flexBusDiv = flexBusDiv;
    clockFreq.flashDiv   = flashDiv;

    /* Set the SIM clock dividers */
    SIM_CLKDIV1 = (systemDiv << 28)  |
     f88:	6e6f6e2d 	cdpvs	14, 6, cr6, cr15, cr13, {1}
                  (busDiv << 24)     |
                  (flexBusDiv << 20) |
                  (flashDiv << 16);
}
     f8c:	61652d65 	cmnvs	r5, r5, ror #26
     f90:	342f6962 	strtcc	r6, [pc], #-2402	; f98 <clockGetFreq+0x4>
*
* Grab the clock frequency for a particular clock source in Hz.
*
*******************************************************************************/
uint32_t clockGetFreq(clockSource_t cs)
{
     f94:	312e362e 	teqcc	lr, lr, lsr #12
     f98:	2f2e2e2f 	svccs	0x002e2e2f
     f9c:	2e2f2e2e 	cdpcs	14, 2, cr2, cr15, cr14, {1}
    uint32_t clock;

    switch (cs) {
     fa0:	2e2e2f2e 	cdpcs	15, 2, cr2, cr14, cr14, {1}
     fa4:	6d72612f 	ldfvse	f6, [r2, #-188]!	; 0xffffff44
     fa8:	6e6f6e2d 	cdpvs	14, 6, cr6, cr15, cr13, {1}
     fac:	61652d65 	cmnvs	r5, r5, ror #26
     fb0:	692f6962 	stmdbvs	pc!, {r1, r5, r6, r8, fp, sp, lr}	; <UNPREDICTABLE>
     fb4:	756c636e 	strbvc	r6, [ip, #-878]!	; 0xfffffc92
     fb8:	2e006564 	cfsh32cs	mvfx6, mvfx0, #52
     fbc:	2e2e2f2e 	cdpcs	15, 2, cr2, cr14, cr14, {1}
    case CLOCK_SYSTEM:
        clock = clockFreq.mcgClockFreq / (clockFreq.systemDiv + 1);
     fc0:	6968432f 	stmdbvs	r8!, {r0, r1, r2, r3, r5, r8, r9, lr}^
     fc4:	534f6962 	movtpl	r6, #63842	; 0xf962
     fc8:	2f736f2f 	svccs	0x00736f2f
     fcc:	74726f70 	ldrbtvc	r6, [r2], #-3952	; 0xfffff090
     fd0:	43472f73 	movtmi	r2, #32627	; 0x7f73
     fd4:	52412f43 	subpl	r2, r1, #268	; 0x10c
     fd8:	784d434d 	stmdavc	sp, {r0, r2, r3, r6, r8, r9, lr}^
     fdc:	2f2e2e00 	svccs	0x002e2e00
        break;
    case CLOCK_BUS:
        clock = clockFreq.mcgClockFreq / (clockFreq.busDiv + 1);
     fe0:	432f2e2e 	teqmi	pc, #736	; 0x2e0
     fe4:	69626968 	stmdbvs	r2!, {r3, r5, r6, r8, fp, sp, lr}^
     fe8:	6f2f534f 	svcvs	0x002f534f
     fec:	656b2f73 	strbvs	r2, [fp, #-3955]!	; 0xfffff08d
     ff0:	6c656e72 	stclvs	14, cr6, [r5], #-456	; 0xfffffe38
     ff4:	636e692f 	cmnvs	lr, #770048	; 0xbc000
     ff8:	6564756c 	strbvs	r7, [r4, #-1388]!	; 0xfffffa94
     ffc:	68630000 	stmdavs	r3!, {}^	; <UNPREDICTABLE>
        break;
    case CLOCK_FLEXBUS:
        clock = clockFreq.mcgClockFreq / (clockFreq.flexBusDiv + 1);
    1000:	616e7964 	cmnvs	lr, r4, ror #18
    1004:	2e63696d 	cdpcs	9, 6, cr6, cr3, cr13, {3}
    1008:	00010063 	andeq	r0, r1, r3, rrx
    100c:	64747300 	ldrbtvs	r7, [r4], #-768	; 0xfffffd00
    1010:	2e666564 	cdpcs	5, 6, cr6, cr6, cr4, {3}
    1014:	00020068 	andeq	r0, r2, r8, rrx
    1018:	64747300 	ldrbtvs	r7, [r4], #-768	; 0xfffffd00
    101c:	2e746e69 	cdpcs	14, 7, cr6, cr4, cr9, {3}
        break;
    case CLOCK_FLASH:
        clock = clockFreq.mcgClockFreq / (clockFreq.flashDiv + 1);
    1020:	00030068 	andeq	r0, r3, r8, rrx
    1024:	74686300 	strbtvc	r6, [r8], #-768	; 0xfffffd00
    1028:	73657079 	cmnvc	r5, #121	; 0x79
    102c:	0400682e 	streq	r6, [r0], #-2094	; 0xfffff7d2
    1030:	68630000 	stmdavs	r3!, {}^	; <UNPREDICTABLE>
    1034:	7473696c 	ldrbtvc	r6, [r3], #-2412	; 0xfffff694
    1038:	00682e73 	rsbeq	r2, r8, r3, ror lr
    103c:	63000005 	movwvs	r0, #5
        break;
    default:
        assert(0);
    1040:	72687468 	rsbvc	r7, r8, #104, 8	; 0x68000000
    1044:	73646165 	cmnvc	r4, #1073741849	; 0x40000019
    1048:	0500682e 	streq	r6, [r0, #-2094]	; 0xfffff7d2
    104c:	68630000 	stmdavs	r3!, {}^	; <UNPREDICTABLE>
    }

    return clock;
    1050:	65726f63 	ldrbvs	r6, [r2, #-3939]!	; 0xfffff09d
}
    1054:	6d37765f 	ldcvs	6, cr7, [r7, #-380]!	; 0xfffffe84
    1058:	0400682e 	streq	r6, [r0], #-2094	; 0xfffff7d2
*        ____ STOP ____ (Entered when MCU enters stop mode, and returns to
*                        previous active mode when exits stop mode )
*
*******************************************************************************/
void clockConfigMcgOut(clockConfig_t clockConfig)
{
    105c:	68630000 	stmdavs	r3!, {}^	; <UNPREDICTABLE>
    1060:	2e78746d 	cdpcs	4, 7, cr7, cr8, cr13, {3}
    1064:	00050068 	andeq	r0, r5, r8, rrx
        {  pee2fei,  pee2fee,     NULL,  pee2blpi,  pee2blpe, },
        { blpi2fei, blpi2fee, blpi2pee,      NULL, blpi2blpe, },
        { blpe2fei, blpe2fee, blpe2pee, blpe2blpi,      NULL, },
    };

    assert(clockConfig < MAX_MCG_CLOCK_OPTIONS);
    1068:	6d686300 	stclvs	3, cr6, [r8, #-0]
    106c:	6f636d65 	svcvs	0x00636d65
    1070:	682e6572 	stmdavs	lr!, {r1, r4, r5, r6, r8, sl, sp, lr}
    1074:	00000500 	andeq	r0, r0, r0, lsl #10
    1078:	65686863 	strbvs	r6, [r8, #-2147]!	; 0xfffff79d

    mcgState.nextMode = clockConfigParam[clockConfig].clockMode;
    107c:	682e7061 	stmdavs	lr!, {r0, r5, r6, ip, sp, lr}
    1080:	00000500 	andeq	r0, r0, r0, lsl #10
    1084:	656d6863 	strbvs	r6, [sp, #-2147]!	; 0xfffff79d
    1088:	6f6f706d 	svcvs	0x006f706d
    108c:	682e736c 	stmdavs	lr!, {r2, r3, r5, r6, r8, r9, ip, sp, lr}
    1090:	00000500 	andeq	r0, r0, r0, lsl #10

    jumpTable[mcgState.currentMode][mcgState.nextMode](clockConfig);
    1094:	02050000 	andeq	r0, r5, #0
    1098:	00001e00 	andeq	r1, r0, r0, lsl #28
    109c:	30012c03 	andcc	r2, r1, r3, lsl #24
    10a0:	214b754c 	cmpcs	fp, ip, asr #10
    10a4:	01000302 	tsteq	r0, r2, lsl #6
    10a8:	02050001 	andeq	r0, r5, #1
    10ac:	00001e30 	andeq	r1, r0, r0, lsr lr
    10b0:	0100c203 	tsteq	r0, r3, lsl #4
    10b4:	4fad4c3f 	svcmi	0x00ad4c3f
    10b8:	01040200 	mrseq	r0, R12_usr
    10bc:	4b064a06 	blmi	1938dc <_flash_swap_addr+0x1540dc>
    10c0:	253da094 	ldrcs	sl, [sp, #-148]!	; 0xffffff6c
    10c4:	022467a0 	eoreq	r6, r4, #160, 14	; 0x2800000

    /* Store the new clock frequency for clockGetFreq() */
    clockFreq.mcgClockFreq = clockConfigParam[clockConfig].clockHz;
    10c8:	01010002 	tsteq	r1, r2
    10cc:	c0020500 	andgt	r0, r2, r0, lsl #10
    10d0:	0300001e 	movweq	r0, #30
    10d4:	6a0100fb 	bvs	414c8 <_flash_swap_addr+0x1cc8>
    10d8:	0b033d59 	bleq	d0644 <_flash_swap_addr+0x90e44>
    10dc:	4b914b3c 	blmi	fe453dd4 <_stack_start+0xde443dd4>
    10e0:	02214b59 	eoreq	r4, r1, #91136	; 0x16400
}
    10e4:	01010003 	tsteq	r1, r3
    10e8:	20020500 	andcs	r0, r2, r0, lsl #10

/*******************************************************************************
* clockConfigMcgIr
*******************************************************************************/
void clockConfigMcgIr()
{
    10ec:	0300001f 	movweq	r0, #31
                                                            /* Not configured */
}
    10f0:	6c0101ac 	stfvss	f0, [r1], {172}	; 0xac
    10f4:	0b033d4b 	bleq	d0628 <_flash_swap_addr+0x90e28>

/*******************************************************************************
* clockConfigMcgFf
*******************************************************************************/
void clockConfigMcgFf()
{
    10f8:	4bad4b3c 	blmi	feb53df0 <_stack_start+0xdeb43df0>
                                                            /* Not configured */
}
    10fc:	214b593d 	cmpcs	fp, sp, lsr r9
    1100:	01000302 	tsteq	r0, r2, lsl #6

/*******************************************************************************
* clockConfigMcgFll
*******************************************************************************/
void clockConfigMcgFll()
{
    1104:	00018a01 	andeq	r8, r1, r1, lsl #20
                                                            /* Not configured */
}
    1108:	34000200 	strcc	r0, [r0], #-512	; 0xfffffe00
    110c:	02000001 	andeq	r0, r0, #1

/*******************************************************************************
* clockConfigMcgPll
*******************************************************************************/
void clockConfigMcgPll()
{
    1110:	0d0efb01 	vstreq	d15, [lr, #-4]
                                                            /* Not configured */
}
    1114:	01010100 	mrseq	r0, (UNDEF: 17)
    1118:	00000001 	andeq	r0, r0, r1

/*******************************************************************************
* clockConfigOsc
*******************************************************************************/
void clockConfigOsc()
{
    111c:	01000001 	tsteq	r0, r1
                                                            /* Not configured */
}
    1120:	2e2f2e2e 	cdpcs	14, 2, cr2, cr15, cr14, {1}
    1124:	68432f2e 	stmdavs	r3, {r1, r2, r3, r5, r8, r9, sl, fp, sp}^

/*******************************************************************************
* clockConfigOsc32k
*******************************************************************************/
void clockConfigOsc32k()
{
    1128:	4f696269 	svcmi	0x00696269
                                                            /* Not configured */
}
    112c:	736f2f53 	cmnvc	pc, #332	; 0x14c
    1130:	72656b2f 	rsbvc	r6, r5, #48128	; 0xbc00

/*******************************************************************************
* clockConfigEr32k
*******************************************************************************/
void clockConfigEr32k()
{
    1134:	2f6c656e 	svccs	0x006c656e
                                                            /* Not configured */
}
    1138:	00637273 	rsbeq	r7, r3, r3, ror r2
    113c:	74706f2f 	ldrbtvc	r6, [r0], #-3887	; 0xfffff0d1

/*******************************************************************************
* clockConfigRtc
*******************************************************************************/
void clockConfigRtc()
{
    1140:	646f432f 	strbtvs	r4, [pc], #-815	; 1148 <clockConfigRtc+0x8>
                                                            /* Not configured */
}
    1144:	756f5365 	strbvc	r5, [pc, #-869]!	; de7 <blpi2blpe+0xf>
    1148:	72656372 	rsbvc	r6, r5, #-939524095	; 0xc8000001

/*******************************************************************************
* clockConfigLpo
*******************************************************************************/
void clockConfigLpo()
{
    114c:	6f532f79 	svcvs	0x00532f79
                                                            /* Not configured */
}
    1150:	65637275 	strbvs	r7, [r3, #-629]!	; 0xfffffd8b
    1154:	435f7972 	cmpmi	pc, #1867776	; 0x1c8000
*
* RETURNS: Nothing
*
*******************************************************************************/
void watchDogUnlock()
{
    1158:	4265646f 	rsbmi	r6, r5, #1862270976	; 0x6f000000
        " :
        /* No output */ :
        /* No input  */ :
        "r0", "r1" ); /* Specify which registers we destroy */
#else
    wdPtr->unlock = WDOG_UNLOCK_KEY_1;
    115c:	68636e65 	stmdavs	r3!, {r0, r2, r5, r6, r9, sl, fp, sp, lr}^
    1160:	74694c5f 	strbtvc	r4, [r9], #-3167	; 0xfffff3a1
    1164:	6f665f65 	svcvs	0x00665f65
    1168:	52415f72 	subpl	r5, r1, #456	; 0x1c8
    wdPtr->unlock = WDOG_UNLOCK_KEY_2;
    116c:	41455f4d 	cmpmi	r5, sp, asr #30
    1170:	622f4942 	eorvs	r4, pc, #1081344	; 0x108000
    1174:	2e2f6e69 	cdpcs	14, 2, cr6, cr15, cr9, {3}
    1178:	696c2f2e 	stmdbvs	ip!, {r1, r2, r3, r5, r8, r9, sl, fp, sp}^
#endif
    /* NOTE: Need to wait one clock cycle before updating any registers */
}
    117c:	63672f62 	cmnvs	r7, #392	; 0x188
    1180:	72612f63 	rsbvc	r2, r1, #396	; 0x18c

/*******************************************************************************
* watchDogInit
*******************************************************************************/
void watchDogInit(const watchDogConfig_t *wdCfgPtr)
{
    1184:	6f6e2d6d 	svcvs	0x006e2d6d
    1188:	652d656e 	strvs	r6, [sp, #-1390]!	; 0xfffffa92
    watchDogUnlock();
    118c:	2f696261 	svccs	0x00696261
        " :
        /* No output */ :
        /* No input  */ :
        "r0", "r1", "r2" ); /* Specify which registers we destroy */
#else
    assert(wdCfgPtr->window < wdCfgPtr->timeout);
    1190:	2e362e34 	mrccs	14, 1, r2, cr6, cr4, {1}
    1194:	6e692f31 	mcrvs	15, 3, r2, cr9, cr1, {1}
    1198:	64756c63 	ldrbtvs	r6, [r5], #-3171	; 0xfffff39d
    119c:	6f2f0065 	svcvs	0x002f0065
    11a0:	432f7470 	teqmi	pc, #112, 8	; 0x70000000
    11a4:	5365646f 	cmnpl	r5, #1862270976	; 0x6f000000
    11a8:	6372756f 	cmnvs	r2, #465567744	; 0x1bc00000

    wdPtr->toValL  = wdCfgPtr->timeout;
    11ac:	2f797265 	svccs	0x00797265
    11b0:	72756f53 	rsbsvc	r6, r5, #332	; 0x14c
    11b4:	79726563 	ldmdbvc	r2!, {r0, r1, r5, r6, r8, sl, sp, lr}^
    11b8:	646f435f 	strbtvs	r4, [pc], #-863	; 11c0 <watchDogInit+0x3c>
    11bc:	6e654265 	cdpvs	2, 6, cr4, cr5, cr5, {3}
    wdPtr->toValH  = wdCfgPtr->timeout >> 16;
    11c0:	4c5f6863 	mrrcmi	8, 6, r6, pc, cr3	; <UNPREDICTABLE>
    11c4:	5f657469 	svcpl	0x00657469
    11c8:	5f726f66 	svcpl	0x00726f66
    11cc:	5f4d5241 	svcpl	0x004d5241
    11d0:	49424145 	stmdbmi	r2, {r0, r2, r6, r8, lr}^
    wdPtr->stCtrlH = wdCfgPtr->stCtrlFlags;
    11d4:	6e69622f 	cdpvs	2, 6, cr6, cr9, cr15, {1}
    11d8:	2f2e2e2f 	svccs	0x002e2e2f
    11dc:	2f62696c 	svccs	0x0062696c
    11e0:	2f636367 	svccs	0x00636367
    wdPtr->presc   = wdCfgPtr->prescaler;
    11e4:	2d6d7261 	sfmcs	f7, 2, [sp, #-388]!	; 0xfffffe7c
    11e8:	656e6f6e 	strbvs	r6, [lr, #-3950]!	; 0xfffff092
    11ec:	6261652d 	rsbvs	r6, r1, #188743680	; 0xb400000
    11f0:	2e342f69 	cdpcs	15, 3, cr2, cr4, cr9, {3}
    wdPtr->winL    = wdCfgPtr->window;
    11f4:	2f312e36 	svccs	0x00312e36
    11f8:	2e2f2e2e 	cdpcs	14, 2, cr2, cr15, cr14, {1}
    11fc:	2e2e2f2e 	cdpcs	15, 2, cr2, cr14, cr14, {1}
    1200:	2f2e2e2f 	svccs	0x002e2e2f
    1204:	2d6d7261 	sfmcs	f7, 2, [sp, #-388]!	; 0xfffffe7c
    wdPtr->winH    = wdCfgPtr->window >> 16;
    1208:	656e6f6e 	strbvs	r6, [lr, #-3950]!	; 0xfffff092
    120c:	6261652d 	rsbvs	r6, r1, #188743680	; 0xb400000
    1210:	6e692f69 	cdpvs	15, 6, cr2, cr9, cr9, {3}
    1214:	64756c63 	ldrbtvs	r6, [r5], #-3171	; 0xfffff39d
    1218:	63000065 	movwvs	r0, #101	; 0x65
    }
    if (wdCfgPtr->stCtrlFlags & WDOG_TEST) {
        /* TODO: If anyone cares let me know */
    }
#endif
}
    121c:	6d656d68 	stclvs	13, cr6, [r5, #-416]!	; 0xfffffe60
    1220:	65726f63 	ldrbvs	r6, [r2, #-3939]!	; 0xfffff09d

/* RFI: Could probably move these elsewhere for general consumption */
static void interruptDisable()
{
    1224:	0100632e 	tsteq	r0, lr, lsr #6
    asm volatile("\n\
    1228:	74730000 	ldrbtvc	r0, [r3], #-0
        cpsid i\n\
        " :
        /* No output */ :
        /* No input  */ :
        ); /* Specify which registers we destroy */
}
    122c:	66656464 	strbtvs	r6, [r5], -r4, ror #8
static void interruptEnable()
{
    1230:	0200682e 	andeq	r6, r0, #3014656	; 0x2e0000
    asm volatile("\n\
    1234:	74730000 	ldrbtvc	r0, [r3], #-0
        cpsie i\n\
        " :
        /* No output */ :
        /* No input  */ :
        ); /* Specify which registers we destroy */
}
    1238:	746e6964 	strbtvc	r6, [lr], #-2404	; 0xfffff69c

/*******************************************************************************
* watchDogKick
*******************************************************************************/
void watchDogKick()
{
    123c:	0300682e 	movweq	r6, #2094	; 0x82e
        " :
        /* No output */ :
        /* No input  */ :
        "r0", "r1" ); /* Specify which registers we destroy */
#else
    interruptDisable();
    1240:	00000000 	andeq	r0, r0, r0
    wdPtr->refresh = WDOG_REFRESH_KEY_1;
    1244:	1f900205 	svcne	0x00900205
    1248:	3a030000 	bcc	c1250 <_flash_swap_addr+0x81a50>
    124c:	c0d71601 	sbcsgt	r1, r7, r1, lsl #12
    1250:	01000102 	tsteq	r0, r2, lsl #2
    wdPtr->refresh = WDOG_REFRESH_KEY_2;
    1254:	02050001 	andeq	r0, r5, #1
    1258:	00001fd0 	ldrdeq	r1, [r0], -r0
    125c:	0100d303 	tsteq	r0, r3, lsl #6
    1260:	4b4b4b3f 	blmi	12d3f64 <_flash_swap_addr+0x1294764>
    interruptEnable();
    1264:	00030221 	andeq	r0, r3, r1, lsr #4
#endif
}
    1268:	05000101 	streq	r0, [r0, #-257]	; 0xfffffeff

/*******************************************************************************
* watchDogDisable
*******************************************************************************/
void watchDogDisable()
{
    126c:	00200002 	eoreq	r0, r0, r2
    watchDogUnlock();
    1270:	00e80300 	rsceq	r0, r8, r0, lsl #6
        " :
        /* No output */ :
        /* No input  */ :
        "r0", "r1" ); /* Specify which registers we destroy */
#else
    wdPtr->stCtrlH = WDOG_STNDBYEN | WDOG_WAITEN | WDOG_STOPEN
    1274:	f3673301 	vcgt.u32	d19, d7, d1
    1278:	21bb673d 			; <UNDEFINED> instruction: 0x21bb673d
    127c:	01000302 	tsteq	r0, r2, lsl #6
    1280:	02050001 	andeq	r0, r5, #1
                   | WDOG_ALLOWUPDATE;
#endif
}
    1284:	00002070 	andeq	r2, r0, r0, ror r0
    1288:	0100fc03 	tsteq	r0, r3, lsl #24
    128c:	0202bb14 	andeq	fp, r2, #20, 22	; 0x5000
 *          that this thread is executed only if there are no other ready
 *          threads in the system.
 *
 * @param[in] p the thread parameter, unused in this scenario
 */
void _idle_thread(void *p) {
    1290:	ad010100 	stfges	f0, [r1, #-0]

  (void)p;
  chRegSetThreadName("idle");
    1294:	02000002 	andeq	r0, r0, #2
    1298:	0001d200 	andeq	sp, r1, r0, lsl #4
    129c:	fb010200 	blx	41aa6 <_flash_swap_addr+0x22a6>
    12a0:	01000d0e 	tsteq	r0, lr, lsl #26
    12a4:	00010101 	andeq	r0, r1, r1, lsl #2
  while (TRUE) {
    port_wait_for_interrupt();
    IDLE_LOOP_HOOK();
  }
    12a8:	00010000 	andeq	r0, r1, r0
    12ac:	2e2e0100 	sufcse	f0, f6, f0
 * @note    This function has special, architecture-dependent, requirements,
 *          see the notes into the various port reference manuals.
 *
 * @special
 */
void chSysInit(void) {
    12b0:	2f2e2e2f 	svccs	0x002e2e2f
  static Thread mainthread;
#if CH_DBG_ENABLE_STACK_CHECK
  extern stkalign_t __main_thread_stack_base__;
#endif

  port_init();
    12b4:	62696843 	rsbvs	r6, r9, #4390912	; 0x430000
  _scheduler_init();
    12b8:	2f534f69 	svccs	0x00534f69
  _vt_init();
    12bc:	6b2f736f 	blvs	bde080 <_flash_swap_addr+0xb9e880>
#if CH_USE_MEMCORE
  _core_init();
    12c0:	656e7265 	strbvs	r7, [lr, #-613]!	; 0xfffffd9b
#endif
#if CH_USE_HEAP
  _heap_init();
    12c4:	72732f6c 	rsbsvc	r2, r3, #108, 30	; 0x1b0
#if CH_DBG_ENABLE_TRACE
  _trace_init();
#endif

  /* Now this instructions flow becomes the main thread.*/
  setcurrp(_thread_init(&mainthread, NORMALPRIO));
    12c8:	6f2f0063 	svcvs	0x002f0063
    12cc:	432f7470 	teqmi	pc, #112, 8	; 0x70000000
    12d0:	5365646f 	cmnpl	r5, #1862270976	; 0x6f000000
    12d4:	6372756f 	cmnvs	r2, #465567744	; 0x1bc00000
    12d8:	2f797265 	svccs	0x00797265
    12dc:	72756f53 	rsbsvc	r6, r5, #332	; 0x14c
    12e0:	79726563 	ldmdbvc	r2!, {r0, r1, r5, r6, r8, sl, sp, lr}^
  currp->p_state = THD_STATE_CURRENT;
    12e4:	646f435f 	strbtvs	r4, [pc], #-863	; 12ec <chSysInit+0x3c>
    12e8:	6e654265 	cdpvs	2, 6, cr4, cr5, cr5, {3}
    12ec:	4c5f6863 	mrrcmi	8, 6, r6, pc, cr3	; <UNPREDICTABLE>
    12f0:	5f657469 	svcpl	0x00657469
#if CH_DBG_ENABLE_STACK_CHECK
  /* This is a special case because the main thread Thread structure is not
     adjacent to its stack area.*/
  currp->p_stklimit = &__main_thread_stack_base__;
#endif
  chSysEnable();
    12f4:	5f726f66 	svcpl	0x00726f66
    12f8:	5f4d5241 	svcpl	0x004d5241
    12fc:	49424145 	stmdbmi	r2, {r0, r2, r6, r8, lr}^

  chRegSetThreadName("main");
    1300:	6e69622f 	cdpvs	2, 6, cr6, cr9, cr15, {1}
    1304:	2f2e2e2f 	svccs	0x002e2e2f
    1308:	2f62696c 	svccs	0x0062696c
    130c:	2f636367 	svccs	0x00636367
    1310:	2d6d7261 	sfmcs	f7, 2, [sp, #-388]!	; 0xfffffe7c

#if !CH_NO_IDLE_THREAD
  /* This thread has the lowest priority in the system, its role is just to
     serve interrupts in its context while keeping the lowest energy saving
     mode compatible with the system status.*/
  chThdCreateStatic(_idle_thread_wa, sizeof(_idle_thread_wa), IDLEPRIO,
    1314:	656e6f6e 	strbvs	r6, [lr, #-3950]!	; 0xfffff092
    1318:	6261652d 	rsbvs	r6, r1, #188743680	; 0xb400000
    131c:	2e342f69 	cdpcs	15, 3, cr2, cr4, cr9, {3}
    1320:	2f312e36 	svccs	0x00312e36
    1324:	6c636e69 	stclvs	14, cr6, [r3], #-420	; 0xfffffe5c
    1328:	00656475 	rsbeq	r6, r5, r5, ror r4
    132c:	74706f2f 	ldrbtvc	r6, [r0], #-3887	; 0xfffff0d1
    1330:	646f432f 	strbtvs	r4, [pc], #-815	; 1338 <chSysInit+0x88>
                    (tfunc_t)_idle_thread, NULL);
#endif
}
    1334:	756f5365 	strbvc	r5, [pc, #-869]!	; fd7 <clockGetFreq+0x43>
    1338:	72656372 	rsbvc	r6, r5, #-939524095	; 0xc8000001
    133c:	6f532f79 	svcvs	0x00532f79
 *          and, together with the @p CH_TIME_QUANTUM macro, the round robin
 *          interval.
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {
    1340:	65637275 	strbvs	r7, [r3, #-629]!	; 0xfffffd8b

  chDbgCheckClassI();

#if CH_TIME_QUANTUM > 0
  /* Running thread has not used up quantum yet? */
  if (currp->p_preempt > 0)
    1344:	435f7972 	cmpmi	pc, #1867776	; 0x1c8000
    1348:	4265646f 	rsbmi	r6, r5, #1862270976	; 0x6f000000
    134c:	68636e65 	stmdavs	r3!, {r0, r2, r5, r6, r9, sl, fp, sp, lr}^
    1350:	74694c5f 	strbtvc	r4, [r9], #-3167	; 0xfffff3a1
    /* Decrement remaining quantum.*/
    currp->p_preempt--;
    1354:	6f665f65 	svcvs	0x00665f65
    1358:	52415f72 	subpl	r5, r1, #456	; 0x1c8
    135c:	41455f4d 	cmpmi	r5, sp, asr #30
    1360:	622f4942 	eorvs	r4, pc, #1081344	; 0x108000
    1364:	2e2f6e69 	cdpcs	14, 2, cr6, cr15, cr9, {3}
#endif
#if CH_DBG_THREADS_PROFILING
  currp->p_time++;
    1368:	696c2f2e 	stmdbvs	ip!, {r1, r2, r3, r5, r8, r9, sl, fp, sp}^
    136c:	63672f62 	cmnvs	r7, #392	; 0x188
    1370:	72612f63 	rsbvc	r2, r1, #396	; 0x18c
    1374:	6f6e2d6d 	svcvs	0x006e2d6d
    1378:	652d656e 	strvs	r6, [sp, #-1390]!	; 0xfffffa92
#endif
  chVTDoTickI();
    137c:	2f696261 	svccs	0x00696261
    1380:	2e362e34 	mrccs	14, 1, r2, cr6, cr4, {1}
    1384:	2e2e2f31 	mcrcs	15, 1, r2, cr14, cr1, {1}
    1388:	2f2e2e2f 	svccs	0x002e2e2f
    138c:	2e2f2e2e 	cdpcs	14, 2, cr2, cr15, cr14, {1}
    1390:	72612f2e 	rsbvc	r2, r1, #46, 30	; 0xb8
    1394:	6f6e2d6d 	svcvs	0x006e2d6d
    1398:	652d656e 	strvs	r6, [sp, #-1390]!	; 0xfffffa92
    139c:	2f696261 	svccs	0x00696261
    13a0:	6c636e69 	stclvs	14, cr6, [r3], #-420	; 0xfffffe5c
    13a4:	00656475 	rsbeq	r6, r5, r5, ror r4
    13a8:	2e2f2e2e 	cdpcs	14, 2, cr2, cr15, cr14, {1}
    13ac:	68432f2e 	stmdavs	r3, {r1, r2, r3, r5, r8, r9, sl, fp, sp}^
    13b0:	4f696269 	svcmi	0x00696269
    13b4:	736f2f53 	cmnvc	pc, #332	; 0x14c
    13b8:	726f702f 	rsbvc	r7, pc, #47	; 0x2f
    13bc:	472f7374 			; <UNDEFINED> instruction: 0x472f7374
    13c0:	412f4343 	teqmi	pc, r3, asr #6
    13c4:	4d434d52 	stclmi	13, cr4, [r3, #-328]	; 0xfffffeb8
    13c8:	2e2e0078 	mcrcs	0, 1, r0, cr14, cr8, {3}
    13cc:	2f2e2e2f 	svccs	0x002e2e2f
    13d0:	62696843 	rsbvs	r6, r9, #4390912	; 0x430000
    13d4:	2f534f69 	svccs	0x00534f69
    13d8:	6b2f736f 	blvs	bde19c <_flash_swap_addr+0xb9e99c>
    13dc:	656e7265 	strbvs	r7, [lr, #-613]!	; 0xfffffd9b
    13e0:	6e692f6c 	cdpvs	15, 6, cr2, cr9, cr12, {3}
    13e4:	64756c63 	ldrbtvs	r6, [r5], #-3171	; 0xfffff39d
    13e8:	63000065 	movwvs	r0, #101	; 0x65
    13ec:	61656868 	cmnvs	r5, r8, ror #16
    13f0:	00632e70 	rsbeq	r2, r3, r0, ror lr
    13f4:	73000001 	movwvc	r0, #1
    13f8:	65646474 	strbvs	r6, [r4, #-1140]!	; 0xfffffb8c
    13fc:	00682e66 	rsbeq	r2, r8, r6, ror #28
    1400:	73000002 	movwvc	r0, #2
    1404:	6e696474 	mcrvs	4, 3, r6, cr9, cr4, {3}
    1408:	00682e74 	rsbeq	r2, r8, r4, ror lr
    140c:	63000003 	movwvs	r0, #3
    1410:	70797468 	rsbsvc	r7, r9, r8, ror #8
#if defined(SYSTEM_TICK_EVENT_HOOK)
  SYSTEM_TICK_EVENT_HOOK();
#endif
}
    1414:	682e7365 	stmdavs	lr!, {r0, r2, r5, r6, r8, r9, ip, sp, lr}
    1418:	00000400 	andeq	r0, r0, r0, lsl #8
    141c:	696c6863 	stmdbvs	ip!, {r0, r1, r5, r6, fp, sp, lr}^
 *
 * @notapi
 */
void _vt_init(void) {

  vtlist.vt_next = vtlist.vt_prev = (void *)&vtlist;
    1420:	2e737473 	mrccs	4, 3, r7, cr3, cr3, {3}
    1424:	00050068 	andeq	r0, r5, r8, rrx
    1428:	74686300 	strbtvc	r6, [r8], #-768	; 0xfffffd00
    142c:	61657268 	cmnvs	r5, r8, ror #4
    1430:	682e7364 	stmdavs	lr!, {r2, r5, r6, r8, r9, ip, sp, lr}
    1434:	00000500 	andeq	r0, r0, r0, lsl #10
    1438:	6f636863 	svcvs	0x00636863
    143c:	765f6572 			; <UNDEFINED> instruction: 0x765f6572
    1440:	682e6d37 	stmdavs	lr!, {r0, r1, r2, r4, r5, r8, sl, fp, sp, lr}
    1444:	00000400 	andeq	r0, r0, r0, lsl #8
  vtlist.vt_time = (systime_t)-1;
    1448:	746d6863 	strbtvc	r6, [sp], #-2147	; 0xfffff79d
    144c:	00682e78 	rsbeq	r2, r8, r8, ror lr
    1450:	63000005 	movwvs	r0, #5
  vtlist.vt_systime = 0;
    1454:	6d656d68 	stclvs	13, cr6, [r5, #-416]!	; 0xfffffe60
    1458:	65726f63 	ldrbvs	r6, [r2, #-3939]!	; 0xfffff09d
    145c:	0500682e 	streq	r6, [r0, #-2094]	; 0xfffff7d2
    1460:	68630000 	stmdavs	r3!, {}^	; <UNPREDICTABLE>
    1464:	70616568 	rsbvc	r6, r1, r8, ror #10
    1468:	0500682e 	streq	r6, [r0, #-2094]	; 0xfffff7d2
    146c:	00000000 	andeq	r0, r0, r0
 * @param[in] par       a parameter that will be passed to the callback
 *                      function
 *
 * @iclass
 */
void chVTSetI(VirtualTimer *vtp, systime_t time, vtfunc_t vtfunc, void *par) {
    1470:	20900205 	addscs	r0, r0, r5, lsl #4
    1474:	c3030000 	movwgt	r0, #12288	; 0x3000
    1478:	91210100 	teqls	r1, r0, lsl #2
  VirtualTimer *p;

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (time != TIME_IMMEDIATE),
    147c:	02407675 	subeq	r7, r0, #122683392	; 0x7500000
    1480:	01010003 	tsteq	r1, r3
    1484:	d0020500 	andle	r0, r2, r0, lsl #10
    1488:	03000020 	movweq	r0, #32
             "chVTSetI");

  vtp->vt_par = par;
    148c:	5b0100db 	blpl	41800 <_flash_swap_addr+0x2000>
  vtp->vt_func = vtfunc;
    1490:	01040200 	mrseq	r0, R12_usr
    1494:	4c065806 	stcmi	8, cr5, [r6], {6}
  p = vtlist.vt_next;
    1498:	4b4b594b 	blmi	12d79cc <_flash_swap_addr+0x12981cc>
    149c:	02026a5a 	andeq	r6, r2, #368640	; 0x5a000
    14a0:	00010100 	andeq	r0, r1, r0, lsl #2
  while (p->vt_time < time) {
    time -= p->vt_time;
    14a4:	21300205 	teqcs	r0, r5, lsl #4
    14a8:	fc030000 	stc2	0, cr0, [r3], {-0}
    14ac:	3d4d0100 	stfcce	f0, [sp, #-0]
    p = p->vt_next;
    14b0:	684b675a 	stmdavs	fp, {r1, r3, r4, r6, r8, r9, sl, sp, lr}^
             "chVTSetI");

  vtp->vt_par = par;
  vtp->vt_func = vtfunc;
  p = vtlist.vt_next;
  while (p->vt_time < time) {
    14b4:	78593d21 	ldmdavc	r9, {r0, r5, r8, sl, fp, ip, sp}^
    14b8:	834b675c 	movthi	r6, #46940	; 0xb75c
    14bc:	2f3e3e3d 	svccs	0x003e3e3d
    time -= p->vt_time;
    p = p->vt_next;
  }

  vtp->vt_prev = (vtp->vt_next = p)->vt_prev;
    14c0:	0402004c 	streq	r0, [r2], #-76	; 0xffffffb4
    14c4:	2e6a0301 	cdpcs	3, 6, cr0, cr10, cr1, {0}
    14c8:	324a1903 	subcc	r1, sl, #49152	; 0xc000
    14cc:	3d3d834b 	ldccc	3, cr8, [sp, #-300]!	; 0xfffffed4
  vtp->vt_prev->vt_next = p->vt_prev = vtp;
    14d0:	2f314b3d 	svccs	0x00314b3d
    14d4:	01000302 	tsteq	r0, r2, lsl #6
    14d8:	02050001 	andeq	r0, r5, #1
    14dc:	00002230 	andeq	r2, r0, r0, lsr r2
  vtp->vt_time = time;
    14e0:	0101ba03 	tsteq	r1, r3, lsl #20
  if (p != (void *)&vtlist)
    14e4:	4b3d4b42 	blmi	f541f4 <_flash_swap_addr+0xf149f4>
    14e8:	03667703 	cmneq	r6, #786432	; 0xc0000
    14ec:	74034a0c 	strvc	r4, [r3], #-2572	; 0xfffff5f4
    14f0:	20100382 	andscs	r0, r0, r2, lsl #7
    p->vt_time -= time;
    14f4:	02040200 	andeq	r0, r4, #0, 4
    14f8:	02006606 	andeq	r6, r0, #6291456	; 0x600000
    14fc:	4b060104 	blmi	181914 <_flash_swap_addr+0x142114>
}
    1500:	01040200 	mrseq	r0, R12_usr
    1504:	4b5a2f2d 	blmi	168d1c0 <_flash_swap_addr+0x164d9c0>
    1508:	5a9fa03e 	bpl	fe7e9608 <_stack_start+0xde7d9608>
    150c:	224c9192 	subcs	r9, ip, #-2147483612	; 0x80000024
 *
 * @param[in] vtp       the @p VirtualTimer structure pointer
 *
 * @iclass
 */
void chVTResetI(VirtualTimer *vtp) {
    1510:	30251d3d 	eorcc	r1, r5, sp, lsr sp
  chDbgCheck(vtp != NULL, "chVTResetI");
  chDbgAssert(vtp->vt_func != NULL,
              "chVTResetI(), #1",
              "timer not set or already triggered");

  if (vtp->vt_next != (void *)&vtlist)
    1514:	01000202 	tsteq	r0, r2, lsl #4
    1518:	02050001 	andeq	r0, r5, #1
    151c:	00002320 	andeq	r2, r0, r0, lsr #6
    1520:	0101f203 	tsteq	r1, r3, lsl #4
    vtp->vt_next->vt_time += vtp->vt_time;
    1524:	685a3d4e 	ldmdavs	sl, {r1, r2, r3, r6, r8, sl, fp, ip, sp}^
    1528:	0402003d 	streq	r0, [r2], #-61	; 0xffffffc3
    152c:	02008302 	andeq	r8, r0, #134217728	; 0x8000000
    1530:	00650204 	rsbeq	r0, r5, r4, lsl #4
    1534:	06010402 	streq	r0, [r1], -r2, lsl #8
  vtp->vt_prev->vt_next = vtp->vt_next;
    1538:	3d4c0674 	stclcc	6, cr0, [ip, #-464]	; 0xfffffe30
    153c:	02212f3e 	eoreq	r2, r1, #62, 30	; 0xf8
  vtp->vt_next->vt_prev = vtp->vt_prev;
    1540:	01010003 	tsteq	r1, r3
    1544:	00000216 	andeq	r0, r0, r6, lsl r2
    1548:	01740002 	cmneq	r4, r2
  vtp->vt_func = (vtfunc_t)NULL;
    154c:	01020000 	mrseq	r0, (UNDEF: 2)
    1550:	000d0efb 	strdeq	r0, [sp], -fp
}
    1554:	01010101 	tsteq	r1, r1, lsl #2
    1558:	01000000 	mrseq	r0, (UNDEF: 0)
    155c:	2e010000 	cdpcs	0, 0, cr0, cr1, cr0, {0}
 * @retval TRUE         current time within the specified time window.
 * @retval FALSE        current time not within the specified time window.
 *
 * @api
 */
bool_t chTimeIsWithin(systime_t start, systime_t end) {
    1560:	2e2e2f2e 	cdpcs	15, 2, cr2, cr14, cr14, {1}
    1564:	6968432f 	stmdbvs	r8!, {r0, r1, r2, r3, r5, r8, r9, lr}^

  systime_t time = chTimeNow();
    1568:	534f6962 	movtpl	r6, #63842	; 0xf962
    156c:	2f736f2f 	svccs	0x00736f2f
    1570:	6e72656b 	cdpvs	5, 7, cr6, cr2, cr11, {3}
  return end > start ? (time >= start) && (time < end) :
    1574:	732f6c65 	teqvc	pc, #25856	; 0x6500
    1578:	2f006372 	svccs	0x00006372
    157c:	2f74706f 	svccs	0x0074706f
    1580:	65646f43 	strbvs	r6, [r4, #-3907]!	; 0xfffff0bd
    1584:	72756f53 	rsbsvc	r6, r5, #332	; 0x14c
    1588:	79726563 	ldmdbvc	r2!, {r0, r1, r5, r6, r8, sl, sp, lr}^
    158c:	756f532f 	strbvc	r5, [pc, #-815]!	; 1265 <watchDogKick+0x29>
    1590:	72656372 	rsbvc	r6, r5, #-939524095	; 0xc8000001
    1594:	6f435f79 	svcvs	0x00435f79
    1598:	65426564 	strbvs	r6, [r2, #-1380]	; 0xfffffa9c
    159c:	5f68636e 	svcpl	0x0068636e
                       (time >= start) || (time < end);
    15a0:	6574694c 	ldrbvs	r6, [r4, #-2380]!	; 0xfffff6b4
    15a4:	726f665f 	rsbvc	r6, pc, #99614720	; 0x5f00000
 * @api
 */
bool_t chTimeIsWithin(systime_t start, systime_t end) {

  systime_t time = chTimeNow();
  return end > start ? (time >= start) && (time < end) :
    15a8:	4d52415f 	ldfmie	f4, [r2, #-380]	; 0xfffffe84
    15ac:	4241455f 	submi	r4, r1, #398458880	; 0x17c00000
                       (time >= start) || (time < end);
}
    15b0:	69622f49 	stmdbvs	r2!, {r0, r3, r6, r8, r9, sl, fp, sp}^
    15b4:	2e2e2f6e 	cdpcs	15, 2, cr2, cr14, cr14, {3}
    15b8:	62696c2f 	rsbvs	r6, r9, #12032	; 0x2f00
    15bc:	6363672f 	cmnvs	r3, #12320768	; 0xbc0000
  tp->p_next = (Thread *)tqp;
  tp->p_prev = tqp->p_prev;
  tp->p_prev->p_next = tqp->p_prev = tp;
}

static INLINE Thread *fifo_remove(ThreadsQueue *tqp) {
    15c0:	6d72612f 	ldfvse	f6, [r2, #-188]!	; 0xffffff44
  Thread *tp = tqp->p_next;
    15c4:	6e6f6e2d 	cdpvs	14, 6, cr6, cr15, cr13, {1}
    15c8:	61652d65 	cmnvs	r5, r5, ror #26

  (tqp->p_next = tp->p_next)->p_prev = (Thread *)tqp;
    15cc:	342f6962 	strtcc	r6, [pc], #-2402	; 15d4 <fifo_remove+0x14>
    15d0:	312e362e 	teqcc	lr, lr, lsr #12
    15d4:	636e692f 	cmnvs	lr, #770048	; 0xbc000
    15d8:	6564756c 	strbvs	r7, [r4, #-1388]!	; 0xfffffa94
  return tp;
}
    15dc:	706f2f00 	rsbvc	r2, pc, r0, lsl #30
    15e0:	6f432f74 	svcvs	0x00432f74
    15e4:	6f536564 	svcvs	0x00536564
    15e8:	65637275 	strbvs	r7, [r3, #-629]!	; 0xfffffd8b
    15ec:	532f7972 	teqpl	pc, #1867776	; 0x1c8000

  (tqp->p_prev = tp->p_prev)->p_next = (Thread *)tqp;
  return tp;
}

static INLINE Thread *dequeue(Thread *tp) {
    15f0:	6372756f 	cmnvs	r2, #465567744	; 0x1bc00000

  tp->p_prev->p_next = tp->p_next;
    15f4:	5f797265 	svcpl	0x00797265
    15f8:	65646f43 	strbvs	r6, [r4, #-3907]!	; 0xfffff0bd
    15fc:	636e6542 	cmnvs	lr, #276824064	; 0x10800000
  tp->p_next->p_prev = tp->p_prev;
    1600:	694c5f68 	stmdbvs	ip, {r3, r5, r6, r8, r9, sl, fp, ip, lr}^
    1604:	665f6574 			; <UNDEFINED> instruction: 0x665f6574
  return tp;
    1608:	415f726f 	cmpmi	pc, pc, ror #4
}
    160c:	455f4d52 	ldrbmi	r4, [pc, #-3410]	; 8c2 <STACK_SIZE+0xc2>
 *
 * @notapi
 */
void _scheduler_init(void) {

  queue_init(&rlist.r_queue);
    1610:	2f494241 	svccs	0x00494241
    1614:	2f6e6962 	svccs	0x006e6962
    1618:	6c2f2e2e 	stcvs	14, cr2, [pc], #-184	; 1568 <chTimeIsWithin+0x8>
    161c:	672f6269 	strvs	r6, [pc, -r9, ror #4]!
    1620:	612f6363 	teqvs	pc, r3, ror #6
    1624:	6e2d6d72 	mcrvs	13, 1, r6, cr13, cr2, {3}
    1628:	2d656e6f 	stclcs	14, cr6, [r5, #-444]!	; 0xfffffe44
    162c:	69626165 	stmdbvs	r2!, {r0, r2, r5, r6, r8, sp, lr}^
    1630:	362e342f 	strtcc	r3, [lr], -pc, lsr #8
    1634:	2e2f312e 	sufcsep	f3, f7, #0.5
  rlist.r_prio = NOPRIO;
    1638:	2e2e2f2e 	cdpcs	15, 2, cr2, cr14, cr14, {1}
    163c:	2f2e2e2f 	svccs	0x002e2e2f
    1640:	612f2e2e 	teqvs	pc, lr, lsr #28
#if CH_USE_REGISTRY
  rlist.r_newer = rlist.r_older = (Thread *)&rlist;
    1644:	6e2d6d72 	mcrvs	13, 1, r6, cr13, cr2, {3}
    1648:	2d656e6f 	stclcs	14, cr6, [r5, #-444]!	; 0xfffffe44
    164c:	69626165 	stmdbvs	r2!, {r0, r2, r5, r6, r8, sp, lr}^
    1650:	636e692f 	cmnvs	lr, #770048	; 0xbc000
    1654:	6564756c 	strbvs	r7, [r4, #-1388]!	; 0xfffffa94
    1658:	2f2e2e00 	svccs	0x002e2e00
    165c:	432f2e2e 	teqmi	pc, #736	; 0x2e0
    1660:	69626968 	stmdbvs	r2!, {r3, r5, r6, r8, fp, sp, lr}^
    1664:	6f2f534f 	svcvs	0x002f534f
    1668:	656b2f73 	strbvs	r2, [fp, #-3955]!	; 0xfffff08d
    166c:	6c656e72 	stclvs	14, cr6, [r5], #-456	; 0xfffffe38
 * @return              The thread pointer.
 *
 * @iclass
 */
#if !defined(PORT_OPTIMIZED_READYI) || defined(__DOXYGEN__)
Thread *chSchReadyI(Thread *tp) {
    1670:	636e692f 	cmnvs	lr, #770048	; 0xbc000
  Thread *cp;

  chDbgCheckClassI();

  /* Integrity checks.*/
  chDbgAssert((tp->p_state != THD_STATE_READY) &&
    1674:	6564756c 	strbvs	r7, [r4, #-1388]!	; 0xfffffa94
 * @return              The thread pointer.
 *
 * @iclass
 */
#if !defined(PORT_OPTIMIZED_READYI) || defined(__DOXYGEN__)
Thread *chSchReadyI(Thread *tp) {
    1678:	68630000 	stmdavs	r3!, {}^	; <UNPREDICTABLE>
  Thread *cp;

  chDbgCheckClassI();

  /* Integrity checks.*/
  chDbgAssert((tp->p_state != THD_STATE_READY) &&
    167c:	706d656d 	rsbvc	r6, sp, sp, ror #10
    1680:	736c6f6f 	cmnvc	ip, #444	; 0x1bc
              (tp->p_state != THD_STATE_FINAL),
              "chSchReadyI(), #1",
              "invalid state");

  tp->p_state = THD_STATE_READY;
    1684:	0100632e 	tsteq	r0, lr, lsr #6
    1688:	74730000 	ldrbtvc	r0, [r3], #-0
  cp = (Thread *)&rlist.r_queue;
    168c:	66656464 	strbtvs	r6, [r5], -r4, ror #8
    1690:	0200682e 	andeq	r6, r0, #3014656	; 0x2e0000
    1694:	74730000 	ldrbtvc	r0, [r3], #-0
  do {
    cp = cp->p_next;
    1698:	746e6964 	strbtvc	r6, [lr], #-2404	; 0xfffff69c
  } while (cp->p_prio >= tp->p_prio);
    169c:	0300682e 	movweq	r6, #2094	; 0x82e
    16a0:	68630000 	stmdavs	r3!, {}^	; <UNPREDICTABLE>
    16a4:	636d656d 	cmnvs	sp, #457179136	; 0x1b400000
  /* Insertion on p_prev.*/
  tp->p_next = cp;
    16a8:	2e65726f 	cdpcs	2, 6, cr7, cr5, cr15, {3}
    16ac:	00040068 	andeq	r0, r4, r8, rrx
  tp->p_prev = cp->p_prev;
    16b0:	6d686300 	stclvs	3, cr6, [r8, #-0]
    16b4:	6f706d65 	svcvs	0x00706d65
  tp->p_prev->p_next = cp->p_prev = tp;
    16b8:	2e736c6f 	cdpcs	12, 7, cr6, cr3, cr15, {3}
    16bc:	00040068 	andeq	r0, r4, r8, rrx
    16c0:	05000000 	streq	r0, [r0, #-0]
    16c4:	0023a002 	eoreq	sl, r3, r2
  return tp;
}
    16c8:	01380300 	teqeq	r8, r0, lsl #6
    16cc:	0402004c 	streq	r0, [r2], #-76	; 0xffffffb4
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
#if !defined(PORT_OPTIMIZED_GOSLEEPS) || defined(__DOXYGEN__)
void chSchGoSleepS(tstate_t newstate) {
    16d0:	063c0601 	ldrteq	r0, [ip], -r1, lsl #12
    16d4:	3d3d4b30 	vldmdbcc	sp!, {d4-d27}
    16d8:	01000202 	tsteq	r0, r2, lsl #4
  Thread *otp;

  chDbgCheckClassS();

  (otp = currp)->p_state = newstate;
    16dc:	02050001 	andeq	r0, r5, #1
    16e0:	000023d0 	ldrdeq	r2, [r0], -r0
    16e4:	0100ce03 	tsteq	r0, r3, lsl #28
    16e8:	0402005a 	streq	r0, [r2], #-90	; 0xffffffa6
    16ec:	003c0601 	eorseq	r0, ip, r1, lsl #12
#if CH_TIME_QUANTUM > 0
  /* The thread is renouncing its remaining time slices so it will have a new
     time quantum when it will wakeup.*/
  otp->p_preempt = CH_TIME_QUANTUM;
    16f0:	06010402 	streq	r0, [r1], -r2, lsl #8
    16f4:	594b2130 	stmdbpl	fp, {r4, r5, r8, sp}^
#endif
  setcurrp(fifo_remove(&rlist.r_queue));
    16f8:	01040200 	mrseq	r0, R12_usr
    16fc:	02024147 	andeq	r4, r2, #-1073741807	; 0xc0000011
    1700:	00010100 	andeq	r0, r1, r0, lsl #2
    1704:	24100205 	ldrcs	r0, [r0], #-517	; 0xfffffdfb
    1708:	e3030000 	movw	r0, #12288	; 0x3000
    170c:	67420100 	strbvs	r0, [r2, -r0, lsl #2]
  currp->p_state = THD_STATE_CURRENT;
    1710:	21754b67 	cmncs	r5, r7, ror #22
    1714:	01000302 	tsteq	r0, r2, lsl #6
    1718:	02050001 	andeq	r0, r5, #1
    171c:	00002450 	andeq	r2, r0, r0, asr r4
  chSysSwitch(currp, otp);
    1720:	0100fa03 	tsteq	r0, r3, lsl #20
    1724:	4b4b4b3f 	blmi	12d4428 <_flash_swap_addr+0x1294c28>
    1728:	00030221 	andeq	r0, r3, r1, lsr #4
    172c:	05000101 	streq	r0, [r0, #-257]	; 0xfffffeff
}
    1730:	00248002 	eoreq	r8, r4, r2
    1734:	018f0300 	orreq	r0, pc, r0, lsl #6
    1738:	00313d01 	eorseq	r3, r1, r1, lsl #26
    173c:	06010402 	streq	r0, [r1], -r2, lsl #8

#if !defined(PORT_OPTIMIZED_GOSLEEPTIMEOUTS) || defined(__DOXYGEN__)
/*
 * Timeout wakeup callback.
 */
static void wakeup(void *p) {
    1740:	4b30063c 	blmi	c03038 <_flash_swap_addr+0xbc3838>
    1744:	0002023d 	andeq	r0, r2, sp, lsr r2
  Thread *tp = (Thread *)p;
    1748:	05000101 	streq	r0, [r0, #-257]	; 0xfffffeff

  chSysLockFromIsr();
    174c:	0024b002 	eoreq	fp, r4, r2
    1750:	01a50300 			; <UNDEFINED> instruction: 0x01a50300
  switch (tp->p_state) {
    1754:	4b4b4c01 	blmi	12d4760 <_flash_swap_addr+0x1294f60>
    1758:	0002024b 	andeq	r0, r2, fp, asr #4
    175c:	02230101 	eoreq	r0, r3, #1073741824	; 0x40000000
    1760:	00020000 	andeq	r0, r2, r0
    1764:	0000016c 	andeq	r0, r0, ip, ror #2
    1768:	0efb0102 	cdpeq	1, 15, cr0, cr11, cr2, {0}
    176c:	0101000d 	tsteq	r1, sp
    1770:	00000101 	andeq	r0, r0, r1, lsl #2
    1774:	00000100 	andeq	r0, r0, r0, lsl #2
    1778:	2f2e2e01 	svccs	0x002e2e01
    177c:	432f2e2e 	teqmi	pc, #736	; 0x2e0
    1780:	69626968 	stmdbvs	r2!, {r3, r5, r6, r8, fp, sp, lr}^
    1784:	6f2f534f 	svcvs	0x002f534f
    1788:	6f702f73 	svcvs	0x00702f73
    178c:	2f737472 	svccs	0x00737472
    1790:	2f434347 	svccs	0x00434347
    1794:	434d5241 	movtmi	r5, #53825	; 0xd241
  case THD_STATE_READY:
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromIsr();
    1798:	2f00784d 	svccs	0x0000784d
    179c:	2f74706f 	svccs	0x0074706f
    return;
    17a0:	65646f43 	strbvs	r6, [r4, #-3907]!	; 0xfffff0bd
#if CH_USE_SEMAPHORES || CH_USE_QUEUES ||                                   \
    (CH_USE_CONDVARS && CH_USE_CONDVARS_TIMEOUT)
#if CH_USE_SEMAPHORES
  case THD_STATE_WTSEM:
    chSemFastSignalI((Semaphore *)tp->p_u.wtobjp);
    17a4:	72756f53 	rsbsvc	r6, r5, #332	; 0x14c
    17a8:	79726563 	ldmdbvc	r2!, {r0, r1, r5, r6, r8, sl, sp, lr}^
    17ac:	756f532f 	strbvc	r5, [pc, #-815]!	; 1485 <chVTSetI+0x15>
#endif
#if CH_USE_CONDVARS && CH_USE_CONDVARS_TIMEOUT
  case THD_STATE_WTCOND:
#endif
    /* States requiring dequeuing.*/
    dequeue(tp);
    17b0:	72656372 	rsbvc	r6, r5, #-939524095	; 0xc8000001
#endif
  }
  tp->p_u.rdymsg = RDY_TIMEOUT;
    17b4:	6f435f79 	svcvs	0x00435f79
    17b8:	65426564 	strbvs	r6, [r2, #-1380]	; 0xfffffa9c
  chSchReadyI(tp);
    17bc:	5f68636e 	svcpl	0x0068636e
    17c0:	6574694c 	ldrbvs	r6, [r4, #-2380]!	; 0xfffff6b4
  chSysUnlockFromIsr();
    17c4:	726f665f 	rsbvc	r6, pc, #99614720	; 0x5f00000
    17c8:	4d52415f 	ldfmie	f4, [r2, #-380]	; 0xfffffe84
}
    17cc:	4241455f 	submi	r4, r1, #398458880	; 0x17c00000
 * @return              The wakeup message.
 * @retval RDY_TIMEOUT if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
    17d0:	69622f49 	stmdbvs	r2!, {r0, r3, r6, r8, r9, sl, fp, sp}^
    17d4:	2e2e2f6e 	cdpcs	15, 2, cr2, cr14, cr14, {3}
    17d8:	62696c2f 	rsbvs	r6, r9, #12032	; 0x2f00

  chDbgCheckClassS();

  if (TIME_INFINITE != time) {
    17dc:	6363672f 	cmnvs	r3, #12320768	; 0xbc0000
    17e0:	6d72612f 	ldfvse	f6, [r2, #-188]!	; 0xffffff44
    VirtualTimer vt;

    chVTSetI(&vt, time, wakeup, currp);
    17e4:	6e6f6e2d 	cdpvs	14, 6, cr6, cr15, cr13, {1}
    17e8:	61652d65 	cmnvs	r5, r5, ror #26
    17ec:	342f6962 	strtcc	r6, [pc], #-2402	; 17f4 <chSchGoSleepTimeoutS+0x24>
    17f0:	312e362e 	teqcc	lr, lr, lsr #12
    17f4:	2f2e2e2f 	svccs	0x002e2e2f
    17f8:	2e2f2e2e 	cdpcs	14, 2, cr2, cr15, cr14, {1}
    17fc:	2e2e2f2e 	cdpcs	15, 2, cr2, cr14, cr14, {1}
    chSchGoSleepS(newstate);
    1800:	6d72612f 	ldfvse	f6, [r2, #-188]!	; 0xffffff44
    1804:	6e6f6e2d 	cdpvs	14, 6, cr6, cr15, cr13, {1}
    1808:	61652d65 	cmnvs	r5, r5, ror #26
    if (chVTIsArmedI(&vt))
    180c:	692f6962 	stmdbvs	pc!, {r1, r5, r6, r8, fp, sp, lr}	; <UNPREDICTABLE>
      chVTResetI(&vt);
    1810:	756c636e 	strbvc	r6, [ip, #-878]!	; 0xfffffc92
    1814:	2e006564 	cfsh32cs	mvfx6, mvfx0, #52
    1818:	2e2e2f2e 	cdpcs	15, 2, cr2, cr14, cr14, {1}
  }
  else
    chSchGoSleepS(newstate);
    181c:	6968432f 	stmdbvs	r8!, {r0, r1, r2, r3, r5, r8, r9, lr}^
    1820:	534f6962 	movtpl	r6, #63842	; 0xf962
  return currp->p_u.rdymsg;
    1824:	2f736f2f 	svccs	0x00736f2f
    1828:	6e72656b 	cdpvs	5, 7, cr6, cr2, cr11, {3}
    182c:	692f6c65 	stmdbvs	pc!, {r0, r2, r5, r6, sl, fp, sp, lr}	; <UNPREDICTABLE>
}
    1830:	756c636e 	strbvc	r6, [ip, #-878]!	; 0xfffffc92
    1834:	2e006564 	cfsh32cs	mvfx6, mvfx0, #52
    1838:	2e2e2f2e 	cdpcs	15, 2, cr2, cr14, cr14, {1}
    183c:	6968432f 	stmdbvs	r8!, {r0, r1, r2, r3, r5, r8, r9, lr}^
 * @param[in] msg       message to the awakened thread
 *
 * @sclass
 */
#if !defined(PORT_OPTIMIZED_WAKEUPS) || defined(__DOXYGEN__)
void chSchWakeupS(Thread *ntp, msg_t msg) {
    1840:	534f6962 	movtpl	r6, #63842	; 0xf962
    1844:	2f736f2f 	svccs	0x00736f2f

  chDbgCheckClassS();

  ntp->p_u.rdymsg = msg;
    1848:	74726f70 	ldrbtvc	r6, [r2], #-3952	; 0xfffff090
    184c:	6f632f73 	svcvs	0x00632f73
  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio)
    1850:	6e6f6d6d 	cdpvs	13, 6, cr6, cr15, cr13, {3}
    1854:	4d52412f 	ldfmie	f4, [r2, #-188]	; 0xffffff44
    1858:	00784d43 	rsbseq	r4, r8, r3, asr #26
    185c:	63686300 	cmnvs	r8, #0, 6
    1860:	5f65726f 	svcpl	0x0065726f
    chSchReadyI(ntp);
    1864:	2e6d3776 	mcrcs	7, 3, r3, cr13, cr6, {3}
    1868:	00010063 	andeq	r0, r1, r3, rrx
  else {
    Thread *otp = chSchReadyI(currp);
    186c:	64747300 	ldrbtvs	r7, [r4], #-768	; 0xfffffd00
    1870:	2e746e69 	cdpcs	14, 7, cr6, cr4, cr9, {3}
    1874:	00020068 	andeq	r0, r2, r8, rrx
    1878:	74686300 	strbtvc	r6, [r8], #-768	; 0xfffffd00
    setcurrp(ntp);
    187c:	73657079 	cmnvc	r5, #121	; 0x79
    1880:	0100682e 	tsteq	r0, lr, lsr #16
    1884:	68630000 	stmdavs	r3!, {}^	; <UNPREDICTABLE>
    ntp->p_state = THD_STATE_CURRENT;
    1888:	7473696c 	ldrbtvc	r6, [r3], #-2412	; 0xfffff694
    188c:	00682e73 	rsbeq	r2, r8, r3, ror lr
    chSysSwitch(ntp, otp);
    1890:	63000003 	movwvs	r0, #3
    1894:	72687468 	rsbvc	r7, r8, #104, 8	; 0x68000000
  }
}
    1898:	73646165 	cmnvc	r4, #1073741849	; 0x40000019
    189c:	0300682e 	movweq	r6, #2094	; 0x82e
 *          the ready list then make the higher priority thread running.
 *
 * @sclass
 */
#if !defined(PORT_OPTIMIZED_RESCHEDULES) || defined(__DOXYGEN__)
void chSchRescheduleS(void) {
    18a0:	68630000 	stmdavs	r3!, {}^	; <UNPREDICTABLE>

  chDbgCheckClassS();

  if (chSchIsRescRequiredI())
    18a4:	65726f63 	ldrbvs	r6, [r2, #-3939]!	; 0xfffff09d
    18a8:	6d37765f 	ldcvs	6, cr7, [r7, #-380]!	; 0xfffffe84
    18ac:	0100682e 	tsteq	r0, lr, lsr #16
    18b0:	766e0000 	strbtvc	r0, [lr], -r0
    18b4:	682e6369 	stmdavs	lr!, {r0, r3, r5, r6, r8, r9, sp, lr}
    18b8:	00000400 	andeq	r0, r0, r0, lsl #8
    18bc:	63736863 	cmnvs	r3, #6488064	; 0x630000
    chSchDoRescheduleAhead();
    18c0:	682e6468 	stmdavs	lr!, {r3, r5, r6, sl, sp, lr}
    18c4:	00000300 	andeq	r0, r0, r0, lsl #6
    18c8:	746d6863 	strbtvc	r6, [sp], #-2147	; 0xfffff79d
    18cc:	00682e78 	rsbeq	r2, r8, r8, ror lr
 *          itself or from within the port layer.
 *
 * @special
 */
#if !defined(PORT_OPTIMIZED_DORESCHEDULEBEHIND) || defined(__DOXYGEN__)
void chSchDoRescheduleBehind(void) {
    18d0:	00000003 	andeq	r0, r0, r3
  Thread *otp;

  otp = currp;
    18d4:	e0020500 	and	r0, r2, r0, lsl #10
    18d8:	03000024 	movweq	r0, #36	; 0x24
    18dc:	4b240127 	blmi	901d80 <_flash_swap_addr+0x8c2580>
  /* Picks the first thread from the ready queue and makes it current.*/
  setcurrp(fifo_remove(&rlist.r_queue));
    18e0:	022f4c2f 	eoreq	r4, pc, #12032	; 0x2f00
    18e4:	01010001 	tsteq	r1, r1
    18e8:	00020500 	andeq	r0, r2, r0, lsl #10
    18ec:	03000025 	movweq	r0, #37	; 0x25
    18f0:	40320139 	eorsmi	r0, r2, r9, lsr r1
    18f4:	024b3d51 	subeq	r3, fp, #5184	; 0x1440
  currp->p_state = THD_STATE_CURRENT;
    18f8:	01010003 	tsteq	r1, r3
    18fc:	30020500 	andcc	r0, r2, r0, lsl #10
    1900:	03000025 	movweq	r0, #37	; 0x25
    1904:	230100ee 	movwcs	r0, #4334	; 0x10ee
#if CH_TIME_QUANTUM > 0
  otp->p_preempt = CH_TIME_QUANTUM;
    1908:	68689375 	stmdavs	r8!, {r0, r2, r4, r5, r6, r8, r9, ip, pc}^
    190c:	00010268 	andeq	r0, r1, r8, ror #4
#endif
  chSchReadyI(otp);
    1910:	05000101 	streq	r0, [r0, #-257]	; 0xfffffeff
    1914:	00258002 	eoreq	r8, r5, r2
  chSysSwitch(currp, otp);
    1918:	018c0300 	orreq	r0, ip, r0, lsl #6
    191c:	944b3001 	strbls	r3, [fp], #-1
    1920:	4e3d4b40 	vsubmi.f64	d4, d13, d0
    1924:	01040200 	mrseq	r0, R12_usr
}
    1928:	02008206 	andeq	r8, r0, #1610612736	; 0x60000000
    192c:	20080204 	andcs	r0, r8, r4, lsl #4
 *          itself or from within the port layer.
 *
 * @special
 */
#if !defined(PORT_OPTIMIZED_DORESCHEDULEAHEAD) || defined(__DOXYGEN__)
void chSchDoRescheduleAhead(void) {
    1930:	03040200 	movweq	r0, #16896	; 0x4200
  Thread *otp, *cp;

  otp = currp;
    1934:	30061208 	andcc	r1, r6, r8, lsl #4
    1938:	03661c03 	cmneq	r6, #768	; 0x300
    193c:	1303206d 	movwne	r2, #12397	; 0x306d
  /* Picks the first thread from the ready queue and makes it current.*/
  setcurrp(fifo_remove(&rlist.r_queue));
    1940:	024b2266 	subeq	r2, fp, #1610612742	; 0x60000006
    1944:	01010003 	tsteq	r1, r3
    1948:	40020500 	andmi	r0, r2, r0, lsl #10
    194c:	03000026 	movweq	r0, #38	; 0x26
    1950:	150101c7 	strne	r0, [r1, #-455]	; 0xfffffe39
    1954:	01021430 	tsteq	r2, r0, lsr r4
  currp->p_state = THD_STATE_CURRENT;
    1958:	00010100 	andeq	r0, r1, r0, lsl #2
    195c:	26500205 	ldrbcs	r0, [r0], -r5, lsl #4
    1960:	d5030000 	strle	r0, [r3, #-0]
    1964:	0f030101 	svceq	0x00030101

  otp->p_state = THD_STATE_READY;
    1968:	50343001 	eorspl	r3, r4, r1
    196c:	01000202 	tsteq	r0, r2, lsl #4
  cp = (Thread *)&rlist.r_queue;
    1970:	02050001 	andeq	r0, r5, #1
    1974:	00002670 	andeq	r2, r0, r0, ror r6
    1978:	0101f403 	tsteq	r1, r3, lsl #8
  do {
    cp = cp->p_next;
    197c:	4d4b1419 	cfstrdmi	mvd1, [fp, #-100]	; 0xffffff9c
  } while (cp->p_prio > otp->p_prio);
    1980:	01000102 	tsteq	r0, r2, lsl #2
    1984:	00011e01 	andeq	r1, r1, r1, lsl #28
    1988:	d4000200 	strle	r0, [r0], #-512	; 0xfffffe00
  /* Insertion on p_prev.*/
  otp->p_next = cp;
    198c:	02000000 	andeq	r0, r0, #0
    1990:	0d0efb01 	vstreq	d15, [lr, #-4]
  otp->p_prev = cp->p_prev;
    1994:	01010100 	mrseq	r0, (UNDEF: 17)
    1998:	00000001 	andeq	r0, r0, r1
  otp->p_prev->p_next = cp->p_prev = otp;
    199c:	01000001 	tsteq	r0, r1
    19a0:	2e2f2e2e 	cdpcs	14, 2, cr2, cr15, cr14, {1}
    19a4:	68432f2e 	stmdavs	r3, {r1, r2, r3, r5, r8, r9, sl, fp, sp}^
    19a8:	4f696269 	svcmi	0x00696269

  chSysSwitch(currp, otp);
    19ac:	736f2f53 	cmnvc	pc, #332	; 0x14c
    19b0:	726f702f 	rsbvc	r7, pc, #47	; 0x2f
    19b4:	632f7374 	teqvs	pc, #116, 6	; 0xd0000001
    19b8:	6f6d6d6f 	svcvs	0x006d6d6f
}
    19bc:	52412f6e 	subpl	r2, r1, #440	; 0x1b8
 *          itself or from within the port layer.
 *
 * @special
 */
#if !defined(PORT_OPTIMIZED_DORESCHEDULE) || defined(__DOXYGEN__)
void chSchDoReschedule(void) {
    19c0:	784d434d 	stmdavc	sp, {r0, r2, r3, r6, r8, r9, lr}^

#if CH_TIME_QUANTUM > 0
  /* If CH_TIME_QUANTUM is enabled then there are two different scenarios to
     handle on preemption: time quantum elapsed or not.*/
  if (currp->p_preempt == 0) {
    19c4:	706f2f00 	rsbvc	r2, pc, r0, lsl #30
    19c8:	6f432f74 	svcvs	0x00432f74
    19cc:	6f536564 	svcvs	0x00536564
    19d0:	65637275 	strbvs	r7, [r3, #-629]!	; 0xfffffd8b
    /* The thread consumed its time quantum so it is enqueued behind threads
       with same priority level, however, it acquires a new time quantum.*/
    chSchDoRescheduleBehind();
    19d4:	532f7972 	teqpl	pc, #1867776	; 0x1c8000
  }
  else {
    /* The thread didn't consume all its time quantum so it is put ahead of
       threads with equal priority and does not acquire a new time quantum.*/
    chSchDoRescheduleAhead();
    19d8:	6372756f 	cmnvs	r2, #465567744	; 0x1bc00000
#else /* !(CH_TIME_QUANTUM > 0) */
  /* If the round-robin mechanism is disabled then the thread goes always
     ahead of its peers.*/
  chSchDoRescheduleAhead();
#endif /* !(CH_TIME_QUANTUM > 0) */
}
    19dc:	5f797265 	svcpl	0x00797265

static INLINE void list_insert(Thread *tp, ThreadsList *tlp) {
    19e0:	65646f43 	strbvs	r6, [r4, #-3907]!	; 0xfffff0bd
    19e4:	636e6542 	cmnvs	lr, #276824064	; 0x10800000

  tp->p_next = tlp->p_next;
    19e8:	694c5f68 	stmdbvs	ip, {r3, r5, r6, r8, r9, sl, fp, ip, lr}^
    19ec:	665f6574 			; <UNDEFINED> instruction: 0x665f6574
  tlp->p_next = tp;
    19f0:	415f726f 	cmpmi	pc, pc, ror #4
}
    19f4:	455f4d52 	ldrbmi	r4, [pc, #-3410]	; caa <pee2fei+0x2a>
    19f8:	2f494241 	svccs	0x00494241
    19fc:	2f6e6962 	svccs	0x006e6962

static INLINE Thread *list_remove(ThreadsList *tlp) {
    1a00:	6c2f2e2e 	stcvs	14, cr2, [pc], #-184	; 1950 <chSchDoRescheduleAhead+0x20>

  Thread *tp = tlp->p_next;
    1a04:	672f6269 	strvs	r6, [pc, -r9, ror #4]!
    1a08:	612f6363 	teqvs	pc, r3, ror #6
  tlp->p_next = tp->p_next;
    1a0c:	6e2d6d72 	mcrvs	13, 1, r6, cr13, cr2, {3}
    1a10:	2d656e6f 	stclcs	14, cr6, [r5, #-444]!	; 0xfffffe44
  return tp;
}
    1a14:	69626165 	stmdbvs	r2!, {r0, r2, r5, r6, r8, sp, lr}^
    1a18:	362e342f 	strtcc	r3, [lr], -pc, lsr #8
    1a1c:	2e2f312e 	sufcsep	f3, f7, #0.5
 * @param[in] prio      the priority level for the new thread
 * @return              The same thread pointer passed as parameter.
 *
 * @notapi
 */
Thread *_thread_init(Thread *tp, tprio_t prio) {
    1a20:	2e2e2f2e 	cdpcs	15, 2, cr2, cr14, cr14, {1}
    1a24:	2f2e2e2f 	svccs	0x002e2e2f

  tp->p_prio = prio;
    1a28:	612f2e2e 	teqvs	pc, lr, lsr #28
  tp->p_state = THD_STATE_SUSPENDED;
    1a2c:	6e2d6d72 	mcrvs	13, 1, r6, cr13, cr2, {3}
    1a30:	2d656e6f 	stclcs	14, cr6, [r5, #-444]!	; 0xfffffe44
  tp->p_flags = THD_MEM_MODE_STATIC;
    1a34:	69626165 	stmdbvs	r2!, {r0, r2, r5, r6, r8, sp, lr}^
    1a38:	636e692f 	cmnvs	lr, #770048	; 0xbc000
#if CH_TIME_QUANTUM > 0
  tp->p_preempt = CH_TIME_QUANTUM;
    1a3c:	6564756c 	strbvs	r7, [r4, #-1388]!	; 0xfffffa94
    1a40:	766e0000 	strbtvc	r0, [lr], -r0
#endif
#if CH_USE_MUTEXES
  tp->p_realprio = prio;
    1a44:	632e6369 	teqvs	lr, #-1543503871	; 0xa4000001
    1a48:	00000100 	andeq	r0, r0, r0, lsl #2
  tp->p_mtxlist = NULL;
    1a4c:	6369766e 	cmnvs	r9, #115343360	; 0x6e00000
    1a50:	0100682e 	tsteq	r0, lr, lsr #16
#endif
#if CH_USE_EVENTS
  tp->p_epending = 0;
    1a54:	74730000 	ldrbtvc	r0, [r3], #-0
    1a58:	746e6964 	strbtvc	r6, [lr], #-2404	; 0xfffff69c
#endif
#if CH_DBG_THREADS_PROFILING
  tp->p_time = 0;
    1a5c:	0200682e 	andeq	r6, r0, #3014656	; 0x2e0000
    1a60:	00000000 	andeq	r0, r0, r0
#endif
#if CH_USE_DYNAMIC
  tp->p_refs = 1;
    1a64:	26900205 	ldrcs	r0, [r0], r5, lsl #4
    1a68:	26030000 	strcs	r0, [r3], -r0
#endif
#if CH_USE_REGISTRY
  tp->p_name = NULL;
    1a6c:	02684b01 	rsbeq	r4, r8, #1024	; 0x400
    1a70:	21081323 	tstcs	r8, r3, lsr #6
  REG_INSERT(tp);
    1a74:	000302f3 	strdeq	r0, [r3], -r3
    1a78:	05000101 	streq	r0, [r0, #-257]	; 0xfffffeff
    1a7c:	00274002 	eoreq	r4, r7, r2
    1a80:	01340300 	teqeq	r4, r0, lsl #6
    1a84:	2108683d 	tstcs	r8, sp, lsr r8
    1a88:	0302c908 	movweq	ip, #10504	; 0x2908
    1a8c:	00010100 	andeq	r0, r1, r0, lsl #2
    1a90:	27c00205 	strbcs	r0, [r0, r5, lsl #4]
    1a94:	c2030000 	andgt	r0, r3, #0
    1a98:	684b0100 	stmdavs	fp, {r8}^
    1a9c:	21732108 	cmncs	r3, r8, lsl #2
    1aa0:	03024c57 	movweq	r4, #11351	; 0x2c57
    1aa4:	cb010100 	blgt	41eac <_flash_swap_addr+0x26ac>
#endif
#if CH_USE_WAITEXIT
  list_init(&tp->p_waiting);
    1aa8:	02000002 	andeq	r0, r0, #2
    1aac:	00016200 	andeq	r6, r1, r0, lsl #4
    1ab0:	fb010200 	blx	422ba <_flash_swap_addr+0x2aba>
#endif
#if CH_USE_MESSAGES
  queue_init(&tp->p_msgqueue);
    1ab4:	01000d0e 	tsteq	r0, lr, lsl #26
    1ab8:	00010101 	andeq	r0, r1, r1, lsl #2
    1abc:	00010000 	andeq	r0, r1, r0
    1ac0:	2e2e0100 	sufcse	f0, f6, f0
  tp->p_stklimit = (stkalign_t *)(tp + 1);
#endif
#if defined(THREAD_EXT_INIT_HOOK)
  THREAD_EXT_INIT_HOOK(tp);
#endif
  return tp;
    1ac4:	2f2e2e2f 	svccs	0x002e2e2f
}
    1ac8:	62696843 	rsbvs	r6, r9, #4390912	; 0x430000
    1acc:	2f534f69 	svccs	0x00534f69
 *                      the thread into the working space area.
 *
 * @iclass
 */
Thread *chThdCreateI(void *wsp, size_t size,
                     tprio_t prio, tfunc_t pf, void *arg) {
    1ad0:	6b2f736f 	blvs	bde894 <_flash_swap_addr+0xb9f094>
    1ad4:	656e7265 	strbvs	r7, [lr, #-613]!	; 0xfffffd9b
    1ad8:	6e692f6c 	cdpvs	15, 6, cr2, cr9, cr12, {3}
  /* Thread structure is layed out in the lower part of the thread workspace.*/
  Thread *tp = wsp;
    1adc:	64756c63 	ldrbtvs	r6, [r5], #-3171	; 0xfffff39d

  chDbgCheckClassI();

  chDbgCheck((wsp != NULL) && (size >= THD_WA_SIZE(0)) &&
    1ae0:	2e2e0065 	cdpcs	0, 2, cr0, cr14, cr5, {3}
    1ae4:	2f2e2e2f 	svccs	0x002e2e2f
    1ae8:	62696843 	rsbvs	r6, r9, #4390912	; 0x430000
    1aec:	2f534f69 	svccs	0x00534f69
    1af0:	6b2f736f 	blvs	bde8b4 <_flash_swap_addr+0xb9f0b4>
    1af4:	656e7265 	strbvs	r7, [lr, #-613]!	; 0xfffffd9b
             (prio <= HIGHPRIO) && (pf != NULL),
             "chThdCreateI");
  SETUP_CONTEXT(wsp, size, pf, arg);
    1af8:	72732f6c 	rsbsvc	r2, r3, #108, 30	; 0x1b0
    1afc:	6f2f0063 	svcvs	0x002f0063
    1b00:	432f7470 	teqmi	pc, #112, 8	; 0x70000000
    1b04:	5365646f 	cmnpl	r5, #1862270976	; 0x6f000000
    1b08:	6372756f 	cmnvs	r2, #465567744	; 0x1bc00000
    1b0c:	2f797265 	svccs	0x00797265
    1b10:	72756f53 	rsbsvc	r6, r5, #332	; 0x14c
    1b14:	79726563 	ldmdbvc	r2!, {r0, r1, r5, r6, r8, sl, sp, lr}^
    1b18:	646f435f 	strbtvs	r4, [pc], #-863	; 1b20 <chThdCreateI+0x50>
    1b1c:	6e654265 	cdpvs	2, 6, cr4, cr5, cr5, {3}
    1b20:	4c5f6863 	mrrcmi	8, 6, r6, pc, cr3	; <UNPREDICTABLE>
  return _thread_init(tp, prio);
    1b24:	5f657469 	svcpl	0x00657469
    1b28:	5f726f66 	svcpl	0x00726f66
}
    1b2c:	5f4d5241 	svcpl	0x004d5241
    1b30:	49424145 	stmdbmi	r2, {r0, r2, r6, r8, lr}^
    1b34:	6e69622f 	cdpvs	2, 6, cr6, cr9, cr15, {1}
    1b38:	2f2e2e2f 	svccs	0x002e2e2f
    1b3c:	2f62696c 	svccs	0x0062696c
 *                      the thread into the working space area.
 *
 * @api
 */
Thread *chThdCreateStatic(void *wsp, size_t size,
                          tprio_t prio, tfunc_t pf, void *arg) {
    1b40:	2f636367 	svccs	0x00636367
    1b44:	2d6d7261 	sfmcs	f7, 2, [sp, #-388]!	; 0xfffffe7c
    1b48:	656e6f6e 	strbvs	r6, [lr, #-3950]!	; 0xfffff092
                  CH_THREAD_FILL_VALUE);
  _thread_memfill((uint8_t *)wsp + sizeof(Thread),
                  (uint8_t *)wsp + size,
                  CH_STACK_FILL_VALUE);
#endif
  chSysLock();
    1b4c:	6261652d 	rsbvs	r6, r1, #188743680	; 0xb400000
    1b50:	2e342f69 	cdpcs	15, 3, cr2, cr4, cr9, {3}
  chSchWakeupS(tp = chThdCreateI(wsp, size, prio, pf, arg), RDY_OK);
    1b54:	2f312e36 	svccs	0x00312e36
    1b58:	2e2f2e2e 	cdpcs	14, 2, cr2, cr15, cr14, {1}
    1b5c:	2e2e2f2e 	cdpcs	15, 2, cr2, cr14, cr14, {1}
    1b60:	2f2e2e2f 	svccs	0x002e2e2f
    1b64:	2d6d7261 	sfmcs	f7, 2, [sp, #-388]!	; 0xfffffe7c
    1b68:	656e6f6e 	strbvs	r6, [lr, #-3950]!	; 0xfffff092
    1b6c:	6261652d 	rsbvs	r6, r1, #188743680	; 0xb400000
  chSysUnlock();
    1b70:	6e692f69 	cdpvs	15, 6, cr2, cr9, cr9, {3}
    1b74:	64756c63 	ldrbtvs	r6, [r5], #-3171	; 0xfffff39d
  return tp;
    1b78:	2e2e0065 	cdpcs	0, 2, cr0, cr14, cr5, {3}
}
    1b7c:	2f2e2e2f 	svccs	0x002e2e2f
 * @param[in] newprio   the new priority level of the running thread
 * @return              The old priority level.
 *
 * @api
 */
tprio_t chThdSetPriority(tprio_t newprio) {
    1b80:	62696843 	rsbvs	r6, r9, #4390912	; 0x430000
    1b84:	2f534f69 	svccs	0x00534f69
  tprio_t oldprio;

  chDbgCheck(newprio <= HIGHPRIO, "chThdSetPriority");

  chSysLock();
    1b88:	702f736f 	eorvc	r7, pc, pc, ror #6
    1b8c:	7374726f 	cmnvc	r4, #-268435450	; 0xf0000006
#if CH_USE_MUTEXES
  oldprio = currp->p_realprio;
    1b90:	4343472f 	movtmi	r4, #14127	; 0x372f
    1b94:	4d52412f 	ldfmie	f4, [r2, #-188]	; 0xffffff44
    1b98:	00784d43 	rsbseq	r4, r8, r3, asr #26
  if ((currp->p_prio == currp->p_realprio) || (newprio > currp->p_prio))
    1b9c:	69686300 	stmdbvs	r8!, {r8, r9, sp, lr}^
    1ba0:	6e696c6e 	cdpvs	12, 6, cr6, cr9, cr14, {3}
    1ba4:	00682e65 	rsbeq	r2, r8, r5, ror #28
    1ba8:	63000001 	movwvs	r0, #1
    1bac:	78746d68 	ldmdavc	r4!, {r3, r5, r6, r8, sl, fp, sp, lr}^
    1bb0:	0200632e 	andeq	r6, r0, #-1207959552	; 0xb8000000
    1bb4:	74730000 	ldrbtvc	r0, [r3], #-0
    1bb8:	746e6964 	strbtvc	r6, [lr], #-2404	; 0xfffff69c
    1bbc:	0300682e 	movweq	r6, #2094	; 0x82e
    1bc0:	68630000 	stmdavs	r3!, {}^	; <UNPREDICTABLE>
    1bc4:	65707974 	ldrbvs	r7, [r0, #-2420]!	; 0xfffff68c
    1bc8:	00682e73 	rsbeq	r2, r8, r3, ror lr
    currp->p_prio = newprio;
    1bcc:	63000004 	movwvs	r0, #4
    1bd0:	73696c68 	cmnvc	r9, #104, 24	; 0x6800
    1bd4:	682e7374 	stmdavs	lr!, {r2, r4, r5, r6, r8, r9, ip, sp, lr}
  currp->p_realprio = newprio;
    1bd8:	00000100 	andeq	r0, r0, r0, lsl #2
    1bdc:	68746863 	ldmdavs	r4!, {r0, r1, r5, r6, fp, sp, lr}^
    1be0:	64616572 	strbtvs	r6, [r1], #-1394	; 0xfffffa8e
    1be4:	00682e73 	rsbeq	r2, r8, r3, ror lr
#else
  oldprio = currp->p_prio;
  currp->p_prio = newprio;
#endif
  chSchRescheduleS();
    1be8:	63000001 	movwvs	r0, #1
  chSysUnlock();
    1bec:	726f6368 	rsbvc	r6, pc, #104, 6	; 0xa0000001
    1bf0:	37765f65 	ldrbcc	r5, [r6, -r5, ror #30]!
  return oldprio;
}
    1bf4:	00682e6d 	rsbeq	r2, r8, sp, ror #28
    1bf8:	63000004 	movwvs	r0, #4
    1bfc:	68637368 	stmdavs	r3!, {r3, r5, r6, r8, r9, ip, sp, lr}^
 * @param[in] tp        pointer to the thread
 * @return              The pointer to the thread.
 *
 * @api
 */
Thread *chThdResume(Thread *tp) {
    1c00:	00682e64 	rsbeq	r2, r8, r4, ror #28
    1c04:	63000001 	movwvs	r0, #1

  chSysLock();
    1c08:	78746d68 	ldmdavc	r4!, {r3, r5, r6, r8, sl, fp, sp, lr}^
    1c0c:	0100682e 	tsteq	r0, lr, lsr #16
  chDbgAssert(tp->p_state == THD_STATE_SUSPENDED,
              "chThdResume(), #1",
              "thread not in THD_STATE_SUSPENDED state");
  chSchWakeupS(tp, RDY_OK);
    1c10:	00000000 	andeq	r0, r0, r0
    1c14:	28200205 	stmdacs	r0!, {r0, r2, r9}
  chSysUnlock();
    1c18:	21030000 	mrscs	r0, (UNDEF: 3)
    1c1c:	02003e01 	andeq	r3, r0, #1, 28
  return tp;
    1c20:	00300104 	eorseq	r0, r0, r4, lsl #2
}
    1c24:	3d010402 	cfstrscc	mvf0, [r1, #-8]
    1c28:	834b3d9f 	movthi	r3, #48543	; 0xbd9f
    1c2c:	01000202 	tsteq	r0, r2, lsl #4
 *
 * @param[in] tp        pointer to the thread
 *
 * @api
 */
void chThdTerminate(Thread *tp) {
    1c30:	02050001 	andeq	r0, r5, #1

  chSysLock();
    1c34:	00002870 	andeq	r2, r0, r0, ror r8
    1c38:	2f013303 	svccs	0x00013303
  tp->p_flags |= THD_TERMINATE;
    1c3c:	0221833e 	eoreq	r8, r1, #-134217728	; 0xf8000000
    1c40:	01010003 	tsteq	r1, r3
    1c44:	a0020500 	andge	r0, r2, r0, lsl #10
    1c48:	03000028 	movweq	r0, #40	; 0x28
  chSysUnlock();
    1c4c:	300100c1 	andcc	r0, r1, r1, asr #1
    1c50:	02215959 	eoreq	r5, r1, #1458176	; 0x164000
}
    1c54:	01010003 	tsteq	r1, r3
    1c58:	05000204 	streq	r0, [r0, #-516]	; 0xfffffdfc
    1c5c:	0028c002 	eoreq	ip, r8, r2
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
void chThdSleep(systime_t time) {
    1c60:	00ce0300 	sbceq	r0, lr, r0, lsl #6
    1c64:	4b753201 	blmi	1d4e470 <_flash_swap_addr+0x1d0ec70>

  chDbgCheck(time != TIME_IMMEDIATE, "chThdSleep");

  chSysLock();
    1c68:	01000202 	tsteq	r0, r2, lsl #4
    1c6c:	00020401 	andeq	r0, r2, r1, lsl #8
  chThdSleepS(time);
    1c70:	28e00205 	stmiacs	r0!, {r0, r2, r9}^
    1c74:	df030000 	svcle	0x00030000
  chSysUnlock();
    1c78:	4c3e0100 	ldfmis	f0, [lr], #-0
    1c7c:	02024b3e 	andeq	r4, r2, #63488	; 0xf800
}
    1c80:	04010100 	streq	r0, [r1], #-256	; 0xffffff00
    1c84:	02050002 	andeq	r0, r5, #2
    1c88:	00002900 	andeq	r2, r0, r0, lsl #18
    1c8c:	0100f103 	tsteq	r0, r3, lsl #2
 *
 * @param[in] time      absolute system time
 *
 * @api
 */
void chThdSleepUntil(systime_t time) {
    1c90:	3f4e6c3d 	svccc	0x004e6c3d
    1c94:	9f934c22 	svcls	0x00934c22

  chSysLock();
    1c98:	200e034b 	andcs	r0, lr, fp, asr #6
    1c9c:	2275289f 	rsbscs	r2, r5, #10420224	; 0x9f0000
  if ((time -= chTimeNow()) > 0)
    1ca0:	01040200 	mrseq	r0, R12_usr
    1ca4:	03205d03 	teqeq	r0, #3, 26	; 0xc0
    1ca8:	3d596626 	ldclcc	6, cr6, [r9, #-152]	; 0xffffff68
    1cac:	3e4b3d60 	cdpcc	13, 4, cr3, cr11, cr0, {3}
    1cb0:	01000202 	tsteq	r0, r2, lsl #4
    chThdSleepS(time);
    1cb4:	00020401 	andeq	r0, r2, r1, lsl #8
    1cb8:	29c00205 	stmibcs	r0, {r0, r2, r9}^
    1cbc:	c6030000 	strgt	r0, [r3], -r0
  chSysUnlock();
    1cc0:	4c3f0101 	ldfmis	f0, [pc], #-4	; 1cc4 <chThdSleepUntil+0x34>
    1cc4:	02214b4c 	eoreq	r4, r1, #76, 22	; 0x13000
}
    1cc8:	01010003 	tsteq	r1, r3
    1ccc:	05000204 	streq	r0, [r0, #-516]	; 0xfffffdfc
 * @details Yields the CPU control to the next thread in the ready list with
 *          equal priority, if any.
 *
 * @api
 */
void chThdYield(void) {
    1cd0:	0029f002 	eoreq	pc, r9, r2

  chSysLock();
    1cd4:	01e20300 	mvneq	r0, r0, lsl #6
    1cd8:	3d4b3301 	stclcc	3, cr3, [fp, #-4]
  chSchDoYieldS();
    1cdc:	2f758375 	svccs	0x00758375
    1ce0:	01000302 	tsteq	r0, r2, lsl #6
    1ce4:	00020401 	andeq	r0, r2, r1, lsl #8
    1ce8:	2a400205 	bcs	1002504 <_flash_swap_addr+0xfc2d04>
    1cec:	f9030000 			; <UNDEFINED> instruction: 0xf9030000
    1cf0:	692f0101 	stmdbvs	pc!, {r0, r8}	; <UNPREDICTABLE>
    1cf4:	3d4a0903 	stclcc	9, cr0, [sl, #-12]
    1cf8:	3d3d5d4c 	ldccc	13, cr5, [sp, #-304]!	; 0xfffffed0
  chSysUnlock();
    1cfc:	04020024 	streq	r0, [r2], #-36	; 0xffffffdc
    1d00:	06580601 	ldrbeq	r0, [r8], -r1, lsl #12
    1d04:	02004b67 	andeq	r4, r0, #105472	; 0x19c00
    1d08:	7a030104 	bvc	c2120 <_flash_swap_addr+0x82920>
    1d0c:	3c0a033c 	stccc	3, cr0, [sl], {60}	; 0x3c
 *
 * @param[in] msg       thread exit code
 *
 * @api
 */
void chThdExit(msg_t msg) {
    1d10:	4b3d593f 	blmi	f58214 <_flash_swap_addr+0xf18a14>
    1d14:	4b4b693d 	blmi	12dc210 <_flash_swap_addr+0x129ca10>

  chSysLock();
    1d18:	00030221 	andeq	r0, r3, r1, lsr #4
    1d1c:	02040101 	andeq	r0, r4, #1073741824	; 0x40000000
  chThdExitS(msg);
    1d20:	f0020500 			; <UNDEFINED> instruction: 0xf0020500
  /* The thread never returns here.*/
}
    1d24:	0300002a 	movweq	r0, #42	; 0x2a
    1d28:	2f0102b5 	svccs	0x000102b5
    1d2c:	3d660d03 	stclcc	13, cr0, [r6, #-12]!
 *
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
    1d30:	3d3d5d4c 	ldccc	13, cr5, [sp, #-304]!	; 0xfffffed0
    1d34:	04020024 	streq	r0, [r2], #-36	; 0xffffffdc
  Thread *tp = currp;
    1d38:	06580601 	ldrbeq	r0, [r8], -r1, lsl #12
    1d3c:	02004b67 	andeq	r4, r0, #105472	; 0x19c00
    1d40:	7a030104 	bvc	c2158 <_flash_swap_addr+0x82958>

  tp->p_u.exitcode = msg;
    1d44:	593f443c 	ldmdbpl	pc!, {r2, r3, r4, r5, sl, lr}	; <UNPREDICTABLE>
#if defined(THREAD_EXT_EXIT_HOOK)
  THREAD_EXT_EXIT_HOOK(tp);
#endif
#if CH_USE_WAITEXIT
  while (notempty(&tp->p_waiting))
    1d48:	4d3d4b3d 	fldmdbxmi	sp!, {d4-d33}	;@ Deprecated
    chSchReadyI(list_remove(&tp->p_waiting));
    1d4c:	0302214b 	movweq	r2, #8523	; 0x214b
    1d50:	04010100 	streq	r0, [r1], #-256	; 0xffffff00
    1d54:	02050002 	andeq	r0, r5, #2
    1d58:	00002b90 	muleq	r0, r0, fp
    1d5c:	0102ee03 	tsteq	r2, r3, lsl #28
  tp->p_u.exitcode = msg;
#if defined(THREAD_EXT_EXIT_HOOK)
  THREAD_EXT_EXIT_HOOK(tp);
#endif
#if CH_USE_WAITEXIT
  while (notempty(&tp->p_waiting))
    1d60:	4c4b682f 	mcrrmi	8, 2, r6, fp, cr15
    1d64:	59594b3d 	ldmdbpl	r9, {r0, r2, r3, r4, r5, r8, r9, fp, lr}^
    1d68:	4d3d4b3d 	fldmdbxmi	sp!, {d4-d33}	;@ Deprecated
    chSchReadyI(list_remove(&tp->p_waiting));
#endif
#if CH_USE_REGISTRY
  /* Static threads are immediately removed from the registry because
     there is no memory to recover.*/
  if ((tp->p_flags & THD_MEM_MODE_MASK) == THD_MEM_MODE_STATIC)
    1d6c:	304b4b4b 	subcc	r4, fp, fp, asr #22
    1d70:	0002024b 	andeq	r0, r2, fp, asr #4
    1d74:	Address 0x00001d74 is out of bounds.


Disassembly of section .debug_info:

00000000 <.debug_info>:
       0:	0000005c 	andeq	r0, r0, ip, asr r0
       4:	00000002 	andeq	r0, r0, r2
       8:	01040000 	mrseq	r0, (UNDEF: 4)
       c:	00000000 	andeq	r0, r0, r0
      10:	00000410 	andeq	r0, r0, r0, lsl r4
      14:	00000558 	andeq	r0, r0, r8, asr r5
      18:	72617473 	rsbvc	r7, r1, #1929379840	; 0x73000000
      1c:	646f6374 	strbtvs	r6, [pc], #-884	; 24 <_vector_rom+0x24>
      20:	00732e65 	rsbseq	r2, r3, r5, ror #28
      24:	6d6f682f 	stclvs	8, cr6, [pc, #-188]!	; ffffff70 <_stack_start+0xdffeff70>
      28:	6b642f65 	blvs	190bdc4 <_flash_swap_addr+0x18cc5c4>
      2c:	656e6e65 	strbvs	r6, [lr, #-3685]!	; 0xfffff19b
      30:	642f7964 	strtvs	r7, [pc], #-2404	; 38 <_vector_rom+0x38>
      34:	6b2f7665 	blvs	bdd9d0 <_flash_swap_addr+0xb9e1d0>
      38:	74656e69 	strbtvc	r6, [r5], #-3689	; 0xfffff197
      3c:	672e7369 	strvs	r7, [lr, -r9, ror #6]!
      40:	702f7469 	eorvc	r7, pc, r9, ror #8
      44:	65736168 	ldrbvs	r6, [r3, #-360]!	; 0xfffffe98
      48:	74725f33 	ldrbtvc	r5, [r2], #-3891	; 0xfffff0cd
      4c:	4700736f 	strmi	r7, [r0, -pc, ror #6]
      50:	4120554e 	teqmi	r0, lr, asr #10
      54:	2e322053 	mrccs	0, 1, r2, cr2, cr3, {2}
      58:	352e3132 	strcc	r3, [lr, #-306]!	; 0xfffffece
      5c:	80010033 	andhi	r0, r1, r3, lsr r0
      60:	00000316 	andeq	r0, r0, r6, lsl r3
      64:	00140002 	andseq	r0, r4, r2
      68:	01040000 	mrseq	r0, (UNDEF: 4)
      6c:	00000287 	andeq	r0, r0, r7, lsl #5
      70:	00000001 	andeq	r0, r0, r1
      74:	00021600 	andeq	r1, r2, r0, lsl #12
      78:	00056000 	andeq	r6, r5, r0
      7c:	00068800 	andeq	r8, r6, r0, lsl #16
      80:	0000c500 	andeq	ip, r0, r0, lsl #10
      84:	05040200 	streq	r0, [r4, #-512]	; 0xfffffe00
      88:	00746e69 	rsbseq	r6, r4, r9, ror #28
      8c:	ed070403 	cfstrs	mvf0, [r7, #-12]
      90:	03000001 	movweq	r0, #1
      94:	01ba0601 			; <UNDEFINED> instruction: 0x01ba0601
      98:	01030000 	mrseq	r0, (UNDEF: 3)
      9c:	0001b808 	andeq	fp, r1, r8, lsl #16
      a0:	05020300 	streq	r0, [r2, #-768]	; 0xfffffd00
      a4:	00000031 	andeq	r0, r0, r1, lsr r0
      a8:	6a070203 	bvs	1c08bc <_flash_swap_addr+0x1810bc>
      ac:	04000002 	streq	r0, [r0], #-2
      b0:	00000300 	andeq	r0, r0, r0, lsl #6
      b4:	005a4f02 	subseq	r4, sl, r2, lsl #30
      b8:	04030000 	streq	r0, [r3], #-0
      bc:	0000f705 	andeq	pc, r0, r5, lsl #14
      c0:	02ff0400 	rscseq	r0, pc, #0, 8
      c4:	50020000 	andpl	r0, r2, r0
      c8:	0000006c 	andeq	r0, r0, ip, rrx
      cc:	e8070403 	stmda	r7, {r0, r1, sl}
      d0:	03000001 	movweq	r0, #1
      d4:	00f20508 	rscseq	r0, r2, r8, lsl #10
      d8:	1f040000 	svcne	0x00040000
      dc:	02000000 	andeq	r0, r0, #0
      e0:	00008578 	andeq	r8, r0, r8, ror r5
      e4:	07080300 	streq	r0, [r8, -r0, lsl #6]
      e8:	000001e3 	andeq	r0, r0, r3, ror #3
      ec:	00041f04 	andeq	r1, r4, r4, lsl #30
      f0:	4f2d0300 	svcmi	0x002d0300
      f4:	04000000 	streq	r0, [r0], #-0
      f8:	0000027d 	andeq	r0, r0, sp, ror r2
      fc:	00613103 	rsbeq	r3, r1, r3, lsl #2
     100:	04050000 	streq	r0, [r5], #-0
     104:	0003b504 	andeq	fp, r3, r4, lsl #10
     108:	7ae40400 	bvc	ff901110 <_stack_start+0xdf8f1110>
     10c:	06000000 	streq	r0, [r0], -r0
     110:	0000b504 	andeq	fp, r0, r4, lsl #10
     114:	00ba0700 	adcseq	r0, sl, r0, lsl #14
     118:	01030000 	mrseq	r0, (UNDEF: 3)
     11c:	0001c108 	andeq	ip, r1, r8, lsl #2
     120:	05040800 	streq	r0, [r4, #-2048]	; 0xfffff800
     124:	0000e4af 	andeq	lr, r0, pc, lsr #9
     128:	00cc0900 	sbceq	r0, ip, r0, lsl #18
     12c:	09010000 	stmdbeq	r1, {}	; <UNPREDICTABLE>
     130:	000000af 	andeq	r0, r0, pc, lsr #1
     134:	00710902 	rsbseq	r0, r1, r2, lsl #18
     138:	09040000 	stmdbeq	r4, {}	; <UNPREDICTABLE>
     13c:	00000090 	muleq	r0, r0, r0
     140:	00048080 	andeq	r8, r4, r0, lsl #1
     144:	1b05010a 	blne	140574 <_flash_swap_addr+0x100d74>
     148:	00011801 	andeq	r1, r1, r1, lsl #16
     14c:	03f70900 	mvnseq	r0, #0, 18
     150:	09000000 	stmdbeq	r0, {}	; <UNPREDICTABLE>
     154:	00000371 	andeq	r0, r0, r1, ror r3
     158:	035d0901 	cmpeq	sp, #16384	; 0x4000
     15c:	09020000 	stmdbeq	r2, {}	; <UNPREDICTABLE>
     160:	000001cf 	andeq	r0, r0, pc, asr #3
     164:	01850903 	orreq	r0, r5, r3, lsl #18
     168:	09040000 	stmdbeq	r4, {}	; <UNPREDICTABLE>
     16c:	00000396 	muleq	r0, r6, r3
     170:	004c0905 	subeq	r0, ip, r5, lsl #18
     174:	00060000 	andeq	r0, r6, r0
     178:	1d05010a 	stfnes	f0, [r5, #-40]	; 0xffffffd8
     17c:	00016a0a 	andeq	r6, r1, sl, lsl #20
     180:	03dc0900 	bicseq	r0, ip, #0, 18
     184:	09000000 	stmdbeq	r0, {}	; <UNPREDICTABLE>
     188:	00000308 	andeq	r0, r0, r8, lsl #6
     18c:	03c00901 	biceq	r0, r0, #16384	; 0x4000
     190:	09020000 	stmdbeq	r2, {}	; <UNPREDICTABLE>
     194:	00000241 	andeq	r0, r0, r1, asr #4
     198:	010c0902 	tsteq	ip, r2, lsl #18
     19c:	09030000 	stmdbeq	r3, {}	; <UNPREDICTABLE>
     1a0:	0000025c 	andeq	r0, r0, ip, asr r2
     1a4:	01000904 	tsteq	r0, r4, lsl #18
     1a8:	09050000 	stmdbeq	r5, {}	; <UNPREDICTABLE>
     1ac:	00000206 	andeq	r0, r0, r6, lsl #4
     1b0:	024c0906 	subeq	r0, ip, #98304	; 0x18000
     1b4:	09070000 	stmdbeq	r7, {}	; <UNPREDICTABLE>
     1b8:	000003cd 	andeq	r0, r0, sp, asr #7
     1bc:	04100908 	ldreq	r0, [r0], #-2312	; 0xfffff6f8
     1c0:	09090000 	stmdbeq	r9, {}	; <UNPREDICTABLE>
     1c4:	000003ab 	andeq	r0, r0, fp, lsr #7
     1c8:	0208000a 	andeq	r0, r8, #10
     1cc:	01ac5d06 			; <UNDEFINED> instruction: 0x01ac5d06
     1d0:	0c090000 	stceq	0, cr0, [r9], {-0}
     1d4:	01000000 	mrseq	r0, (UNDEF: 0)
     1d8:	0001fa09 	andeq	pc, r1, r9, lsl #20
     1dc:	24090200 	strcs	r0, [r9], #-512	; 0xfffffe00
     1e0:	04000001 	streq	r0, [r0], #-1
     1e4:	00002809 	andeq	r2, r0, r9, lsl #16
     1e8:	31090800 	tstcc	r9, r0, lsl #16
     1ec:	10000004 	andne	r0, r0, r4
     1f0:	00019909 	andeq	r9, r1, r9, lsl #18
     1f4:	c6092000 	strgt	r2, [r9], -r0
     1f8:	c0000001 	andgt	r0, r0, r1
     1fc:	03eb0900 	mvneq	r0, #0, 18
     200:	01800000 	orreq	r0, r0, r0
     204:	00011609 	andeq	r1, r1, r9, lsl #12
     208:	00028000 	andeq	r8, r2, r0
     20c:	cb06010a 	blgt	18063c <_flash_swap_addr+0x140e3c>
     210:	00021c02 	andeq	r1, r2, r2, lsl #24
     214:	02930900 	addseq	r0, r3, #0, 18
     218:	09000000 	stmdbeq	r0, {}	; <UNPREDICTABLE>
     21c:	0000029f 	muleq	r0, pc, r2	; <UNPREDICTABLE>
     220:	02ab0901 	adceq	r0, fp, #16384	; 0x4000
     224:	09020000 	stmdbeq	r2, {}	; <UNPREDICTABLE>
     228:	000002b7 			; <UNDEFINED> instruction: 0x000002b7
     22c:	02c30903 	sbceq	r0, r3, #49152	; 0xc000
     230:	09040000 	stmdbeq	r4, {}	; <UNPREDICTABLE>
     234:	000002cf 	andeq	r0, r0, pc, asr #5
     238:	02db0905 	sbcseq	r0, fp, #81920	; 0x14000
     23c:	09060000 	stmdbeq	r6, {}	; <UNPREDICTABLE>
     240:	000002e7 	andeq	r0, r0, r7, ror #5
     244:	02f30907 	rscseq	r0, r3, #114688	; 0x1c000
     248:	09080000 	stmdbeq	r8, {}	; <UNPREDICTABLE>
     24c:	0000012d 	andeq	r0, r0, sp, lsr #2
     250:	013a0909 	teqeq	sl, r9, lsl #18
     254:	090a0000 	stmdbeq	sl, {}	; <UNPREDICTABLE>
     258:	00000147 	andeq	r0, r0, r7, asr #2
     25c:	0154090b 	cmpeq	r4, fp, lsl #18
     260:	090c0000 	stmdbeq	ip, {}	; <UNPREDICTABLE>
     264:	00000161 	andeq	r0, r0, r1, ror #2
     268:	0389090d 	orreq	r0, r9, #212992	; 0x34000
     26c:	090e0000 	stmdbeq	lr, {}	; <UNPREDICTABLE>
     270:	00000178 	andeq	r0, r0, r8, ror r1
     274:	0425090f 	strteq	r0, [r5], #-2319	; 0xfffff6f1
     278:	00100000 	andseq	r0, r0, r0
     27c:	e006010a 	and	r0, r6, sl, lsl #2
     280:	00023e02 	andeq	r3, r2, r2, lsl #28
     284:	03170900 	tsteq	r7, #0, 18
     288:	09000000 	stmdbeq	r0, {}	; <UNPREDICTABLE>
     28c:	0000032f 	andeq	r0, r0, pc, lsr #6
     290:	03460901 	movteq	r0, #26881	; 0x6901
     294:	09020000 	stmdbeq	r2, {}	; <UNPREDICTABLE>
     298:	000001a2 	andeq	r0, r0, r2, lsr #3
     29c:	010b0003 	tsteq	fp, r3
     2a0:	00000017 	andeq	r0, r0, r7, lsl r0
     2a4:	60010b01 	andvs	r0, r1, r1, lsl #22
     2a8:	74000005 	strvc	r0, [r0], #-5
     2ac:	00000005 	andeq	r0, r0, r5
     2b0:	74000000 	strvc	r0, [r0], #-0
     2b4:	0c000002 	stceq	0, cr0, [r0], {2}
     2b8:	0000006c 	andeq	r0, r0, ip, rrx
     2bc:	00af0b01 	adceq	r0, pc, r1, lsl #22
     2c0:	91020000 	mrsls	r0, (UNDEF: 2)
     2c4:	00e80c74 	rsceq	r0, r8, r4, ror ip
     2c8:	0b010000 	bleq	402d0 <_flash_swap_addr+0xad0>
     2cc:	00000274 	andeq	r0, r0, r4, ror r2
     2d0:	00709102 	rsbseq	r9, r0, r2, lsl #2
     2d4:	00002507 	andeq	r2, r0, r7, lsl #10
     2d8:	01700d00 	cmneq	r0, r0, lsl #26
     2dc:	0e010000 	cdpeq	0, 0, cr0, cr1, cr0, {0}
     2e0:	00008c01 	andeq	r8, r0, r1, lsl #24
     2e4:	00057400 	andeq	r7, r5, r0, lsl #8
     2e8:	00059600 	andeq	r9, r5, r0, lsl #12
     2ec:	00003800 	andeq	r3, r0, r0, lsl #16
     2f0:	0002a400 	andeq	sl, r2, r0, lsl #8
     2f4:	72610e00 	rsbvc	r0, r1, #0, 28
     2f8:	0e010067 	cdpeq	0, 0, cr0, cr1, cr7, {3}
     2fc:	000000a2 	andeq	r0, r0, r2, lsr #1
     300:	00749102 	rsbseq	r9, r4, r2, lsl #2
     304:	0000610f 	andeq	r6, r0, pc, lsl #2
     308:	01170100 	tsteq	r7, r0, lsl #2
     30c:	00000598 	muleq	r0, r8, r5
     310:	000005ba 			; <UNDEFINED> instruction: 0x000005ba
     314:	00000070 	andeq	r0, r0, r0, ror r0
     318:	00003b10 	andeq	r3, r0, r0, lsl fp
     31c:	01280100 	teqeq	r8, r0, lsl #2
     320:	000005bc 			; <UNDEFINED> instruction: 0x000005bc
     324:	00000610 	andeq	r0, r0, r0, lsl r6
     328:	0000009c 	muleq	r0, ip, r0
     32c:	000002df 	ldrdeq	r0, [r0], -pc	; <UNPREDICTABLE>
     330:	0000ed11 	andeq	lr, r0, r1, lsl sp
     334:	6c2a0100 	stfvss	f0, [sl], #-0
     338:	02000000 	andeq	r0, r0, #0
     33c:	12007491 	andne	r7, r0, #-1862270976	; 0x91000000
     340:	00004701 	andeq	r4, r0, r1, lsl #14
     344:	01330100 	teqeq	r3, r0, lsl #2
     348:	00000025 	andeq	r0, r0, r5, lsr #32
     34c:	00000610 	andeq	r0, r0, r0, lsl r6
     350:	00000688 	andeq	r0, r0, r8, lsl #13
     354:	000000d4 	ldrdeq	r0, [r0], -r4
     358:	0000a413 	andeq	sl, r0, r3, lsl r4
     35c:	00030800 	andeq	r0, r3, r0, lsl #16
     360:	002c1400 	eoreq	r1, ip, r0, lsl #8
     364:	00360000 	eorseq	r0, r6, r0
     368:	00016e11 	andeq	r6, r1, r1, lsl lr
     36c:	f80d0100 			; <UNDEFINED> instruction: 0xf80d0100
     370:	05000002 	streq	r0, [r0, #-2]
     374:	00043003 	andeq	r3, r4, r3
     378:	03ac0020 			; <UNDEFINED> instruction: 0x03ac0020
     37c:	00020000 	andeq	r0, r2, r0
     380:	00000131 	andeq	r0, r0, r1, lsr r1
     384:	02870104 	addeq	r0, r7, #4, 2
     388:	51010000 	mrspl	r0, (UNDEF: 1)
     38c:	16000004 	strne	r0, [r0], -r4
     390:	88000002 	stmdahi	r0, {r1}
     394:	28000006 	stmdacs	r0, {r1, r2}
     398:	2c00000a 	stccs	0, cr0, [r0], {10}
     39c:	02000002 	andeq	r0, r0, #2
     3a0:	01b80801 			; <UNDEFINED> instruction: 0x01b80801
     3a4:	02020000 	andeq	r0, r2, #0
     3a8:	00026a07 	andeq	r6, r2, r7, lsl #20
     3ac:	02ff0300 	rscseq	r0, pc, #0, 6
     3b0:	19030000 	stmdbne	r3, {}	; <UNPREDICTABLE>
     3b4:	0000003e 	andeq	r0, r0, lr, lsr r0
     3b8:	e8070402 	stmda	r7, {r1, sl}
     3bc:	02000001 	andeq	r0, r0, #1
     3c0:	01ba0601 			; <UNDEFINED> instruction: 0x01ba0601
     3c4:	02020000 	andeq	r0, r2, #0
     3c8:	00003105 	andeq	r3, r0, r5, lsl #2
     3cc:	05040200 	streq	r0, [r4, #-512]	; 0xfffffe00
     3d0:	000000f7 	strdeq	r0, [r0], -r7
     3d4:	ed070402 	cfstrs	mvf0, [r7, #-8]
     3d8:	04000001 	streq	r0, [r0], #-1
     3dc:	01e80202 	mvneq	r0, r2, lsl #4
     3e0:	000000af 	andeq	r0, r0, pc, lsr #1
     3e4:	00057705 	andeq	r7, r5, r5, lsl #14
     3e8:	26050000 	strcs	r0, [r5], -r0
     3ec:	00000005 	andeq	r0, r0, r5
     3f0:	00055705 	andeq	r5, r5, r5, lsl #14
     3f4:	05028000 	streq	r8, [r2, #-0]
     3f8:	000004a2 	andeq	r0, r0, r2, lsr #9
     3fc:	b0050280 	andlt	r0, r5, r0, lsl #5
     400:	80000004 	andhi	r0, r0, r4
     404:	04be0504 	ldrteq	r0, [lr], #1284	; 0x504
     408:	06800000 	streq	r0, [r0], r0
     40c:	0004cc05 	andeq	ip, r4, r5, lsl #24
    .thumb_func

_default_reset_handler:

unlock_watchdog:
    ldr r6, =0x4005200e
     410:	05088000 	streq	r8, [r8, #-0]
    ldr r0, =0xc520
    strh r0, [r6]
     414:	000004da 	ldrdeq	r0, [r0], -sl
    ldr r0, =0xd928
    strh r0, [r6]
     418:	e8050a80 	stmda	r5, {r7, r9, fp}

disable_watchdog:
    ldr r6, =0x40052000
    ldr r0, =0x01d2
     41c:	80000004 	andhi	r0, r0, r4
     * address 0x00000000 (which is the first element in the vector_table) by
     * the hardware. The next three lines are required in case this image
     * is not located at 0x0 (i.e. it is being launched from a bootloader).
     */

    ldr r1, =_vector_table
     420:	04f6050c 	ldrbteq	r0, [r6], #1292	; 0x50c
    ldr r2, [r1]
    mov	sp,r2
     424:	0e800000 	cdpeq	0, 8, cr0, cr0, cr0, {0}
chibi_setup:
    /*
     * ChibiOS requires a process stack to be initialized.
     */
    ldr r1, =_process_stack_start
    msr PSP, r1
     428:	02180600 	andseq	r0, r8, #0, 12

    /* TODO: FPU register initialization per crt0.c */
    /*
     * Set up system to run in privileged mode using the PSP stack
     */
    ldr r1, =0x00000002
     42c:	01130216 	tsteq	r3, r6, lsl r2
    msr CONTROL, r1
     430:	98070000 	stmdals	r7, {}	; <UNPREDICTABLE>
    isb
     434:	02000004 	andeq	r0, r0, #4
     * address and the start address are not the same. This code supports
     * running an entire image out of SRAM.
     */

    ldr r0, =_text_start
    ldr r1, =_text_end
     438:	00330217 	eorseq	r0, r3, r7, lsl r2
    ldr r2, =_text_load

    cmp r0, r2
     43c:	23020000 	movwcs	r0, #8192	; 0x2000
    beq end_text_loop
     440:	05180700 	ldreq	r0, [r8, #-1792]	; 0xfffff900
text_loop:
    cmp r0, r1
    ittt    lt
     444:	18020000 	stmdane	r2, {}	; <UNPREDICTABLE>
    ldrlt   r3, [r2], #4
     448:	00003302 	andeq	r3, r0, r2, lsl #6
    strlt   r3, [r0], #4
     44c:	04230200 	strteq	r0, [r3], #-512	; 0xfffffe00
    blt     text_loop
     450:	00044007 	andeq	r4, r4, r7
    /*
     * Relocate the .ramcode section from FLASH to SRAM.
     */

    ldr r0, =_ramcode_start
    ldr r1, =_ramcode_end
     454:	02190200 	andseq	r0, r9, #0, 4
    ldr r2, =_ramcode_load

ramcode_loop:
    cmp r0, r1
     458:	00000033 	andeq	r0, r0, r3, lsr r0
    ittt    lt
    ldrlt   r3, [r2], #4
     45c:	07082302 	streq	r2, [r8, -r2, lsl #6]
    strlt   r3, [r0], #4
     460:	00000565 	andeq	r0, r0, r5, ror #10
    blt     ramcode_loop
     464:	33021a02 	movwcc	r1, #10754	; 0x2a02

    /*
     * Relocate vector table to SRAM.
     */

     ldr r0, =_vector_ram_start
     468:	02000000 	andeq	r0, r0, #0
     ldr r1, =_vector_ram_end
     ldr r2, =_vector_rom
     46c:	93070c23 	movwls	r0, #31779	; 0x7c23
vector_loop:
    cmp r0, r1
    ittt    lt
     470:	02000004 	andeq	r0, r0, #4
    ldrlt   r3, [r2], #4
     474:	0033021b 	eorseq	r0, r3, fp, lsl r2
    strlt   r3, [r0], #4
     478:	23020000 	movwcs	r0, #8192	; 0x2000
    blt     vector_loop
     47c:	043b0710 	ldrteq	r0, [fp], #-1808	; 0xfffff8f0
    /*
     * Point to the SRAM vector table.
     */

    ldr r1,=0xe000ed08
    ldr r0,=_vector_ram_start
     480:	1c020000 	stcne	0, cr0, [r2], {-0}
     * Note: _data_start contains the SRAM (destination) address and
     *       _text_end contains the (source) address of the .data section
     *       in FLASH.
     */

    ldr r0, =_data_start
     484:	00003302 	andeq	r3, r0, r2, lsl #6
    ldr r1, =_data_end
    ldr r2, =_data_load
     488:	14230200 	strtne	r0, [r3], #-512	; 0xfffffe00

data_loop:
    cmp r0, r1
    ittt    lt
     48c:	04880800 	streq	r0, [r8], #2048	; 0x800
    ldrlt   r3, [r2], #4
     490:	1d020000 	stcne	0, cr0, [r2, #-0]
    strlt   r3, [r0], #4
     494:	0000af02 	andeq	sl, r0, r2, lsl #30
    blt     data_loop
     498:	05040900 	streq	r0, [r4, #-2304]	; 0xfffff700
    /*
     * Zero out the .bss section in SRAM.
     */

    ldr r0, =_bss_start
    ldr r1, =_bss_end
     49c:	00746e69 	rsbseq	r6, r4, r9, ror #28
    ldr r2, =0x00000000

bss_loop:
    cmp r0, r1
     4a0:	f2050802 	vadd.i8	d0, d5, d2
    itt     lt
    strlt   r2, [r0], #4
     4a4:	02000000 	andeq	r0, r0, #0
    blt     bss_loop
     4a8:	01e30708 	mvneq	r0, r8, lsl #14

    /*
     * Zero out heap.
     */

    ldr r0, =_heap_start
     4ac:	01020000 	mrseq	r0, (UNDEF: 2)
    ldr r1, =_heap_end

heap_loop:
    cmp r0, r1
     4b0:	0001c108 	andeq	ip, r1, r8, lsl #2
    itt     lt
    strlt   r2, [r0], #4
     4b4:	04020a00 	streq	r0, [r2], #-2560	; 0xfffff600
    blt     heap_loop
     4b8:	00017d5d 	andeq	r7, r1, sp, asr sp
    ldr r0, =_stack_start
    ldr r1, =_stack_end
    ldr r2, =0xefefefef
*/

    ldr r0, =_stack_end
     4bc:	000c0500 	andeq	r0, ip, r0, lsl #10
    ldr r1, =_stack_start
    ldr r2, =0xefefefef
     4c0:	05010000 	streq	r0, [r1, #-0]

stack_loop:
    cmp r0, r1
    itt     lt
     4c4:	000001fa 	strdeq	r0, [r0], -sl
    strlt   r2, [r0], #4
     4c8:	01240502 	teqeq	r4, r2, lsl #10
    blt     stack_loop
     4cc:	05040000 	streq	r0, [r4, #-0]

call_user_asm_code:
    bl main
     4d0:	00000028 	andeq	r0, r0, r8, lsr #32
    /*
     * Epilogue processing would go here.
     */

end_loop:
    b end_loop
     4d4:	04310508 	ldrteq	r0, [r1], #-1288	; 0xfffffaf8

    .align 2
    .thumb_func

_default_nmi_handler:
    b _default_nmi_handler
     4d8:	05100000 	ldreq	r0, [r0, #-0]

    .align 2
    .thumb_func

_default_fault_handler:
    b _default_fault_handler
     4dc:	00000199 	muleq	r0, r9, r1

    .align 2
    .thumb_func

_default_irq_handler:
    b _default_irq_handler
     4e0:	01c60520 	biceq	r0, r6, r0, lsr #10
    .thumb_func

_default_reset_handler:

unlock_watchdog:
    ldr r6, =0x4005200e
     4e4:	00c00000 	sbceq	r0, r0, r0
    ldr r0, =0xc520
     4e8:	0003eb05 	andeq	lr, r3, r5, lsl #22
    strh r0, [r6]
    ldr r0, =0xd928
     4ec:	05018000 	streq	r8, [r1, #-0]
    strh r0, [r6]

disable_watchdog:
    ldr r6, =0x40052000
     4f0:	00000116 	andeq	r0, r0, r6, lsl r1
    ldr r0, =0x01d2
     4f4:	0b000280 	bleq	efc <clockSetDividers+0xc0>
     * address 0x00000000 (which is the first element in the vector_table) by
     * the hardware. The next three lines are required in case this image
     * is not located at 0x0 (i.e. it is being launched from a bootloader).
     */

    ldr r1, =_vector_table
     4f8:	00000445 	andeq	r0, r0, r5, asr #8

chibi_setup:
    /*
     * ChibiOS requires a process stack to be initialized.
     */
    ldr r1, =_process_stack_start
     4fc:	b6012301 	strlt	r2, [r1], -r1, lsl #6

    /* TODO: FPU register initialization per crt0.c */
    /*
     * Set up system to run in privileged mode using the PSP stack
     */
    ldr r1, =0x00000002
     500:	88000001 	stmdahi	r0, {r0}
     * Relocate the .text section from FLASH to SRAM only if the load
     * address and the start address are not the same. This code supports
     * running an entire image out of SRAM.
     */

    ldr r0, =_text_start
     504:	3c000006 	stccc	0, cr0, [r0], {6}
    ldr r1, =_text_end
     508:	0c000007 	stceq	0, cr0, [r0], {7}
    ldr r2, =_text_load
     50c:	b6000001 	strlt	r0, [r0], -r1

    /*
     * Relocate the .ramcode section from FLASH to SRAM.
     */

    ldr r0, =_ramcode_start
     510:	0c000001 	stceq	0, cr0, [r0], {1}
    ldr r1, =_ramcode_end
     514:	00000552 	andeq	r0, r0, r2, asr r5
    ldr r2, =_ramcode_load
     518:	00332301 	eorseq	r2, r3, r1, lsl #6

    /*
     * Relocate vector table to SRAM.
     */

     ldr r0, =_vector_ram_start
     51c:	91020000 	mrsls	r0, (UNDEF: 2)
     ldr r1, =_vector_ram_end
     520:	049d0d6c 	ldreq	r0, [sp], #3436	; 0xd6c
     ldr r2, =_vector_rom
     524:	25010000 	strcs	r0, [r1, #-0]

    /*
     * Point to the SRAM vector table.
     */

    ldr r1,=0xe000ed08
     528:	00000033 	andeq	r0, r0, r3, lsr r0
     * Note: _data_start contains the SRAM (destination) address and
     *       _text_end contains the (source) address of the .data section
     *       in FLASH.
     */

    ldr r0, =_data_start
     52c:	00749102 	rsbseq	r9, r4, r2, lsl #2
    ldr r1, =_data_end
     530:	01bc040e 			; <UNDEFINED> instruction: 0x01bc040e
    ldr r2, =_data_load
     534:	130f0000 	movwne	r0, #61440	; 0xf000

    /*
     * Zero out the .bss section in SRAM.
     */

    ldr r0, =_bss_start
     538:	10000001 	andne	r0, r0, r1
    ldr r1, =_bss_end
     53c:	00046d01 	andeq	r6, r4, r1, lsl #26
    ldr r2, =0x00000000
     540:	013f0100 	teqeq	pc, r0, lsl #2

    /*
     * Zero out heap.
     */

    ldr r0, =_heap_start
     544:	0000073c 	andeq	r0, r0, ip, lsr r7
    ldr r1, =_heap_end
     548:	0000093e 	andeq	r0, r0, lr, lsr r9
    ldr r0, =_stack_start
    ldr r1, =_stack_end
    ldr r2, =0xefefefef
*/

    ldr r0, =_stack_end
     54c:	00000144 	andeq	r0, r0, r4, asr #2
    ldr r1, =_stack_start
     550:	0000022f 	andeq	r0, r0, pc, lsr #4
    ldr r2, =0xefefefef
     554:	0005520c 	andeq	r5, r5, ip, lsl #4
     558:	333f0100 	teqcc	pc, #0, 2
     55c:	02000000 	andeq	r0, r0, #0
#define TSI_ORANGE_BIT    BIT_5

#define TSI_YELLOW_INDEX  8
#define TSI_YELLOW_BIT    BIT_8

void assert_(const char *file, const int line) { }
     560:	70116491 	mulsvc	r1, r1, r4
     564:	01006e69 	tsteq	r0, r9, ror #28
     568:	0000333f 	andeq	r3, r0, pc, lsr r3
     56c:	60910200 	addsvs	r0, r1, r0, lsl #4
     570:	74706f11 	ldrbtvc	r6, [r0], #-3857	; 0xfffff0ef

static WORKING_AREA(waThread1, 128);
static msg_t Thread1(void *arg) {
     574:	333f0100 	teqcc	pc, #0, 2
     578:	02000000 	andeq	r0, r0, #0
    while (TRUE) {
        chThdSleepMilliseconds(500);
     57c:	450d5c91 	strmi	r5, [sp, #-3217]	; 0xfffff36f
     580:	01000005 	tsteq	r0, r5
        gpioToggle(N_LED_YELLOW_PORT, N_LED_YELLOW_PIN);
     584:	0000335a 	andeq	r3, r0, sl, asr r3
     588:	74910200 	ldrvc	r0, [r1], #512	; 0x200
     58c:	00051d0d 	andeq	r1, r5, sp, lsl #26
     590:	b6780100 	ldrbtlt	r0, [r8], -r0, lsl #2
    }
     594:	02000001 	andeq	r0, r0, #1

    return 0;
}

static void clocksInit(void)
{
     598:	360d7091 			; <UNDEFINED> instruction: 0x360d7091
     * System:  100 MHz
     * Bus:      50 MHz
     * Flexbus:  50 MHz
     * Flash:    25 MHz
     */
    clockSetDividers(DIVIDE_BY_1, DIVIDE_BY_2, DIVIDE_BY_4, DIVIDE_BY_4);
     59c:	01000005 	tsteq	r0, r5
     5a0:	00003379 	andeq	r3, r0, r9, ror r3
     5a4:	6c910200 	lfmvs	f0, 4, [r1], {0}
     5a8:	3d011000 	stccc	0, cr1, [r1, #-0]
     5ac:	01000005 	tsteq	r0, r5
    clockConfigMcgOut(MCG_PLL_EXTERNAL_100MHZ);
     5b0:	09400187 	stmdbeq	r0, {r0, r1, r2, r7, r8}^
     5b4:	096a0000 	stmdbeq	sl!, {}^	; <UNPREDICTABLE>
}
     5b8:	017c0000 	cmneq	ip, r0

static void systickInit(void)
{
     5bc:	02730000 	rsbseq	r0, r3, #0
     5c0:	520c0000 	andpl	r0, ip, #0
    uint32_t freq = clockGetFreq(CLOCK_CORE);
     5c4:	01000005 	tsteq	r0, r5
     5c8:	00003387 	andeq	r3, r0, r7, lsl #7

    NVIC_SYSTICK_RELOAD = freq / CH_FREQUENCY - 1;
     5cc:	6c910200 	lfmvs	f0, 4, [r1], {0}
     5d0:	6e697011 	mcrvs	0, 3, r7, cr9, cr1, {0}
     5d4:	33870100 	orrcc	r0, r7, #0, 2
     5d8:	02000000 	andeq	r0, r0, #0
     5dc:	1d0d6891 	stcne	8, cr6, [sp, #-580]	; 0xfffffdbc
     5e0:	01000005 	tsteq	r0, r5
     5e4:	0001b689 	andeq	fp, r1, r9, lsl #13
     5e8:	74910200 	ldrvc	r0, [r1], #512	; 0x200
    NVIC_SYSTICK_VALUE = 0;
     5ec:	7e011000 	cdpvc	0, 0, cr1, cr1, cr0, {0}
     5f0:	01000004 	tsteq	r0, r4
     5f4:	096c0190 	stmdbeq	ip!, {r4, r7, r8}^
     5f8:	09960000 	ldmibeq	r6, {}	; <UNPREDICTABLE>
    NVIC_SYSTICK_CONTROL = NVIC_SYSTICK_CONTROL_ENABLE
     5fc:	01b40000 			; <UNDEFINED> instruction: 0x01b40000
     600:	02b70000 	adcseq	r0, r7, #0
     604:	520c0000 	andpl	r0, ip, #0
                         | NVIC_SYSTICK_CONTROL_TICKINT
                         | NVIC_SYSTICK_CONTROL_CLKSOURCE;
}
     608:	01000005 	tsteq	r0, r5
     60c:	00003390 	muleq	r0, r0, r3

int main(void)
{
     610:	6c910200 	lfmvs	f0, 4, [r1], {0}
     614:	6e697011 	mcrvs	0, 3, r7, cr9, cr1, {0}
    clocksInit();
     618:	33900100 	orrscc	r0, r0, #0, 2
    systickInit();
     61c:	02000000 	andeq	r0, r0, #0
    chSysInit();
     620:	1d0d6891 	stcne	8, cr6, [sp, #-580]	; 0xfffffdbc

    gpioConfig(N_LED_ORANGE_PORT, N_LED_ORANGE_PIN, GPIO_OUTPUT | GPIO_LOW);
     624:	01000005 	tsteq	r0, r5
     628:	0001b692 	muleq	r1, r2, r6
     62c:	74910200 	ldrvc	r0, [r1], #512	; 0x200
     630:	04011000 	streq	r1, [r1], #-0
     634:	01000005 	tsteq	r0, r5
    gpioConfig(N_LED_YELLOW_PORT, N_LED_YELLOW_PIN, GPIO_OUTPUT | GPIO_LOW);
     638:	09980199 	ldmibeq	r8, {r0, r3, r4, r7, r8}
     63c:	09c20000 	stmibeq	r2, {}^	; <UNPREDICTABLE>
     640:	01ec0000 	mvneq	r0, r0
     644:	02fb0000 	rscseq	r0, fp, #0
     648:	520c0000 	andpl	r0, ip, #0

    chThdCreateStatic(waThread1, sizeof(waThread1), NORMALPRIO, Thread1, NULL);
     64c:	01000005 	tsteq	r0, r5
     650:	00003399 	muleq	r0, r9, r3
     654:	6c910200 	lfmvs	f0, 4, [r1], {0}
     658:	6e697011 	mcrvs	0, 3, r7, cr9, cr1, {0}
     65c:	33990100 	orrscc	r0, r9, #0, 2
     660:	02000000 	andeq	r0, r0, #0
     664:	1d0d6891 	stcne	8, cr6, [sp, #-580]	; 0xfffffdbc
     668:	01000005 	tsteq	r0, r5

    hwInterruptsEnable();
     66c:	0001b69b 	muleq	r1, fp, r6

    while (TRUE) {
        chThdSleepMilliseconds(123);
     670:	74910200 	ldrvc	r0, [r1], #512	; 0x200
     674:	89011000 	stmdbhi	r1, {ip}
        gpioToggle(N_LED_ORANGE_PORT, N_LED_ORANGE_PIN);
     678:	01000005 	tsteq	r0, r5
     67c:	09c401a8 	stmibeq	r4, {r3, r5, r7, r8}^
     680:	09da0000 	ldmibeq	sl, {}^	; <UNPREDICTABLE>
     684:	02240000 	eoreq	r0, r4, #0
*
* RETURNS: The corresponding GPIO_BASE_ADDR.
*
*******************************************************************************/
static volatile gpioPort_t *gpioPortGet(uint32_t port)
{
     688:	033f0000 	teqeq	pc, #0
     68c:	520c0000 	andpl	r0, ip, #0
    uint32_t addr;

    switch (port) {
     690:	01000005 	tsteq	r0, r5
     694:	000033a8 	andeq	r3, r0, r8, lsr #7
     698:	74910200 	ldrvc	r0, [r1], #512	; 0x200
     69c:	000e0e0c 	andeq	r0, lr, ip, lsl #28
     6a0:	33a80100 			; <UNDEFINED> instruction: 0x33a80100
     6a4:	02000000 	andeq	r0, r0, #0
     6a8:	780c7091 	stmdavc	ip, {r0, r4, r7, ip, sp, lr}
     6ac:	01000004 	tsteq	r0, r4
     6b0:	000033a8 	andeq	r3, r0, r8, lsr #7
     6b4:	6c910200 	lfmvs	f0, 4, [r1], {0}
     6b8:	6a011200 	bvs	44ec0 <_flash_swap_addr+0x56c0>
     6bc:	01000005 	tsteq	r0, r5
     6c0:	003301b5 	ldrhteq	r0, [r3], -r5
     6c4:	09dc0000 	ldmibeq	ip, {}^	; <UNPREDICTABLE>
     6c8:	09f40000 	ldmibeq	r4!, {}^	; <UNPREDICTABLE>
     6cc:	025c0000 	subseq	r0, ip, #0
     6d0:	036b0000 	cmneq	fp, #0
     6d4:	520c0000 	andpl	r0, ip, #0
     6d8:	01000005 	tsteq	r0, r5
     6dc:	000033b5 			; <UNDEFINED> instruction: 0x000033b5
    case PORTA: addr = GPIOA_BASE_ADDR; break;
     6e0:	74910200 	ldrvc	r0, [r1], #512	; 0x200
     6e4:	0f011300 	svceq	0x00011300
     6e8:	01000005 	tsteq	r0, r5
    case PORTB: addr = GPIOB_BASE_ADDR; break;
     6ec:	003301c3 	eorseq	r0, r3, r3, asr #3
     6f0:	09f40000 	ldmibeq	r4!, {}^	; <UNPREDICTABLE>
     6f4:	0a280000 	beq	a006fc <_flash_swap_addr+0x9c0efc>
    case PORTC: addr = GPIOC_BASE_ADDR; break;
     6f8:	02940000 	addseq	r0, r4, #0
     6fc:	520c0000 	andpl	r0, ip, #0
     700:	01000005 	tsteq	r0, r5
    case PORTD: addr = GPIOD_BASE_ADDR; break;
     704:	000033c3 	andeq	r3, r0, r3, asr #7
     708:	6c910200 	lfmvs	f0, 4, [r1], {0}
     70c:	6e697011 	mcrvs	0, 3, r7, cr9, cr1, {0}
    case PORTE: addr = GPIOE_BASE_ADDR; break;
     710:	33c30100 	biccc	r0, r3, #0, 2
     714:	02000000 	andeq	r0, r0, #0
     718:	1d0d6891 	stcne	8, cr6, [sp, #-580]	; 0xfffffdbc
    default:
        assert(0);
     71c:	01000005 	tsteq	r0, r5
     720:	0001b6c5 	andeq	fp, r1, r5, asr #13
     724:	74910200 	ldrvc	r0, [r1], #512	; 0x200
     728:	0b460000 	bleq	1180730 <_flash_swap_addr+0x1140f30>
        return 0;
     72c:	00020000 	andeq	r0, r2, r0
    }

    return ((volatile gpioPort_t *) addr);
     730:	0000024f 	andeq	r0, r0, pc, asr #4
}
     734:	02870104 	addeq	r0, r7, #4, 2
     738:	c6010000 	strgt	r0, [r1], -r0
*
* RETURNS: Nothing
*
*******************************************************************************/
void gpioConfig(uint32_t port, uint32_t pin, uint32_t opt)
{
     73c:	16000005 	strne	r0, [r0], -r5
     740:	28000002 	stmdacs	r0, {r1}
     744:	5600000a 	strpl	r0, [r0], -sl
    /*
     * Ensure pin number is legal
     */

    assert((pin < 32));
     748:	f7000011 			; <UNDEFINED> instruction: 0xf7000011
     74c:	02000002 	andeq	r0, r0, #2
     750:	00000a33 	andeq	r0, r0, r3, lsr sl
     754:	00301702 	eorseq	r1, r0, r2, lsl #14
     758:	01030000 	mrseq	r0, (UNDEF: 3)
     75c:	0001b808 	andeq	fp, r1, r8, lsl #16

    /*
     * Config the SIM Clock Gate
     */

    switch (port) {
     760:	07020300 	streq	r0, [r2, -r0, lsl #6]
     764:	0000026a 	andeq	r0, r0, sl, ror #4
     768:	0002ff02 	andeq	pc, r2, r2, lsl #30
     76c:	49190200 	ldmdbmi	r9, {r9}
     770:	03000000 	movweq	r0, #0
     774:	01e80704 	mvneq	r0, r4, lsl #14
     778:	01030000 	mrseq	r0, (UNDEF: 3)
     77c:	0001ba06 	andeq	fp, r1, r6, lsl #20
     780:	05020300 	streq	r0, [r2, #-768]	; 0xfffffd00
     784:	00000031 	andeq	r0, r0, r1, lsr r0
     788:	f7050403 			; <UNDEFINED> instruction: 0xf7050403
     78c:	03000000 	movweq	r0, #0
     790:	01ed0704 	mvneq	r0, r4, lsl #14
     794:	01040000 	mrseq	r0, (UNDEF: 4)
     798:	a0011b03 	andge	r1, r1, r3, lsl #22
     79c:	05000000 	streq	r0, [r0, #-0]
     7a0:	000003f7 	strdeq	r0, [r0], -r7
     7a4:	03710500 	cmneq	r1, #0, 10
     7a8:	05010000 	streq	r0, [r1, #-0]
    case PORTA: SIM_SCGC5 |= SIM_SCGC5_PORTA_ENABLE; break;
     7ac:	0000035d 	andeq	r0, r0, sp, asr r3
     7b0:	01cf0502 	biceq	r0, pc, r2, lsl #10
     7b4:	05030000 	streq	r0, [r3, #-0]
     7b8:	00000185 	andeq	r0, r0, r5, lsl #3
     7bc:	03960504 	orrseq	r0, r6, #4, 10	; 0x1000000
     7c0:	05050000 	streq	r0, [r5, #-0]
     7c4:	0000004c 	andeq	r0, r0, ip, asr #32
    case PORTB: SIM_SCGC5 |= SIM_SCGC5_PORTB_ENABLE; break;
     7c8:	01040006 	tsteq	r4, r6
     7cc:	f20a1d03 	vadd.f32	d1, d10, d3
     7d0:	05000000 	streq	r0, [r0, #-0]
     7d4:	000003dc 	ldrdeq	r0, [r0], -ip
     7d8:	03080500 	movweq	r0, #34048	; 0x8500
     7dc:	05010000 	streq	r0, [r1, #-0]
    case PORTC: SIM_SCGC5 |= SIM_SCGC5_PORTC_ENABLE; break;
     7e0:	000003c0 	andeq	r0, r0, r0, asr #7
     7e4:	02410502 	subeq	r0, r1, #8388608	; 0x800000
     7e8:	05020000 	streq	r0, [r2, #-0]
     7ec:	0000010c 	andeq	r0, r0, ip, lsl #2
     7f0:	025c0503 	subseq	r0, ip, #12582912	; 0xc00000
     7f4:	05040000 	streq	r0, [r4, #-0]
     7f8:	00000100 	andeq	r0, r0, r0, lsl #2
    case PORTD: SIM_SCGC5 |= SIM_SCGC5_PORTD_ENABLE; break;
     7fc:	02060505 	andeq	r0, r6, #20971520	; 0x1400000
     800:	05060000 	streq	r0, [r6, #-0]
     804:	0000024c 	andeq	r0, r0, ip, asr #4
     808:	03cd0507 	biceq	r0, sp, #29360128	; 0x1c00000
     80c:	05080000 	streq	r0, [r8, #-0]
     810:	00000410 	andeq	r0, r0, r0, lsl r4
    case PORTE: SIM_SCGC5 |= SIM_SCGC5_PORTE_ENABLE; break;
     814:	03ab0509 			; <UNDEFINED> instruction: 0x03ab0509
     818:	000a0000 	andeq	r0, sl, r0
     81c:	00081506 	andeq	r1, r8, r6, lsl #10
     820:	0a2a0300 	beq	a81428 <_flash_swap_addr+0xa41c28>
     824:	000000a0 	andeq	r0, r0, r0, lsr #1
     828:	2d030c07 	stccs	12, cr0, [r3, #-28]	; 0xffffffe4
     82c:	0001b40a 	andeq	fp, r1, sl, lsl #8
    default:
        assert(0);
     830:	31630800 	cmncc	r3, r0, lsl #16
     834:	0a2e0300 	beq	b8143c <_flash_swap_addr+0xb41c3c>
     838:	00000025 	andeq	r0, r0, r5, lsr #32
     83c:	08002302 	stmdaeq	r0, {r1, r8, r9, sp}

    /*
     * Configure the Port Controller
     */

    uint32_t portCtrlBits = PORT_MUX_GPIO;
     840:	03003263 	movweq	r3, #611	; 0x263
     844:	00250a2f 	eoreq	r0, r5, pc, lsr #20

    if (opt & GPIO_OUTPUT) {
     848:	23020000 	movwcs	r0, #8192	; 0x2000
     84c:	33630801 	cmncc	r3, #65536	; 0x10000
        if (opt & GPIO_ODE) {
     850:	0a300300 	beq	c01458 <_flash_swap_addr+0xbc1c58>
     854:	00000025 	andeq	r0, r0, r5, lsr #32
     858:	08022302 	stmdaeq	r2, {r1, r8, r9, sp}
            portCtrlBits |= PORT_ODE;
     85c:	03003463 	movweq	r3, #1123	; 0x463
     860:	00250a31 	eoreq	r0, r5, r1, lsr sl
        } else {
            if (opt & GPIO_DSE)
     864:	23020000 	movwcs	r0, #8192	; 0x2000
     868:	35630803 	strbcc	r0, [r3, #-2051]!	; 0xfffff7fd
     86c:	0a320300 	beq	c81474 <_flash_swap_addr+0xc41c74>
                portCtrlBits |= PORT_DSE;
     870:	00000025 	andeq	r0, r0, r5, lsr #32
     874:	08042302 	stmdaeq	r4, {r1, r8, r9, sp}
        }

    } else if (opt & GPIO_INPUT) {
     878:	03003663 	movweq	r3, #1635	; 0x663
     87c:	00250a33 	eoreq	r0, r5, r3, lsr sl
     880:	23020000 	movwcs	r0, #8192	; 0x2000
        if (opt & GPIO_PFE)
     884:	00730805 	rsbseq	r0, r3, r5, lsl #16
     888:	250a3403 	strcs	r3, [sl, #-1027]	; 0xfffffbfd
     88c:	02000000 	andeq	r0, r0, #0
            portCtrlBits |= PORT_PFE;
     890:	e8090623 	stmda	r9, {r0, r1, r5, r9, sl}
     894:	03000009 	movweq	r0, #9

    } else {
        assert(0);
     898:	01b40a35 			; <UNDEFINED> instruction: 0x01b40a35
     89c:	23020000 	movwcs	r0, #8192	; 0x2000
     8a0:	74610807 	strbtvc	r0, [r1], #-2055	; 0xfffff7f9
     8a4:	36030063 	strcc	r0, [r3], -r3, rrx
        return;
     8a8:	0000250a 	andeq	r2, r0, sl, lsl #10
    }

    if (opt & GPIO_PULLUP)
     8ac:	08230200 	stmdaeq	r3!, {r9}
     8b0:	0009f109 	andeq	pc, r9, r9, lsl #2
        portCtrlBits |= PORT_PULLUP_ENABLE;
     8b4:	0a370300 	beq	dc14bc <_flash_swap_addr+0xd81cbc>
     8b8:	000001b4 			; <UNDEFINED> instruction: 0x000001b4
     8bc:	09092302 	stmdbeq	r9, {r1, r8, r9, sp}
    else if (opt & GPIO_PULLDOWN)
     8c0:	000007ba 			; <UNDEFINED> instruction: 0x000007ba
     8c4:	250a3803 	strcs	r3, [sl, #-2051]	; 0xfffff7fd
        portCtrlBits |= PORT_PULLDOWN_ENABLE;
     8c8:	02000000 	andeq	r0, r0, #0
     8cc:	6c090a23 	stcvs	10, cr0, [r9], {35}	; 0x23

    PORT_PCR(port, pin) = portCtrlBits;
     8d0:	0300000a 	movweq	r0, #10
     8d4:	00250a39 	eoreq	r0, r5, r9, lsr sl
     8d8:	23020000 	movwcs	r0, #8192	; 0x2000
     8dc:	250a000b 	strcs	r0, [sl, #-11]

    /*
     * Configure the GPIO Controller
     */

    volatile gpioPort_t *gpioPort = gpioPortGet(port);
     8e0:	06000000 	streq	r0, [r0], -r0
     8e4:	00000669 	andeq	r0, r0, r9, ror #12
    uint32_t pinBit = 1 << pin;
     8e8:	fe0a3a03 	cdp2	10, 0, cr3, cr10, cr3, {0}
     8ec:	04000000 	streq	r0, [r0], #-0
     8f0:	0a3e0301 	beq	f814fc <_flash_swap_addr+0xf41cfc>

    if (opt & GPIO_OUTPUT) {
     8f4:	0000025a 	andeq	r0, r0, sl, asr r2
     8f8:	00064e05 	andeq	r4, r6, r5, lsl #28
        gpioPort->pddr |= pinBit;
     8fc:	0501c000 	streq	ip, [r1, #-0]
     900:	0000088d 	andeq	r0, r0, sp, lsl #17
     904:	0a570538 	beq	15c1dec <_flash_swap_addr+0x15825ec>
        if (opt & GPIO_HIGH)
     908:	05040000 	streq	r0, [r4, #-0]
     90c:	00000608 	andeq	r0, r0, r8, lsl #12
     910:	09d80502 	ldmibeq	r8, {r1, r8, sl}^
            gpioPort->psor |= pinBit;
     914:	05010000 	streq	r0, [r1, #-0]
     918:	00000a0f 	andeq	r0, r0, pc, lsl #20
     91c:	08380530 	ldmdaeq	r8!, {r4, r5, r8, sl}
        else if (opt & GPIO_LOW)
     920:	05080000 	streq	r0, [r8, #-0]
     924:	00000597 	muleq	r0, r7, r5
     928:	09b50504 	ldmibeq	r5!, {r2, r8, sl}
            gpioPort->pcor |= pinBit;
     92c:	05020000 	streq	r0, [r2, #-0]
     930:	00000624 	andeq	r0, r0, r4, lsr #12
     934:	08690501 	stmdaeq	r9!, {r0, r8, sl}^
    }
}
     938:	01ff0000 	mvnseq	r0, r0
     93c:	0009fa05 	andeq	pc, r9, r5, lsl #20

/*******************************************************************************
* gpioSet
*******************************************************************************/
void gpioSet(uint32_t port, uint32_t pin)
{
     940:	05018000 	streq	r8, [r1, #-0]
     944:	0000070b 	andeq	r0, r0, fp, lsl #14
     948:	8d0500e0 	stchi	0, cr0, [r5, #-896]	; 0xfffffc80
    volatile gpioPort_t *gpioPort = gpioPortGet(port);
     94c:	1e000009 	cdpne	0, 0, cr0, cr0, cr9, {0}
     950:	000a3b05 	andeq	r3, sl, r5, lsl #22
    gpioPort->psor = 1 << pin;
     954:	7a050100 	bvc	140d5c <_flash_swap_addr+0x10155c>
     958:	c000000a 	andgt	r0, r0, sl
     95c:	067c0500 	ldrbteq	r0, [ip], -r0, lsl #10
     960:	05200000 	streq	r0, [r0, #-0]!
}
     964:	000007ef 	andeq	r0, r0, pc, ror #15
     968:	0980051f 	stmibeq	r0, {r0, r1, r2, r3, r4, r8, sl}

/*******************************************************************************
* gpioClear
*******************************************************************************/
void gpioClear(uint32_t port, uint32_t pin)
{
     96c:	01800000 	orreq	r0, r0, r0
     970:	0008f605 	andeq	pc, r8, r5, lsl #12
     974:	0500c000 	streq	ip, [r0, #-0]
    volatile gpioPort_t *gpioPort = gpioPortGet(port);
     978:	00000938 	andeq	r0, r0, r8, lsr r9
     97c:	06da0520 	ldrbeq	r0, [sl], r0, lsr #10
    gpioPort->pcor = 1 << pin;
     980:	001f0000 	andseq	r0, pc, r0
     984:	5e030104 	adfpls	f0, f3, f4
     988:	0002900a 	andeq	r9, r2, sl
     98c:	09a00500 	stmibeq	r0!, {r8, sl}
}
     990:	01800000 	orreq	r0, r0, r0
     994:	0005e405 	andeq	lr, r5, r5, lsl #8

/*******************************************************************************
* gpioToggle
*******************************************************************************/
void gpioToggle(uint32_t port, uint32_t pin)
{
     998:	0500c000 	streq	ip, [r0, #-0]
     99c:	00000974 	andeq	r0, r0, r4, ror r9
     9a0:	06170520 	ldreq	r0, [r7], -r0, lsr #10
    volatile gpioPort_t *gpioPort = gpioPortGet(port);
     9a4:	05100000 	ldreq	r0, [r0, #-0]
     9a8:	0000087c 	andeq	r0, r0, ip, ror r8
    gpioPort->ptor = 1 << pin;
     9ac:	092a050c 	stmdbeq	sl!, {r2, r3, r8, sl}
     9b0:	05020000 	streq	r0, [r2, #-0]
     9b4:	00000729 	andeq	r0, r0, r9, lsr #14
     9b8:	01070001 	tsteq	r7, r1
}
     9bc:	a80a7403 	stmdage	sl, {r0, r1, sl, ip, sp, lr}
     9c0:	08000002 	stmdaeq	r0, {r1}
*
* RETURNS:
*
*******************************************************************************/
void gpioPortWrite(uint32_t port, uint32_t mask, uint32_t value)
{
     9c4:	03007263 	movweq	r7, #611	; 0x263
     9c8:	00250a75 	eoreq	r0, r5, r5, ror sl
     9cc:	23020000 	movwcs	r0, #8192	; 0x2000
}
     9d0:	63060000 	movwvs	r0, #24576	; 0x6000
     9d4:	03000007 	movweq	r0, #7
     9d8:	02900a76 	addseq	r0, r0, #483328	; 0x76000
*
* RETURNS:
*
*******************************************************************************/
uint32_t gpioPortRead(uint32_t port)
{
     9dc:	240b0000 	strcs	r0, [fp], #-0
     9e0:	0a840301 	beq	fe1015ec <_stack_start+0xde0f15ec>
    return 0;
     9e4:	00000363 	andeq	r0, r0, r3, ror #6
}
     9e8:	72737408 	rsbsvc	r7, r3, #8, 8	; 0x8000000
     9ec:	0a850300 	beq	fe1415f4 <_stack_start+0xde1315f4>
     9f0:	0000003e 	andeq	r0, r0, lr, lsr r0
*
* RETURNS:
*
*******************************************************************************/
uint32_t gpioRead(uint32_t port, uint32_t pin)
{
     9f4:	08002302 	stmdaeq	r0, {r1, r8, r9, sp}
     9f8:	00727074 	rsbseq	r7, r2, r4, ror r0
     9fc:	3e0a8603 	cfmadd32cc	mvax0, mvfx8, mvfx10, mvfx3
    volatile gpioPort_t *gpioPort = gpioPortGet(port);
     a00:	02000000 	andeq	r0, r0, #0
     a04:	74080423 	strvc	r0, [r8], #-1059	; 0xfffffbdd
    return ((gpioPort->pdir & (1 << pin)) ? TRUE : FALSE);
     a08:	03007261 	movweq	r7, #609	; 0x261
     a0c:	003e0a87 	eorseq	r0, lr, r7, lsl #21
     a10:	23020000 	movwcs	r0, #8192	; 0x2000
     a14:	63740808 	cmnvs	r4, #8, 16	; 0x80000
     a18:	88030072 	stmdahi	r3, {r1, r4, r5, r6}
     a1c:	00003e0a 	andeq	r3, r0, sl, lsl #28
}
     a20:	0c230200 	sfmeq	f0, 4, [r3], #-0
     a24:	00726308 	rsbseq	r6, r2, r8, lsl #6
    .flashDiv     = FLASH_DIVIDER_DFLT,
};


static void fei2fee(clockConfig_t cc)
{
     a28:	3e0a8903 	cdpcc	9, 0, cr8, cr10, cr3, {0}
     a2c:	02000000 	andeq	r0, r0, #0
     a30:	73081023 	movwvc	r1, #32803	; 0x8023
     * Uno problemo: The largest divide factor available by FRDIV is 1024... And
     * 50MHz / 1024 = 48.3 kHz, which exceeds the 39.0625 kHz range. With our
     * setup, it doesn't seem that we can reach a FEE mode (and I don't want to
     * risk the tower to see what could happen if I did!)
     */
}
     a34:	8a030072 	bhi	c0c04 <_flash_swap_addr+0x81404>
     a38:	00003e0a 	andeq	r3, r0, sl, lsl #28

static void fei2pee(clockConfig_t cc)
{
     a3c:	14230200 	strtne	r0, [r3], #-512	; 0xfffffe00
     a40:	00726c08 	rsbseq	r6, r2, r8, lsl #24
     a44:	3e0a8b03 	vmlacc.f64	d8, d10, d3
                                                    /* External crystal setup */
    /* Select the OSCCLK */
    SIM_SOPT2 &= ~SIM_SOPT2_MCGCLKSEL;
     a48:	02000000 	andeq	r0, r0, #0
     a4c:	69081823 	stmdbvs	r8, {r0, r1, r5, fp, ip}
     a50:	03007265 	movweq	r7, #613	; 0x265
     a54:	003e0a8c 	eorseq	r0, lr, ip, lsl #21
     a58:	23020000 	movwcs	r0, #8192	; 0x2000
     a5c:	0a72091c 	beq	1c82ed4 <_flash_swap_addr+0x1c436d4>
     * Enabling the XTAL for 50MHz
     * RANGE=1, match the frequency of the crystal being used
     * HGO=1,   set for high gain operation (best against noise)
     * EREFS=1, enable the external oscillator
     */
    clock.mcg->c2 = (MCG_C2_RANGE_MASK & (0x1 << 4)) |
     a60:	8d030000 	stchi	0, cr0, [r3, #-0]
     a64:	0003730a 	andeq	r7, r3, sl, lsl #6
     a68:	20230200 	eorcs	r0, r3, r0, lsl #4
     a6c:	72617708 	rsbvc	r7, r1, #8, 14	; 0x200000
     * mode from FBE (here we are going to PEE)
     *
     * IREFS=0, select external reference clock and enable the external
     * oscillator.
     */
    clock.mcg->c1 = ((MCG_C1_CLKS_MASK & (0x2 << 6)) |
     a70:	0a8e0300 	beq	fe381678 <_stack_start+0xde371678>
     a74:	0000003e 	andeq	r0, r0, lr, lsr r0
     a78:	029c2303 	addseq	r2, ip, #201326592	; 0xc000000
     a7c:	72617208 	rsbvc	r7, r1, #8, 4	; 0x80000000
                    (MCG_C1_FRDIV_MASK & (0x3 << 3))) &
                    (~MCG_C1_IREFS);

                                                    /* Wait for status update */
    /* Wait for oscillator to initialize */
    while (!(clock.mcg->s & MCG_S_OSCINIT)) {}
     a80:	0a8f0300 	beq	fe3c1688 <_stack_start+0xde3b1688>
     a84:	0000003e 	andeq	r0, r0, lr, lsr r0
     a88:	02a02303 	adceq	r2, r0, #201326592	; 0xc000000
     a8c:	003e0c00 	eorseq	r0, lr, r0, lsl #24
     a90:	03730000 	cmneq	r3, #0
     a94:	650d0000 	strvs	r0, [sp, #-0]
    /* Wait for reference clock's to become the external reference */
    while (clock.mcg->s & MCG_S_IREFST) {}
     a98:	3e000000 	cdpcc	0, 0, cr0, cr0, cr0, {0}
     a9c:	03630a00 	cmneq	r3, #0, 20
     aa0:	aa060000 	bge	180aa8 <_flash_swap_addr+0x1412a8>
     aa4:	03000007 	movweq	r0, #7
     aa8:	02b40a90 	adcseq	r0, r4, #144, 20	; 0x90000
     aac:	040e0000 	streq	r0, [lr], #-0
    /* Wait for the indicator that MCGOTUCLK is fed by the external ref clock */
    while ((clock.mcg->s & MCG_S_CLKST_MASK) != (0x2 << 2)) {}
     ab0:	746e6905 	strbtvc	r6, [lr], #-2309	; 0xfffff6fb
     ab4:	05080300 	streq	r0, [r8, #-768]	; 0xfffffd00
     ab8:	000000f2 	strdeq	r0, [r0], -r2
     abc:	e3070803 	movw	r0, #30723	; 0x7803
     ac0:	03000001 	movweq	r0, #1
     ac4:	01c10801 	biceq	r0, r1, r1, lsl #16

                                            /* Generate correct PLL frequency */
    clock.mcg->c5 &= 0xE0; /* clear bits */
     ac8:	01040000 	mrseq	r0, (UNDEF: 4)
     acc:	1002cb04 	andne	ip, r2, r4, lsl #22
     ad0:	05000004 	streq	r0, [r0, #-4]
     ad4:	00000293 	muleq	r0, r3, r2
     ad8:	029f0500 	addseq	r0, pc, #0, 10
     adc:	05010000 	streq	r0, [r1, #-0]
     ae0:	000002ab 	andeq	r0, r0, fp, lsr #5
     ae4:	02b70502 	adcseq	r0, r7, #8388608	; 0x800000
    clock.mcg->c5 |= clockConfigParam[cc].divider;
     ae8:	05030000 	streq	r0, [r3, #-0]
     aec:	000002c3 	andeq	r0, r0, r3, asr #5
     af0:	02cf0504 	sbceq	r0, pc, #4, 10	; 0x1000000
     af4:	05050000 	streq	r0, [r5, #-0]
     af8:	000002db 	ldrdeq	r0, [r0], -fp
     afc:	02e70506 	rsceq	r0, r7, #25165824	; 0x1800000
     b00:	05070000 	streq	r0, [r7, #-0]
     b04:	000002f3 	strdeq	r0, [r0], -r3
     b08:	012d0508 	teqeq	sp, r8, lsl #10
     b0c:	05090000 	streq	r0, [r9, #-0]
     b10:	0000013a 	andeq	r0, r0, sl, lsr r1
     b14:	0147050a 	cmpeq	r7, sl, lsl #10
    clock.mcg->c6 &= 0xE0;
     b18:	050b0000 	streq	r0, [fp, #-0]
     b1c:	00000154 	andeq	r0, r0, r4, asr r1
     b20:	0161050c 	cmneq	r1, ip, lsl #10
     b24:	050d0000 	streq	r0, [sp, #-0]
     b28:	00000389 	andeq	r0, r0, r9, lsl #7
     b2c:	0178050e 	cmneq	r8, lr, lsl #10
     b30:	050f0000 	streq	r0, [pc, #-0]	; b38 <fei2pee+0xfc>
     b34:	00000425 	andeq	r0, r0, r5, lsr #8
    clock.mcg->c6 |= clockConfigParam[cc].multiplier;
     b38:	b0060010 	andlt	r0, r6, r0, lsl r0
     b3c:	04000007 	streq	r0, [r0], #-7
     b40:	03a002dd 	moveq	r0, #-805306355	; 0xd000000d
     b44:	01040000 	mrseq	r0, (UNDEF: 4)
     b48:	3e02e004 	cdpcc	0, 0, cr14, cr2, cr4, {0}
     b4c:	05000004 	streq	r0, [r0, #-4]
     b50:	00000317 	andeq	r0, r0, r7, lsl r3
     b54:	032f0500 	teqeq	pc, #0, 10
     b58:	05010000 	streq	r0, [r1, #-0]
     b5c:	00000346 	andeq	r0, r0, r6, asr #6
     b60:	01a20502 			; <UNDEFINED> instruction: 0x01a20502
     b64:	00030000 	andeq	r0, r3, r0
                                                            /* Enter PBE mode */
    /* PLLS=1, select the PLL. */
    clock.mcg->c6 |= MCG_C6_PLLS;
     b68:	00094306 	andeq	r4, r9, r6, lsl #6
     b6c:	02e50400 	rsceq	r0, r5, #0, 8
     b70:	0000041c 	andeq	r0, r0, ip, lsl r4
     b74:	1f010c0f 	svcne	0x00010c0f
     b78:	0000047d 	andeq	r0, r0, sp, ror r4
     b7c:	67636d10 			; <UNDEFINED> instruction: 0x67636d10
     b80:	7d200100 	stfvcs	f0, [r0, #-0]
     b84:	02000004 	andeq	r0, r0, #4

                                                    /* Wait for status update */
    /* Wait for the PLL to be the clock source */
    while (!(clock.mcg->s & MCG_S_PLLST)) {}
     b88:	6f100023 	svcvs	0x00100023
     b8c:	01006373 	tsteq	r0, r3, ror r3
     b90:	00048821 	andeq	r8, r4, r1, lsr #16
     b94:	04230200 	strteq	r0, [r3], #-512	; 0xfffffe00
     b98:	63747210 	cmnvs	r4, #16, 4
     b9c:	93220100 	teqls	r2, #0, 2
    /* Wait until the PLL has acquired lock on the external frequency */
    while (!(clock.mcg->s & MCG_S_LOCK)) {}
     ba0:	02000004 	andeq	r0, r0, #4
     ba4:	11000823 	tstne	r0, r3, lsr #16
     ba8:	00048304 	andeq	r8, r4, r4, lsl #6
     bac:	01b91200 			; <UNDEFINED> instruction: 0x01b91200
     bb0:	04110000 	ldreq	r0, [r1], #-0
     bb4:	0000048e 	andeq	r0, r0, lr, lsl #9

                                                            /* Enter PEE mode */
    /* Select the output of the PLL */
    clock.mcg->c1 &= ~MCG_C1_CLKS_MASK;
     bb8:	0002a812 	andeq	sl, r2, r2, lsl r8
     bbc:	99041100 	stmdbls	r4, {r8, ip}
     bc0:	12000004 	andne	r0, r0, #4
     bc4:	00000378 	andeq	r0, r0, r8, ror r3
     bc8:	0007e402 	andeq	lr, r7, r2, lsl #8
     bcc:	4a230100 	bmi	8c0fd4 <_flash_swap_addr+0x8817d4>
     bd0:	13000004 	movwne	r0, #4
     bd4:	ee2b0101 	sufe	f0, f3, f1

                                                    /* Wait for status update */
    /* Wait until output of the PLL is selected */
    while ((clock.mcg->s & MCG_S_CLKST_MASK) != (0x3 << 2)) {}
     bd8:	05000004 	streq	r0, [r0, #-4]
     bdc:	0000096b 	andeq	r0, r0, fp, ror #18
     be0:	09510500 	ldmdbeq	r1, {r8, sl}^
     be4:	05010000 	streq	r0, [r1, #-0]
     be8:	00000abc 			; <UNDEFINED> instruction: 0x00000abc
     bec:	065f0502 	ldrbeq	r0, [pc], -r2, lsl #10

    mcgState.currentMode = MODE_PEE;
     bf0:	05030000 	streq	r0, [r3, #-0]
     bf4:	00000638 	andeq	r0, r0, r8, lsr r6
     bf8:	075a0504 	ldrbeq	r0, [sl, -r4, lsl #10]
}
     bfc:	05050000 	streq	r0, [r5, #-0]
     c00:	00000751 	andeq	r0, r0, r1, asr r7
     c04:	09170506 	ldmdbeq	r7, {r1, r2, r8, sl}

static void fei2blpi(clockConfig_t cc)
{
     c08:	05070000 	streq	r0, [r7, #-0]
     c0c:	000006d0 	ldrdeq	r0, [r0], -r0	; <UNPREDICTABLE>
     c10:	09200508 	stmdbeq	r0!, {r3, r8, sl}
                                                            /* Not configured */
}
     c14:	00090000 	andeq	r0, r9, r0
     c18:	00090202 	andeq	r0, r9, r2, lsl #4

static void fei2blpe(clockConfig_t cc)
{
     c1c:	a9360100 	ldmdbge	r6!, {r8}
     c20:	13000004 	movwne	r0, #4
     c24:	0e380101 	rsfeqe	f0, f0, f1
                                                            /* Not configured */
}
     c28:	05000005 	streq	r0, [r0, #-5]
     c2c:	000008d0 	ldrdeq	r0, [r0], -r0	; <UNPREDICTABLE>


static void fee2fei(clockConfig_t cc)
{
     c30:	068b0500 	streq	r0, [fp], r0, lsl #10
     c34:	00010000 	andeq	r0, r1, r0
     c38:	00066f02 	andeq	r6, r6, r2, lsl #30
                                                            /* Not configured */
}
     c3c:	f93b0100 			; <UNDEFINED> instruction: 0xf93b0100
     c40:	0f000004 	svceq	0x00000004

static void fee2pee(clockConfig_t cc)
{
     c44:	683d0108 	ldmdavs	sp!, {r3, r8}
     c48:	14000005 	strne	r0, [r0], #-5
     c4c:	000008e3 	andeq	r0, r0, r3, ror #17
                                                            /* Not configured */
}
     c50:	04ee3e01 	strbteq	r3, [lr], #3585	; 0xe01
     c54:	23020000 	movwcs	r0, #8192	; 0x2000

static void fee2blpi(clockConfig_t cc)
{
     c58:	0a641400 	beq	1905c60 <_flash_swap_addr+0x18c6460>
     c5c:	3f010000 	svccc	0x00010000
     c60:	00000025 	andeq	r0, r0, r5, lsr #32
                                                            /* Not configured */
}
     c64:	14012302 	strne	r2, [r1], #-770	; 0xfffffcfe
     c68:	0000080a 	andeq	r0, r0, sl, lsl #16

static void fee2blpe(clockConfig_t cc)
{
     c6c:	00254001 	eoreq	r4, r5, r1
     c70:	23020000 	movwcs	r0, #8192	; 0x2000
     c74:	06eb1402 	strbteq	r1, [fp], r2, lsl #8
                                                            /* Not configured */
}
     c78:	41010000 	mrsmi	r0, (UNDEF: 1)
     c7c:	0000050e 	andeq	r0, r0, lr, lsl #10


static void pee2fei(clockConfig_t cc)
{
     c80:	14032302 	strne	r2, [r3], #-770	; 0xfffffcfe
     c84:	00000861 	andeq	r0, r0, r1, ror #16
     c88:	003e4201 	eorseq	r4, lr, r1, lsl #4

                                                            /* Enter PBE mode */
    clock.mcg->c1 = (MCG_C1_CLKS_MASK & (0x2 << 6)); /* Select external clock */
     c8c:	23020000 	movwcs	r0, #8192	; 0x2000
     c90:	c0020004 	andgt	r0, r2, r4
     c94:	01000007 	tsteq	r0, r7
     c98:	00051943 	andeq	r1, r5, r3, asr #18

                                                    /* Wait for status update */
    while ((clock.mcg->s & MCG_S_CLKST_MASK) != (0x2 << 2)) {}
     c9c:	01030f00 	tsteq	r3, r0, lsl #30
     ca0:	0005a672 	andeq	sl, r5, r2, ror r6
     ca4:	07691400 	strbeq	r1, [r9, -r0, lsl #8]!
     ca8:	73010000 	movwvc	r0, #4096	; 0x1000
     cac:	000004ee 	andeq	r0, r0, lr, ror #9
     cb0:	14002302 	strne	r2, [r0], #-770	; 0xfffffcfe

                                                            /* Enter FBE mode */
    /*
     * With the FLL frequency valid, we can now clear the PLLS bit to select FLL
     */
    clock.mcg->c6 &= ~MCG_C6_PLLS;
     cb4:	000008ed 	andeq	r0, r0, sp, ror #17
     cb8:	04ee7401 	strbteq	r7, [lr], #1025	; 0x401
     cbc:	23020000 	movwcs	r0, #8192	; 0x2000
     cc0:	08551401 	ldmdaeq	r5, {r0, sl, ip}^
     cc4:	75010000 	strvc	r0, [r1, #-0]
     cc8:	0000043e 	andeq	r0, r0, lr, lsr r4
     ccc:	00022302 	andeq	r2, r2, r2, lsl #6
     cd0:	0008a702 	andeq	sl, r8, r2, lsl #14

                                                    /* Wait for status update */
    /* Wait until the current source is FLL */
    while (clock.mcg->s & MCG_S_PLLST) {}
     cd4:	73760100 	cmnvc	r6, #0, 2
     cd8:	0f000005 	svceq	0x00000005
     cdc:	007b0108 	rsbseq	r0, fp, r8, lsl #2
     ce0:	14000006 	strne	r0, [r0], #-6
     ce4:	00000a4a 	andeq	r0, r0, sl, asr #20
     ce8:	003e7c01 	eorseq	r7, lr, r1, lsl #24

                                            /* Generate correct FLL frequency */
    clock.mcg->c4 = clockConfigParam[cc].multiplier;
     cec:	23020000 	movwcs	r0, #8192	; 0x2000
     cf0:	08231400 	stmdaeq	r3!, {sl, ip}
     cf4:	7d010000 	stcvc	0, cr0, [r1, #-0]
     cf8:	00000410 	andeq	r0, r0, r0, lsl r4
     cfc:	14042302 	strne	r2, [r4], #-770	; 0xfffffcfe
     d00:	000005ad 	andeq	r0, r0, sp, lsr #11
     d04:	04107e01 	ldreq	r7, [r0], #-3585	; 0xfffff1ff

                                                            /* Enter FEI mode */
    clock.mcg->c1 = (MCG_C1_CLKS_MASK & (0x0 << 6)) |
     d08:	23020000 	movwcs	r0, #8192	; 0x2000
     d0c:	082d1405 	stmdaeq	sp!, {r0, r2, sl, ip}
     d10:	7f010000 	svcvc	0x00010000
     d14:	00000410 	andeq	r0, r0, r0, lsl r4
                    (MCG_C1_IREFS);

                                                    /* Wait for status update */
    /* Wait for reference clock's to become the internal reference */
    while (!(clock.mcg->s & MCG_S_IREFST)) {}
     d18:	14062302 	strne	r2, [r6], #-770	; 0xfffffcfe
     d1c:	000005a4 	andeq	r0, r0, r4, lsr #11
     d20:	04108001 	ldreq	r8, [r0], #-1
     d24:	23020000 	movwcs	r0, #8192	; 0x2000
     d28:	42020007 	andmi	r0, r2, #7
     d2c:	01000006 	tsteq	r0, r6
    /* Wait until the output of the FLL is selected */
    while ((clock.mcg->s & MCG_S_CLKST_MASK) != (0x0 << 2)) {}
     d30:	0005b181 	andeq	fp, r5, r1, lsl #3
     d34:	089f1500 	ldmeq	pc, {r8, sl, ip}	; <UNPREDICTABLE>
     d38:	9a010000 	bls	40d40 <_flash_swap_addr+0x1540>
     d3c:	000a2801 	andeq	r2, sl, r1, lsl #16
     d40:	000a3c00 	andeq	r3, sl, r0, lsl #24
     d44:	0002cc00 	andeq	ip, r2, r0, lsl #24

    mcgState.currentMode = MODE_FEI;
     d48:	00063100 	andeq	r3, r6, r0, lsl #2
     d4c:	63631600 	cmnvs	r3, #0, 12
     d50:	3e9a0100 	fmlcce	f0, f2, f0
     d54:	02000004 	andeq	r0, r0, #4
}
     d58:	15007791 	strne	r7, [r0, #-1937]	; 0xfffff86f
     d5c:	000009bf 			; <UNDEFINED> instruction: 0x000009bf

static void pee2fee(clockConfig_t cc)
{
     d60:	3c01ab01 	stccc	11, cr10, [r1], {1}
     d64:	0600000a 	streq	r0, [r0], -sl
     d68:	0400000c 	streq	r0, [r0], #-12
                                                            /* Not configured */
}
     d6c:	57000003 	strpl	r0, [r0, -r3]
     d70:	16000006 	strne	r0, [r0], -r6

static void pee2blpi(clockConfig_t cc)
{
     d74:	01006363 	tsteq	r0, r3, ror #6
     d78:	00043eab 	andeq	r3, r4, fp, lsr #29
     d7c:	77910200 	ldrvc	r0, [r1, r0, lsl #4]
                                                            /* Not configured */
}
     d80:	07a11500 	streq	r1, [r1, r0, lsl #10]!
     d84:	ec010000 	stc	0, cr0, [r1], {-0}

static void pee2blpe(clockConfig_t cc)
{
     d88:	000c0801 	andeq	r0, ip, r1, lsl #16
     d8c:	000c1c00 	andeq	r1, ip, r0, lsl #24
     d90:	00033c00 	andeq	r3, r3, r0, lsl #24
                                                            /* Not configured */
}
     d94:	00067d00 	andeq	r7, r6, r0, lsl #26
     d98:	63631600 	cmnvs	r3, #0, 12


static void blpi2fei(clockConfig_t cc)
{
     d9c:	3eec0100 	cdpcc	1, 14, cr0, cr12, cr0, {0}
     da0:	02000004 	andeq	r0, r0, #4
     da4:	15007791 	strne	r7, [r0, #-1937]	; 0xfffff86f
                                                            /* Not configured */
}
     da8:	00000798 	muleq	r0, r8, r7
     dac:	1c01f101 	stfned	f7, [r1], {1}

static void blpi2fee(clockConfig_t cc)
{
     db0:	3000000c 	andcc	r0, r0, ip
     db4:	7400000c 	strvc	r0, [r0], #-12
     db8:	a3000003 	movwge	r0, #3
                                                            /* Not configured */
}
     dbc:	16000006 	strne	r0, [r0], -r6
     dc0:	01006363 	tsteq	r0, r3, ror #6

static void blpi2pee(clockConfig_t cc)
{
     dc4:	00043ef1 	strdeq	r3, [r4], -r1
     dc8:	77910200 	ldrvc	r0, [r1, r0, lsl #4]
     dcc:	06301500 	ldrteq	r1, [r0], -r0, lsl #10
                                                            /* Not configured */
}
     dd0:	f7010000 			; <UNDEFINED> instruction: 0xf7010000
     dd4:	000c3001 	andeq	r3, ip, r1

static void blpi2blpe(clockConfig_t cc)
{
     dd8:	000c4400 	andeq	r4, ip, r0, lsl #8
     ddc:	0003ac00 	andeq	sl, r3, r0, lsl #24
     de0:	0006c900 	andeq	ip, r6, r0, lsl #18
                                                            /* Not configured */
}
     de4:	63631600 	cmnvs	r3, #0, 12
     de8:	3ef70100 	cdpcc	1, 15, cr0, cr7, cr0, {0}


static void blpe2fei(clockConfig_t cc)
{
     dec:	02000004 	andeq	r0, r0, #4
     df0:	15007791 	strne	r7, [r0, #-1937]	; 0xfffff86f
     df4:	00000703 	andeq	r0, r0, r3, lsl #14
                                                            /* Not configured */
}
     df8:	4401fc01 	strmi	pc, [r1], #-3073	; 0xfffff3ff
     dfc:	5800000c 	stmdapl	r0, {r2, r3}

static void blpe2fee(clockConfig_t cc)
{
     e00:	e400000c 	str	r0, [r0], #-12
     e04:	ef000003 	svc	0x00000003
     e08:	16000006 	strne	r0, [r0], -r6
                                                            /* Not configured */
}
     e0c:	01006363 	tsteq	r0, r3, ror #6
     e10:	00043efc 	strdeq	r3, [r4], -ip

static void blpe2pee(clockConfig_t cc)
{
     e14:	77910200 	ldrvc	r0, [r1, r0, lsl #4]
     e18:	07481700 	strbeq	r1, [r8, -r0, lsl #14]
     e1c:	01010000 	mrseq	r0, (UNDEF: 1)
                                                            /* Not configured */
}
     e20:	0c580101 	ldfeqe	f0, [r8], {1}
     e24:	0c6c0000 	stcleq	0, cr0, [ip], #-0

static void blpe2blpi(clockConfig_t cc)
{
     e28:	041c0000 	ldreq	r0, [ip], #-0
     e2c:	07170000 	ldreq	r0, [r7, -r0]
     e30:	63180000 	tstvs	r8, #0
                                                            /* Not configured */
}
     e34:	01010063 	tsteq	r1, r3, rrx
     e38:	00043e01 	andeq	r3, r4, r1, lsl #28
* system, bus, flexbus, and flash clock frequencies.
*
*******************************************************************************/
void clockSetDividers(divider_t systemDiv, divider_t busDiv,
                                       divider_t flexBusDiv, divider_t flashDiv)
{
     e3c:	77910200 	ldrvc	r0, [r1, r0, lsl #4]
     e40:	07351700 	ldreq	r1, [r5, -r0, lsl #14]!
     e44:	06010000 	streq	r0, [r1], -r0
     e48:	0c6c0101 	stfeqe	f0, [ip], #-4
    int mcgClock = clockFreq.mcgClockFreq;
     e4c:	0c800000 	stceq	0, cr0, [r0], {0}
     e50:	04540000 	ldrbeq	r0, [r4], #-0
     e54:	073f0000 	ldreq	r0, [pc, -r0]!

    /*
     * The asserts are raised when the internal clock requirements (sec. 5.5)
     * are not met.
     */
    assert( (mcgClock / (systemDiv +1)) <= MAX_SYSTEM_FREQ);
     e58:	63180000 	tstvs	r8, #0
     e5c:	06010063 	streq	r0, [r1], -r3, rrx
     e60:	00043e01 	andeq	r3, r4, r1, lsl #28
     e64:	77910200 	ldrvc	r0, [r1, r0, lsl #4]
     e68:	0a071700 	beq	1c6a70 <_flash_swap_addr+0x187270>
     e6c:	0c010000 	stceq	0, cr0, [r1], {-0}
     e70:	0c800101 	stfeqs	f0, [r0], {1}
     e74:	0d600000 	stcleq	0, cr0, [r0, #-0]
     e78:	048c0000 	streq	r0, [ip], #0
     e7c:	07670000 	strbeq	r0, [r7, -r0]!

    assert( (mcgClock / (busDiv    +1)) <= MAX_BUS_FREQ &&
     e80:	63180000 	tstvs	r8, #0
     e84:	0c010063 	stceq	0, cr0, [r1], {99}	; 0x63
     e88:	00043e01 	andeq	r3, r4, r1, lsl #28
     e8c:	77910200 	ldrvc	r0, [r1, r0, lsl #4]
     e90:	084d1700 	stmdaeq	sp, {r8, r9, sl, ip}^
     e94:	2f010000 	svccs	0x00010000
     e98:	0d600101 	stfeqe	f0, [r0, #-4]!
     e9c:	0d740000 	ldcleq	0, cr0, [r4, #-0]
     ea0:	04c40000 	strbeq	r0, [r4], #0
     ea4:	078f0000 	streq	r0, [pc, r0]
     ea8:	63180000 	tstvs	r8, #0
     eac:	2f010063 	svccs	0x00010063
     eb0:	00043e01 	andeq	r3, r4, r1, lsl #28
     eb4:	77910200 	ldrvc	r0, [r1, r0, lsl #4]
     eb8:	0aad1700 	beq	feb46ac0 <_stack_start+0xdeb36ac0>
     ebc:	34010000 	strcc	r0, [r1], #-0
     ec0:	0d740101 	ldfeqe	f0, [r4, #-4]!
            (mcgClock / (busDiv    +1)) <= (mcgClock / (systemDiv+1)));

    assert( (mcgClock / (flashDiv  +1)) <= MAX_FLASH_FREQ &&
     ec4:	0d880000 	stceq	0, cr0, [r8]
     ec8:	04fc0000 	ldrbteq	r0, [ip], #0
     ecc:	07b70000 	ldreq	r0, [r7, r0]!
     ed0:	63180000 	tstvs	r8, #0
     ed4:	34010063 	strcc	r0, [r1], #-99	; 0xffffff9d
     ed8:	00043e01 	andeq	r3, r4, r1, lsl #28
     edc:	77910200 	ldrvc	r0, [r1, r0, lsl #4]
     ee0:	0aa41700 	beq	fe906ae8 <_stack_start+0xde8f6ae8>
     ee4:	39010000 	stmdbcc	r1, {}	; <UNPREDICTABLE>
     ee8:	0d880101 	stfeqs	f0, [r8, #4]
     eec:	0d9c0000 	ldceq	0, cr0, [ip]
     ef0:	05340000 	ldreq	r0, [r4, #-0]!
     ef4:	07df0000 	ldrbeq	r0, [pc, r0]
     ef8:	63180000 	tstvs	r8, #0
     efc:	39010063 	stmdbcc	r1, {r0, r1, r5, r6}
     f00:	00043e01 	andeq	r3, r4, r1, lsl #28
     f04:	77910200 	ldrvc	r0, [r1, r0, lsl #4]
            (mcgClock / (flashDiv  +1)) <= (mcgClock / (busDiv+1)));

    assert( (mcgClock / (flexBusDiv+1)) <= (mcgClock / (busDiv+1)));
     f08:	06a31700 	strteq	r1, [r3], r0, lsl #14
     f0c:	3f010000 	svccc	0x00010000
     f10:	0d9c0101 	ldfeqs	f0, [ip, #4]
     f14:	0db00000 	ldceq	0, cr0, [r0]
     f18:	056c0000 	strbeq	r0, [ip, #-0]!
     f1c:	08070000 	stmdaeq	r7, {}	; <UNPREDICTABLE>
     f20:	63180000 	tstvs	r8, #0
     f24:	3f010063 	svccc	0x00010063
     f28:	00043e01 	andeq	r3, r4, r1, lsl #28
     f2c:	77910200 	ldrvc	r0, [r1, r0, lsl #4]
     f30:	069a1700 	ldreq	r1, [sl], r0, lsl #14

    /* Save the new dividers */
    clockFreq.systemDiv  = systemDiv;
     f34:	44010000 	strmi	r0, [r1], #-0
     f38:	0db00101 	ldfeqs	f0, [r0, #4]!
     f3c:	0dc40000 	stcleq	0, cr0, [r4]
    clockFreq.busDiv     = busDiv;
     f40:	05a40000 	streq	r0, [r4, #0]!
     f44:	082f0000 	stmdaeq	pc!, {}	; <UNPREDICTABLE>
     f48:	63180000 	tstvs	r8, #0
    clockFreq.flexBusDiv = flexBusDiv;
     f4c:	44010063 	strmi	r0, [r1], #-99	; 0xffffff9d
     f50:	00043e01 	andeq	r3, r4, r1, lsl #28
     f54:	77910200 	ldrvc	r0, [r1, r0, lsl #4]
    clockFreq.flashDiv   = flashDiv;
     f58:	078f1700 	streq	r1, [pc, r0, lsl #14]
     f5c:	49010000 	stmdbmi	r1, {}	; <UNPREDICTABLE>
     f60:	0dc40101 	stfeqe	f0, [r4, #4]

    /* Set the SIM clock dividers */
    SIM_CLKDIV1 = (systemDiv << 28)  |
     f64:	0dd80000 	ldcleq	0, cr0, [r8]
     f68:	05dc0000 	ldrbeq	r0, [ip]
     f6c:	08570000 	ldmdaeq	r7, {}^	; <UNPREDICTABLE>
                  (busDiv << 24)     |
     f70:	63180000 	tstvs	r8, #0
     f74:	49010063 	stmdbmi	r1, {r0, r1, r5, r6}
                  (flexBusDiv << 20) |
     f78:	00043e01 	andeq	r3, r4, r1, lsl #28
     f7c:	77910200 	ldrvc	r0, [r1, r0, lsl #4]
                  (flashDiv << 16);
     f80:	073e1700 	ldreq	r1, [lr, -r0, lsl #14]!
     f84:	4e010000 	cdpmi	0, 0, cr0, cr1, cr0, {0}
    clockFreq.busDiv     = busDiv;
    clockFreq.flexBusDiv = flexBusDiv;
    clockFreq.flashDiv   = flashDiv;

    /* Set the SIM clock dividers */
    SIM_CLKDIV1 = (systemDiv << 28)  |
     f88:	0dd80101 	ldfeqe	f0, [r8, #4]
                  (busDiv << 24)     |
                  (flexBusDiv << 20) |
                  (flashDiv << 16);
}
     f8c:	0dec0000 	stcleq	0, cr0, [ip]
     f90:	06140000 	ldreq	r0, [r4], -r0
*
* Grab the clock frequency for a particular clock source in Hz.
*
*******************************************************************************/
uint32_t clockGetFreq(clockSource_t cs)
{
     f94:	087f0000 	ldmdaeq	pc!, {}^	; <UNPREDICTABLE>
     f98:	63180000 	tstvs	r8, #0
     f9c:	4e010063 	cdpmi	0, 0, cr0, cr1, cr3, {3}
    uint32_t clock;

    switch (cs) {
     fa0:	00043e01 	andeq	r3, r4, r1, lsl #28
     fa4:	77910200 	ldrvc	r0, [r1, r0, lsl #4]
     fa8:	0a8a1700 	beq	fe286bb0 <_stack_start+0xde276bb0>
     fac:	54010000 	strpl	r0, [r1], #-0
     fb0:	0dec0101 	stfeqe	f0, [ip, #4]!
     fb4:	0e000000 	cdpeq	0, 0, cr0, cr0, cr0, {0}
     fb8:	064c0000 	strbeq	r0, [ip], -r0
     fbc:	08a70000 	stmiaeq	r7!, {}	; <UNPREDICTABLE>
    case CLOCK_SYSTEM:
        clock = clockFreq.mcgClockFreq / (clockFreq.systemDiv + 1);
     fc0:	63180000 	tstvs	r8, #0
     fc4:	54010063 	strpl	r0, [r1], #-99	; 0xffffff9d
     fc8:	00043e01 	andeq	r3, r4, r1, lsl #28
     fcc:	77910200 	ldrvc	r0, [r1, r0, lsl #4]
     fd0:	090e1700 	stmdbeq	lr, {r8, r9, sl, ip}
     fd4:	59010000 	stmdbpl	r1, {}	; <UNPREDICTABLE>
     fd8:	0e000101 	adfeqs	f0, f0, f1
     fdc:	0e140000 	cdpeq	0, 1, cr0, cr4, cr0, {0}
        break;
    case CLOCK_BUS:
        clock = clockFreq.mcgClockFreq / (clockFreq.busDiv + 1);
     fe0:	06840000 	streq	r0, [r4], r0
     fe4:	08cf0000 	stmiaeq	pc, {}^	; <UNPREDICTABLE>
     fe8:	63180000 	tstvs	r8, #0
     fec:	59010063 	stmdbpl	r1, {r0, r1, r5, r6}
     ff0:	00043e01 	andeq	r3, r4, r1, lsl #28
     ff4:	77910200 	ldrvc	r0, [r1, r0, lsl #4]
     ff8:	08011700 	stmdaeq	r1, {r8, r9, sl, ip}
     ffc:	5e010000 	cdppl	0, 0, cr0, cr1, cr0, {0}
        break;
    case CLOCK_FLEXBUS:
        clock = clockFreq.mcgClockFreq / (clockFreq.flexBusDiv + 1);
    1000:	0e140101 	mufeqs	f0, f4, f1
    1004:	0e280000 	cdpeq	0, 2, cr0, cr8, cr0, {0}
    1008:	06bc0000 	ldrteq	r0, [ip], r0
    100c:	08f70000 	ldmeq	r7!, {}^	; <UNPREDICTABLE>
    1010:	63180000 	tstvs	r8, #0
    1014:	5e010063 	cdppl	0, 0, cr0, cr1, cr3, {3}
    1018:	00043e01 	andeq	r3, r4, r1, lsl #28
    101c:	77910200 	ldrvc	r0, [r1, r0, lsl #4]
        break;
    case CLOCK_FLASH:
        clock = clockFreq.mcgClockFreq / (clockFreq.flashDiv + 1);
    1020:	08431700 	stmdaeq	r3, {r8, r9, sl, ip}^
    1024:	63010000 	movwvs	r0, #4096	; 0x1000
    1028:	0e280101 	sufeqe	f0, f0, f1
    102c:	0e3c0000 	cdpeq	0, 3, cr0, cr12, cr0, {0}
    1030:	06f40000 	ldrbteq	r0, [r4], r0
    1034:	091f0000 	ldmdbeq	pc, {}	; <UNPREDICTABLE>
    1038:	63180000 	tstvs	r8, #0
    103c:	63010063 	movwvs	r0, #4195	; 0x1063
        break;
    default:
        assert(0);
    1040:	00043e01 	andeq	r3, r4, r1, lsl #28
    1044:	77910200 	ldrvc	r0, [r1, r0, lsl #4]
    1048:	5a011900 	bpl	47450 <_flash_swap_addr+0x7c50>
    104c:	01000009 	tsteq	r0, r9
    }

    return clock;
    1050:	3c010170 	stfccs	f0, [r1], {112}	; 0x70
}
    1054:	9200000e 	andls	r0, r0, #14
    1058:	2c00000f 	stccs	0, cr0, [r0], {15}
*        ____ STOP ____ (Entered when MCU enters stop mode, and returns to
*                        previous active mode when exits stop mode )
*
*******************************************************************************/
void clockConfigMcgOut(clockConfig_t clockConfig)
{
    105c:	85000007 	strhi	r0, [r0, #-7]
    1060:	1a000009 	bne	108c <clockConfigMcgOut+0x30>
    1064:	00000823 	andeq	r0, r0, r3, lsr #16
        {  pee2fei,  pee2fee,     NULL,  pee2blpi,  pee2blpe, },
        { blpi2fei, blpi2fee, blpi2pee,      NULL, blpi2blpe, },
        { blpe2fei, blpe2fee, blpe2pee, blpe2blpi,      NULL, },
    };

    assert(clockConfig < MAX_MCG_CLOCK_OPTIONS);
    1068:	10017001 	andne	r7, r1, r1
    106c:	02000004 	andeq	r0, r0, #4
    1070:	ad1a6f91 	ldcge	15, cr6, [sl, #-580]	; 0xfffffdbc
    1074:	01000005 	tsteq	r0, r5
    1078:	04100170 	ldreq	r0, [r0], #-368	; 0xfffffe90

    mcgState.nextMode = clockConfigParam[clockConfig].clockMode;
    107c:	91020000 	mrsls	r0, (UNDEF: 2)
    1080:	082d1a6e 	stmdaeq	sp!, {r1, r2, r3, r5, r6, r9, fp, ip}
    1084:	71010000 	mrsvc	r0, (UNDEF: 1)
    1088:	00041001 	andeq	r1, r4, r1
    108c:	6d910200 	lfmvs	f0, 4, [r1]
    1090:	0005a41a 	andeq	sl, r5, sl, lsl r4

    jumpTable[mcgState.currentMode][mcgState.nextMode](clockConfig);
    1094:	01710100 	cmneq	r1, r0, lsl #2
    1098:	00000410 	andeq	r0, r0, r0, lsl r4
    109c:	1b6c9102 	blne	1b254ac <_flash_swap_addr+0x1ae5cac>
    10a0:	00000775 	andeq	r0, r0, r5, ror r7
    10a4:	84017301 	strhi	r7, [r1], #-769	; 0xfffffcff
    10a8:	02000003 	andeq	r0, r0, #3
    10ac:	1c007491 	cfstrsne	mvf7, [r0], {145}	; 0x91
    10b0:	0006f601 	andeq	pc, r6, r1, lsl #12
    10b4:	01970100 	orrseq	r0, r7, r0, lsl #2
    10b8:	00003e01 	andeq	r3, r0, r1, lsl #28
    10bc:	000f9400 	andeq	r9, pc, r0, lsl #8
    10c0:	00105c00 	andseq	r5, r0, r0, lsl #24
    10c4:	00076400 	andeq	r6, r7, r0, lsl #8

    /* Store the new clock frequency for clockGetFreq() */
    clockFreq.mcgClockFreq = clockConfigParam[clockConfig].clockHz;
    10c8:	0009c100 	andeq	ip, r9, r0, lsl #2
    10cc:	73631800 	cmnvc	r3, #0, 16
    10d0:	01970100 	orrseq	r0, r7, r0, lsl #2
    10d4:	000000f2 	strdeq	r0, [r0], -r2
    10d8:	1b6f9102 	blne	1be54e8 <_flash_swap_addr+0x1ba5ce8>
    10dc:	00000ab6 			; <UNDEFINED> instruction: 0x00000ab6
    10e0:	3e019901 	cdpcc	9, 0, cr9, cr1, cr1, {0}
}
    10e4:	02000000 	andeq	r0, r0, #0
    10e8:	19007491 	stmdbne	r0, {r0, r4, r7, sl, ip, sp, lr}

/*******************************************************************************
* clockConfigMcgIr
*******************************************************************************/
void clockConfigMcgIr()
{
    10ec:	0006ac01 	andeq	sl, r6, r1, lsl #24
                                                            /* Not configured */
}
    10f0:	01c90100 	biceq	r0, r9, r0, lsl #2
    10f4:	00105c01 	andseq	r5, r0, r1, lsl #24

/*******************************************************************************
* clockConfigMcgFf
*******************************************************************************/
void clockConfigMcgFf()
{
    10f8:	0010ec00 	andseq	lr, r0, r0, lsl #24
                                                            /* Not configured */
}
    10fc:	00079c00 	andeq	r9, r7, r0, lsl #24
    1100:	0009fd00 	andeq	pc, r9, r0, lsl #26

/*******************************************************************************
* clockConfigMcgFll
*******************************************************************************/
void clockConfigMcgFll()
{
    1104:	08551a00 	ldmdaeq	r5, {r9, fp, ip}^
                                                            /* Not configured */
}
    1108:	c9010000 	stmdbgt	r1, {}	; <UNPREDICTABLE>
    110c:	00043e01 	andeq	r3, r4, r1, lsl #28

/*******************************************************************************
* clockConfigMcgPll
*******************************************************************************/
void clockConfigMcgPll()
{
    1110:	77910200 	ldrvc	r0, [r1, r0, lsl #4]
                                                            /* Not configured */
}
    1114:	0009ab1b 	andeq	sl, r9, fp, lsl fp
    1118:	01d00100 	bicseq	r0, r0, r0, lsl #2

/*******************************************************************************
* clockConfigOsc
*******************************************************************************/
void clockConfigOsc()
{
    111c:	00000a25 	andeq	r0, r0, r5, lsr #20
                                                            /* Not configured */
}
    1120:	2c5c0305 	mrrccs	3, 0, r0, ip, cr5
    1124:	0c000000 	stceq	0, cr0, [r0], {-0}

/*******************************************************************************
* clockConfigOsc32k
*******************************************************************************/
void clockConfigOsc32k()
{
    1128:	00000a1f 	andeq	r0, r0, pc, lsl sl
                                                            /* Not configured */
}
    112c:	00000a13 	andeq	r0, r0, r3, lsl sl
    1130:	0000650d 	andeq	r6, r0, sp, lsl #10

/*******************************************************************************
* clockConfigEr32k
*******************************************************************************/
void clockConfigEr32k()
{
    1134:	650d0400 	strvs	r0, [sp, #-1024]	; 0xfffffc00
                                                            /* Not configured */
}
    1138:	04000000 	streq	r0, [r0], #-0
    113c:	1f011d00 	svcne	0x00011d00

/*******************************************************************************
* clockConfigRtc
*******************************************************************************/
void clockConfigRtc()
{
    1140:	1e00000a 	cdpne	0, 0, cr0, cr0, cr10, {0}
                                                            /* Not configured */
}
    1144:	0000043e 	andeq	r0, r0, lr, lsr r4
    1148:	13041100 	movwne	r1, #16640	; 0x4100

/*******************************************************************************
* clockConfigLpo
*******************************************************************************/
void clockConfigLpo()
{
    114c:	0a00000a 	beq	117c <watchDogUnlock+0x24>
                                                            /* Not configured */
}
    1150:	000009fd 	strdeq	r0, [r0], -sp
    1154:	077e011f 			; <UNDEFINED> instruction: 0x077e011f
*
* RETURNS: Nothing
*
*******************************************************************************/
void watchDogUnlock()
{
    1158:	e5010000 	str	r0, [r1, #-0]
        " :
        /* No output */ :
        /* No input  */ :
        "r0", "r1" ); /* Specify which registers we destroy */
#else
    wdPtr->unlock = WDOG_UNLOCK_KEY_1;
    115c:	0010ec01 	andseq	lr, r0, r1, lsl #24
    1160:	0010f600 	andseq	pc, r0, r0, lsl #12
    1164:	0007d400 	andeq	sp, r7, r0, lsl #8
    1168:	c7011f00 	strgt	r1, [r1, -r0, lsl #30]
    wdPtr->unlock = WDOG_UNLOCK_KEY_2;
    116c:	01000009 	tsteq	r0, r9
    1170:	10f801ed 	rscsne	r0, r8, sp, ror #3
    1174:	11020000 	mrsne	r0, (UNDEF: 2)
    1178:	08000000 	stmdaeq	r0, {}	; <UNPREDICTABLE>
#endif
    /* NOTE: Need to wait one clock cycle before updating any registers */
}
    117c:	011f0000 	tsteq	pc, r0
    1180:	000005b4 			; <UNDEFINED> instruction: 0x000005b4

/*******************************************************************************
* watchDogInit
*******************************************************************************/
void watchDogInit(const watchDogConfig_t *wdCfgPtr)
{
    1184:	0401f501 	streq	pc, [r1], #-1281	; 0xfffffaff
    1188:	0e000011 	mcreq	0, 0, r0, cr0, cr1, {0}
    watchDogUnlock();
    118c:	2c000011 	stccs	0, cr0, [r0], {17}
        " :
        /* No output */ :
        /* No input  */ :
        "r0", "r1", "r2" ); /* Specify which registers we destroy */
#else
    assert(wdCfgPtr->window < wdCfgPtr->timeout);
    1190:	1f000008 	svcne	0x00000008
    1194:	0006be01 	andeq	fp, r6, r1, lsl #28
    1198:	01fd0100 	mvnseq	r0, r0, lsl #2
    119c:	00001110 	andeq	r1, r0, r0, lsl r1
    11a0:	0000111a 	andeq	r1, r0, sl, lsl r1
    11a4:	00000858 	andeq	r0, r0, r8, asr r8
    11a8:	05ef011f 	strbeq	r0, [pc, #287]!	; 12cf <chSysInit+0x1f>

    wdPtr->toValL  = wdCfgPtr->timeout;
    11ac:	05010000 	streq	r0, [r1, #-0]
    11b0:	00111c02 	andseq	r1, r1, r2, lsl #24
    11b4:	00112600 	andseq	r2, r1, r0, lsl #12
    11b8:	00088400 	andeq	r8, r8, r0, lsl #8
    11bc:	21011f00 	tstcs	r1, r0, lsl #30
    wdPtr->toValH  = wdCfgPtr->timeout >> 16;
    11c0:	0100000a 	tsteq	r0, sl
    11c4:	1128020d 	teqne	r8, sp, lsl #4
    11c8:	11320000 	teqne	r2, r0
    11cc:	08b00000 	ldmeq	r0!, {}	; <UNPREDICTABLE>
    11d0:	011f0000 	tsteq	pc, r0
    wdPtr->stCtrlH = wdCfgPtr->stCtrlFlags;
    11d4:	00000a93 	muleq	r0, r3, sl
    11d8:	34021501 	strcc	r1, [r2], #-1281	; 0xfffffaff
    11dc:	3e000011 	mcrcc	0, 0, r0, cr0, cr1, {0}
    11e0:	dc000011 	stcle	0, cr0, [r0], {17}
    wdPtr->presc   = wdCfgPtr->prescaler;
    11e4:	1f000008 	svcne	0x00000008
    11e8:	0008b201 	andeq	fp, r8, r1, lsl #4
    11ec:	021d0100 	andseq	r0, sp, #0, 2
    11f0:	00001140 	andeq	r1, r0, r0, asr #2
    wdPtr->winL    = wdCfgPtr->window;
    11f4:	0000114a 	andeq	r1, r0, sl, asr #2
    11f8:	00000908 	andeq	r0, r0, r8, lsl #18
    11fc:	08c1011f 	stmiaeq	r1, {r0, r1, r2, r3, r4, r8}^
    1200:	25010000 	strcs	r0, [r1, #-0]
    1204:	00114c02 	andseq	r4, r1, r2, lsl #24
    wdPtr->winH    = wdCfgPtr->window >> 16;
    1208:	00115600 	andseq	r5, r1, r0, lsl #12
    120c:	00093400 	andeq	r3, r9, r0, lsl #8
    1210:	0ab62000 	beq	fed89218 <_stack_start+0xded79218>
    1214:	25010000 	strcs	r0, [r1, #-0]
    1218:	0000049e 	muleq	r0, lr, r4
    }
    if (wdCfgPtr->stCtrlFlags & WDOG_TEST) {
        /* TODO: If anyone cares let me know */
    }
#endif
}
    121c:	04000305 	streq	r0, [r0], #-773	; 0xfffffcfb
    1220:	680c2000 	stmdavs	ip, {sp}

/* RFI: Could probably move these elsewhere for general consumption */
static void interruptDisable()
{
    1224:	08000005 	stmdaeq	r0, {r0, r2}
    asm volatile("\n\
    1228:	0d00000b 	stceq	0, cr0, [r0, #-44]	; 0xffffffd4
        cpsid i\n\
        " :
        /* No output */ :
        /* No input  */ :
        ); /* Specify which registers we destroy */
}
    122c:	00000065 	andeq	r0, r0, r5, rrx
static void interruptEnable()
{
    1230:	d3210002 	teqle	r1, #2
    asm volatile("\n\
    1234:	01000007 	tsteq	r0, r7
        cpsie i\n\
        " :
        /* No output */ :
        /* No input  */ :
        ); /* Specify which registers we destroy */
}
    1238:	000af848 	andeq	pc, sl, r8, asr #16

/*******************************************************************************
* watchDogKick
*******************************************************************************/
void watchDogKick()
{
    123c:	20010100 	andcs	r0, r1, r0, lsl #2
        " :
        /* No output */ :
        /* No input  */ :
        "r0", "r1" ); /* Specify which registers we destroy */
#else
    interruptDisable();
    1240:	00000720 	andeq	r0, r0, r0, lsr #14
    wdPtr->refresh = WDOG_REFRESH_KEY_1;
    1244:	05a67901 	streq	r7, [r6, #2305]!	; 0x901
    1248:	03050000 	movweq	r0, #20480	; 0x5000
    124c:	200005e8 	andcs	r0, r0, r8, ror #11
    1250:	0005fe20 	andeq	pc, r5, r0, lsr #28
    wdPtr->refresh = WDOG_REFRESH_KEY_2;
    1254:	00830100 	addeq	r0, r3, r0, lsl #2
    1258:	05000006 	streq	r0, [r0, #-6]
    125c:	00042403 	andeq	r2, r4, r3, lsl #8
    1260:	07d32220 	ldrbeq	r2, [r3, r0, lsr #4]
    interruptEnable();
    1264:	48010000 	stmdami	r1, {}	; <UNPREDICTABLE>
#endif
}
    1268:	00000af8 	strdeq	r0, [r0], -r8

/*******************************************************************************
* watchDogDisable
*******************************************************************************/
void watchDogDisable()
{
    126c:	0c030501 	cfstr32eq	mvfx0, [r3], {1}
    watchDogUnlock();
    1270:	00200004 	eoreq	r0, r0, r4
        " :
        /* No output */ :
        /* No input  */ :
        "r0", "r1" ); /* Specify which registers we destroy */
#else
    wdPtr->stCtrlH = WDOG_STNDBYEN | WDOG_WAITEN | WDOG_STOPEN
    1274:	000002d9 	ldrdeq	r0, [r0], -r9
    1278:	042c0002 	strteq	r0, [ip], #-2
    127c:	01040000 	mrseq	r0, (UNDEF: 4)
    1280:	00000287 	andeq	r0, r0, r7, lsl #5
                   | WDOG_ALLOWUPDATE;
#endif
}
    1284:	000c1601 	andeq	r1, ip, r1, lsl #12
    1288:	00021600 	andeq	r1, r2, r0, lsl #12
    128c:	00115800 	andseq	r5, r1, r0, lsl #16
 *          that this thread is executed only if there are no other ready
 *          threads in the system.
 *
 * @param[in] p the thread parameter, unused in this scenario
 */
void _idle_thread(void *p) {
    1290:	00128600 	andseq	r8, r2, r0, lsl #12

  (void)p;
  chRegSetThreadName("idle");
    1294:	00046b00 	andeq	r6, r4, r0, lsl #22
    1298:	08010200 	stmdaeq	r1, {r9}
    129c:	000001b8 			; <UNDEFINED> instruction: 0x000001b8
    12a0:	000c0103 	andeq	r0, ip, r3, lsl #2
    12a4:	37180200 	ldrcc	r0, [r8, -r0, lsl #4]
  while (TRUE) {
    port_wait_for_interrupt();
    IDLE_LOOP_HOOK();
  }
    12a8:	02000000 	andeq	r0, r0, #0
    12ac:	026a0702 	rsbeq	r0, sl, #524288	; 0x80000
 * @note    This function has special, architecture-dependent, requirements,
 *          see the notes into the various port reference manuals.
 *
 * @special
 */
void chSysInit(void) {
    12b0:	ff030000 			; <UNDEFINED> instruction: 0xff030000
  static Thread mainthread;
#if CH_DBG_ENABLE_STACK_CHECK
  extern stkalign_t __main_thread_stack_base__;
#endif

  port_init();
    12b4:	02000002 	andeq	r0, r0, #2
  _scheduler_init();
    12b8:	00004919 	andeq	r4, r0, r9, lsl r9
  _vt_init();
    12bc:	07040200 	streq	r0, [r4, -r0, lsl #4]
#if CH_USE_MEMCORE
  _core_init();
    12c0:	000001e8 	andeq	r0, r0, r8, ror #3
#endif
#if CH_USE_HEAP
  _heap_init();
    12c4:	ba060102 	blt	1816d4 <_flash_swap_addr+0x141ed4>
#if CH_DBG_ENABLE_TRACE
  _trace_init();
#endif

  /* Now this instructions flow becomes the main thread.*/
  setcurrp(_thread_init(&mainthread, NORMALPRIO));
    12c8:	02000001 	andeq	r0, r0, #1
    12cc:	00310502 	eorseq	r0, r1, r2, lsl #10
    12d0:	04020000 	streq	r0, [r2], #-0
    12d4:	0000f705 	andeq	pc, r0, r5, lsl #14
    12d8:	07040200 	streq	r0, [r4, -r0, lsl #4]
    12dc:	000001ed 	andeq	r0, r0, sp, ror #3
    12e0:	1b030104 	blne	c16f8 <_flash_swap_addr+0x81ef8>
  currp->p_state = THD_STATE_CURRENT;
    12e4:	0000a001 	andeq	sl, r0, r1
    12e8:	03f70500 	mvnseq	r0, #0, 10
    12ec:	05000000 	streq	r0, [r0, #-0]
    12f0:	00000371 	andeq	r0, r0, r1, ror r3
#if CH_DBG_ENABLE_STACK_CHECK
  /* This is a special case because the main thread Thread structure is not
     adjacent to its stack area.*/
  currp->p_stklimit = &__main_thread_stack_base__;
#endif
  chSysEnable();
    12f4:	035d0501 	cmpeq	sp, #4194304	; 0x400000
    12f8:	05020000 	streq	r0, [r2, #-0]
    12fc:	000001cf 	andeq	r0, r0, pc, asr #3

  chRegSetThreadName("main");
    1300:	01850503 	orreq	r0, r5, r3, lsl #10
    1304:	05040000 	streq	r0, [r4, #-0]
    1308:	00000396 	muleq	r0, r6, r3
    130c:	004c0505 	subeq	r0, ip, r5, lsl #10
    1310:	00060000 	andeq	r0, r6, r0

#if !CH_NO_IDLE_THREAD
  /* This thread has the lowest priority in the system, its role is just to
     serve interrupts in its context while keeping the lowest energy saving
     mode compatible with the system status.*/
  chThdCreateStatic(_idle_thread_wa, sizeof(_idle_thread_wa), IDLEPRIO,
    1314:	24030c06 	strcs	r0, [r3], #-3078	; 0xfffff3fa
    1318:	0000e603 	andeq	lr, r0, r3, lsl #12
    131c:	0c0a0700 	stceq	7, cr0, [sl], {-0}
    1320:	25030000 	strcs	r0, [r3, #-0]
    1324:	00002c03 	andeq	r2, r0, r3, lsl #24
    1328:	00230200 	eoreq	r0, r3, r0, lsl #4
    132c:	000b1b07 	andeq	r1, fp, r7, lsl #22
    1330:	03260300 	teqeq	r6, #0, 6
                    (tfunc_t)_idle_thread, NULL);
#endif
}
    1334:	0000002c 	andeq	r0, r0, ip, lsr #32
    1338:	07022302 	streq	r2, [r2, -r2, lsl #6]
    133c:	00000bbe 			; <UNDEFINED> instruction: 0x00000bbe
 *          and, together with the @p CH_TIME_QUANTUM macro, the round robin
 *          interval.
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {
    1340:	3e032703 	cdpcc	7, 0, cr2, cr3, cr3, {0}

  chDbgCheckClassI();

#if CH_TIME_QUANTUM > 0
  /* Running thread has not used up quantum yet? */
  if (currp->p_preempt > 0)
    1344:	02000000 	andeq	r0, r0, #0
    1348:	49070423 	stmdbmi	r7, {r0, r1, r5, sl}
    134c:	0300000c 	movweq	r0, #12
    1350:	003e0328 	eorseq	r0, lr, r8, lsr #6
    /* Decrement remaining quantum.*/
    currp->p_preempt--;
    1354:	23020000 	movwcs	r0, #8192	; 0x2000
    1358:	3d080008 	stccc	0, cr0, [r8, #-32]	; 0xffffffe0
    135c:	0300000b 	movweq	r0, #11
    1360:	00a00329 	adceq	r0, r0, r9, lsr #6
    1364:	02040000 	andeq	r0, r4, #0
#endif
#if CH_DBG_THREADS_PROFILING
  currp->p_time++;
    1368:	53032c03 	movwpl	r2, #15363	; 0x3c03
    136c:	05000001 	streq	r0, [r0, #-1]
    1370:	00000ba5 	andeq	r0, r0, r5, lsr #23
    1374:	0c500501 	cfldr64eq	mvdx0, [r0], {1}
    1378:	05020000 	streq	r0, [r2, #-0]
#endif
  chVTDoTickI();
    137c:	00000ad2 	ldrdeq	r0, [r0], -r2
    1380:	0c830504 	cfstr32eq	mvfx0, [r3], {4}
    1384:	05080000 	streq	r0, [r8, #-0]
    1388:	00000b2c 	andeq	r0, r0, ip, lsr #22
    138c:	0b550510 	bleq	15427d4 <_flash_swap_addr+0x1502fd4>
    1390:	05200000 	streq	r0, [r0, #-0]!
    1394:	00000bc6 	andeq	r0, r0, r6, asr #23
    1398:	8f0500c0 	svchi	0x000500c0
    139c:	8000000b 	andhi	r0, r0, fp
    13a0:	0af00501 	beq	ffc027ac <_stack_start+0xdfbf27ac>
    13a4:	02800000 	addeq	r0, r0, #0
    13a8:	000b6005 	andeq	r6, fp, r5
    13ac:	05088000 	streq	r8, [r8, #-0]
    13b0:	00000b75 	andeq	r0, r0, r5, ror fp
    13b4:	e2051080 	and	r1, r5, #128	; 0x80
    13b8:	8000000b 	andhi	r0, r0, fp
    13bc:	c50500e0 	strgt	r0, [r5, #-224]	; 0xffffff20
    13c0:	8000000a 	andhi	r0, r0, sl
    13c4:	09000180 	stmdbeq	r0, {r7, r8}
    13c8:	6e690504 	cdpvs	5, 6, cr0, cr9, cr4, {0}
    13cc:	08020074 	stmdaeq	r2, {r2, r4, r5, r6}
    13d0:	0000f205 	andeq	pc, r0, r5, lsl #4
    13d4:	07080200 	streq	r0, [r8, -r0, lsl #4]
    13d8:	000001e3 	andeq	r0, r0, r3, ror #3
    13dc:	c1080102 	tstgt	r8, r2, lsl #2
    13e0:	0a000001 	beq	13ec <chSysTimerHandlerI+0xac>
    13e4:	20380118 	eorscs	r0, r8, r8, lsl r1
    13e8:	0b000002 	bleq	13f8 <chSysTimerHandlerI+0xb8>
    13ec:	00000ae0 	andeq	r0, r0, r0, ror #21
    13f0:	002c3901 	eoreq	r3, ip, r1, lsl #18
    13f4:	23020000 	movwcs	r0, #8192	; 0x2000
    13f8:	0ae80b00 	beq	ffa04000 <_stack_start+0xdf9f4000>
    13fc:	3a010000 	bcc	41404 <_flash_swap_addr+0x1c04>
    1400:	0000002c 	andeq	r0, r0, ip, lsr #32
    1404:	0b022302 	bleq	8a014 <_flash_swap_addr+0x4a814>
    1408:	00000b25 	andeq	r0, r0, r5, lsr #22
    140c:	002c3b01 	eoreq	r3, ip, r1, lsl #22
    1410:	23020000 	movwcs	r0, #8192	; 0x2000
#if defined(SYSTEM_TICK_EVENT_HOOK)
  SYSTEM_TICK_EVENT_HOOK();
#endif
}
    1414:	0b4e0b04 	bleq	138402c <_flash_swap_addr+0x134482c>
    1418:	3c010000 	stccc	0, cr0, [r1], {-0}
    141c:	0000002c 	andeq	r0, r0, ip, lsr #32
 *
 * @notapi
 */
void _vt_init(void) {

  vtlist.vt_next = vtlist.vt_prev = (void *)&vtlist;
    1420:	0b062302 	bleq	18a030 <_flash_swap_addr+0x14a830>
    1424:	00000b9b 	muleq	r0, fp, fp
    1428:	002c3d01 	eoreq	r3, ip, r1, lsl #26
    142c:	23020000 	movwcs	r0, #8192	; 0x2000
    1430:	0ba00b08 	bleq	fe804058 <_stack_start+0xde7f4058>
    1434:	3e010000 	cdpcc	0, 0, cr0, cr1, cr0, {0}
    1438:	0000002c 	andeq	r0, r0, ip, lsr #32
    143c:	0b0a2302 	bleq	28a04c <_flash_swap_addr+0x24a84c>
    1440:	00000bb6 			; <UNDEFINED> instruction: 0x00000bb6
    1444:	002c3f01 	eoreq	r3, ip, r1, lsl #30
  vtlist.vt_time = (systime_t)-1;
    1448:	23020000 	movwcs	r0, #8192	; 0x2000
    144c:	0c420b0c 	mcrreq	11, 0, r0, r2, cr12
    1450:	40010000 	andmi	r0, r1, r0
  vtlist.vt_systime = 0;
    1454:	0000002c 	andeq	r0, r0, ip, lsr #32
    1458:	0b0e2302 	bleq	38a068 <_flash_swap_addr+0x34a868>
    145c:	00000bf1 	strdeq	r0, [r0], -r1
    1460:	002c4101 	eoreq	r4, ip, r1, lsl #2
    1464:	23020000 	movwcs	r0, #8192	; 0x2000
    1468:	0bf90b10 	bleq	ffe440b0 <_stack_start+0xdfe340b0>
    146c:	42010000 	andmi	r0, r1, #0
 * @param[in] par       a parameter that will be passed to the callback
 *                      function
 *
 * @iclass
 */
void chVTSetI(VirtualTimer *vtp, systime_t time, vtfunc_t vtfunc, void *par) {
    1470:	0000002c 	andeq	r0, r0, ip, lsr #32
    1474:	0b122302 	bleq	48a084 <_flash_swap_addr+0x44a884>
    1478:	00000c7c 	andeq	r0, r0, ip, ror ip
  VirtualTimer *p;

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (time != TIME_IMMEDIATE),
    147c:	002c4301 	eoreq	r4, ip, r1, lsl #6
    1480:	23020000 	movwcs	r0, #8192	; 0x2000
    1484:	0c3c0b14 	ldceq	11, cr0, [ip], #-80	; 0xffffffb0
    1488:	44010000 	strmi	r0, [r1], #-0
             "chVTSetI");

  vtp->vt_par = par;
    148c:	0000002c 	andeq	r0, r0, ip, lsr #32
  vtp->vt_func = vtfunc;
    1490:	00162302 	andseq	r2, r6, r2, lsl #6
    1494:	000b6a03 	andeq	r6, fp, r3, lsl #20
  p = vtlist.vt_next;
    1498:	6f450100 	svcvs	0x00450100
    149c:	0c000001 	stceq	0, cr0, [r0], {1}
    14a0:	000c6d01 	andeq	r6, ip, r1, lsl #26
  while (p->vt_time < time) {
    time -= p->vt_time;
    14a4:	58510100 	ldmdapl	r1, {r8}^
    14a8:	82000011 	andhi	r0, r0, #17
    14ac:	60000011 	andvs	r0, r0, r1, lsl r0
    p = p->vt_next;
    14b0:	0d000009 	stceq	0, cr0, [r0, #-36]	; 0xffffffdc
             "chVTSetI");

  vtp->vt_par = par;
  vtp->vt_func = vtfunc;
  p = vtlist.vt_next;
  while (p->vt_time < time) {
    14b4:	000b8201 	andeq	r8, fp, r1, lsl #4
    14b8:	016a0100 	cmneq	sl, r0, lsl #2
    14bc:	00001184 	andeq	r1, r0, r4, lsl #3
    time -= p->vt_time;
    p = p->vt_next;
  }

  vtp->vt_prev = (vtp->vt_next = p)->vt_prev;
    14c0:	00001224 	andeq	r1, r0, r4, lsr #4
    14c4:	0000098c 	andeq	r0, r0, ip, lsl #19
    14c8:	00000267 	andeq	r0, r0, r7, ror #4
    14cc:	000bad0e 	andeq	sl, fp, lr, lsl #26
  vtp->vt_prev->vt_next = p->vt_prev = vtp;
    14d0:	676a0100 	strbvs	r0, [sl, -r0, lsl #2]!
    14d4:	02000002 	andeq	r0, r0, #2
    14d8:	0f007491 	svceq	0x00007491
    14dc:	00026d04 	andeq	r6, r2, r4, lsl #26
  vtp->vt_time = time;
    14e0:	00e61000 	rsceq	r1, r6, r0
  if (p != (void *)&vtlist)
    14e4:	5c110000 	ldcpl	0, cr0, [r1], {-0}
    14e8:	0100000c 	tsteq	r0, ip
    14ec:	00122496 	mulseq	r2, r6, r4
    14f0:	00123000 	andseq	r3, r2, r0
    p->vt_time -= time;
    14f4:	0009c400 	andeq	ip, r9, r0, lsl #8
    14f8:	0bd21100 	bleq	ff485900 <_stack_start+0xdf475900>
    14fc:	9f010000 	svcls	0x00010000
}
    1500:	00001230 	andeq	r1, r0, r0, lsr r2
    1504:	0000123c 	andeq	r1, r0, ip, lsr r2
    1508:	000009f0 	strdeq	r0, [r0], -r0	; <UNPREDICTABLE>
    150c:	0b0e010c 	bleq	381944 <_flash_swap_addr+0x342144>
 *
 * @param[in] vtp       the @p VirtualTimer structure pointer
 *
 * @iclass
 */
void chVTResetI(VirtualTimer *vtp) {
    1510:	ac010000 	stcge	0, cr0, [r1], {-0}
  chDbgCheck(vtp != NULL, "chVTResetI");
  chDbgAssert(vtp->vt_func != NULL,
              "chVTResetI(), #1",
              "timer not set or already triggered");

  if (vtp->vt_next != (void *)&vtlist)
    1514:	0000123c 	andeq	r1, r0, ip, lsr r2
    1518:	0000126a 	andeq	r1, r0, sl, ror #4
    151c:	00000a1c 	andeq	r0, r0, ip, lsl sl
    1520:	0afe010c 	beq	fff81958 <_stack_start+0xdff71958>
    vtp->vt_next->vt_time += vtp->vt_time;
    1524:	c6010000 	strgt	r0, [r1], -r0
    1528:	0000126c 	andeq	r1, r0, ip, ror #4
    152c:	00001286 	andeq	r1, r0, r6, lsl #5
    1530:	00000a48 	andeq	r0, r0, r8, asr #20
    1534:	000c3612 	andeq	r3, ip, r2, lsl r6
  vtp->vt_prev->vt_next = vtp->vt_next;
    1538:	d1460100 	mrsle	r0, (UNDEF: 86)
    153c:	05000002 	streq	r0, [r0, #-2]
  vtp->vt_next->vt_prev = vtp->vt_prev;
    1540:	00042c03 	andeq	r2, r4, r3, lsl #24
    1544:	d7040f20 	strle	r0, [r4, -r0, lsr #30]
    1548:	13000002 	movwne	r0, #2
  vtp->vt_func = (vtfunc_t)NULL;
    154c:	00000220 	andeq	r0, r0, r0, lsr #4
    1550:	00067700 	andeq	r7, r6, r0, lsl #14
}
    1554:	2e000200 	cdpcs	2, 0, cr0, cr0, cr0, {0}
    1558:	04000005 	streq	r0, [r0], #-5
    155c:	00028701 	andeq	r8, r2, r1, lsl #14
 * @retval TRUE         current time within the specified time window.
 * @retval FALSE        current time not within the specified time window.
 *
 * @api
 */
bool_t chTimeIsWithin(systime_t start, systime_t end) {
    1560:	0cb50100 	ldfeqs	f0, [r5]
    1564:	02160000 	andseq	r0, r6, #0
	...

  systime_t time = chTimeNow();
  return end > start ? (time >= start) && (time < end) :
    1574:	05060000 	streq	r0, [r6, #-0]
    1578:	04020000 	streq	r0, [r2], #-0
    157c:	746e6905 	strbtvc	r6, [lr], #-2309	; 0xfffff6fb
    1580:	07040300 	streq	r0, [r4, -r0, lsl #6]
    1584:	000001ed 	andeq	r0, r0, sp, ror #3
    1588:	ba060103 	blt	18199c <_flash_swap_addr+0x14219c>
    158c:	04000001 	streq	r0, [r0], #-1
    1590:	00000a33 	andeq	r0, r0, r3, lsr sl
    1594:	00492a02 	subeq	r2, r9, r2, lsl #20
    1598:	01030000 	mrseq	r0, (UNDEF: 3)
    159c:	0001b808 	andeq	fp, r1, r8, lsl #16
                       (time >= start) || (time < end);
    15a0:	05020300 	streq	r0, [r2, #-768]	; 0xfffffd00
    15a4:	00000031 	andeq	r0, r0, r1, lsr r0
 * @api
 */
bool_t chTimeIsWithin(systime_t start, systime_t end) {

  systime_t time = chTimeNow();
  return end > start ? (time >= start) && (time < end) :
    15a8:	6a070203 	bvs	1c1dbc <_flash_swap_addr+0x1825bc>
    15ac:	04000002 	streq	r0, [r0], #-2
                       (time >= start) || (time < end);
}
    15b0:	00000300 	andeq	r0, r0, r0, lsl #6
    15b4:	00694f02 	rsbeq	r4, r9, r2, lsl #30
    15b8:	04030000 	streq	r0, [r3], #-0
    15bc:	0000f705 	andeq	pc, r0, r5, lsl #14
  tp->p_next = (Thread *)tqp;
  tp->p_prev = tqp->p_prev;
  tp->p_prev->p_next = tqp->p_prev = tp;
}

static INLINE Thread *fifo_remove(ThreadsQueue *tqp) {
    15c0:	02ff0400 	rscseq	r0, pc, #0, 8
  Thread *tp = tqp->p_next;
    15c4:	50020000 	andpl	r0, r2, r0
    15c8:	0000007b 	andeq	r0, r0, fp, ror r0

  (tqp->p_next = tp->p_next)->p_prev = (Thread *)tqp;
    15cc:	e8070403 	stmda	r7, {r0, r1, sl}
    15d0:	03000001 	movweq	r0, #1
    15d4:	00f20508 	rscseq	r0, r2, r8, lsl #10
    15d8:	1f040000 	svcne	0x00040000
  return tp;
}
    15dc:	02000000 	andeq	r0, r0, #0
    15e0:	00009478 	andeq	r9, r0, r8, ror r4
    15e4:	07080300 	streq	r0, [r8, -r0, lsl #6]
    15e8:	000001e3 	andeq	r0, r0, r3, ror #3
    15ec:	000d6204 	andeq	r6, sp, r4, lsl #4

  (tqp->p_prev = tp->p_prev)->p_next = (Thread *)tqp;
  return tp;
}

static INLINE Thread *dequeue(Thread *tp) {
    15f0:	3e280300 	cdpcc	3, 2, cr0, cr8, cr0, {0}

  tp->p_prev->p_next = tp->p_next;
    15f4:	04000000 	streq	r0, [r0], #-0
    15f8:	00000d18 	andeq	r0, r0, r8, lsl sp
    15fc:	003e2903 	eorseq	r2, lr, r3, lsl #18
  tp->p_next->p_prev = tp->p_prev;
    1600:	d2040000 	andle	r0, r4, #0
    1604:	0300000d 	movweq	r0, #13
  return tp;
    1608:	00003e2a 	andeq	r3, r0, sl, lsr #28
}
    160c:	0d0e0400 	cfstrseq	mvf0, [lr, #-0]
 *
 * @notapi
 */
void _scheduler_init(void) {

  queue_init(&rlist.r_queue);
    1610:	2b030000 	blcs	c1618 <_flash_swap_addr+0x81e18>
    1614:	0000003e 	andeq	r0, r0, lr, lsr r0
    1618:	000de104 	andeq	lr, sp, r4, lsl #2
    161c:	702c0300 	eorvc	r0, ip, r0, lsl #6
    1620:	04000000 	streq	r0, [r0], #-0
    1624:	0000041f 	andeq	r0, r0, pc, lsl r4
    1628:	005e2d03 	subseq	r2, lr, r3, lsl #26
    162c:	76040000 	strvc	r0, [r4], -r0
    1630:	0300000d 	movweq	r0, #13
    1634:	0000702f 	andeq	r7, r0, pc, lsr #32
  rlist.r_prio = NOPRIO;
    1638:	027d0400 	rsbseq	r0, sp, #0, 8
    163c:	31030000 	mrscc	r0, (UNDEF: 3)
    1640:	00000070 	andeq	r0, r0, r0, ror r0
#if CH_USE_REGISTRY
  rlist.r_newer = rlist.r_older = (Thread *)&rlist;
    1644:	000e1b04 	andeq	r1, lr, r4, lsl #22
    1648:	fe230400 	cdp2	4, 2, cr0, cr3, cr0, {0}
    164c:	05000000 	streq	r0, [r0, #-0]
    1650:	00000e1b 	andeq	r0, r0, fp, lsl lr
    1654:	23570548 	cmpcs	r7, #72, 10	; 0x12000000
    1658:	06000002 	streq	r0, [r0], -r2
    165c:	00001157 	andeq	r1, r0, r7, asr r1
    1660:	02485805 	subeq	r5, r8, #327680	; 0x50000
    1664:	23020000 	movwcs	r0, #8192	; 0x2000
    1668:	0dda0600 	ldcleq	6, cr0, [sl]
    166c:	5a050000 	bpl	141674 <_flash_swap_addr+0x101e74>
 * @return              The thread pointer.
 *
 * @iclass
 */
#if !defined(PORT_OPTIMIZED_READYI) || defined(__DOXYGEN__)
Thread *chSchReadyI(Thread *tp) {
    1670:	00000248 	andeq	r0, r0, r8, asr #4
  Thread *cp;

  chDbgCheckClassI();

  /* Integrity checks.*/
  chDbgAssert((tp->p_state != THD_STATE_READY) &&
    1674:	06042302 	streq	r2, [r4], -r2, lsl #6
 * @return              The thread pointer.
 *
 * @iclass
 */
#if !defined(PORT_OPTIMIZED_READYI) || defined(__DOXYGEN__)
Thread *chSchReadyI(Thread *tp) {
    1678:	00000ced 	andeq	r0, r0, sp, ror #25
  Thread *cp;

  chDbgCheckClassI();

  /* Integrity checks.*/
  chDbgAssert((tp->p_state != THD_STATE_READY) &&
    167c:	00c75c05 	sbceq	r5, r7, r5, lsl #24
    1680:	23020000 	movwcs	r0, #8192	; 0x2000
              (tp->p_state != THD_STATE_FINAL),
              "chSchReadyI(), #1",
              "invalid state");

  tp->p_state = THD_STATE_READY;
    1684:	0ebc0608 	cdpeq	6, 11, cr0, cr12, cr8, {0}
    1688:	5d050000 	stcpl	0, cr0, [r5, #-0]
  cp = (Thread *)&rlist.r_queue;
    168c:	00000321 	andeq	r0, r0, r1, lsr #6
    1690:	060c2302 	streq	r2, [ip], -r2, lsl #6
    1694:	00000d21 	andeq	r0, r0, r1, lsr #26
  do {
    cp = cp->p_next;
    1698:	02485f05 	subeq	r5, r8, #5, 30
  } while (cp->p_prio >= tp->p_prio);
    169c:	23020000 	movwcs	r0, #8192	; 0x2000
    16a0:	0d980610 	ldceq	6, cr0, [r8, #64]	; 0x40
    16a4:	60050000 	andvs	r0, r5, r0
  /* Insertion on p_prev.*/
  tp->p_next = cp;
    16a8:	00000248 	andeq	r0, r0, r8, asr #4
    16ac:	06142302 	ldreq	r2, [r4], -r2, lsl #6
  tp->p_prev = cp->p_prev;
    16b0:	00000e9b 	muleq	r0, fp, lr
    16b4:	04fb6705 	ldrbteq	r6, [fp], #1797	; 0x705
  tp->p_prev->p_next = cp->p_prev = tp;
    16b8:	23020000 	movwcs	r0, #8192	; 0x2000
    16bc:	0df30618 	ldcleq	6, cr0, [r3, #96]!	; 0x60
    16c0:	72050000 	andvc	r0, r5, #0
    16c4:	000000a6 	andeq	r0, r0, r6, lsr #1
  return tp;
}
    16c8:	061c2302 	ldreq	r2, [ip], -r2, lsl #6
    16cc:	00000e13 	andeq	r0, r0, r3, lsl lr
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
#if !defined(PORT_OPTIMIZED_GOSLEEPS) || defined(__DOXYGEN__)
void chSchGoSleepS(tstate_t newstate) {
    16d0:	009b7605 	addseq	r7, fp, r5, lsl #12
    16d4:	23020000 	movwcs	r0, #8192	; 0x2000
    16d8:	0e7d061d 	mrceq	6, 3, r0, cr13, cr13, {0}
  Thread *otp;

  chDbgCheckClassS();

  (otp = currp)->p_state = newstate;
    16dc:	7b050000 	blvc	1416e4 <_flash_swap_addr+0x101ee4>
    16e0:	000000b1 	strheq	r0, [r0], -r1
    16e4:	061e2302 	ldreq	r2, [lr], -r2, lsl #6
    16e8:	00000dfb 	strdeq	r0, [r0], -fp
    16ec:	00bc8105 	adcseq	r8, ip, r5, lsl #2
#if CH_TIME_QUANTUM > 0
  /* The thread is renouncing its remaining time slices so it will have a new
     time quantum when it will wakeup.*/
  otp->p_preempt = CH_TIME_QUANTUM;
    16f0:	23020000 	movwcs	r0, #8192	; 0x2000
    16f4:	0e5d061f 	mrceq	6, 2, r0, cr13, cr15, {0}
#endif
  setcurrp(fifo_remove(&rlist.r_queue));
    16f8:	88050000 	stmdahi	r5, {}	; <UNPREDICTABLE>
    16fc:	00000406 	andeq	r0, r0, r6, lsl #8
    1700:	07202302 	streq	r2, [r0, -r2, lsl #6]!
    1704:	00755f70 	rsbseq	r5, r5, r0, ror pc
    1708:	04c6ad05 	strbeq	sl, [r6], #3333	; 0xd05
    170c:	23020000 	movwcs	r0, #8192	; 0x2000
  currp->p_state = THD_STATE_CURRENT;
    1710:	0ec20624 	cdpeq	6, 12, cr0, cr2, cr4, {1}
    1714:	b2050000 	andlt	r0, r5, #0
    1718:	00000270 	andeq	r0, r0, r0, ror r2
    171c:	06282302 	strteq	r2, [r8], -r2, lsl #6
  chSysSwitch(currp, otp);
    1720:	00000e6b 	andeq	r0, r0, fp, ror #28
    1724:	024eb805 	subeq	fp, lr, #327680	; 0x50000
    1728:	23020000 	movwcs	r0, #8192	; 0x2000
    172c:	0c8e062c 	stceq	6, cr0, [lr], {44}	; 0x2c
}
    1730:	bc050000 	stclt	0, cr0, [r5], {-0}
    1734:	000000d2 	ldrdeq	r0, [r0], -r2
    1738:	06342302 	ldrteq	r2, [r4], -r2, lsl #6
    173c:	00000e22 	andeq	r0, r0, r2, lsr #28

#if !defined(PORT_OPTIMIZED_GOSLEEPTIMEOUTS) || defined(__DOXYGEN__)
/*
 * Timeout wakeup callback.
 */
static void wakeup(void *p) {
    1740:	00ddc205 	sbcseq	ip, sp, r5, lsl #4
    1744:	23020000 	movwcs	r0, #8192	; 0x2000
  Thread *tp = (Thread *)p;
    1748:	0de90638 	stcleq	6, cr0, [r9, #224]!	; 0xe0

  chSysLockFromIsr();
    174c:	c9050000 	stmdbgt	r5, {}	; <UNPREDICTABLE>
    1750:	0000050d 	andeq	r0, r0, sp, lsl #10
  switch (tp->p_state) {
    1754:	063c2302 	ldrteq	r2, [ip], -r2, lsl #6
    1758:	00000e49 	andeq	r0, r0, r9, asr #28
    175c:	00c7cd05 	sbceq	ip, r7, r5, lsl #26
    1760:	23020000 	movwcs	r0, #8192	; 0x2000
    1764:	0cfe0640 	ldcleq	6, cr0, [lr], #256	; 0x100
    1768:	d3050000 	movwle	r0, #20480	; 0x5000
    176c:	00000286 	andeq	r0, r0, r6, lsl #5
    1770:	00442302 	subeq	r2, r4, r2, lsl #6
    1774:	5a040808 	bpl	10379c <_flash_swap_addr+0xc3f9c>
    1778:	00000248 	andeq	r0, r0, r8, asr #4
    177c:	00115706 	andseq	r5, r1, r6, lsl #14
    1780:	485b0400 	ldmdami	fp, {sl}^
    1784:	02000002 	andeq	r0, r0, #2
    1788:	da060023 	ble	18181c <_flash_swap_addr+0x14201c>
    178c:	0400000d 	streq	r0, [r0], #-13
    1790:	0002485d 	andeq	r4, r2, sp, asr r8
    1794:	04230200 	strteq	r0, [r3], #-512	; 0xfffffe00
  case THD_STATE_READY:
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromIsr();
    1798:	f3040900 	vmls.i8	d0, d4, d0
    179c:	04000000 	streq	r0, [r0], #-0
    return;
    17a0:	00000da6 	andeq	r0, r0, r6, lsr #27
#if CH_USE_SEMAPHORES || CH_USE_QUEUES ||                                   \
    (CH_USE_CONDVARS && CH_USE_CONDVARS_TIMEOUT)
#if CH_USE_SEMAPHORES
  case THD_STATE_WTSEM:
    chSemFastSignalI((Semaphore *)tp->p_u.wtobjp);
    17a4:	02235f04 	eoreq	r5, r3, #4, 30
    17a8:	04080000 	streq	r0, [r8], #-0
    17ac:	02706404 	rsbseq	r6, r0, #4, 8	; 0x4000000
#endif
#if CH_USE_CONDVARS && CH_USE_CONDVARS_TIMEOUT
  case THD_STATE_WTCOND:
#endif
    /* States requiring dequeuing.*/
    dequeue(tp);
    17b0:	57060000 	strpl	r0, [r6, -r0]
#endif
  }
  tp->p_u.rdymsg = RDY_TIMEOUT;
    17b4:	04000011 	streq	r0, [r0], #-17	; 0xffffffef
    17b8:	00024866 	andeq	r4, r2, r6, ror #16
  chSchReadyI(tp);
    17bc:	00230200 	eoreq	r0, r3, r0, lsl #4
    17c0:	0d6a0400 	cfstrdeq	mvd0, [sl, #-0]
  chSysUnlockFromIsr();
    17c4:	69040000 	stmdbvs	r4, {}	; <UNPREDICTABLE>
    17c8:	00000259 	andeq	r0, r0, r9, asr r2
}
    17cc:	000d4104 	andeq	r4, sp, r4, lsl #2
 * @return              The wakeup message.
 * @retval RDY_TIMEOUT if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
    17d0:	86de0600 	ldrbhi	r0, [lr], r0, lsl #12
    17d4:	0a000002 	beq	17e4 <chSchGoSleepTimeoutS+0x14>
    17d8:	03b50404 			; <UNDEFINED> instruction: 0x03b50404

  chDbgCheckClassS();

  if (TIME_INFINITE != time) {
    17dc:	e4060000 	str	r0, [r6], #-0
    17e0:	00000089 	andeq	r0, r0, r9, lsl #1
    VirtualTimer vt;

    chVTSetI(&vt, time, wakeup, currp);
    17e4:	000e640b 	andeq	r6, lr, fp, lsl #8
    17e8:	05062400 	streq	r2, [r6, #-1024]	; 0xfffffc00
    17ec:	00032101 	andeq	r2, r3, r1, lsl #2
    17f0:	34720c00 	ldrbtcc	r0, [r2], #-3072	; 0xfffff400
    17f4:	01180600 	tsteq	r8, r0, lsl #12
    17f8:	0000027b 	andeq	r0, r0, fp, ror r2
    17fc:	0c002302 	stceq	3, cr2, [r0], {2}
    chSchGoSleepS(newstate);
    1800:	06003572 			; <UNDEFINED> instruction: 0x06003572
    1804:	027b0119 	rsbseq	r0, fp, #1073741830	; 0x40000006
    1808:	23020000 	movwcs	r0, #8192	; 0x2000
    if (chVTIsArmedI(&vt))
    180c:	36720c04 	ldrbtcc	r0, [r2], -r4, lsl #24
      chVTResetI(&vt);
    1810:	011a0600 	tsteq	sl, r0, lsl #12
    1814:	0000027b 	andeq	r0, r0, fp, ror r2
    1818:	0c082302 	stceq	3, cr2, [r8], {2}
  }
  else
    chSchGoSleepS(newstate);
    181c:	06003772 			; <UNDEFINED> instruction: 0x06003772
    1820:	027b011b 	rsbseq	r0, fp, #-1073741818	; 0xc0000006
  return currp->p_u.rdymsg;
    1824:	23020000 	movwcs	r0, #8192	; 0x2000
    1828:	38720c0c 	ldmdacc	r2!, {r2, r3, sl, fp}^
    182c:	011c0600 	tsteq	ip, r0, lsl #12
}
    1830:	0000027b 	andeq	r0, r0, fp, ror r2
    1834:	0c102302 	ldceq	3, cr2, [r0], {2}
    1838:	06003972 			; <UNDEFINED> instruction: 0x06003972
    183c:	027b011d 	rsbseq	r0, fp, #1073741831	; 0x40000007
 * @param[in] msg       message to the awakened thread
 *
 * @sclass
 */
#if !defined(PORT_OPTIMIZED_WAKEUPS) || defined(__DOXYGEN__)
void chSchWakeupS(Thread *ntp, msg_t msg) {
    1840:	23020000 	movwcs	r0, #8192	; 0x2000
    1844:	31720c14 	cmncc	r2, r4, lsl ip

  chDbgCheckClassS();

  ntp->p_u.rdymsg = msg;
    1848:	1e060030 	mcrne	0, 0, r0, cr6, cr0, {1}
    184c:	00027b01 	andeq	r7, r2, r1, lsl #22
  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio)
    1850:	18230200 	stmdane	r3!, {r9}
    1854:	3131720c 	teqcc	r1, ip, lsl #4
    1858:	011f0600 	tsteq	pc, r0, lsl #12
    185c:	0000027b 	andeq	r0, r0, fp, ror r2
    1860:	0c1c2302 	ldceq	3, cr2, [ip], {2}
    chSchReadyI(ntp);
    1864:	0600726c 	streq	r7, [r0], -ip, ror #4
    1868:	027b0120 	rsbseq	r0, fp, #32, 2
  else {
    Thread *otp = chSchReadyI(currp);
    186c:	23020000 	movwcs	r0, #8192	; 0x2000
    1870:	5a0b0020 	bpl	2c18f8 <_flash_swap_addr+0x2820f8>
    1874:	0400000d 	streq	r0, [r0], #-13
    1878:	3e012a06 	vmlacc.f32	s4, s2, s12
    setcurrp(ntp);
    187c:	0c000003 	stceq	0, cr0, [r0], {3}
    1880:	00333172 	eorseq	r3, r3, r2, ror r1
    1884:	3e012b06 	vmlacc.f64	d2, d1, d6
    ntp->p_state = THD_STATE_CURRENT;
    1888:	02000003 	andeq	r0, r0, #3
    188c:	09000023 	stmdbeq	r0, {r0, r1, r5}
    chSysSwitch(ntp, otp);
    1890:	00029304 	andeq	r9, r2, r4, lsl #6
    1894:	0e540400 	cdpeq	4, 5, cr0, cr4, cr0, {0}
  }
}
    1898:	4e070000 	cdpmi	0, 0, cr0, cr7, cr0, {0}
    189c:	0000034f 	andeq	r0, r0, pc, asr #6
 *          the ready list then make the higher priority thread running.
 *
 * @sclass
 */
#if !defined(PORT_OPTIMIZED_RESCHEDULES) || defined(__DOXYGEN__)
void chSchRescheduleS(void) {
    18a0:	03550409 	cmpeq	r5, #150994944	; 0x9000000

  chDbgCheckClassS();

  if (chSchIsRescRequiredI())
    18a4:	010d0000 	mrseq	r0, (UNDEF: 13)
    18a8:	00000361 	andeq	r0, r0, r1, ror #6
    18ac:	0002860e 	andeq	r8, r2, lr, lsl #12
    18b0:	35040000 	strcc	r0, [r4, #-0]
    18b4:	0700000e 	streq	r0, [r0, -lr]
    18b8:	00036c53 	andeq	r6, r3, r3, asr ip
    18bc:	0e350500 	cfabs32eq	mvfx0, mvfx5
    chSchDoRescheduleAhead();
    18c0:	07140000 	ldreq	r0, [r4, -r0]
    18c4:	0003bf5a 	andeq	fp, r3, sl, asr pc
    18c8:	0d520600 	ldcleq	6, cr0, [r2, #-0]
    18cc:	5b070000 	blpl	1c18d4 <_flash_swap_addr+0x1820d4>
 *          itself or from within the port layer.
 *
 * @special
 */
#if !defined(PORT_OPTIMIZED_DORESCHEDULEBEHIND) || defined(__DOXYGEN__)
void chSchDoRescheduleBehind(void) {
    18d0:	000003bf 			; <UNDEFINED> instruction: 0x000003bf
  Thread *otp;

  otp = currp;
    18d4:	06002302 	streq	r2, [r0], -r2, lsl #6
    18d8:	00000d4a 	andeq	r0, r0, sl, asr #26
    18dc:	03bf5d07 			; <UNDEFINED> instruction: 0x03bf5d07
  /* Picks the first thread from the ready queue and makes it current.*/
  setcurrp(fifo_remove(&rlist.r_queue));
    18e0:	23020000 	movwcs	r0, #8192	; 0x2000
    18e4:	0d880604 	stceq	6, cr0, [r8, #16]
    18e8:	5f070000 	svcpl	0x00070000
    18ec:	000000e8 	andeq	r0, r0, r8, ror #1
    18f0:	06082302 	streq	r2, [r8], -r2, lsl #6
    18f4:	00000d90 	muleq	r0, r0, sp
  currp->p_state = THD_STATE_CURRENT;
    18f8:	03446007 	movteq	r6, #16391	; 0x4007
    18fc:	23020000 	movwcs	r0, #8192	; 0x2000
    1900:	0e76060c 	cdpeq	6, 7, cr0, cr6, cr12, {0}
    1904:	62070000 	andvs	r0, r7, #0
#if CH_TIME_QUANTUM > 0
  otp->p_preempt = CH_TIME_QUANTUM;
    1908:	00000286 	andeq	r0, r0, r6, lsl #5
    190c:	00102302 	andseq	r2, r0, r2, lsl #6
#endif
  chSchReadyI(otp);
    1910:	03610409 	cmneq	r1, #150994944	; 0x9000000
    1914:	10080000 	andne	r0, r8, r0
  chSysSwitch(currp, otp);
    1918:	04066c07 	streq	r6, [r6], #-3079	; 0xfffff3f9
    191c:	52060000 	andpl	r0, r6, #0
    1920:	0700000d 	streq	r0, [r0, -sp]
    1924:	0003bf6d 	andeq	fp, r3, sp, ror #30
}
    1928:	00230200 	eoreq	r0, r3, r0, lsl #4
    192c:	000d4a06 	andeq	r4, sp, r6, lsl #20
 *          itself or from within the port layer.
 *
 * @special
 */
#if !defined(PORT_OPTIMIZED_DORESCHEDULEAHEAD) || defined(__DOXYGEN__)
void chSchDoRescheduleAhead(void) {
    1930:	bf6f0700 	svclt	0x006f0700
  Thread *otp, *cp;

  otp = currp;
    1934:	02000003 	andeq	r0, r0, #3
    1938:	88060423 	stmdahi	r6, {r0, r1, r5, sl}
    193c:	0700000d 	streq	r0, [r0, -sp]
  /* Picks the first thread from the ready queue and makes it current.*/
  setcurrp(fifo_remove(&rlist.r_queue));
    1940:	0000e871 	andeq	lr, r0, r1, ror r8
    1944:	08230200 	stmdaeq	r3!, {r9}
    1948:	000ea206 	andeq	sl, lr, r6, lsl #4
    194c:	06720700 	ldrbteq	r0, [r2], -r0, lsl #14
    1950:	02000004 	andeq	r0, r0, #4
    1954:	0f000c23 	svceq	0x00000c23
  currp->p_state = THD_STATE_CURRENT;
    1958:	000000e8 	andeq	r0, r0, r8, ror #1
    195c:	000ead04 	andeq	sl, lr, r4, lsl #26
    1960:	c5730700 	ldrbgt	r0, [r3, #-1792]!	; 0xfffff900
    1964:	08000003 	stmdaeq	r0, {r0, r1}

  otp->p_state = THD_STATE_READY;
    1968:	7357081c 	cmpvc	r7, #28, 16	; 0x1c0000
    196c:	06000004 	streq	r0, [r0], -r4
  cp = (Thread *)&rlist.r_queue;
    1970:	00000e2d 	andeq	r0, r0, sp, lsr #28
    1974:	024e5808 	subeq	r5, lr, #8, 16	; 0x80000
    1978:	23020000 	movwcs	r0, #8192	; 0x2000
  do {
    cp = cp->p_next;
    197c:	0e050600 	cfmadd32eq	mvax0, mvfx0, mvfx5, mvfx0
  } while (cp->p_prio > otp->p_prio);
    1980:	59080000 	stmdbpl	r8, {}	; <UNPREDICTABLE>
    1984:	000000c7 	andeq	r0, r0, r7, asr #1
    1988:	06082302 	streq	r2, [r8], -r2, lsl #6
  /* Insertion on p_prev.*/
  otp->p_next = cp;
    198c:	00000da0 	andeq	r0, r0, r0, lsr #27
    1990:	03215b08 	teqeq	r1, #8, 22	; 0x2000
  otp->p_prev = cp->p_prev;
    1994:	23020000 	movwcs	r0, #8192	; 0x2000
    1998:	0d39060c 	ldceq	6, cr0, [r9, #-48]!	; 0xffffffd0
  otp->p_prev->p_next = cp->p_prev = otp;
    199c:	5e080000 	cdppl	0, 0, cr0, cr8, cr0, {0}
    19a0:	00000248 	andeq	r0, r0, r8, asr #4
    19a4:	06102302 	ldreq	r2, [r0], -r2, lsl #6
    19a8:	00000dbd 			; <UNDEFINED> instruction: 0x00000dbd

  chSysSwitch(currp, otp);
    19ac:	02485f08 	subeq	r5, r8, #8, 30
    19b0:	23020000 	movwcs	r0, #8192	; 0x2000
    19b4:	0db30614 	ldceq	6, cr0, [r3, #80]!	; 0x50
    19b8:	62080000 	andvs	r0, r8, #0
}
    19bc:	00000248 	andeq	r0, r0, r8, asr #4
 *          itself or from within the port layer.
 *
 * @special
 */
#if !defined(PORT_OPTIMIZED_DORESCHEDULE) || defined(__DOXYGEN__)
void chSchDoReschedule(void) {
    19c0:	00182302 	andseq	r2, r8, r2, lsl #6

#if CH_TIME_QUANTUM > 0
  /* If CH_TIME_QUANTUM is enabled then there are two different scenarios to
     handle on preemption: time quantum elapsed or not.*/
  if (currp->p_preempt == 0) {
    19c4:	000e8404 	andeq	r8, lr, r4, lsl #8
    19c8:	16640800 	strbtne	r0, [r4], -r0, lsl #16
    19cc:	05000004 	streq	r0, [r0, #-4]
    19d0:	00000d82 	andeq	r0, r0, r2, lsl #27
    /* The thread consumed its time quantum so it is enqueued behind threads
       with same priority level, however, it acquires a new time quantum.*/
    chSchDoRescheduleBehind();
    19d4:	b5250910 	strlt	r0, [r5, #-2320]!	; 0xfffff6f0
  }
  else {
    /* The thread didn't consume all its time quantum so it is put ahead of
       threads with equal priority and does not acquire a new time quantum.*/
    chSchDoRescheduleAhead();
    19d8:	06000004 	streq	r0, [r0], -r4
#else /* !(CH_TIME_QUANTUM > 0) */
  /* If the round-robin mechanism is disabled then the thread goes always
     ahead of its peers.*/
  chSchDoRescheduleAhead();
#endif /* !(CH_TIME_QUANTUM > 0) */
}
    19dc:	00000d06 	andeq	r0, r0, r6, lsl #26

static INLINE void list_insert(Thread *tp, ThreadsList *tlp) {
    19e0:	024e2609 	subeq	r2, lr, #9437184	; 0x900000
    19e4:	23020000 	movwcs	r0, #8192	; 0x2000

  tp->p_next = tlp->p_next;
    19e8:	0eb40600 	cdpeq	6, 11, cr0, cr4, cr0, {0}
    19ec:	28090000 	stmdacs	r9, {}	; <UNPREDICTABLE>
  tlp->p_next = tp;
    19f0:	00000248 	andeq	r0, r0, r8, asr #4
}
    19f4:	06082302 	streq	r2, [r8], -r2, lsl #6
    19f8:	00000e42 	andeq	r0, r0, r2, asr #28
    19fc:	04b52a09 	ldrteq	r2, [r5], #2569	; 0xa09

static INLINE Thread *list_remove(ThreadsList *tlp) {
    1a00:	23020000 	movwcs	r0, #8192	; 0x2000

  Thread *tp = tlp->p_next;
    1a04:	0409000c 	streq	r0, [r9], #-12
    1a08:	0000047e 	andeq	r0, r0, lr, ror r4
  tlp->p_next = tp->p_next;
    1a0c:	000d8204 	andeq	r8, sp, r4, lsl #4
    1a10:	7e2c0900 	cdpvc	9, 2, cr0, cr12, cr0, {0}
  return tp;
}
    1a14:	10000004 	andne	r0, r0, r4
    1a18:	fb8f0504 	blx	fe3c2e32 <_stack_start+0xde3b2e32>
    1a1c:	11000004 	tstne	r0, r4
 * @param[in] prio      the priority level for the new thread
 * @return              The same thread pointer passed as parameter.
 *
 * @notapi
 */
Thread *_thread_init(Thread *tp, tprio_t prio) {
    1a20:	00000c94 	muleq	r0, r4, ip
    1a24:	00d29605 	sbcseq	r9, r2, r5, lsl #12

  tp->p_prio = prio;
    1a28:	d9110000 	ldmdble	r1, {}	; <UNPREDICTABLE>
  tp->p_state = THD_STATE_SUSPENDED;
    1a2c:	0500000c 	streq	r0, [r0, #-12]
    1a30:	0000d29d 	muleq	r0, sp, r2
  tp->p_flags = THD_MEM_MODE_STATIC;
    1a34:	0e941100 	fmleqs	f1, f4, f0
    1a38:	a4050000 	strge	r0, [r5], #-0
#if CH_TIME_QUANTUM > 0
  tp->p_preempt = CH_TIME_QUANTUM;
    1a3c:	00000286 	andeq	r0, r0, r6, lsl #5
    1a40:	000e0c11 	andeq	r0, lr, r1, lsl ip
#endif
#if CH_USE_MUTEXES
  tp->p_realprio = prio;
    1a44:	ddab0500 	cfstr32le	mvfx0, [fp]
    1a48:	00000000 	andeq	r0, r0, r0
  tp->p_mtxlist = NULL;
    1a4c:	05010409 	streq	r0, [r1, #-1033]	; 0xfffffbf7
    1a50:	06120000 	ldreq	r0, [r2], -r0
#endif
#if CH_USE_EVENTS
  tp->p_epending = 0;
    1a54:	03000005 	movweq	r0, #5
    1a58:	01c10801 	biceq	r0, r1, r1, lsl #16
#endif
#if CH_DBG_THREADS_PROFILING
  tp->p_time = 0;
    1a5c:	04090000 	streq	r0, [r9], #-0
    1a60:	000004bb 			; <UNDEFINED> instruction: 0x000004bb
#endif
#if CH_USE_DYNAMIC
  tp->p_refs = 1;
    1a64:	00112704 	andseq	r2, r1, r4, lsl #14
    1a68:	1ede0500 	cdpne	5, 13, cr0, cr14, cr0, {0}
#endif
#if CH_USE_REGISTRY
  tp->p_name = NULL;
    1a6c:	09000005 	stmdbeq	r0, {r0, r2}
    1a70:	00052404 	andeq	r2, r5, r4, lsl #8
  REG_INSERT(tp);
    1a74:	d2011300 	andle	r1, r1, #0, 6
    1a78:	34000000 	strcc	r0, [r0], #-0
    1a7c:	0e000005 	cdpeq	0, 0, cr0, cr0, cr5, {0}
    1a80:	00000286 	andeq	r0, r0, r6, lsl #5
    1a84:	c5011400 	strgt	r1, [r1, #-1024]	; 0xfffffc00
    1a88:	0100000d 	tsteq	r0, sp
    1a8c:	12900136 	addsne	r0, r0, #-2147483635	; 0x8000000d
    1a90:	12aa0000 	adcne	r0, sl, #0
    1a94:	0a740000 	beq	1d01a9c <_flash_swap_addr+0x1cc229c>
    1a98:	055a0000 	ldrbeq	r0, [sl, #-0]
    1a9c:	70150000 	andsvc	r0, r5, r0
    1aa0:	86360100 	ldrthi	r0, [r6], -r0, lsl #2
    1aa4:	02000002 	andeq	r0, r0, #2
#endif
#if CH_USE_WAITEXIT
  list_init(&tp->p_waiting);
    1aa8:	14007c91 	strne	r7, [r0], #-3217	; 0xfffff36f
    1aac:	000cf401 	andeq	pc, ip, r1, lsl #8
    1ab0:	014d0100 	mrseq	r0, (UNDEF: 93)
#endif
#if CH_USE_MESSAGES
  queue_init(&tp->p_msgqueue);
    1ab4:	000012b0 			; <UNDEFINED> instruction: 0x000012b0
    1ab8:	00001338 	andeq	r1, r0, r8, lsr r3
    1abc:	00000a94 	muleq	r0, r4, sl
    1ac0:	0000059c 	muleq	r0, ip, r5
  tp->p_stklimit = (stkalign_t *)(tp + 1);
#endif
#if defined(THREAD_EXT_INIT_HOOK)
  THREAD_EXT_INIT_HOOK(tp);
#endif
  return tp;
    1ac4:	000ce216 	andeq	lr, ip, r6, lsl r2
}
    1ac8:	f34e0100 	vrhadd.u8	d16, d14, d0
    1acc:	05000000 	streq	r0, [r0, #-0]
 *                      the thread into the working space area.
 *
 * @iclass
 */
Thread *chThdCreateI(void *wsp, size_t size,
                     tprio_t prio, tfunc_t pf, void *arg) {
    1ad0:	0006b003 	andeq	fp, r6, r3
    1ad4:	12f41720 	rscsne	r1, r4, #32, 14	; 0x800000
    1ad8:	12fe0000 	rscsne	r0, lr, #0
  /* Thread structure is layed out in the lower part of the thread workspace.*/
  Thread *tp = wsp;
    1adc:	74180000 	ldrvc	r0, [r8], #-0

  chDbgCheckClassI();

  chDbgCheck((wsp != NULL) && (size >= THD_WA_SIZE(0)) &&
    1ae0:	0100706d 	tsteq	r0, sp, rrx
    1ae4:	00007068 	andeq	r7, r0, r8, rrx
    1ae8:	00530100 	subseq	r0, r3, r0, lsl #2
    1aec:	a2011400 	andge	r1, r1, #0, 8
    1af0:	0100000c 	tsteq	r0, ip
    1af4:	13400180 	movtne	r0, #384	; 0x180
             (prio <= HIGHPRIO) && (pf != NULL),
             "chThdCreateI");
  SETUP_CONTEXT(wsp, size, pf, arg);
    1af8:	14180000 	ldrne	r0, [r8], #-0
    1afc:	0ac00000 	beq	ff001b04 <_stack_start+0xdeff1b04>
    1b00:	06170000 	ldreq	r0, [r7], -r0
    1b04:	a8170000 	ldmdage	r7, {}	; <UNPREDICTABLE>
    1b08:	14000013 	strne	r0, [r0], #-19	; 0xffffffed
    1b0c:	18000014 	stmdane	r0, {r2, r4}
    1b10:	00707476 	rsbseq	r7, r0, r6, ror r4
    1b14:	03bf8d01 			; <UNDEFINED> instruction: 0x03bf8d01
    1b18:	91020000 	mrsls	r0, (UNDEF: 2)
    1b1c:	13bc1774 			; <UNDEFINED> instruction: 0x13bc1774
    1b20:	14000000 	strne	r0, [r0], #-0
  return _thread_init(tp, prio);
    1b24:	66180000 	ldrvs	r0, [r8], -r0
    1b28:	8d01006e 	stchi	0, cr0, [r1, #-440]	; 0xfffffe48
}
    1b2c:	00000344 	andeq	r0, r0, r4, asr #6
    1b30:	19709102 	ldmdbne	r0!, {r1, r8, ip, pc}^
    1b34:	000013e6 	andeq	r1, r0, r6, ror #7
    1b38:	000013ee 	andeq	r1, r0, lr, ror #7
    1b3c:	000005fd 	strdeq	r0, [r0], -sp
 *                      the thread into the working space area.
 *
 * @api
 */
Thread *chThdCreateStatic(void *wsp, size_t size,
                          tprio_t prio, tfunc_t pf, void *arg) {
    1b40:	706d7418 	rsbvc	r7, sp, r8, lsl r4
    1b44:	708d0100 	addvc	r0, sp, r0, lsl #2
    1b48:	01000000 	mrseq	r0, (UNDEF: 0)
                  CH_THREAD_FILL_VALUE);
  _thread_memfill((uint8_t *)wsp + sizeof(Thread),
                  (uint8_t *)wsp + size,
                  CH_STACK_FILL_VALUE);
#endif
  chSysLock();
    1b4c:	f8170053 			; <UNDEFINED> instruction: 0xf8170053
    1b50:	00000013 	andeq	r0, r0, r3, lsl r0
  chSchWakeupS(tp = chThdCreateI(wsp, size, prio, pf, arg), RDY_OK);
    1b54:	18000014 	stmdane	r0, {r2, r4}
    1b58:	00706d74 	rsbseq	r6, r0, r4, ror sp
    1b5c:	00708d01 	rsbseq	r8, r0, r1, lsl #26
    1b60:	53010000 	movwpl	r0, #4096	; 0x1000
    1b64:	00000000 	andeq	r0, r0, r0
    1b68:	000c9b1a 	andeq	r9, ip, sl, lsl fp
    1b6c:	0bd10700 	bleq	ff443774 <_stack_start+0xdf433774>
  chSysUnlock();
    1b70:	01000004 	tsteq	r0, r4
    1b74:	0e8e1a01 	vdiveq.f32	s2, s28, s2
  return tp;
    1b78:	68080000 	stmdavs	r8, {}	; <UNPREDICTABLE>
}
    1b7c:	00000473 	andeq	r0, r0, r3, ror r4
 * @param[in] newprio   the new priority level of the running thread
 * @return              The old priority level.
 *
 * @api
 */
tprio_t chThdSetPriority(tprio_t newprio) {
    1b80:	881b0101 	ldmdahi	fp, {r0, r8}
    1b84:	41000002 	tstmi	r0, r2
  tprio_t oldprio;

  chDbgCheck(newprio <= HIGHPRIO, "chThdSetPriority");

  chSysLock();
    1b88:	1c000006 	stcne	0, cr0, [r0], {6}
    1b8c:	00000030 	andeq	r0, r0, r0, lsr r0
#if CH_USE_MUTEXES
  oldprio = currp->p_realprio;
    1b90:	291a0017 	ldmdbcs	sl, {r0, r1, r2, r4}
    1b94:	0a00000d 	beq	1bd0 <chThdSetPriority+0x50>
    1b98:	00063182 	andeq	r3, r6, r2, lsl #3
  if ((currp->p_prio == currp->p_realprio) || (newprio > currp->p_prio))
    1b9c:	1a010100 	bne	41fa4 <_flash_swap_addr+0x27a4>
    1ba0:	00000c9b 	muleq	r0, fp, ip
    1ba4:	040bd107 	streq	sp, [fp], #-263	; 0xfffffef9
    1ba8:	01010000 	mrseq	r0, (UNDEF: 1)
    1bac:	000e8e1a 	andeq	r8, lr, sl, lsl lr
    1bb0:	73680800 	cmnvc	r8, #0, 16
    1bb4:	01000004 	tsteq	r0, r4
    1bb8:	0d291d01 	stceq	13, cr1, [r9, #-4]!
    1bbc:	2a010000 	bcs	41bc4 <_flash_swap_addr+0x23c4>
    1bc0:	00000631 	andeq	r0, r0, r1, lsr r6
    1bc4:	f0030501 			; <UNDEFINED> instruction: 0xf0030501
    1bc8:	00200005 	eoreq	r0, r0, r5
    currp->p_prio = newprio;
    1bcc:	00000274 	andeq	r0, r0, r4, ror r2
    1bd0:	069e0002 	ldreq	r0, [lr], r2
    1bd4:	01040000 	mrseq	r0, (UNDEF: 4)
  currp->p_realprio = newprio;
    1bd8:	00000287 	andeq	r0, r0, r7, lsl #5
    1bdc:	000efb01 	andeq	pc, lr, r1, lsl #22
    1be0:	00021600 	andeq	r1, r2, r0, lsl #12
	...
#else
  oldprio = currp->p_prio;
  currp->p_prio = newprio;
#endif
  chSchRescheduleS();
  chSysUnlock();
    1bec:	00002000 	andeq	r2, r0, r0
    1bf0:	0006d000 	andeq	sp, r6, r0
  return oldprio;
}
    1bf4:	05040200 	streq	r0, [r4, #-512]	; 0xfffffe00
    1bf8:	00746e69 	rsbseq	r6, r4, r9, ror #28
    1bfc:	ed070403 	cfstrs	mvf0, [r7, #-12]
 * @param[in] tp        pointer to the thread
 * @return              The pointer to the thread.
 *
 * @api
 */
Thread *chThdResume(Thread *tp) {
    1c00:	03000001 	movweq	r0, #1
    1c04:	01ba0601 			; <UNDEFINED> instruction: 0x01ba0601

  chSysLock();
    1c08:	01030000 	mrseq	r0, (UNDEF: 3)
    1c0c:	0001b808 	andeq	fp, r1, r8, lsl #16
  chDbgAssert(tp->p_state == THD_STATE_SUSPENDED,
              "chThdResume(), #1",
              "thread not in THD_STATE_SUSPENDED state");
  chSchWakeupS(tp, RDY_OK);
    1c10:	05020300 	streq	r0, [r2, #-768]	; 0xfffffd00
    1c14:	00000031 	andeq	r0, r0, r1, lsr r0
  chSysUnlock();
    1c18:	6a070203 	bvs	1c242c <_flash_swap_addr+0x182c2c>
    1c1c:	04000002 	streq	r0, [r0], #-2
  return tp;
    1c20:	00000300 	andeq	r0, r0, r0, lsl #6
}
    1c24:	005e4f02 	subseq	r4, lr, r2, lsl #30
    1c28:	04030000 	streq	r0, [r3], #-0
    1c2c:	0000f705 	andeq	pc, r0, r5, lsl #14
 *
 * @param[in] tp        pointer to the thread
 *
 * @api
 */
void chThdTerminate(Thread *tp) {
    1c30:	02ff0400 	rscseq	r0, pc, #0, 8

  chSysLock();
    1c34:	50020000 	andpl	r0, r2, r0
    1c38:	00000070 	andeq	r0, r0, r0, ror r0
  tp->p_flags |= THD_TERMINATE;
    1c3c:	e8070403 	stmda	r7, {r0, r1, sl}
    1c40:	03000001 	movweq	r0, #1
    1c44:	00f20508 	rscseq	r0, r2, r8, lsl #10
    1c48:	08030000 	stmdaeq	r3, {}	; <UNPREDICTABLE>
  chSysUnlock();
    1c4c:	0001e307 	andeq	lr, r1, r7, lsl #6
    1c50:	0ed50400 	cdpeq	4, 13, cr0, cr5, cr0, {0}
}
    1c54:	27030000 	strcs	r0, [r3, -r0]
    1c58:	00000053 	andeq	r0, r0, r3, asr r0
    1c5c:	00027d04 	andeq	r7, r2, r4, lsl #26
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
void chThdSleep(systime_t time) {
    1c60:	65310300 	ldrvs	r0, [r1, #-768]!	; 0xfffffd00
    1c64:	05000000 	streq	r0, [r0, #-0]

  chDbgCheck(time != TIME_IMMEDIATE, "chThdSleep");

  chSysLock();
    1c68:	0e540404 	cdpeq	4, 5, cr0, cr4, cr4, {0}
    1c6c:	4e040000 	cdpmi	0, 0, cr0, cr4, cr0, {0}
  chThdSleepS(time);
    1c70:	000000a8 	andeq	r0, r0, r8, lsr #1
    1c74:	00ae0406 	adceq	r0, lr, r6, lsl #8
  chSysUnlock();
    1c78:	01070000 	mrseq	r0, (UNDEF: 7)
    1c7c:	000000ba 	strheq	r0, [r0], -sl
}
    1c80:	00009b08 	andeq	r9, r0, r8, lsl #22
    1c84:	35040000 	strcc	r0, [r4, #-0]
    1c88:	0400000e 	streq	r0, [r0], #-14
    1c8c:	0000c553 	andeq	ip, r0, r3, asr r5
 *
 * @param[in] time      absolute system time
 *
 * @api
 */
void chThdSleepUntil(systime_t time) {
    1c90:	0e350900 	cdpeq	9, 3, cr0, cr5, cr0, {0}
    1c94:	04140000 	ldreq	r0, [r4], #-0

  chSysLock();
    1c98:	0001185a 	andeq	r1, r1, sl, asr r8
    1c9c:	0d520a00 	vldreq	s1, [r2, #-0]
  if ((time -= chTimeNow()) > 0)
    1ca0:	5b040000 	blpl	101ca8 <_flash_swap_addr+0xc24a8>
    1ca4:	00000118 	andeq	r0, r0, r8, lsl r1
    1ca8:	0a002302 	beq	a8b8 <_data_load+0x7bc8>
    1cac:	00000d4a 	andeq	r0, r0, sl, asr #26
    1cb0:	01185d04 	tsteq	r8, r4, lsl #26
    chThdSleepS(time);
    1cb4:	23020000 	movwcs	r0, #8192	; 0x2000
    1cb8:	0d880a04 	vstreq	s0, [r8, #16]
    1cbc:	5f040000 	svcpl	0x00040000
  chSysUnlock();
    1cc0:	00000090 	muleq	r0, r0, r0
    1cc4:	0a082302 	beq	20a8d4 <_flash_swap_addr+0x1cb0d4>
}
    1cc8:	00000d90 	muleq	r0, r0, sp
    1ccc:	009d6004 	addseq	r6, sp, r4
 * @details Yields the CPU control to the next thread in the ready list with
 *          equal priority, if any.
 *
 * @api
 */
void chThdYield(void) {
    1cd0:	23020000 	movwcs	r0, #8192	; 0x2000

  chSysLock();
    1cd4:	0e760a0c 	vaddeq.f32	s1, s12, s24
    1cd8:	62040000 	andvs	r0, r4, #0
  chSchDoYieldS();
    1cdc:	0000009b 	muleq	r0, fp, r0
    1ce0:	00102302 	andseq	r2, r0, r2, lsl #6
    1ce4:	00ba0406 	adcseq	r0, sl, r6, lsl #8
    1ce8:	100b0000 	andne	r0, fp, r0
    1cec:	015f6c04 	cmpeq	pc, r4, lsl #24
    1cf0:	520a0000 	andpl	r0, sl, #0
    1cf4:	0400000d 	streq	r0, [r0], #-13
    1cf8:	0001186d 	andeq	r1, r1, sp, ror #16
  chSysUnlock();
    1cfc:	00230200 	eoreq	r0, r3, r0, lsl #4
    1d00:	000d4a0a 	andeq	r4, sp, sl, lsl #20
    1d04:	186f0400 	stmdane	pc!, {sl}^	; <UNPREDICTABLE>
    1d08:	02000001 	andeq	r0, r0, #1
    1d0c:	880a0423 	stmdahi	sl, {r0, r1, r5, sl}
 *
 * @param[in] msg       thread exit code
 *
 * @api
 */
void chThdExit(msg_t msg) {
    1d10:	0400000d 	streq	r0, [r0], #-13
    1d14:	00009071 	andeq	r9, r0, r1, ror r0

  chSysLock();
    1d18:	08230200 	stmdaeq	r3!, {r9}
    1d1c:	000ea20a 	andeq	sl, lr, sl, lsl #4
  chThdExitS(msg);
    1d20:	5f720400 	svcpl	0x00720400
  /* The thread never returns here.*/
}
    1d24:	02000001 	andeq	r0, r0, #1
    1d28:	0c000c23 	stceq	12, cr0, [r0], {35}	; 0x23
    1d2c:	00000090 	muleq	r0, r0, r0
 *
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
    1d30:	000ead04 	andeq	sl, lr, r4, lsl #26
    1d34:	1e730400 	cdpne	4, 7, cr0, cr3, cr0, {0}
  Thread *tp = currp;
    1d38:	03000001 	movweq	r0, #1
    1d3c:	01c10801 	biceq	r0, r1, r1, lsl #16
    1d40:	010d0000 	mrseq	r0, (UNDEF: 13)

  tp->p_u.exitcode = msg;
    1d44:	00000edc 	ldrdeq	r0, [r0], -ip
#if defined(THREAD_EXT_EXIT_HOOK)
  THREAD_EXT_EXIT_HOOK(tp);
#endif
#if CH_USE_WAITEXIT
  while (notempty(&tp->p_waiting))
    1d48:	20012b01 	andcs	r2, r1, r1, lsl #22
    chSchReadyI(list_remove(&tp->p_waiting));
    1d4c:	64000014 	strvs	r0, [r0], #-20	; 0xffffffec
    1d50:	02000014 	andeq	r0, r0, #20
    1d54:	010e007d 	tsteq	lr, sp, ror r0
    1d58:	00000ecc 	andeq	r0, r0, ip, asr #29
    1d5c:	70014501 	andvc	r4, r1, r1, lsl #10
  tp->p_u.exitcode = msg;
#if defined(THREAD_EXT_EXIT_HOOK)
  THREAD_EXT_EXIT_HOOK(tp);
#endif
#if CH_USE_WAITEXIT
  while (notempty(&tp->p_waiting))
    1d60:	02000014 	andeq	r0, r0, #20
    1d64:	ec000015 	stc	0, cr0, [r0], {21}
    1d68:	e800000a 	stmda	r0, {r1, r3}
    chSchReadyI(list_remove(&tp->p_waiting));
#endif
#if CH_USE_REGISTRY
  /* Static threads are immediately removed from the registry because
     there is no memory to recover.*/
  if ((tp->p_flags & THD_MEM_MODE_MASK) == THD_MEM_MODE_STATIC)
    1d6c:	0f000001 	svceq	0x00000001
    1d70:	00707476 	rsbseq	r7, r0, r6, ror r4
    1d74:	01184501 	tsteq	r8, r1, lsl #10
    REG_REMOVE(tp);
    1d78:	91020000 	mrsls	r0, (UNDEF: 2)
    1d7c:	0e5f1074 	mrceq	0, 2, r1, cr15, cr4, {3}
    1d80:	45010000 	strmi	r0, [r1, #-0]
    1d84:	00000090 	muleq	r0, r0, r0
    1d88:	10709102 	rsbsne	r9, r0, r2, lsl #2
#endif
  chSchGoSleepS(THD_STATE_FINAL);
    1d8c:	00000ee5 	andeq	r0, r0, r5, ror #29
    1d90:	009d4501 	addseq	r4, sp, r1, lsl #10
  /* The thread never returns here.*/
  chDbgAssert(FALSE, "chThdExitS(), #1", "zombies apocalypse");
}
    1d94:	91020000 	mrsls	r0, (UNDEF: 2)
    1d98:	61700f6c 	cmnvs	r0, ip, ror #30
    1d9c:	45010072 	strmi	r0, [r1, #-114]	; 0xffffff8e
 * @param[in] tp        pointer to the thread
 * @return              The exit code from the terminated thread.
 *
 * @api
 */
msg_t chThdWait(Thread *tp) {
    1da0:	0000009b 	muleq	r0, fp, r0
    1da4:	11689102 	cmnne	r8, r2, lsl #2
  msg_t msg;

  chDbgCheck(tp != NULL, "chThdWait");

  chSysLock();
    1da8:	46010070 			; <UNDEFINED> instruction: 0x46010070
    1dac:	00000118 	andeq	r0, r0, r8, lsl r1
  chDbgAssert(tp != currp, "chThdWait(), #1", "waiting self");
#if CH_USE_DYNAMIC
  chDbgAssert(tp->p_refs > 0, "chThdWait(), #2", "not referenced");
#endif
  if (tp->p_state != THD_STATE_FINAL) {
    1db0:	007c9102 	rsbseq	r9, ip, r2, lsl #2
    1db4:	0f1e010e 	svceq	0x001e010e
    list_insert(currp, &tp->p_waiting);
    1db8:	63010000 	movwvs	r0, #4096	; 0x1000
    1dbc:	00151001 	andseq	r1, r5, r1
    1dc0:	00155600 	andseq	r5, r5, r0, lsl #12
    1dc4:	000b0c00 	andeq	r0, fp, r0, lsl #24
    1dc8:	00021000 	andeq	r1, r2, r0
    1dcc:	74760f00 	ldrbtvc	r0, [r6], #-3840	; 0xfffff100
    chSchGoSleepS(THD_STATE_WTEXIT);
    1dd0:	63010070 	movwvs	r0, #4208	; 0x1070
    1dd4:	00000118 	andeq	r0, r0, r8, lsl r1
  }
  msg = tp->p_u.exitcode;
    1dd8:	007c9102 	rsbseq	r9, ip, r2, lsl #2
  chSysUnlock();
    1ddc:	0eec0112 	mcreq	1, 7, r0, cr12, cr2, {0}
    1de0:	7f010000 	svcvc	0x00010000
#if CH_USE_DYNAMIC
  chThdRelease(tp);
    1de4:	00008501 	andeq	r8, r0, r1, lsl #10
    1de8:	00156000 	andseq	r6, r5, r0
#endif
  return msg;
}
    1dec:	0015b600 	andseq	fp, r5, r0, lsl #12
    1df0:	000b2c00 	andeq	r2, fp, r0, lsl #24
    1df4:	00025800 	andeq	r5, r2, r0, lsl #16
    1df8:	13d71000 	bicsne	r1, r7, #0
    1dfc:	7f010000 	svcvc	0x00010000
 * @return              The same thread pointer passed as parameter
 *                      representing the new reference.
 *
 * @api
 */
Thread *chThdAddRef(Thread *tp) {
    1e00:	00000090 	muleq	r0, r0, r0

  chSysLock();
    1e04:	0f749102 	svceq	0x00749102
    1e08:	00646e65 	rsbeq	r6, r4, r5, ror #28
  chDbgAssert(tp->p_refs < 255, "chThdAddRef(), #1", "too many references");
  tp->p_refs++;
    1e0c:	00907f01 	addseq	r7, r0, r1, lsl #30
    1e10:	91020000 	mrsls	r0, (UNDEF: 2)
    1e14:	0e5f1370 	mrceq	3, 2, r1, cr15, cr0, {3}
    1e18:	81010000 	mrshi	r0, (UNDEF: 1)
  chSysUnlock();
    1e1c:	00000090 	muleq	r0, r0, r0
    1e20:	007c9102 	rsbseq	r9, ip, r2, lsl #2
  return tp;
}
    1e24:	000c9b14 	andeq	r9, ip, r4, lsl fp
    1e28:	64d10400 	ldrbvs	r0, [r1], #1024	; 0x400
    1e2c:	01000001 	tsteq	r0, r1
 *
 * @param[in] tp        pointer to the thread
 *
 * @api
 */
void chThdRelease(Thread *tp) {
    1e30:	0c9b1501 	cfldr32eq	mvfx1, [fp], {1}
    1e34:	23010000 	movwcs	r0, #4096	; 0x1000
  trefs_t refs;

  chSysLock();
    1e38:	00000164 	andeq	r0, r0, r4, ror #2
    1e3c:	f8030501 			; <UNDEFINED> instruction: 0xf8030501
  chDbgAssert(tp->p_refs > 0, "chThdRelease(), #1", "not referenced");
  refs = --tp->p_refs;
    1e40:	00200006 	eoreq	r0, r0, r6
    1e44:	000007a1 	andeq	r0, r0, r1, lsr #15
    1e48:	07cc0002 	strbeq	r0, [ip, r2]
    1e4c:	01040000 	mrseq	r0, (UNDEF: 4)
    1e50:	00000287 	andeq	r0, r0, r7, lsl #5
  chSysUnlock();
    1e54:	000fbb01 	andeq	fp, pc, r1, lsl #22
    1e58:	00021600 	andeq	r1, r2, r0, lsl #12
	...

  /* If the references counter reaches zero and the thread is in its
     terminated state then the memory can be returned to the proper
     allocator. Of course static threads are not affected.*/
  if ((refs == 0) && (tp->p_state == THD_STATE_FINAL)) {
    1e64:	00004800 	andeq	r4, r0, r0, lsl #16
    1e68:	00088700 	andeq	r8, r8, r0, lsl #14
    switch (tp->p_flags & THD_MEM_MODE_MASK) {
    1e6c:	05040200 	streq	r0, [r4, #-512]	; 0xfffffe00
    1e70:	00746e69 	rsbseq	r6, r4, r9, ror #28
    1e74:	ed070403 	cfstrs	mvf0, [r7, #-12]
    1e78:	03000001 	movweq	r0, #1
    1e7c:	01ba0601 			; <UNDEFINED> instruction: 0x01ba0601
#if CH_USE_HEAP
    case THD_MEM_MODE_HEAP:
#if CH_USE_REGISTRY
      REG_REMOVE(tp);
    1e80:	33040000 	movwcc	r0, #16384	; 0x4000
    1e84:	0300000a 	movweq	r0, #10
    1e88:	0000492a 	andeq	r4, r0, sl, lsr #18
    1e8c:	08010300 	stmdaeq	r1, {r8, r9}
    1e90:	000001b8 			; <UNDEFINED> instruction: 0x000001b8
#endif
      chHeapFree(tp);
    1e94:	31050203 	tstcc	r5, r3, lsl #4
      break;
    1e98:	03000000 	movweq	r0, #0
#endif
#if CH_USE_MEMPOOLS
    case THD_MEM_MODE_MEMPOOL:
#if CH_USE_REGISTRY
      REG_REMOVE(tp);
    1e9c:	026a0702 	rsbeq	r0, sl, #524288	; 0x80000
    1ea0:	00040000 	andeq	r0, r4, r0
    1ea4:	03000003 	movweq	r0, #3
    1ea8:	0000694f 	andeq	r6, r0, pc, asr #18
    1eac:	05040300 	streq	r0, [r4, #-768]	; 0xfffffd00
#endif
      chPoolFree(tp->p_mpool, tp);
    1eb0:	000000f7 	strdeq	r0, [r0], -r7
    1eb4:	0002ff04 	andeq	pc, r2, r4, lsl #30
    1eb8:	7b500300 	blvc	1402ac0 <_flash_swap_addr+0x13c32c0>
      break;
#endif
    }
  }
}
    1ebc:	03000000 	movweq	r0, #0
 * @retval NULL         if the memory cannot be allocated.
 *
 * @api
 */
Thread *chThdCreateFromHeap(MemoryHeap *heapp, size_t size,
                            tprio_t prio, tfunc_t pf, void *arg) {
    1ec0:	01e80704 	mvneq	r0, r4, lsl #14
    1ec4:	08030000 	stmdaeq	r3, {}	; <UNPREDICTABLE>
    1ec8:	0000f205 	andeq	pc, r0, r5, lsl #4
  void *wsp;
  Thread *tp;

  wsp = chHeapAlloc(heapp, size);
    1ecc:	07080300 	streq	r0, [r8, -r0, lsl #6]
    1ed0:	000001e3 	andeq	r0, r0, r3, ror #3
    1ed4:	000d6204 	andeq	r6, sp, r4, lsl #4
  if (wsp == NULL)
    1ed8:	3e280400 	cdpcc	4, 2, cr0, cr8, cr0, {0}
    return NULL;
    1edc:	04000000 	streq	r0, [r0], #-0
    1ee0:	00000d18 	andeq	r0, r0, r8, lsl sp
  _thread_memfill((uint8_t *)wsp + sizeof(Thread),
                  (uint8_t *)wsp + size,
                  CH_STACK_FILL_VALUE);
#endif
  
  chSysLock();
    1ee4:	003e2904 	eorseq	r2, lr, r4, lsl #18
    1ee8:	d2040000 	andle	r0, r4, #0
  tp = chThdCreateI(wsp, size, prio, pf, arg);
    1eec:	0400000d 	streq	r0, [r0], #-13
    1ef0:	00003e2a 	andeq	r3, r0, sl, lsr #28
    1ef4:	0d0e0400 	cfstrseq	mvf0, [lr, #-0]
    1ef8:	2b040000 	blcs	101f00 <_flash_swap_addr+0xc2700>
  tp->p_flags = THD_MEM_MODE_HEAP;
    1efc:	0000003e 	andeq	r0, r0, lr, lsr r0
    1f00:	000de104 	andeq	lr, sp, r4, lsl #2
  chSchWakeupS(tp, RDY_OK);
    1f04:	702c0400 	eorvc	r0, ip, r0, lsl #8
    1f08:	04000000 	streq	r0, [r0], #-0
    1f0c:	0000041f 	andeq	r0, r0, pc, lsl r4
  chSysUnlock();
    1f10:	005e2d04 	subseq	r2, lr, r4, lsl #26
    1f14:	76040000 	strvc	r0, [r4], -r0
  return tp;
}
    1f18:	0400000d 	streq	r0, [r0], #-13
    1f1c:	0000702f 	andeq	r7, r0, pc, lsr #32
 * @retval  NULL        if the memory pool is empty.
 *
 * @api
 */
Thread *chThdCreateFromMemoryPool(MemoryPool *mp, tprio_t prio,
                                  tfunc_t pf, void *arg) {
    1f20:	027d0400 	rsbseq	r0, sp, #0, 8
    1f24:	31040000 	mrscc	r0, (UNDEF: 4)
    1f28:	00000070 	andeq	r0, r0, r0, ror r0
  void *wsp;
  Thread *tp;

  chDbgCheck(mp != NULL, "chThdCreateFromMemoryPool");

  wsp = chPoolAlloc(mp);
    1f2c:	000f7b04 	andeq	r7, pc, r4, lsl #22
    1f30:	5e320400 	cfabsspl	mvf0, mvf2
  if (wsp == NULL)
    1f34:	04000000 	streq	r0, [r0], #-0
    1f38:	00000e1b 	andeq	r0, r0, fp, lsl lr
    return NULL;
    1f3c:	00fe2305 	rscseq	r2, lr, r5, lsl #6
  _thread_memfill((uint8_t *)wsp + sizeof(Thread),
                  (uint8_t *)wsp + mp->mp_object_size,
                  CH_STACK_FILL_VALUE);
#endif

  chSysLock();
    1f40:	1b050000 	blne	141f48 <_flash_swap_addr+0x102748>
    1f44:	4800000e 	stmdami	r0, {r1, r2, r3}
  tp = chThdCreateI(wsp, mp->mp_object_size, prio, pf, arg);
    1f48:	02235706 	eoreq	r5, r3, #1572864	; 0x180000
    1f4c:	57060000 	strpl	r0, [r6, -r0]
    1f50:	06000011 			; <UNDEFINED> instruction: 0x06000011
    1f54:	00024858 	andeq	r4, r2, r8, asr r8
    1f58:	00230200 	eoreq	r0, r3, r0, lsl #4
    1f5c:	000dda06 	andeq	sp, sp, r6, lsl #20
  tp->p_flags = THD_MEM_MODE_MEMPOOL;
    1f60:	485a0600 	ldmdami	sl, {r9, sl}^
    1f64:	02000002 	andeq	r0, r0, #2
  tp->p_mpool = mp;
    1f68:	ed060423 	cfstrs	mvf0, [r6, #-140]	; 0xffffff74
  chSchWakeupS(tp, RDY_OK);
    1f6c:	0600000c 	streq	r0, [r0], -ip
    1f70:	0000bc5c 	andeq	fp, r0, ip, asr ip
    1f74:	08230200 	stmdaeq	r3!, {r9}
  chSysUnlock();
    1f78:	000ebc06 	andeq	fp, lr, r6, lsl #24
    1f7c:	165d0600 	ldrbne	r0, [sp], -r0, lsl #12
  return tp;
}
    1f80:	02000003 	andeq	r0, r0, #3
    1f84:	21060c23 	tstcs	r6, r3, lsr #24
    1f88:	0600000d 	streq	r0, [r0], -sp
    1f8c:	0002485f 	andeq	r4, r2, pc, asr r8
 */
void _core_init(void) {
#if CH_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];
  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
    1f90:	10230200 	eorne	r0, r3, r0, lsl #4
    1f94:	000d9806 	andeq	r9, sp, r6, lsl #16
    1f98:	48600600 	stmdami	r0!, {r9, sl}^
    1f9c:	02000002 	andeq	r0, r0, #2
    1fa0:	9b061423 	blls	187034 <_flash_swap_addr+0x147834>
    1fa4:	0600000e 	streq	r0, [r0], -lr
    1fa8:	0004d867 	andeq	sp, r4, r7, ror #16
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
    1fac:	18230200 	stmdane	r3!, {r9}
    1fb0:	000df306 	andeq	pc, sp, r6, lsl #6
    1fb4:	9b720600 	blls	1c837bc <_flash_swap_addr+0x1c43fbc>
    1fb8:	02000000 	andeq	r0, r0, #0
    1fbc:	13061c23 	movwne	r1, #27683	; 0x6c23
    1fc0:	0600000e 	streq	r0, [r0], -lr
#else
  static stkalign_t buffer[MEM_ALIGN_NEXT(CH_MEMCORE_SIZE)/MEM_ALIGN_SIZE];
  nextmem = (uint8_t *)&buffer[0];
  endmem = (uint8_t *)&buffer[MEM_ALIGN_NEXT(CH_MEMCORE_SIZE)/MEM_ALIGN_SIZE];
#endif
}
    1fc4:	00009076 	andeq	r9, r0, r6, ror r0
    1fc8:	1d230200 	sfmne	f0, 4, [r3, #-0]
    1fcc:	000e7d06 	andeq	r7, lr, r6, lsl #26
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
void *chCoreAlloc(size_t size) {
    1fd0:	a67b0600 	ldrbtge	r0, [fp], -r0, lsl #12
    1fd4:	02000000 	andeq	r0, r0, #0
  void *p;

  chSysLock();
    1fd8:	fb061e23 	blx	18986e <_flash_swap_addr+0x14a06e>
    1fdc:	0600000d 	streq	r0, [r0], -sp
  p = chCoreAllocI(size);
    1fe0:	0000b181 	andeq	fp, r0, r1, lsl #3
    1fe4:	1f230200 	svcne	0x00230200
  chSysUnlock();
    1fe8:	000e5d06 	andeq	r5, lr, r6, lsl #26
    1fec:	ba880600 	blt	fe2037f4 <_stack_start+0xde1f37f4>
  return p;
}
    1ff0:	02000003 	andeq	r0, r0, #3
    1ff4:	70072023 	andvc	r2, r7, r3, lsr #32
    1ff8:	0600755f 			; <UNDEFINED> instruction: 0x0600755f
    1ffc:	0004a3ad 	andeq	sl, r4, sp, lsr #7
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @iclass
 */
void *chCoreAllocI(size_t size) {
    2000:	24230200 	strtcs	r0, [r3], #-512	; 0xfffffe00
  void *p;

  chDbgCheckClassI();

  size = MEM_ALIGN_NEXT(size);
    2004:	000ec206 	andeq	ip, lr, r6, lsl #4
    2008:	70b20600 	adcsvc	r0, r2, r0, lsl #12
    200c:	02000002 	andeq	r0, r0, #2
  if ((size_t)(endmem - nextmem) < size)
    2010:	6b062823 	blvs	18c0a4 <_flash_swap_addr+0x14c8a4>
    2014:	0600000e 	streq	r0, [r0], -lr
    2018:	00024eb8 			; <UNDEFINED> instruction: 0x00024eb8
    201c:	2c230200 	sfmcs	f0, 4, [r3], #-0
    2020:	000c8e06 	andeq	r8, ip, r6, lsl #28
    2024:	c7bc0600 	ldrgt	r0, [ip, r0, lsl #12]!
    2028:	02000000 	andeq	r0, r0, #0
    202c:	22063423 	andcs	r3, r6, #587202560	; 0x23000000
    return NULL;
    2030:	0600000e 	streq	r0, [r0], -lr
    2034:	0000d2c2 	andeq	sp, r0, r2, asr #5
  p = nextmem;
    2038:	38230200 	stmdacc	r3!, {r9}
    203c:	000de906 	andeq	lr, sp, r6, lsl #18
    2040:	eac90600 	b	ff243848 <_stack_start+0xdf233848>
  nextmem += size;
    2044:	02000004 	andeq	r0, r0, #4
    2048:	49063c23 	stmdbmi	r6, {r0, r1, r5, sl, fp, ip, sp}
    204c:	0600000e 	streq	r0, [r0], -lr
    2050:	0000bccd 	andeq	fp, r0, sp, asr #25
    2054:	40230200 	eormi	r0, r3, r0, lsl #4
    2058:	000cfe06 	andeq	pc, ip, r6, lsl #28
  return p;
}
    205c:	86d30600 	ldrbhi	r0, [r3], r0, lsl #12
    2060:	02000002 	andeq	r0, r0, #2
    2064:	08004423 	stmdaeq	r0, {r0, r1, r5, sl, lr}
    2068:	485a0508 	ldmdami	sl, {r3, r8, sl}^
    206c:	06000002 	streq	r0, [r0], -r2
 *
 * @api
 */
size_t chCoreStatus(void) {

  return (size_t)(endmem - nextmem);
    2070:	00001157 	andeq	r1, r0, r7, asr r1
    2074:	02485b05 	subeq	r5, r8, #5120	; 0x1400
    2078:	23020000 	movwcs	r0, #8192	; 0x2000
    207c:	0dda0600 	ldcleq	6, cr0, [sl]
    2080:	5d050000 	stcpl	0, cr0, [r5, #-0]
    2084:	00000248 	andeq	r0, r0, r8, asr #4
}
    2088:	00042302 	andeq	r2, r4, r2, lsl #6
    208c:	00f30409 	rscseq	r0, r3, r9, lsl #8
/**
 * @brief   Initializes the default heap.
 *
 * @notapi
 */
void _heap_init(void) {
    2090:	a6040000 	strge	r0, [r4], -r0
  default_heap.h_provider = chCoreAlloc;
    2094:	0500000d 	streq	r0, [r0, #-13]
    2098:	0002235f 	andeq	r2, r2, pc, asr r3
    209c:	05040800 	streq	r0, [r4, #-2048]	; 0xfffff800
    20a0:	00027064 	andeq	r7, r2, r4, rrx
  default_heap.h_free.h.u.next = (union heap_header *)NULL;
    20a4:	11570600 	cmpne	r7, r0, lsl #12
    20a8:	66050000 	strvs	r0, [r5], -r0
    20ac:	00000248 	andeq	r0, r0, r8, asr #4
    20b0:	00002302 	andeq	r2, r0, r2, lsl #6
  default_heap.h_free.h.size = 0;
    20b4:	000d6a04 	andeq	r6, sp, r4, lsl #20
    20b8:	59690500 	stmdbpl	r9!, {r8, sl}^
    20bc:	04000002 	streq	r0, [r0], #-2
#if CH_USE_MUTEXES || defined(__DOXYGEN__)
  chMtxInit(&default_heap.h_mtx);
    20c0:	00000d41 	andeq	r0, r0, r1, asr #26
    20c4:	0286de07 	addeq	sp, r6, #7, 28	; 0x70
#else
  chSemInit(&default_heap.h_sem, 1);
#endif
}
    20c8:	040a0000 	streq	r0, [sl], #-0
    20cc:	000e640b 	andeq	r6, lr, fp, lsl #8
 * @param[in] buf       heap buffer base
 * @param[in] size      heap size
 *
 * @init
 */
void chHeapInit(MemoryHeap *heapp, void *buf, size_t size) {
    20d0:	05072400 	streq	r2, [r7, #-1024]	; 0xfffffc00
    20d4:	00031601 	andeq	r1, r3, r1, lsl #12
    20d8:	34720c00 	ldrbtcc	r0, [r2], #-3072	; 0xfffff400
  union heap_header *hp;

  chDbgCheck(MEM_IS_ALIGNED(buf) && MEM_IS_ALIGNED(size), "chHeapInit");
    20dc:	01180700 	tsteq	r8, r0, lsl #14
    20e0:	0000027b 	andeq	r0, r0, fp, ror r2
    20e4:	0c002302 	stceq	3, cr2, [r0], {2}
    20e8:	07003572 	smlsdxeq	r0, r2, r5, r3

  heapp->h_provider = (memgetfunc_t)NULL;
    20ec:	027b0119 	rsbseq	r0, fp, #1073741830	; 0x40000006
    20f0:	23020000 	movwcs	r0, #8192	; 0x2000
  heapp->h_free.h.u.next = hp = buf;
    20f4:	36720c04 	ldrbtcc	r0, [r2], -r4, lsl #24
    20f8:	011a0700 	tsteq	sl, r0, lsl #14
    20fc:	0000027b 	andeq	r0, r0, fp, ror r2
  heapp->h_free.h.size = 0;
    2100:	0c082302 	stceq	3, cr2, [r8], {2}
    2104:	07003772 	smlsdxeq	r0, r2, r7, r3
  hp->h.u.next = NULL;
    2108:	027b011b 	rsbseq	r0, fp, #-1073741818	; 0xc0000006
    210c:	23020000 	movwcs	r0, #8192	; 0x2000
  hp->h.size = size - sizeof(union heap_header);
    2110:	38720c0c 	ldmdacc	r2!, {r2, r3, sl, fp}^
    2114:	011c0700 	tsteq	ip, r0, lsl #14
#if CH_USE_MUTEXES || defined(__DOXYGEN__)
  chMtxInit(&heapp->h_mtx);
    2118:	0000027b 	andeq	r0, r0, fp, ror r2
    211c:	0c102302 	ldceq	3, cr2, [r0], {2}
    2120:	07003972 	smlsdxeq	r0, r2, r9, r3
#else
  chSemInit(&heapp->h_sem, 1);
#endif
}
    2124:	027b011d 	rsbseq	r0, fp, #1073741831	; 0x40000007
    2128:	23020000 	movwcs	r0, #8192	; 0x2000
    212c:	31720c14 	cmncc	r2, r4, lsl ip
 * @return              A pointer to the allocated block.
 * @retval NULL         if the block cannot be allocated.
 *
 * @api
 */
void *chHeapAlloc(MemoryHeap *heapp, size_t size) {
    2130:	1e070030 	mcrne	0, 0, r0, cr7, cr0, {1}
    2134:	00027b01 	andeq	r7, r2, r1, lsl #22
  union heap_header *qp, *hp, *fp;

  if (heapp == NULL)
    2138:	18230200 	stmdane	r3!, {r9}
    213c:	3131720c 	teqcc	r1, ip, lsl #4
    heapp = &default_heap;
    2140:	011f0700 	tsteq	pc, r0, lsl #14
    2144:	0000027b 	andeq	r0, r0, fp, ror r2

  size = MEM_ALIGN_NEXT(size);
    2148:	0c1c2302 	ldceq	3, cr2, [ip], {2}
    214c:	0700726c 	streq	r7, [r0, -ip, ror #4]
    2150:	027b0120 	rsbseq	r0, fp, #32, 2
  qp = &heapp->h_free;
    2154:	23020000 	movwcs	r0, #8192	; 0x2000
    2158:	5a0b0020 	bpl	2c21e0 <_flash_swap_addr+0x2829e0>
  H_LOCK(heapp);
    215c:	0400000d 	streq	r0, [r0], #-13
    2160:	33012a07 	movwcc	r2, #6663	; 0x1a07
    2164:	0c000003 	stceq	0, cr0, [r0], {3}

  while (qp->h.u.next != NULL) {
    2168:	00333172 	eorseq	r3, r3, r2, ror r1
    hp = qp->h.u.next;
    216c:	33012b07 	movwcc	r2, #6919	; 0x1b07
    if (hp->h.size >= size) {
    2170:	02000003 	andeq	r0, r0, #3
    2174:	09000023 	stmdbeq	r0, {r0, r1, r5}
    2178:	00028804 	andeq	r8, r2, r4, lsl #16
      if (hp->h.size < size + sizeof(union heap_header)) {
    217c:	0e540400 	cdpeq	4, 5, cr0, cr4, cr0, {0}
    2180:	4e080000 	cdpmi	0, 0, cr0, cr8, cr0, {0}
    2184:	00000344 	andeq	r0, r0, r4, asr #6
        /* Gets the whole block even if it is slightly bigger than the
           requested size because the fragment would be too small to be
           useful.*/
        qp->h.u.next = hp->h.u.next;
    2188:	034a0409 	movteq	r0, #41993	; 0xa409
    218c:	010d0000 	mrseq	r0, (UNDEF: 13)
    2190:	00000356 	andeq	r0, r0, r6, asr r3
      }
      else {
        /* Block bigger enough, must split it.*/
        fp = (void *)((uint8_t *)(hp) + sizeof(union heap_header) + size);
    2194:	0002860e 	andeq	r8, r2, lr, lsl #12
    2198:	35040000 	strcc	r0, [r4, #-0]
    219c:	0800000e 	stmdaeq	r0, {r1, r2, r3}
        fp->h.u.next = hp->h.u.next;
    21a0:	00036153 	andeq	r6, r3, r3, asr r1
    21a4:	0e350500 	cfabs32eq	mvfx0, mvfx5
        fp->h.size = hp->h.size - sizeof(union heap_header) - size;
    21a8:	08140000 	ldmdaeq	r4, {}	; <UNPREDICTABLE>
    21ac:	0003b45a 	andeq	fp, r3, sl, asr r4
    21b0:	0d520600 	ldcleq	6, cr0, [r2, #-0]
    21b4:	5b080000 	blpl	2021bc <_flash_swap_addr+0x1c29bc>
        qp->h.u.next = fp;
    21b8:	000003b4 			; <UNDEFINED> instruction: 0x000003b4
        hp->h.size = size;
    21bc:	06002302 	streq	r2, [r0], -r2, lsl #6
    21c0:	00000d4a 	andeq	r0, r0, sl, asr #26
      }
      hp->h.u.heap = heapp;
    21c4:	03b45d08 			; <UNDEFINED> instruction: 0x03b45d08

      H_UNLOCK(heapp);
    21c8:	23020000 	movwcs	r0, #8192	; 0x2000
      return (void *)(hp + 1);
    21cc:	0d880604 	stceq	6, cr0, [r8, #16]
    21d0:	5f080000 	svcpl	0x00080000
    }
    qp = hp;
    21d4:	000000dd 	ldrdeq	r0, [r0], -sp

  size = MEM_ALIGN_NEXT(size);
  qp = &heapp->h_free;
  H_LOCK(heapp);

  while (qp->h.u.next != NULL) {
    21d8:	06082302 	streq	r2, [r8], -r2, lsl #6
    21dc:	00000d90 	muleq	r0, r0, sp
      return (void *)(hp + 1);
    }
    qp = hp;
  }

  H_UNLOCK(heapp);
    21e0:	03396008 	teqeq	r9, #8

  /* More memory is required, tries to get it from the associated provider
     else fails.*/
  if (heapp->h_provider) {
    21e4:	23020000 	movwcs	r0, #8192	; 0x2000
    21e8:	0e76060c 	cdpeq	6, 7, cr0, cr6, cr12, {0}
    hp = heapp->h_provider(size + sizeof(union heap_header));
    21ec:	62080000 	andvs	r0, r8, #0
    21f0:	00000286 	andeq	r0, r0, r6, lsl #5
    21f4:	00102302 	andseq	r2, r0, r2, lsl #6
    21f8:	03560409 	cmpeq	r6, #150994944	; 0x9000000
    if (hp != NULL) {
    21fc:	dd0f0000 	stcle	0, cr0, [pc, #-0]	; 2204 <chHeapAlloc+0xd4>
    2200:	08000000 	stmdaeq	r0, {}	; <UNPREDICTABLE>
      hp->h.u.heap = heapp;
    2204:	1c57091c 	mrrcne	9, 1, r0, r7, cr12
      hp->h.size = size;
    2208:	06000004 	streq	r0, [r0], -r4
    220c:	00000e2d 	andeq	r0, r0, sp, lsr #28
      hp++;
    2210:	024e5809 	subeq	r5, lr, #589824	; 0x90000
    2214:	23020000 	movwcs	r0, #8192	; 0x2000
      return (void *)hp;
    2218:	0e050600 	cfmadd32eq	mvax0, mvfx0, mvfx5, mvfx0
    }
  }
  return NULL;
    221c:	59090000 	stmdbpl	r9, {}	; <UNPREDICTABLE>
}
    2220:	000000bc 	strheq	r0, [r0], -ip
    2224:	06082302 	streq	r2, [r8], -r2, lsl #6
    2228:	00000da0 	andeq	r0, r0, r0, lsr #27
    222c:	03165b09 	tsteq	r6, #9216	; 0x2400
 *
 * @param[in] p         pointer to the memory block to be freed
 *
 * @api
 */
void chHeapFree(void *p) {
    2230:	23020000 	movwcs	r0, #8192	; 0x2000
    2234:	0d39060c 	ldceq	6, cr0, [r9, #-48]!	; 0xffffffd0
  union heap_header *qp, *hp;
  MemoryHeap *heapp;

  chDbgCheck(p != NULL, "chHeapFree");

  hp = (union heap_header *)p - 1;
    2238:	5e090000 	cdppl	0, 0, cr0, cr9, cr0, {0}
    223c:	00000248 	andeq	r0, r0, r8, asr #4
  heapp = hp->h.u.heap;
    2240:	06102302 	ldreq	r2, [r0], -r2, lsl #6
  qp = &heapp->h_free;
    2244:	00000dbd 			; <UNDEFINED> instruction: 0x00000dbd
    2248:	02485f09 	subeq	r5, r8, #9, 30	; 0x24
  H_LOCK(heapp);
    224c:	23020000 	movwcs	r0, #8192	; 0x2000
    2250:	0db30614 	ldceq	6, cr0, [r3, #80]!	; 0x50
    2254:	62090000 	andvs	r0, r9, #0
 *
 * @param[in] p         pointer to the memory block to be freed
 *
 * @api
 */
void chHeapFree(void *p) {
    2258:	00000248 	andeq	r0, r0, r8, asr #4
    225c:	00182302 	andseq	r2, r8, r2, lsl #6
  heapp = hp->h.u.heap;
  qp = &heapp->h_free;
  H_LOCK(heapp);

  while (TRUE) {
    chDbgAssert((hp < qp) || (hp >= LIMIT(qp)),
    2260:	000e8404 	andeq	r8, lr, r4, lsl #8
    2264:	bf640900 	svclt	0x00640900
    2268:	05000003 	streq	r0, [r0, #-3]
    226c:	0000100f 	andeq	r1, r0, pc
 *
 * @param[in] p         pointer to the memory block to be freed
 *
 * @api
 */
void chHeapFree(void *p) {
    2270:	50250a0c 	eorpl	r0, r5, ip, lsl #20
  while (TRUE) {
    chDbgAssert((hp < qp) || (hp >= LIMIT(qp)),
                "chHeapFree(), #1",
                "within free block");

    if (((qp == &heapp->h_free) || (hp > qp)) &&
    2274:	06000004 	streq	r0, [r0], -r4
    2278:	00000f50 	andeq	r0, r0, r0, asr pc
    227c:	024e260a 	subeq	r2, lr, #10485760	; 0xa00000
    2280:	23020000 	movwcs	r0, #8192	; 0x2000
    2284:	0f880600 	svceq	0x00880600
        ((qp->h.u.next == NULL) || (hp < qp->h.u.next))) {
    2288:	280a0000 	stmdacs	sl, {}	; <UNPREDICTABLE>
  while (TRUE) {
    chDbgAssert((hp < qp) || (hp >= LIMIT(qp)),
                "chHeapFree(), #1",
                "within free block");

    if (((qp == &heapp->h_free) || (hp > qp)) &&
    228c:	000000e8 	andeq	r0, r0, r8, ror #1
        ((qp->h.u.next == NULL) || (hp < qp->h.u.next))) {
    2290:	00082302 	andeq	r2, r8, r2, lsl #6
    2294:	00100f04 	andseq	r0, r0, r4, lsl #30
      /* Insertion after qp.*/
      hp->h.u.next = qp->h.u.next;
    2298:	27290a00 	strcs	r0, [r9, -r0, lsl #20]!
    229c:	05000004 	streq	r0, [r0, #-4]
      qp->h.u.next = hp;
    22a0:	00000d82 	andeq	r0, r0, r2, lsl #27
    22a4:	92250b10 	eorls	r0, r5, #16, 22	; 0x4000
      /* Verifies if the newly inserted block should be merged.*/
      if (LIMIT(hp) == hp->h.u.next) {
    22a8:	06000004 	streq	r0, [r0], -r4
    22ac:	00000d06 	andeq	r0, r0, r6, lsl #26
    22b0:	024e260b 	subeq	r2, lr, #11534336	; 0xb00000
    22b4:	23020000 	movwcs	r0, #8192	; 0x2000
    22b8:	0eb40600 	cdpeq	6, 11, cr0, cr4, cr0, {0}
        /* Merge with the next block.*/
        hp->h.size += hp->h.u.next->h.size + sizeof(union heap_header);
    22bc:	280b0000 	stmdacs	fp, {}	; <UNPREDICTABLE>
    22c0:	00000248 	andeq	r0, r0, r8, asr #4
    22c4:	06082302 	streq	r2, [r8], -r2, lsl #6
    22c8:	00000e42 	andeq	r0, r0, r2, asr #28
    22cc:	04922a0b 	ldreq	r2, [r2], #2571	; 0xa0b
        hp->h.u.next = hp->h.u.next->h.u.next;
    22d0:	23020000 	movwcs	r0, #8192	; 0x2000
    22d4:	0409000c 	streq	r0, [r9], #-12
      }
      if ((LIMIT(qp) == hp)) {
    22d8:	0000045b 	andeq	r0, r0, fp, asr r4
    22dc:	000d8204 	andeq	r8, sp, r4, lsl #4
    22e0:	5b2c0b00 	blpl	b04ee8 <_flash_swap_addr+0xac56e8>
    22e4:	10000004 	andne	r0, r0, r4
    22e8:	d88f0604 	stmle	pc, {r2, r9, sl}	; <UNPREDICTABLE>
        /* Merge with the previous block.*/
        qp->h.size += hp->h.size + sizeof(union heap_header);
    22ec:	11000004 	tstne	r0, r4
    22f0:	00000c94 	muleq	r0, r4, ip
    22f4:	00c79606 	sbceq	r9, r7, r6, lsl #12
    22f8:	d9110000 	ldmdble	r1, {}	; <UNPREDICTABLE>
        qp->h.u.next = hp->h.u.next;
    22fc:	0600000c 	streq	r0, [r0], -ip
    2300:	0000c79d 	muleq	r0, sp, r7
      }
      break;
    2304:	0e941100 	fmleqs	f1, f4, f0
    }
    qp = qp->h.u.next;
    2308:	a4060000 	strge	r0, [r6], #-0
  }
    230c:	00000286 	andeq	r0, r0, r6, lsl #5

  H_UNLOCK(heapp);
    2310:	000e0c11 	andeq	r0, lr, r1, lsl ip
  return;
}
    2314:	d2ab0600 	adcle	r0, fp, #0, 12
    2318:	00000000 	andeq	r0, r0, r0
    231c:	04de0409 	ldrbeq	r0, [lr], #1033	; 0x409
 *                      fragmented free space
 * @return              The number of fragments in the heap.
 *
 * @api
 */
size_t chHeapStatus(MemoryHeap *heapp, size_t *sizep) {
    2320:	e3120000 	tst	r2, #0
    2324:	03000004 	movweq	r0, #4
  union heap_header *qp;
  size_t n, sz;

  if (heapp == NULL)
    2328:	01c10801 	biceq	r0, r1, r1, lsl #16
    232c:	04090000 	streq	r0, [r9], #-0
    heapp = &default_heap;
    2330:	00000498 	muleq	r0, r8, r4
    2334:	000ff713 	andeq	pc, pc, r3, lsl r7	; <UNPREDICTABLE>

  H_LOCK(heapp);
    2338:	01340100 	teqeq	r4, r0, lsl #2
    233c:	00000248 	andeq	r0, r0, r8, asr #4
    2340:	000015c0 	andeq	r1, r0, r0, asr #11

  sz = 0;
    2344:	000015e2 	andeq	r1, r0, r2, ror #11
    2348:	00000b4c 	andeq	r0, r0, ip, asr #22
  for (n = 0, qp = &heapp->h_free; qp->h.u.next; n++, qp = qp->h.u.next)
    234c:	00000528 	andeq	r0, r0, r8, lsr #10
    2350:	70717414 	rsbsvc	r7, r1, r4, lsl r4
    2354:	28340100 	ldmdacs	r4!, {r8}
    2358:	02000005 	andeq	r0, r0, #5
    sz += qp->h.u.next->h.size;
    235c:	74157491 	ldrvc	r7, [r5], #-1169	; 0xfffffb6f
    2360:	35010070 	strcc	r0, [r1, #-112]	; 0xffffff90
    2364:	00000248 	andeq	r0, r0, r8, asr #4
    heapp = &default_heap;

  H_LOCK(heapp);

  sz = 0;
  for (n = 0, qp = &heapp->h_free; qp->h.u.next; n++, qp = qp->h.u.next)
    2368:	007c9102 	rsbseq	r9, ip, r2, lsl #2
    236c:	024e0409 	subeq	r0, lr, #150994944	; 0x9000000
    2370:	b3130000 	tstlt	r3, #0
    2374:	0100000f 	tsteq	r0, pc
    2378:	02480142 	subeq	r0, r8, #-2147483632	; 0x80000010
    sz += qp->h.u.next->h.size;
  if (sizep)
    237c:	15f00000 	ldrbne	r0, [r0, #0]!
    2380:	16100000 	ldrne	r0, [r0], -r0
    *sizep = sz;
    2384:	0b6c0000 	bleq	1b0238c <_flash_swap_addr+0x1ac2b8c>

  H_UNLOCK(heapp);
    2388:	05580000 	ldrbeq	r0, [r8, #-0]
  return n;
    238c:	74140000 	ldrvc	r0, [r4], #-0
}
    2390:	42010070 	andmi	r0, r1, #112	; 0x70
    2394:	00000248 	andeq	r0, r0, r8, asr #4
    2398:	007c9102 	rsbseq	r9, ip, r2, lsl #2
    239c:	0f400116 	svceq	0x00400116
 *                      @p NULL if the pool is not allowed to grow
 *                      automatically
 *
 * @init
 */
void chPoolInit(MemoryPool *mp, size_t size, memgetfunc_t provider) {
    23a0:	30020000 	andcc	r0, r2, r0
    23a4:	00161001 	andseq	r1, r6, r1

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)), "chPoolInit");
    23a8:	00166c00 	andseq	r6, r6, r0, lsl #24
    23ac:	007d0200 	rsbseq	r0, sp, r0, lsl #4
    23b0:	10030117 	andne	r0, r3, r7, lsl r1

  mp->mp_next = NULL;
    23b4:	4a020000 	bmi	823bc <_flash_swap_addr+0x42bbc>
    23b8:	00024801 	andeq	r4, r2, r1, lsl #16
  mp->mp_object_size = size;
    23bc:	00167000 	andseq	r7, r6, r0
  mp->mp_provider = provider;
    23c0:	0016ce00 	andseq	ip, r6, r0, lsl #28
    23c4:	000b8c00 	andeq	r8, fp, r0, lsl #24
}
    23c8:	0005a400 	andeq	sl, r5, r0, lsl #8
    23cc:	70741400 	rsbsvc	r1, r4, r0, lsl #8
 * @param[in] p         pointer to the array first element
 * @param[in] n         number of elements in the array
 *
 * @api
 */
void chPoolLoadArray(MemoryPool *mp, void *p, size_t n) {
    23d0:	484a0200 	stmdami	sl, {r9}^
    23d4:	02000002 	andeq	r0, r0, #2
    23d8:	63157491 	tstvs	r5, #-1862270976	; 0x91000000

  chDbgCheck((mp != NULL) && (n != 0), "chPoolLoadArray");
    23dc:	4b020070 	blmi	825a4 <_flash_swap_addr+0x42da4>
    23e0:	00000248 	andeq	r0, r0, r8, asr #4

  while (n) {
    23e4:	007c9102 	rsbseq	r9, ip, r2, lsl #2
    chPoolAdd(mp, p);
    23e8:	0fe90118 	svceq	0x00e90118
    23ec:	6c020000 	stcvs	0, cr0, [r2], {-0}
    p = (void *)(((uint8_t *)p) + mp->mp_object_size);
    23f0:	0016d001 	andseq	sp, r6, r1
    23f4:	00173400 	andseq	r3, r7, r0, lsl #8
    n--;
    23f8:	000bac00 	andeq	sl, fp, r0, lsl #24
    23fc:	0005da00 	andeq	sp, r5, r0, lsl #20
 */
void chPoolLoadArray(MemoryPool *mp, void *p, size_t n) {

  chDbgCheck((mp != NULL) && (n != 0), "chPoolLoadArray");

  while (n) {
    2400:	0fe01900 	svceq	0x00e01900
    2404:	6c020000 	stcvs	0, cr0, [r2], {-0}
    chPoolAdd(mp, p);
    p = (void *)(((uint8_t *)p) + mp->mp_object_size);
    n--;
  }
}
    2408:	0000009b 	muleq	r0, fp, r0
    240c:	156f9102 	strbne	r9, [pc, #-258]!	; 2312 <chHeapFree+0xe2>
 * @return              The pointer to the allocated object.
 * @retval NULL         if pool is empty.
 *
 * @iclass
 */
void *chPoolAllocI(MemoryPool *mp) {
    2410:	0070746f 	rsbseq	r7, r0, pc, ror #8
    2414:	02486d02 	subeq	r6, r8, #2, 26	; 0x80
  void *objp;

  chDbgCheckClassI();
  chDbgCheck(mp != NULL, "chPoolAllocI");

  if ((objp = mp->mp_next) != NULL)
    2418:	91020000 	mrsls	r0, (UNDEF: 2)
    241c:	811a0074 	tsthi	sl, r4, ror r0
    2420:	0200000f 	andeq	r0, r0, #15
    mp->mp_next = mp->mp_next->ph_next;
    2424:	17400181 	strbne	r0, [r0, -r1, lsl #3]
    2428:	17ce0000 	strbne	r0, [lr, r0]
    242c:	0bd80000 	bleq	ff602434 <_stack_start+0xdf5f2434>
  else if (mp->mp_provider != NULL)
    2430:	06590000 	ldrbeq	r0, [r9], -r0
    2434:	70140000 	andsvc	r0, r4, r0
    objp = mp->mp_provider(mp->mp_object_size);
    2438:	86810200 	strhi	r0, [r1], r0, lsl #4
    243c:	02000002 	andeq	r0, r0, #2
    2440:	74156c91 	ldrvc	r6, [r5], #-3217	; 0xfffff36f
  return objp;
    2444:	82020070 	andhi	r0, r2, #112	; 0x70
}
    2448:	00000248 	andeq	r0, r0, r8, asr #4
    244c:	1b749102 	blne	1d2685c <_flash_swap_addr+0x1ce705c>
 * @return              The pointer to the allocated object.
 * @retval NULL         if pool is empty.
 *
 * @api
 */
void *chPoolAlloc(MemoryPool *mp) {
    2450:	0000174a 	andeq	r1, r0, sl, asr #14
    2454:	00001752 	andeq	r1, r0, r2, asr r7
  void *objp;

  chSysLock();
    2458:	00000626 	andeq	r0, r0, r6, lsr #12
    245c:	706d7415 	rsbvc	r7, sp, r5, lsl r4
  objp = chPoolAllocI(mp);
    2460:	70840200 	addvc	r0, r4, r0, lsl #4
    2464:	01000000 	mrseq	r0, (UNDEF: 0)
  chSysUnlock();
    2468:	981b0053 	ldmdals	fp, {r0, r1, r4, r6}
    246c:	a0000017 	andge	r0, r0, r7, lsl r0
  return objp;
}
    2470:	41000017 	tstmi	r0, r7, lsl r0
    2474:	15000006 	strne	r0, [r0, #-6]
    2478:	00706d74 	rsbseq	r6, r0, r4, ror sp
    247c:	00708902 	rsbseq	r8, r0, r2, lsl #18
 * @param[in] mp        pointer to a @p MemoryPool structure
 * @param[in] objp      the pointer to the object to be released
 *
 * @iclass
 */
void chPoolFreeI(MemoryPool *mp, void *objp) {
    2480:	53010000 	movwpl	r0, #4096	; 0x1000
    2484:	17c21c00 	strbne	r1, [r2, r0, lsl #24]
  struct pool_header *php = objp;
    2488:	17ca0000 	strbne	r0, [sl, r0]

  chDbgCheckClassI();
  chDbgCheck((mp != NULL) && (objp != NULL), "chPoolFreeI");
    248c:	74150000 	ldrvc	r0, [r5], #-0
    2490:	0200706d 	andeq	r7, r0, #109	; 0x6d

  php->ph_next = mp->mp_next;
    2494:	0000709e 	muleq	r0, lr, r0
    2498:	00530100 	subseq	r0, r3, r0, lsl #2
  mp->mp_next = php;
    249c:	19011700 	stmdbne	r1, {r8, r9, sl, ip}
    24a0:	02000010 	andeq	r0, r0, #16
}
    24a4:	00c701b6 	strheq	r0, [r7], #22
    24a8:	17d00000 	ldrbne	r0, [r0, r0]
    24ac:	18360000 	ldmdane	r6!, {}	; <UNPREDICTABLE>
 * @param[in] mp        pointer to a @p MemoryPool structure
 * @param[in] objp      the pointer to the object to be released
 *
 * @api
 */
void chPoolFree(MemoryPool *mp, void *objp) {
    24b0:	0c040000 	stceq	0, cr0, [r4], {-0}
    24b4:	06aa0000 	strteq	r0, [sl], r0

  chSysLock();
    24b8:	e0190000 	ands	r0, r9, r0
    24bc:	0200000f 	andeq	r0, r0, #15
  chPoolFreeI(mp, objp);
    24c0:	00009bb6 			; <UNDEFINED> instruction: 0x00009bb6
    24c4:	5f910200 	svcpl	0x00910200
  chSysUnlock();
    24c8:	000e5f19 	andeq	r5, lr, r9, lsl pc
    24cc:	ddb60200 	lfmle	f0, 4, [r6]
}
    24d0:	02000000 	andeq	r0, r0, #0
    24d4:	e41c5891 	ldr	r5, [ip], #-2193	; 0xfffff76f
    24d8:	1a000017 	bne	253c <_port_init+0xc>
    24dc:	15000018 	strne	r0, [r0, #-24]	; 0xffffffe8
/**
 * @brief   System Timer vector.
 * @details This interrupt is used as system tick.
 * @note    The timer must be initialized in the startup code.
 */
CH_IRQ_HANDLER(SysTickVector) {
    24e0:	02007476 	andeq	r7, r0, #1979711488	; 0x76000000

  CH_IRQ_PROLOGUE();

  chSysLockFromIsr();
    24e4:	000356bb 			; <UNDEFINED> instruction: 0x000356bb
    24e8:	64910200 	ldrvs	r0, [r1], #512	; 0x200
  chSysTimerHandlerI();
    24ec:	01180000 	tsteq	r8, r0
  chSysUnlockFromIsr();
    24f0:	00000f8e 	andeq	r0, r0, lr, lsl #31
    24f4:	4001da02 	andmi	sp, r1, r2, lsl #20

  CH_IRQ_EPILOGUE();
    24f8:	9c000018 	stcls	0, cr0, [r0], {24}
    24fc:	30000018 	andcc	r0, r0, r8, lsl r0
 * @brief   SVC vector.
 * @details The SVC vector is used for exception mode re-entering after a
 *          context switch.
 * @note    The PendSV vector is only used in advanced kernel mode.
 */
void SVCallVector(void) {
    2500:	f800000c 			; <UNDEFINED> instruction: 0xf800000c
  struct extctx *ctxp;

  /* Current PSP value.*/
  asm volatile ("mrs     %0, PSP" : "=r" (ctxp) : : "memory");
    2504:	14000006 	strne	r0, [r0], #-6
    2508:	0070746e 	rsbseq	r7, r0, lr, ror #8

  /* Discarding the current exception context and positioning the stack to
     point to the real one.*/
  ctxp++;
    250c:	0248da02 	subeq	sp, r8, #8192	; 0x2000
    2510:	91020000 	mrsls	r0, (UNDEF: 2)
#if CORTEX_USE_FPU
  /* Restoring the special register SCB_FPCCR.*/
  SCB_FPCCR = (uint32_t)ctxp->fpccr;
  SCB_FPCAR = SCB_FPCAR + sizeof (struct extctx);
#endif
  asm volatile ("msr     PSP, %0" : : "r" (ctxp) : "memory");
    2514:	736d146c 	cmnvc	sp, #108, 8	; 0x6c000000
  port_unlock_from_isr();
    2518:	da020067 	ble	826bc <_flash_swap_addr+0x42ebc>
    251c:	000000c7 	andeq	r0, r0, r7, asr #1
}
    2520:	1c689102 	stfnep	f1, [r8], #-8
    2524:	0000186a 	andeq	r1, r0, sl, ror #16
    2528:	00001898 	muleq	r0, r8, r8
    252c:	70746f15 	rsbsvc	r6, r4, r5, lsl pc
/*===========================================================================*/

/**
 * @brief   Port-related initialization code.
 */
void _port_init(void) {
    2530:	48e60200 	stmiami	r6!, {r9}^

  /* Initialization of the vector table and priority related settings.*/
  SCB_VTOR = CORTEX_VTOR_INIT;
    2534:	02000002 	andeq	r0, r0, #2
    2538:	00007491 	muleq	r0, r1, r4
    253c:	0f58011d 	svceq	0x0058011d
  SCB_AIRCR = AIRCR_VECTKEY | AIRCR_PRIGROUP(CORTEX_PRIGROUP_INIT);
    2540:	f6020000 			; <UNDEFINED> instruction: 0xf6020000
    2544:	0018a001 	andseq	sl, r8, r1
    2548:	0018c400 	andseq	ip, r8, r0, lsl #8
    254c:	000c5c00 	andeq	r5, ip, r0, lsl #24
    2550:	9b011e00 	blls	49d58 <_flash_swap_addr+0xa558>

  /* Initialization of the system vectors used by the port.*/
  nvicSetSystemHandlerPriority(HANDLER_SVCALL,
    2554:	0200000f 	andeq	r0, r0, #15
    2558:	d0010129 	andle	r0, r1, r9, lsr #2
    255c:	2c000018 	stccs	0, cr0, [r0], {24}
    CORTEX_PRIORITY_MASK(CORTEX_PRIORITY_SVCALL));
  nvicSetSystemHandlerPriority(HANDLER_PENDSV,
    2560:	7c000019 	stcvc	0, cr0, [r0], {25}
    2564:	3700000c 	strcc	r0, [r0, -ip]
    2568:	1f000007 	svcne	0x00000007
    CORTEX_PRIORITY_MASK(CORTEX_PRIORITY_PENDSV));
  nvicSetSystemHandlerPriority(HANDLER_SYSTICK,
    256c:	0070746f 	rsbseq	r7, r0, pc, ror #8
    2570:	48012a02 	stmdami	r1, {r1, r9, fp, sp}
    2574:	02000002 	andeq	r0, r0, #2
    2578:	1e007491 	mcrne	4, 0, r7, cr0, cr1, {4}
    257c:	000f2901 	andeq	r2, pc, r1, lsl #18
#endif

/**
 * @brief   Exception exit redirection to _port_switch_from_isr().
 */
void _port_irq_epilogue(void) {
    2580:	01420200 	mrseq	r0, (UNDEF: 98)

  port_lock_from_isr();
    2584:	00193001 	andseq	r3, r9, r1
    2588:	0019c000 	andseq	ip, r9, r0
  if ((SCB_ICSR & ICSR_RETTOBASE) != 0) {
    258c:	000ca800 	andeq	sl, ip, r0, lsl #16
    2590:	00076f00 	andeq	r6, r7, r0, lsl #30
    2594:	746f1f00 	strbtvc	r1, [pc], #-3840	; 259c <_port_irq_epilogue+0x1c>
    2598:	43020070 	movwmi	r0, #8304	; 0x2070
    259c:	00024801 	andeq	r4, r2, r1, lsl #16
    struct extctx *ctxp;

    /* Current PSP value.*/
    asm volatile ("mrs     %0, PSP" : "=r" (ctxp) : : "memory");
    25a0:	70910200 	addsvc	r0, r1, r0, lsl #4

    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;
    25a4:	0070631f 	rsbseq	r6, r0, pc, lsl r3
    25a8:	48014302 	stmdami	r1, {r1, r8, r9, lr}
    asm volatile ("msr     PSP, %0" : : "r" (ctxp) : "memory");
    25ac:	02000002 	andeq	r0, r0, #2
    25b0:	20007491 	mulcs	r0, r1, r4
    ctxp->xpsr = (regarm_t)0x01000000;
    25b4:	000f6901 	andeq	r6, pc, r1, lsl #18
    25b8:	01630200 	cmneq	r3, r0, lsl #4

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
    25bc:	0019c001 	andseq	ip, r9, r1
    25c0:	0019de00 	andseq	sp, r9, r0, lsl #28
    25c4:	000cd400 	andeq	sp, ip, r0, lsl #8
    25c8:	0e8e2100 	rmfeqe	f2, f6, f0
    25cc:	68090000 	stmdavs	r9, {}	; <UNPREDICTABLE>
    25d0:	0000041c 	andeq	r0, r0, ip, lsl r4
    25d4:	8e220101 	sufhis	f0, f2, f1
    25d8:	0200000e 	andeq	r0, r0, #14
    25dc:	00041c28 	andeq	r1, r4, r8, lsr #24
    25e0:	03050100 	movweq	r0, #20736	; 0x5100
    25e4:	20000708 	andcs	r0, r0, r8, lsl #14
    25e8:	000a3200 	andeq	r3, sl, r0, lsl #4
    25ec:	c9000200 	stmdbgt	r0, {r9}
    25f0:	04000009 	streq	r0, [r0], #-9
    25f4:	00028701 	andeq	r8, r2, r1, lsl #14
    25f8:	10350100 	eorsne	r0, r5, r0, lsl #2
    25fc:	02160000 	andseq	r0, r6, #0
	...
    2608:	00b00000 	adcseq	r0, r0, r0
    260c:	0b4b0000 	bleq	12c2614 <_flash_swap_addr+0x1282e14>
    2610:	04020000 	streq	r0, [r2], #-0
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (void *)_port_switch_from_isr;
    2614:	746e6905 	strbtvc	r6, [lr], #-2309	; 0xfffff6fb
    2618:	102e0300 	eorne	r0, lr, r0, lsl #6
    261c:	d4030000 	strle	r0, [r3], #-0
    }
#endif

    /* Note, returning without unlocking is intentional, this is done in
       order to keep the rest of the context switching atomic.*/
    return;
    2620:	0000003b 	andeq	r0, r0, fp, lsr r0
#endif
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ctxp->pc = (void *)_port_exit_from_isr;
    2624:	ed070404 	cfstrs	mvf0, [r7, #-16]
    2628:	04000001 	streq	r0, [r0], #-1
    262c:	01ba0601 			; <UNDEFINED> instruction: 0x01ba0601

    /* Note, returning without unlocking is intentional, this is done in
       order to keep the rest of the context switching atomic.*/
    return;
  }
  port_unlock_from_isr();
    2630:	33030000 	movwcc	r0, #12288	; 0x3000
    2634:	0400000a 	streq	r0, [r0], #-10
}
    2638:	0000542a 	andeq	r5, r0, sl, lsr #8
    263c:	08010400 	stmdaeq	r1, {sl}
__attribute__((naked))
#endif
void _port_switch_from_isr(void) {

  dbg_check_lock();
  chSchDoReschedule();
    2640:	000001b8 			; <UNDEFINED> instruction: 0x000001b8
  dbg_check_unlock();
  asm volatile ("_port_exit_from_isr:" : : : "memory");
#if !CORTEX_SIMPLIFIED_PRIORITY || defined(__DOXYGEN__)
  asm volatile ("svc     #0");
    2644:	31050204 	tstcc	r5, r4, lsl #4
    2648:	04000000 	streq	r0, [r0], #-0
    264c:	026a0702 	rsbeq	r0, sl, #524288	; 0x80000
 * @param[in] otp       the thread to be switched out
 */
#if !defined(__DOXYGEN__)
__attribute__((naked))
#endif
void _port_switch(Thread *ntp, Thread *otp) {
    2650:	00030000 	andeq	r0, r3, r0

  asm volatile ("push    {r4, r5, r6, r7, r8, r9, r10, r11, lr}"
    2654:	04000003 	streq	r0, [r0], #-3
                : : : "memory");
#if CORTEX_USE_FPU
  asm volatile ("vpush   {s16-s31}" : : : "memory");
#endif

  asm volatile ("str     sp, [%1, #12]                          \n\t"
    2658:	0000744f 	andeq	r7, r0, pc, asr #8
    265c:	05040400 	streq	r0, [r4, #-1024]	; 0xfffffc00
                "ldr     sp, [%0, #12]" : : "r" (ntp), "r" (otp));

#if CORTEX_USE_FPU
  asm volatile ("vpop    {s16-s31}" : : : "memory");
#endif
  asm volatile ("pop     {r4, r5, r6, r7, r8, r9, r10, r11, pc}"
    2660:	000000f7 	strdeq	r0, [r0], -r7
    2664:	0002ff03 	andeq	pc, r2, r3, lsl #30
    2668:	86500400 	ldrbhi	r0, [r0], -r0, lsl #8
    266c:	04000000 	streq	r0, [r0], #-0
 * @details If the work function returns @p chThdExit() is automatically
 *          invoked.
 */
void _port_thread_start(void) {

  chSysUnlock();
    2670:	01e80704 	mvneq	r0, r4, lsl #14
    2674:	08040000 	stmdaeq	r4, {}	; <UNPREDICTABLE>
  asm volatile ("mov     r0, r5                                 \n\t"
    2678:	0000f205 	andeq	pc, r0, r5, lsl #4
    267c:	07080400 	streq	r0, [r8, -r0, lsl #8]
                "blx     r4                                     \n\t"
                "bl      chThdExit");
}
    2680:	000001e3 	andeq	r0, r0, r3, ror #3
    2684:	000d6203 	andeq	r6, sp, r3, lsl #4
    2688:	49280500 	stmdbmi	r8!, {r8, sl}
    268c:	03000000 	movweq	r0, #0
 * @note    The parameters are not tested for correctness.
 *
 * @param[in] n         the interrupt number
 * @param[in] prio      the interrupt priority mask
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {
    2690:	00000d18 	andeq	r0, r0, r8, lsl sp
    2694:	00492905 	subeq	r2, r9, r5, lsl #18
  unsigned sh = (n & 3) << 3;
    2698:	d2030000 	andle	r0, r3, #0
    269c:	0500000d 	streq	r0, [r0, #-13]
    26a0:	0000492a 	andeq	r4, r0, sl, lsr #18

  NVIC_IPR(n >> 2) = (NVIC_IPR(n >> 2) & ~(0xFF << sh)) | (prio << sh);
    26a4:	0d0e0300 	stceq	3, cr0, [lr, #-0]
    26a8:	2b050000 	blcs	1426b0 <_flash_swap_addr+0x102eb0>
    26ac:	00000049 	andeq	r0, r0, r9, asr #32
    26b0:	000de103 	andeq	lr, sp, r3, lsl #2
    26b4:	7b2c0500 	blvc	b03abc <_flash_swap_addr+0xac42bc>
    26b8:	03000000 	movweq	r0, #0
    26bc:	0000041f 	andeq	r0, r0, pc, lsl r4
    26c0:	00692d05 	rsbeq	r2, r9, r5, lsl #26
    26c4:	76030000 	strvc	r0, [r3], -r0
    26c8:	0500000d 	streq	r0, [r0, #-13]
    26cc:	00007b2f 	andeq	r7, r0, pc, lsr #22
    26d0:	027d0300 	rsbseq	r0, sp, #0, 6
    26d4:	31050000 	mrscc	r0, (UNDEF: 5)
    26d8:	0000007b 	andeq	r0, r0, fp, ror r0
    26dc:	000e1b03 	andeq	r1, lr, r3, lsl #22
    26e0:	fe230600 	cdp2	6, 2, cr0, cr3, cr0, {0}
    26e4:	05000000 	streq	r0, [r0, #-0]
    26e8:	00000e1b 	andeq	r0, r0, fp, lsl lr
  NVIC_ICPR(n >> 5) = 1 << (n & 0x1F);
    26ec:	23570748 	cmpcs	r7, #72, 14	; 0x1200000
    26f0:	06000002 	streq	r0, [r0], -r2
    26f4:	00001157 	andeq	r1, r0, r7, asr r1
    26f8:	02485807 	subeq	r5, r8, #458752	; 0x70000
    26fc:	23020000 	movwcs	r0, #8192	; 0x2000
    2700:	0dda0600 	ldcleq	6, cr0, [sl]
    2704:	5a070000 	bpl	1c270c <_flash_swap_addr+0x182f0c>
    2708:	00000248 	andeq	r0, r0, r8, asr #4
    270c:	06042302 	streq	r2, [r4], -r2, lsl #6
  NVIC_ISER(n >> 5) = 1 << (n & 0x1F);
    2710:	00000ced 	andeq	r0, r0, sp, ror #25
    2714:	00c75c07 	sbceq	r5, r7, r7, lsl #24
    2718:	23020000 	movwcs	r0, #8192	; 0x2000
    271c:	0ebc0608 	cdpeq	6, 11, cr0, cr12, cr8, {0}
    2720:	5d070000 	stcpl	0, cr0, [r7, #-0]
    2724:	00000316 	andeq	r0, r0, r6, lsl r3
    2728:	060c2302 	streq	r2, [ip], -r2, lsl #6
    272c:	00000d21 	andeq	r0, r0, r1, lsr #26
}
    2730:	02485f07 	subeq	r5, r8, #7, 30
    2734:	23020000 	movwcs	r0, #8192	; 0x2000
    2738:	0d980610 	ldceq	6, cr0, [r8, #64]	; 0x40
    273c:	60070000 	andvs	r0, r7, r0
 * @brief   Disables an interrupt handler.
 * @note    The parameters are not tested for correctness.
 *
 * @param[in] n         the interrupt number
 */
void nvicDisableVector(uint32_t n) {
    2740:	00000248 	andeq	r0, r0, r8, asr #4
    2744:	06142302 	ldreq	r2, [r4], -r2, lsl #6
  unsigned sh = (n & 3) << 3;
    2748:	00000e9b 	muleq	r0, fp, lr
    274c:	04f06707 	ldrbteq	r6, [r0], #1799	; 0x707
    2750:	23020000 	movwcs	r0, #8192	; 0x2000

  NVIC_ICER(n >> 5) = 1 << (n & 0x1F);
    2754:	0df30618 	ldcleq	6, cr0, [r3, #96]!	; 0x60
    2758:	72070000 	andvc	r0, r7, #0
    275c:	000000a6 	andeq	r0, r0, r6, lsr #1
    2760:	061c2302 	ldreq	r2, [ip], -r2, lsl #6
    2764:	00000e13 	andeq	r0, r0, r3, lsl lr
    2768:	009b7607 	addseq	r7, fp, r7, lsl #12
    276c:	23020000 	movwcs	r0, #8192	; 0x2000
    2770:	0e7d061d 	mrceq	6, 3, r0, cr13, cr13, {0}
    2774:	7b070000 	blvc	1c277c <_flash_swap_addr+0x182f7c>
  NVIC_IPR(n >> 2) = NVIC_IPR(n >> 2) & ~(0xFF << sh);
    2778:	000000b1 	strheq	r0, [r0], -r1
    277c:	061e2302 	ldreq	r2, [lr], -r2, lsl #6
    2780:	00000dfb 	strdeq	r0, [r0], -fp
    2784:	00bc8107 	adcseq	r8, ip, r7, lsl #2
    2788:	23020000 	movwcs	r0, #8192	; 0x2000
    278c:	0e5d061f 	mrceq	6, 2, r0, cr13, cr15, {0}
    2790:	88070000 	stmdahi	r7, {}	; <UNPREDICTABLE>
    2794:	000003fb 	strdeq	r0, [r0], -fp
    2798:	07202302 	streq	r2, [r0, -r2, lsl #6]!
    279c:	00755f70 	rsbseq	r5, r5, r0, ror pc
    27a0:	04bbad07 	ldrteq	sl, [fp], #3335	; 0xd07
    27a4:	23020000 	movwcs	r0, #8192	; 0x2000
    27a8:	0ec20624 	cdpeq	6, 12, cr0, cr2, cr4, {1}
    27ac:	b2070000 	andlt	r0, r7, #0
    27b0:	00000270 	andeq	r0, r0, r0, ror r2
}
    27b4:	06282302 	strteq	r2, [r8], -r2, lsl #6
    27b8:	00000e6b 	andeq	r0, r0, fp, ror #28
    27bc:	024eb807 	subeq	fp, lr, #458752	; 0x70000
 * @note    The parameters are not tested for correctness.
 *
 * @param[in] handler   the system handler number
 * @param[in] prio      the system handler priority mask
 */
void nvicSetSystemHandlerPriority(uint32_t handler, uint32_t prio) {
    27c0:	23020000 	movwcs	r0, #8192	; 0x2000
    27c4:	0c8e062c 	stceq	6, cr0, [lr], {44}	; 0x2c
  unsigned sh = (handler & 3) * 8;
    27c8:	bc070000 	stclt	0, cr0, [r7], {-0}
    27cc:	000000d2 	ldrdeq	r0, [r0], -r2
    27d0:	06342302 	ldrteq	r2, [r4], -r2, lsl #6

  SCB_SHPR(handler >> 2) = (SCB_SHPR(handler >> 2) &
    27d4:	00000e22 	andeq	r0, r0, r2, lsr #28
    27d8:	00ddc207 	sbcseq	ip, sp, r7, lsl #4
    27dc:	23020000 	movwcs	r0, #8192	; 0x2000
    27e0:	0de90638 	stcleq	6, cr0, [r9, #224]!	; 0xe0
    27e4:	c9070000 	stmdbgt	r7, {}	; <UNPREDICTABLE>
    27e8:	00000502 	andeq	r0, r0, r2, lsl #10
    27ec:	063c2302 	ldrteq	r2, [ip], -r2, lsl #6
    27f0:	00000e49 	andeq	r0, r0, r9, asr #28
    27f4:	00c7cd07 	sbceq	ip, r7, r7, lsl #26
                           ~(0xFF << sh)) | (prio << sh);
    27f8:	23020000 	movwcs	r0, #8192	; 0x2000
    27fc:	0cfe0640 	ldcleq	6, cr0, [lr], #256	; 0x100
    2800:	d3070000 	movwle	r0, #28672	; 0x7000
    2804:	00000286 	andeq	r0, r0, r6, lsl #5
    2808:	00442302 	subeq	r2, r4, r2, lsl #6
    280c:	5a060808 	bpl	184834 <_flash_swap_addr+0x145034>
    2810:	00000248 	andeq	r0, r0, r8, asr #4
 * @param[in] prio      the system handler priority mask
 */
void nvicSetSystemHandlerPriority(uint32_t handler, uint32_t prio) {
  unsigned sh = (handler & 3) * 8;

  SCB_SHPR(handler >> 2) = (SCB_SHPR(handler >> 2) &
    2814:	00115706 	andseq	r5, r1, r6, lsl #14
    2818:	485b0600 	ldmdami	fp, {r9, sl}^
                           ~(0xFF << sh)) | (prio << sh);
}
    281c:	02000002 	andeq	r0, r0, #2
#define _CHINLINE_H_

/* If the performance code path has been chosen then all the following
   functions are inlined into the various kernel modules.*/
#if CH_OPTIMIZE_SPEED
static INLINE void prio_insert(Thread *tp, ThreadsQueue *tqp) {
    2820:	da060023 	ble	1828b4 <_flash_swap_addr+0x1430b4>
    2824:	0600000d 	streq	r0, [r0], -sp

  Thread *cp = (Thread *)tqp;
    2828:	0002485d 	andeq	r4, r2, sp, asr r8
  do {
    cp = cp->p_next;
    282c:	04230200 	strteq	r0, [r3], #-512	; 0xfffffe00
  } while ((cp != (Thread *)tqp) && (cp->p_prio >= tp->p_prio));
    2830:	f3040900 	vmls.i8	d0, d4, d0
    2834:	03000000 	movweq	r0, #0
    2838:	00000da6 	andeq	r0, r0, r6, lsr #27
    283c:	02235f06 	eoreq	r5, r3, #6, 30
    2840:	04080000 	streq	r0, [r8], #-0
  tp->p_next = cp;
    2844:	02706406 	rsbseq	r6, r0, #100663296	; 0x6000000
    2848:	57060000 	strpl	r0, [r6, -r0]
  tp->p_prev = cp->p_prev;
    284c:	06000011 			; <UNDEFINED> instruction: 0x06000011
    2850:	00024866 	andeq	r4, r2, r6, ror #16
  tp->p_prev->p_next = cp->p_prev = tp;
    2854:	00230200 	eoreq	r0, r3, r0, lsl #4
    2858:	0d6a0300 	stcleq	3, cr0, [sl, #-0]
    285c:	69060000 	stmdbvs	r6, {}	; <UNPREDICTABLE>
    2860:	00000259 	andeq	r0, r0, r9, asr r2
}
    2864:	000d4103 	andeq	r4, sp, r3, lsl #2
    2868:	86de0800 	ldrbhi	r0, [lr], r0, lsl #16
    286c:	0a000002 	beq	287c <fifo_remove+0xc>
  tp->p_next = (Thread *)tqp;
  tp->p_prev = tqp->p_prev;
  tp->p_prev->p_next = tqp->p_prev = tp;
}

static INLINE Thread *fifo_remove(ThreadsQueue *tqp) {
    2870:	0e640b04 	vmuleq.f64	d16, d4, d4
  Thread *tp = tqp->p_next;
    2874:	08240000 	stmdaeq	r4!, {}	; <UNPREDICTABLE>
    2878:	03160105 	tsteq	r6, #1073741825	; 0x40000001

  (tqp->p_next = tp->p_next)->p_prev = (Thread *)tqp;
    287c:	720c0000 	andvc	r0, ip, #0
    2880:	18080034 	stmdane	r8, {r2, r4, r5}
    2884:	00027b01 	andeq	r7, r2, r1, lsl #22
    2888:	00230200 	eoreq	r0, r3, r0, lsl #4
  return tp;
}
    288c:	0035720c 	eorseq	r7, r5, ip, lsl #4
    2890:	7b011908 	blvc	48cb8 <_flash_swap_addr+0x94b8>
    2894:	02000002 	andeq	r0, r0, #2
    2898:	720c0423 	andvc	r0, ip, #587202560	; 0x23000000
    289c:	1a080036 	bne	20297c <_flash_swap_addr+0x1c317c>

  (tqp->p_prev = tp->p_prev)->p_next = (Thread *)tqp;
  return tp;
}

static INLINE Thread *dequeue(Thread *tp) {
    28a0:	00027b01 	andeq	r7, r2, r1, lsl #22

  tp->p_prev->p_next = tp->p_next;
    28a4:	08230200 	stmdaeq	r3!, {r9}
    28a8:	0037720c 	eorseq	r7, r7, ip, lsl #4
    28ac:	7b011b08 	blvc	494d4 <_flash_swap_addr+0x9cd4>
  tp->p_next->p_prev = tp->p_prev;
    28b0:	02000002 	andeq	r0, r0, #2
    28b4:	720c0c23 	andvc	r0, ip, #8960	; 0x2300
  return tp;
    28b8:	1c080038 	stcne	0, cr0, [r8], {56}	; 0x38
}
    28bc:	00027b01 	andeq	r7, r2, r1, lsl #22
 *
 * @param[out] mp       pointer to a @p Mutex structure
 *
 * @init
 */
void chMtxInit(Mutex *mp) {
    28c0:	10230200 	eorne	r0, r3, r0, lsl #4

  chDbgCheck(mp != NULL, "chMtxInit");

  queue_init(&mp->m_queue);
    28c4:	0039720c 	eorseq	r7, r9, ip, lsl #4
    28c8:	7b011d08 	blvc	49cf0 <_flash_swap_addr+0xa4f0>
    28cc:	02000002 	andeq	r0, r0, #2
    28d0:	720c1423 	andvc	r1, ip, #587202560	; 0x23000000
  mp->m_owner = NULL;
    28d4:	08003031 	stmdaeq	r0, {r0, r4, r5, ip, sp}
    28d8:	027b011e 	rsbseq	r0, fp, #-2147483641	; 0x80000007
}
    28dc:	23020000 	movwcs	r0, #8192	; 0x2000
 *
 * @param[in] mp        pointer to the @p Mutex structure
 *
 * @api
 */
void chMtxLock(Mutex *mp) {
    28e0:	31720c18 	cmncc	r2, r8, lsl ip
    28e4:	1f080031 	svcne	0x00080031

  chSysLock();
    28e8:	00027b01 	andeq	r7, r2, r1, lsl #22
    28ec:	1c230200 	sfmne	f0, 4, [r3], #-0

  chMtxLockS(mp);
    28f0:	00726c0c 	rsbseq	r6, r2, ip, lsl #24

  chSysUnlock();
    28f4:	7b012008 	blvc	4a91c <_flash_swap_addr+0xb11c>
    28f8:	02000002 	andeq	r0, r0, #2
}
    28fc:	0b002023 	bleq	a990 <_data_load+0x7ca0>
 *
 * @param[in] mp        pointer to the @p Mutex structure
 *
 * @sclass
 */
void chMtxLockS(Mutex *mp) {
    2900:	00000d5a 	andeq	r0, r0, sl, asr sp
    2904:	012a0804 	teqeq	sl, r4, lsl #16
  Thread *ctp = currp;
    2908:	00000333 	andeq	r0, r0, r3, lsr r3
    290c:	3331720c 	teqcc	r1, #12, 4	; 0xc0000000
    2910:	012b0800 	teqeq	fp, r0, lsl #16

  chDbgCheckClassS();
  chDbgCheck(mp != NULL, "chMtxLockS");

  /* Is the mutex already locked? */
  if (mp->m_owner != NULL) {
    2914:	00000333 	andeq	r0, r0, r3, lsr r3
    2918:	00002302 	andeq	r2, r0, r2, lsl #6
    /* Priority inheritance protocol; explores the thread-mutex dependencies
       boosting the priority of all the affected threads to equal the priority
       of the running thread requesting the mutex.*/
    Thread *tp = mp->m_owner;
    291c:	02880409 	addeq	r0, r8, #150994944	; 0x9000000
    /* Does the running thread have higher priority than the mutex
       owning thread? */
    while (tp->p_prio < ctp->p_prio) {
    2920:	54030000 	strpl	r0, [r3], #-0
      /* Make priority of thread tp match the running thread's priority.*/
      tp->p_prio = ctp->p_prio;
    2924:	0900000e 	stmdbeq	r0, {r1, r2, r3}
    2928:	0003444e 	andeq	r4, r3, lr, asr #8
      /* The following states need priority queues reordering.*/
      switch (tp->p_state) {
    292c:	4a040900 	bmi	104d34 <_flash_swap_addr+0xc5534>
    2930:	0d000003 	stceq	0, cr0, [r0, #-12]
    2934:	00035601 	andeq	r5, r3, r1, lsl #12
    2938:	02860e00 	addeq	r0, r6, #0, 28
      case THD_STATE_WTMTX:
        /* Re-enqueues the mutex owner with its new priority.*/
        prio_insert(dequeue(tp), (ThreadsQueue *)tp->p_u.wtobjp);
    293c:	03000000 	movweq	r0, #0
    2940:	00000e35 	andeq	r0, r0, r5, lsr lr
    2944:	03615309 	cmneq	r1, #603979776	; 0x24000000
    2948:	35050000 	strcc	r0, [r5, #-0]
    294c:	1400000e 	strne	r0, [r0], #-14
        tp = ((Mutex *)tp->p_u.wtobjp)->m_owner;
    2950:	03b45a09 			; <UNDEFINED> instruction: 0x03b45a09
    2954:	52060000 	andpl	r0, r6, #0
        continue;
    2958:	0900000d 	stmdbeq	r0, {r0, r2, r3}
#endif
#if CH_USE_MESSAGES && CH_USE_MESSAGES_PRIORITY
      case THD_STATE_SNDMSGQ:
#endif
        /* Re-enqueues tp with its new priority on the queue.*/
        prio_insert(dequeue(tp), (ThreadsQueue *)tp->p_u.wtobjp);
    295c:	0003b45b 	andeq	fp, r3, fp, asr r4
    2960:	00230200 	eoreq	r0, r3, r0, lsl #4
    2964:	000d4a06 	andeq	r4, sp, r6, lsl #20
    2968:	b45d0900 	ldrblt	r0, [sp], #-2304	; 0xfffff700
    296c:	02000003 	andeq	r0, r0, #3
#if CH_DBG_ENABLE_ASSERTS
        /* Prevents an assertion in chSchReadyI().*/
        tp->p_state = THD_STATE_CURRENT;
#endif
        /* Re-enqueues tp with its new priority on the ready list.*/
        chSchReadyI(dequeue(tp));
    2970:	88060423 	stmdahi	r6, {r0, r1, r5, sl}
    2974:	0900000d 	stmdbeq	r0, {r0, r2, r3}
    2978:	0000e85f 	andeq	lr, r0, pc, asr r8
    297c:	08230200 	stmdaeq	r3!, {r9}
        break;
      }
      break;
    2980:	000d9006 	andeq	r9, sp, r6
       boosting the priority of all the affected threads to equal the priority
       of the running thread requesting the mutex.*/
    Thread *tp = mp->m_owner;
    /* Does the running thread have higher priority than the mutex
       owning thread? */
    while (tp->p_prio < ctp->p_prio) {
    2984:	39600900 	stmdbcc	r0!, {r8, fp}^
    2988:	02000003 	andeq	r0, r0, #3
    298c:	76060c23 	strvc	r0, [r6], -r3, lsr #24
        break;
      }
      break;
    }
    /* Sleep on the mutex.*/
    prio_insert(ctp, &mp->m_queue);
    2990:	0900000e 	stmdbeq	r0, {r1, r2, r3}
    2994:	00028662 	andeq	r8, r2, r2, ror #12
    ctp->p_u.wtobjp = mp;
    2998:	10230200 	eorne	r0, r3, r0, lsl #4
    299c:	56040900 	strpl	r0, [r4], -r0, lsl #18
    chSchGoSleepS(THD_STATE_WTMTX);
    29a0:	08000003 	stmdaeq	r0, {r0, r1}
    29a4:	fb6c0910 	blx	1b04dee <_flash_swap_addr+0x1ac55ee>
    chDbgAssert(mp->m_owner == ctp, "chMtxLockS(), #1", "not owner");
    chDbgAssert(ctp->p_mtxlist == mp, "chMtxLockS(), #2", "not owned");
  }
  else {
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->m_owner = ctp;
    29a8:	06000003 	streq	r0, [r0], -r3
    29ac:	00000d52 	andeq	r0, r0, r2, asr sp
    mp->m_next = ctp->p_mtxlist;
    29b0:	03b46d09 			; <UNDEFINED> instruction: 0x03b46d09
    29b4:	23020000 	movwcs	r0, #8192	; 0x2000
    ctp->p_mtxlist = mp;
    29b8:	0d4a0600 	stcleq	6, cr0, [sl, #-0]
  }
}
    29bc:	6f090000 	svcvs	0x00090000
 * @retval TRUE         if the mutex has been successfully acquired
 * @retval FALSE        if the lock attempt failed.
 *
 * @api
 */
bool_t chMtxTryLock(Mutex *mp) {
    29c0:	000003b4 			; <UNDEFINED> instruction: 0x000003b4
    29c4:	06042302 	streq	r2, [r4], -r2, lsl #6
  bool_t b;

  chSysLock();
    29c8:	00000d88 	andeq	r0, r0, r8, lsl #27
    29cc:	00e87109 	rsceq	r7, r8, r9, lsl #2

  b = chMtxTryLockS(mp);
    29d0:	23020000 	movwcs	r0, #8192	; 0x2000
    29d4:	0ea20608 	cdpeq	6, 10, cr0, cr2, cr8, {0}

  chSysUnlock();
    29d8:	72090000 	andvc	r0, r9, #0
    29dc:	000003fb 	strdeq	r0, [r0], -fp
  return b;
}
    29e0:	000c2302 	andeq	r2, ip, r2, lsl #6
    29e4:	0000e80f 	andeq	lr, r0, pc, lsl #16
    29e8:	0ead0300 	cdpeq	3, 10, cr0, cr13, cr0, {0}
    29ec:	73090000 	movwvc	r0, #36864	; 0x9000
 * @retval TRUE         if the mutex has been successfully acquired
 * @retval FALSE        if the lock attempt failed.
 *
 * @sclass
 */
bool_t chMtxTryLockS(Mutex *mp) {
    29f0:	000003ba 			; <UNDEFINED> instruction: 0x000003ba

  chDbgCheckClassS();
  chDbgCheck(mp != NULL, "chMtxTryLockS");

  if (mp->m_owner != NULL)
    29f4:	570a1c08 	strpl	r1, [sl, -r8, lsl #24]
    29f8:	00000468 	andeq	r0, r0, r8, ror #8
    return FALSE;
    29fc:	000e2d06 	andeq	r2, lr, r6, lsl #26
    2a00:	4e580a00 	vnmlsmi.f32	s1, s16, s0
  mp->m_owner = currp;
    2a04:	02000002 	andeq	r0, r0, #2
    2a08:	05060023 	streq	r0, [r6, #-35]	; 0xffffffdd
    2a0c:	0a00000e 	beq	2a4c <chMtxUnlock+0xc>
  mp->m_next = currp->p_mtxlist;
    2a10:	0000c759 	andeq	ip, r0, r9, asr r7
    2a14:	08230200 	stmdaeq	r3!, {r9}
    2a18:	000da006 	andeq	sl, sp, r6
    2a1c:	165b0a00 	ldrbne	r0, [fp], -r0, lsl #20
  currp->p_mtxlist = mp;
    2a20:	02000003 	andeq	r0, r0, #3
    2a24:	39060c23 	stmdbcc	r6, {r0, r1, r5, sl, fp}
    2a28:	0a00000d 	beq	2a64 <chMtxUnlock+0x24>
    2a2c:	0002485e 	andeq	r4, r2, lr, asr r8
  return TRUE;
    2a30:	10230200 	eorne	r0, r3, r0, lsl #4
}
    2a34:	000dbd06 	andeq	fp, sp, r6, lsl #26
    2a38:	485f0a00 	ldmdami	pc, {r9, fp}^	; <UNPREDICTABLE>
    2a3c:	02000002 	andeq	r0, r0, #2
 *
 * @return              A pointer to the unlocked mutex.
 *
 * @api
 */
Mutex *chMtxUnlock(void) {
    2a40:	b3061423 	movwlt	r1, #25635	; 0x6423
  Thread *ctp = currp;
    2a44:	0a00000d 	beq	2a80 <chMtxUnlock+0x40>
    2a48:	00024862 	andeq	r4, r2, r2, ror #16
    2a4c:	18230200 	stmdane	r3!, {r9}
  Mutex *ump, *mp;

  chSysLock();
    2a50:	0e840300 	cdpeq	3, 8, cr0, cr4, cr0, {0}
    2a54:	640a0000 	strvs	r0, [sl], #-0
  chDbgAssert(ctp->p_mtxlist->m_owner == ctp,
              "chMtxUnlock(), #2",
              "ownership failure");
  /* Removes the top Mutex from the Thread's owned mutexes list and marks it
     as not owned.*/
  ump = ctp->p_mtxlist;
    2a58:	0000040b 	andeq	r0, r0, fp, lsl #8
    2a5c:	000d8205 	andeq	r8, sp, r5, lsl #4
  ctp->p_mtxlist = ump->m_next;
    2a60:	250b1000 	strcs	r1, [fp, #-0]
    2a64:	000004aa 	andeq	r0, r0, sl, lsr #9
  /* If a thread is waiting on the mutex then the fun part begins.*/
  if (chMtxQueueNotEmptyS(ump)) {
    2a68:	000d0606 	andeq	r0, sp, r6, lsl #12
    2a6c:	4e260b00 	vmulmi.f64	d0, d6, d0
    Thread *tp;

    /* Recalculates the optimal thread priority by scanning the owned
       mutexes list.*/
    tprio_t newprio = ctp->p_realprio;
    2a70:	02000002 	andeq	r0, r0, #2
    2a74:	b4060023 	strlt	r0, [r6], #-35	; 0xffffffdd
    mp = ctp->p_mtxlist;
    2a78:	0b00000e 	bleq	2ab8 <chMtxUnlock+0x78>
    while (mp != NULL) {
    2a7c:	00024828 	andeq	r4, r2, r8, lsr #16
      /* If the highest priority thread waiting in the mutexes list has a
         greater priority than the current thread base priority then the final
         priority will have at least that priority.*/
      if (chMtxQueueNotEmptyS(mp) && (mp->m_queue.p_next->p_prio > newprio))
    2a80:	08230200 	stmdaeq	r3!, {r9}
    2a84:	000e4206 	andeq	r4, lr, r6, lsl #4
    2a88:	aa2a0b00 	bge	a85690 <_flash_swap_addr+0xa45e90>
    2a8c:	02000004 	andeq	r0, r0, #4
    2a90:	09000c23 	stmdbeq	r0, {r0, r1, r5, sl, fp}
        newprio = mp->m_queue.p_next->p_prio;
    2a94:	00047304 	andeq	r7, r4, r4, lsl #6
    2a98:	0d820300 	stceq	3, cr0, [r2]
      mp = mp->m_next;
    2a9c:	2c0b0000 	stccs	0, cr0, [fp], {-0}
    2aa0:	00000473 	andeq	r0, r0, r3, ror r4

    /* Recalculates the optimal thread priority by scanning the owned
       mutexes list.*/
    tprio_t newprio = ctp->p_realprio;
    mp = ctp->p_mtxlist;
    while (mp != NULL) {
    2aa4:	8f070410 	svchi	0x00070410
        newprio = mp->m_queue.p_next->p_prio;
      mp = mp->m_next;
    }
    /* Assigns to the current thread the highest priority among all the
       waiting threads.*/
    ctp->p_prio = newprio;
    2aa8:	000004f0 	strdeq	r0, [r0], -r0	; <UNPREDICTABLE>
    2aac:	000c9411 	andeq	r9, ip, r1, lsl r4
    /* Awakens the highest priority thread waiting for the unlocked mutex and
       assigns the mutex to it.*/
    tp = fifo_remove(&ump->m_queue);
    2ab0:	d2960700 	addsle	r0, r6, #0, 14
    2ab4:	11000000 	mrsne	r0, (UNDEF: 0)
    ump->m_owner = tp;
    2ab8:	00000cd9 	ldrdeq	r0, [r0], -r9
    2abc:	00d29d07 	sbcseq	r9, r2, r7, lsl #26
    ump->m_next = tp->p_mtxlist;
    2ac0:	94110000 	ldrls	r0, [r1], #-0
    2ac4:	0700000e 	streq	r0, [r0, -lr]
    tp->p_mtxlist = ump;
    2ac8:	000286a4 	andeq	r8, r2, r4, lsr #13
    chSchWakeupS(tp, RDY_OK);
    2acc:	0e0c1100 	adfeqe	f1, f4, f0
    2ad0:	ab070000 	blge	1c2ad8 <_flash_swap_addr+0x1832d8>
    2ad4:	000000dd 	ldrdeq	r0, [r0], -sp
  }
  else
    ump->m_owner = NULL;
    2ad8:	f6040900 			; <UNDEFINED> instruction: 0xf6040900
    2adc:	12000004 	andne	r0, r0, #4
  chSysUnlock();
    2ae0:	000004fb 	strdeq	r0, [r0], -fp
    2ae4:	c1080104 	tstgt	r8, r4, lsl #2
  return ump;
    2ae8:	09000001 	stmdbeq	r0, {r0}
}
    2aec:	0004b004 	andeq	fp, r4, r4
 *
 * @return              A pointer to the unlocked mutex.
 *
 * @sclass
 */
Mutex *chMtxUnlockS(void) {
    2af0:	11270300 	teqne	r7, r0, lsl #6
  Thread *ctp = currp;
    2af4:	de070000 	cdple	0, 0, cr0, cr7, cr0, {0}
    2af8:	00000513 	andeq	r0, r0, r3, lsl r5
    2afc:	05190409 	ldreq	r0, [r9, #-1033]	; 0xfffffbf7
              "chMtxUnlockS(), #2",
              "ownership failure");

  /* Removes the top Mutex from the owned mutexes list and marks it as not
     owned.*/
  ump = ctp->p_mtxlist;
    2b00:	01130000 	tsteq	r3, r0
    2b04:	000000d2 	ldrdeq	r0, [r0], -r2
  ctp->p_mtxlist = ump->m_next;
    2b08:	00000529 	andeq	r0, r0, r9, lsr #10
    2b0c:	0002860e 	andeq	r8, r2, lr, lsl #12
  /* If a thread is waiting on the mutex then the fun part begins.*/
  if (chMtxQueueNotEmptyS(ump)) {
    2b10:	d9140000 	ldmdble	r4, {}	; <UNPREDICTABLE>
    2b14:	01000010 	tsteq	r0, r0, lsl r0
    Thread *tp;

    /* Recalculates the optimal thread priority by scanning the owned
       mutexes list.*/
    tprio_t newprio = ctp->p_realprio;
    2b18:	19e00149 	stmibne	r0!, {r0, r3, r6, r8}^
    2b1c:	19f80000 	ldmibne	r8!, {}^	; <UNPREDICTABLE>
    mp = ctp->p_mtxlist;
    2b20:	0cf40000 	ldcleq	0, cr0, [r4]
    while (mp != NULL) {
    2b24:	055d0000 	ldrbeq	r0, [sp, #-0]
      /* If the highest priority thread waiting in the mutexes list has a
         greater priority than the current thread base priority then the final
         priority will have at least that priority.*/
      if (chMtxQueueNotEmptyS(mp) && (mp->m_queue.p_next->p_prio > newprio))
    2b28:	74150000 	ldrvc	r0, [r5], #-0
    2b2c:	49010070 	stmdbmi	r1, {r4, r5, r6}
    2b30:	00000248 	andeq	r0, r0, r8, asr #4
    2b34:	157c9102 	ldrbne	r9, [ip, #-258]!	; 0xfffffefe
    2b38:	00706c74 	rsbseq	r6, r0, r4, ror ip
        newprio = mp->m_queue.p_next->p_prio;
    2b3c:	055d4901 	ldrbeq	r4, [sp, #-2305]	; 0xfffff6ff
    2b40:	91020000 	mrsls	r0, (UNDEF: 2)
      mp = mp->m_next;
    2b44:	04090078 	streq	r0, [r9], #-120	; 0xffffff88
    2b48:	00000270 	andeq	r0, r0, r0, ror r2

    /* Recalculates the optimal thread priority by scanning the owned
       mutexes list.*/
    tprio_t newprio = ctp->p_realprio;
    mp = ctp->p_mtxlist;
    while (mp != NULL) {
    2b4c:	00107f16 	andseq	r7, r0, r6, lsl pc
         priority will have at least that priority.*/
      if (chMtxQueueNotEmptyS(mp) && (mp->m_queue.p_next->p_prio > newprio))
        newprio = mp->m_queue.p_next->p_prio;
      mp = mp->m_next;
    }
    ctp->p_prio = newprio;
    2b50:	014f0100 	mrseq	r0, (UNDEF: 95)
    2b54:	00000248 	andeq	r0, r0, r8, asr #4
    /* Awakens the highest priority thread waiting for the unlocked mutex and
       assigns the mutex to it.*/
    tp = fifo_remove(&ump->m_queue);
    2b58:	00001a00 	andeq	r1, r0, r0, lsl #20
    2b5c:	00001a1a 	andeq	r1, r0, sl, lsl sl
    ump->m_owner = tp;
    2b60:	00000d14 	andeq	r0, r0, r4, lsl sp
    2b64:	0000059b 	muleq	r0, fp, r5
    ump->m_next = tp->p_mtxlist;
    2b68:	706c7415 	rsbvc	r7, ip, r5, lsl r4
    2b6c:	5d4f0100 	stfple	f0, [pc, #-0]	; 2b74 <chMtxUnlockS+0x84>
    tp->p_mtxlist = ump;
    2b70:	02000005 	andeq	r0, r0, #5
    chSchReadyI(tp);
    2b74:	74177491 	ldrvc	r7, [r7], #-1169	; 0xfffffb6f
    2b78:	51010070 	tstpl	r1, r0, ror r0
  }
  else
    ump->m_owner = NULL;
    2b7c:	00000248 	andeq	r0, r0, r8, asr #4
    2b80:	007c9102 	rsbseq	r9, ip, r2, lsl #2
  return ump;
    2b84:	10f50118 	rscsne	r0, r5, r8, lsl r1
}
    2b88:	45020000 	strmi	r0, [r2, #-0]
    2b8c:	00024801 	andeq	r4, r2, r1, lsl #16
 *          this function does not have any overhead related to the priority
 *          inheritance mechanism.
 *
 * @api
 */
void chMtxUnlockAll(void) {
    2b90:	001a2000 	andseq	r2, sl, r0
  Thread *ctp = currp;
    2b94:	001acc00 	andseq	ip, sl, r0, lsl #24
    2b98:	000d3400 	andeq	r3, sp, r0, lsl #8
    2b9c:	0005d400 	andeq	sp, r5, r0, lsl #8

  chSysLock();
    2ba0:	70741500 	rsbsvc	r1, r4, r0, lsl #10
    2ba4:	48450200 	stmdami	r5, {r9}^
  if (ctp->p_mtxlist != NULL) {
    2ba8:	02000002 	andeq	r0, r0, #2
    2bac:	ef197c91 	svc	0x00197c91
    do {
      Mutex *ump = ctp->p_mtxlist;
    2bb0:	0200000c 	andeq	r0, r0, #12
    2bb4:	0000c745 	andeq	ip, r0, r5, asr #14
      ctp->p_mtxlist = ump->m_next;
    2bb8:	78910200 	ldmvc	r1, {r9}
    2bbc:	72011800 	andvc	r1, r1, #0, 16
      if (chMtxQueueNotEmptyS(ump)) {
    2bc0:	02000010 	andeq	r0, r0, #16
    2bc4:	02480196 	subeq	r0, r8, #-2147483611	; 0x80000025
        Thread *tp = fifo_remove(&ump->m_queue);
    2bc8:	1ad00000 	bne	ff402bd0 <_stack_start+0xdf3f2bd0>
    2bcc:	1b320000 	blne	c82bd4 <_flash_swap_addr+0xc433d4>
    2bd0:	0d540000 	ldcleq	0, cr0, [r4, #-0]
        ump->m_owner = tp;
    2bd4:	06440000 	strbeq	r0, [r4], -r0
        ump->m_next = tp->p_mtxlist;
    2bd8:	77150000 	ldrvc	r0, [r5, -r0]
    2bdc:	02007073 	andeq	r7, r0, #115	; 0x73
        tp->p_mtxlist = ump;
    2be0:	00028696 	muleq	r2, r6, r6
    2be4:	6c910200 	lfmvs	f0, 4, [r1], {0}
        chSchReadyI(tp);
    2be8:	0011a019 	andseq	sl, r1, r9, lsl r0
    2bec:	30960200 	addscc	r0, r6, r0, lsl #4
      }
      else
        ump->m_owner = NULL;
    2bf0:	02000000 	andeq	r0, r0, #0
    2bf4:	ef196891 	svc	0x00196891
    } while (ctp->p_mtxlist != NULL);
    2bf8:	0200000c 	andeq	r0, r0, #12
    2bfc:	0000c797 	muleq	r0, r7, r7
    ctp->p_prio = ctp->p_realprio;
    2c00:	64910200 	ldrvs	r0, [r1], #512	; 0x200
    2c04:	00667015 	rsbeq	r7, r6, r5, lsl r0
    chSchRescheduleS();
    2c08:	05089702 	streq	r9, [r8, #-1794]	; 0xfffff8fe
  }
  chSysUnlock();
    2c0c:	91020000 	mrsls	r0, (UNDEF: 2)
    2c10:	72611560 	rsbvc	r1, r1, #96, 10	; 0x18000000
}
    2c14:	97020067 	strls	r0, [r2, -r7, rrx]
    2c18:	00000286 	andeq	r0, r0, r6, lsl #5
    2c1c:	17009102 	strne	r9, [r0, -r2, lsl #2]
    2c20:	02007074 	andeq	r7, r0, #116	; 0x74
    2c24:	00024899 	muleq	r2, r9, r8
    2c28:	74910200 	ldrvc	r0, [r1], #512	; 0x200
    2c2c:	bb011800 	bllt	48c34 <_flash_swap_addr+0x9434>
    2c30:	02000010 	andeq	r0, r0, #16
    2c34:	024801b4 	subeq	r0, r8, #180, 2	; 0x2d
    2c38:	1b400000 	blne	1002c40 <_flash_swap_addr+0xfc3440>
    2c3c:	1b800000 	blne	fe002c44 <_stack_start+0xddff2c44>
    2c40:	0d800000 	stceq	0, cr0, [r0]
    2c44:	06e60000 	strbteq	r0, [r6], r0
    2c48:	77150000 	ldrvc	r0, [r5, -r0]
    2c4c:	02007073 	andeq	r7, r0, #115	; 0x73
    2c50:	000286b4 			; <UNDEFINED> instruction: 0x000286b4
    2c54:	6c910200 	lfmvs	f0, 4, [r1], {0}
    2c58:	0011a019 	andseq	sl, r1, r9, lsl r0
    2c5c:	30b40200 	adcscc	r0, r4, r0, lsl #4
    2c60:	02000000 	andeq	r0, r0, #0
    2c64:	ef196891 	svc	0x00196891
    2c68:	0200000c 	andeq	r0, r0, #12
    2c6c:	0000c7b5 			; <UNDEFINED> instruction: 0x0000c7b5
    2c70:	64910200 	ldrvs	r0, [r1], #512	; 0x200
    2c74:	00667015 	rsbeq	r7, r6, r5, lsl r0
    2c78:	0508b502 	streq	fp, [r8, #-1282]	; 0xfffffafe
    2c7c:	91020000 	mrsls	r0, (UNDEF: 2)
    2c80:	72611560 	rsbvc	r1, r1, #96, 10	; 0x18000000
    2c84:	b5020067 	strlt	r0, [r2, #-103]	; 0xffffff99
    2c88:	00000286 	andeq	r0, r0, r6, lsl #5
    2c8c:	17009102 	strne	r9, [r0, -r2, lsl #2]
    2c90:	02007074 	andeq	r7, r0, #116	; 0x74
    2c94:	000248b6 			; <UNDEFINED> instruction: 0x000248b6
    2c98:	74910200 	ldrvc	r0, [r1], #512	; 0x200
    2c9c:	001b4c1a 	andseq	r4, fp, sl, lsl ip
    2ca0:	001b5400 	andseq	r5, fp, r0, lsl #8
    2ca4:	0006ce00 	andeq	ip, r6, r0, lsl #28
    2ca8:	6d741700 	ldclvs	7, cr1, [r4, #-0]
    2cac:	c0020070 	andgt	r0, r2, r0, ror r0
    2cb0:	0000007b 	andeq	r0, r0, fp, ror r0
    2cb4:	1b005301 	blne	178c0 <_data_load+0x14bd0>
    2cb8:	00001b70 	andeq	r1, r0, r0, ror fp
    2cbc:	00001b78 	andeq	r1, r0, r8, ror fp
    2cc0:	706d7417 	rsbvc	r7, sp, r7, lsl r4
    2cc4:	7bc20200 	blvc	ff0834cc <_stack_start+0xdf0734cc>
    2cc8:	01000000 	mrseq	r0, (UNDEF: 0)
    2ccc:	18000053 	stmdane	r0, {r0, r1, r4, r6}
    2cd0:	00108b01 	andseq	r8, r0, r1, lsl #22
    2cd4:	01d20200 	bicseq	r0, r2, r0, lsl #4
    2cd8:	000000c7 	andeq	r0, r0, r7, asr #1
    2cdc:	00001b80 	andeq	r1, r0, r0, lsl #23
    2ce0:	00001bfa 	strdeq	r1, [r0], -sl
    2ce4:	00000dac 	andeq	r0, r0, ip, lsr #27
    2ce8:	00000752 	andeq	r0, r0, r2, asr r7
    2cec:	00109c19 	andseq	r9, r0, r9, lsl ip
    2cf0:	c7d20200 	ldrbgt	r0, [r2, r0, lsl #4]
    2cf4:	02000000 	andeq	r0, r0, #0
    2cf8:	b31c6c91 	tstlt	ip, #37120	; 0x9100
    2cfc:	02000010 	andeq	r0, r0, #16
    2d00:	0000c7d3 	ldrdeq	ip, [r0], -r3
    2d04:	74910200 	ldrvc	r0, [r1], #512	; 0x200
    2d08:	001b861a 	andseq	r8, fp, sl, lsl r6
    2d0c:	001b8e00 	andseq	r8, fp, r0, lsl #28
    2d10:	00073a00 	andeq	r3, r7, r0, lsl #20
    2d14:	6d741700 	ldclvs	7, cr1, [r4, #-0]
    2d18:	d7020070 	smlsdxle	r2, r0, r0, r0
    2d1c:	0000007b 	andeq	r0, r0, fp, ror r0
    2d20:	1b005301 	blne	1792c <_data_load+0x14c3c>
    2d24:	00001bea 	andeq	r1, r0, sl, ror #23
    2d28:	00001bf2 	strdeq	r1, [r0], -r2
    2d2c:	706d7417 	rsbvc	r7, sp, r7, lsl r4
    2d30:	7be20200 	blvc	ff883538 <_stack_start+0xdf873538>
    2d34:	01000000 	mrseq	r0, (UNDEF: 0)
    2d38:	18000053 	stmdane	r0, {r0, r1, r4, r6}
    2d3c:	0010cd01 	andseq	ip, r0, r1, lsl #26
    2d40:	01f30200 	mvnseq	r0, r0, lsl #4
    2d44:	00000248 	andeq	r0, r0, r8, asr #4
    2d48:	00001c00 	andeq	r1, r0, r0, lsl #24
    2d4c:	00001c28 	andeq	r1, r0, r8, lsr #24
    2d50:	00000dd8 	ldrdeq	r0, [r0], -r8
    2d54:	000007af 	andeq	r0, r0, pc, lsr #15
    2d58:	00707415 	rsbseq	r7, r0, r5, lsl r4
    2d5c:	0248f302 	subeq	pc, r8, #134217728	; 0x8000000
    2d60:	91020000 	mrsls	r0, (UNDEF: 2)
    2d64:	1c061a74 	stcne	10, cr1, [r6], {116}	; 0x74
    2d68:	1c0e0000 	stcne	0, cr0, [lr], {-0}
    2d6c:	07970000 	ldreq	r0, [r7, r0]
    2d70:	74170000 	ldrvc	r0, [r7], #-0
    2d74:	0200706d 	andeq	r7, r0, #109	; 0x6d
    2d78:	00007bf5 	strdeq	r7, [r0], -r5
    2d7c:	00530100 	subseq	r0, r3, r0, lsl #2
    2d80:	001c181b 	andseq	r1, ip, fp, lsl r8
    2d84:	001c2000 	andseq	r2, ip, r0
    2d88:	6d741700 	ldclvs	7, cr1, [r4, #-0]
    2d8c:	fa020070 	blx	82f54 <_flash_swap_addr+0x43754>
    2d90:	0000007b 	andeq	r0, r0, fp, ror r0
    2d94:	00005301 	andeq	r5, r0, r1, lsl #6
    2d98:	10a4011d 	adcne	r0, r4, sp, lsl r1
    2d9c:	0a020000 	beq	82da4 <_flash_swap_addr+0x435a4>
    2da0:	1c300101 	ldfnes	f0, [r0], #-4
    2da4:	1c560000 	mrane	r0, r6, acc0
    2da8:	0e040000 	cdpeq	0, 0, cr0, cr4, cr0, {0}
    2dac:	080c0000 	stmdaeq	ip, {}	; <UNPREDICTABLE>
    2db0:	741e0000 	ldrvc	r0, [lr], #-0
    2db4:	0a020070 	beq	82f7c <_flash_swap_addr+0x4377c>
    2db8:	00024801 	andeq	r4, r2, r1, lsl #16
    2dbc:	7c910200 	lfmvc	f0, 4, [r1], {0}
    2dc0:	001c341a 	andseq	r3, ip, sl, lsl r4
    2dc4:	001c3c00 	andseq	r3, ip, r0, lsl #24
    2dc8:	0007f300 	andeq	pc, r7, r0, lsl #6
    2dcc:	6d741f00 	ldclvs	15, cr1, [r4, #-0]
    2dd0:	0c020070 	stceq	0, cr0, [r2], {112}	; 0x70
    2dd4:	00007b01 	andeq	r7, r0, r1, lsl #22
    2dd8:	00530100 	subseq	r0, r3, r0, lsl #2
    2ddc:	001c4a1b 	andseq	r4, ip, fp, lsl sl
    2de0:	001c5200 	andseq	r5, ip, r0, lsl #4
    2de4:	6d741f00 	ldclvs	15, cr1, [r4, #-0]
    2de8:	0e020070 	mcreq	0, 0, r0, cr2, cr0, {3}
    2dec:	00007b01 	andeq	r7, r0, r1, lsl #22
    2df0:	00530100 	subseq	r0, r3, r0, lsl #2
    2df4:	0c011d00 	stceq	13, cr1, [r1], {-0}
    2df8:	02000011 	andeq	r0, r0, #17
    2dfc:	6001011d 	andvs	r0, r1, sp, lsl r1
    2e00:	8400001c 	strhi	r0, [r0], #-28	; 0xffffffe4
    2e04:	2400001c 	strcs	r0, [r0], #-28	; 0xffffffe4
    2e08:	6a00000e 	bvs	2e48 <_data_load+0x158>
    2e0c:	20000008 	andcs	r0, r0, r8
    2e10:	00000e5f 	andeq	r0, r0, pc, asr lr
    2e14:	e8011d02 	stmda	r1, {r1, r8, sl, fp, ip}
    2e18:	02000000 	andeq	r0, r0, #0
    2e1c:	661a7491 			; <UNDEFINED> instruction: 0x661a7491
    2e20:	6e00001c 	mcrvs	0, 0, r0, cr0, cr12, {0}
    2e24:	5100001c 	tstpl	r0, ip, lsl r0
    2e28:	1f000008 	svcne	0x00000008
    2e2c:	00706d74 	rsbseq	r6, r0, r4, ror sp
    2e30:	7b012102 	blvc	4b240 <_flash_swap_addr+0xba40>
    2e34:	01000000 	mrseq	r0, (UNDEF: 0)
    2e38:	781b0053 	ldmdavc	fp, {r0, r1, r4, r6}
    2e3c:	8000001c 	andhi	r0, r0, ip, lsl r0
    2e40:	1f00001c 	svcne	0x0000001c
    2e44:	00706d74 	rsbseq	r6, r0, r4, ror sp
    2e48:	7b012302 	blvc	4ba58 <_flash_swap_addr+0xc258>
    2e4c:	01000000 	mrseq	r0, (UNDEF: 0)
    2e50:	1d000053 	stcne	0, cr0, [r0, #-332]	; 0xfffffeb4
    2e54:	0010e501 	andseq	lr, r0, r1, lsl #10
    2e58:	012e0200 	teqeq	lr, r0, lsl #4
    2e5c:	001c9001 	andseq	r9, ip, r1
    2e60:	001cca00 	andseq	ip, ip, r0, lsl #20
    2e64:	000e5000 	andeq	r5, lr, r0
    2e68:	0008c800 	andeq	ip, r8, r0, lsl #16
    2e6c:	0e5f2000 	cdpeq	0, 5, cr2, cr15, cr0, {0}
    2e70:	2e020000 	cdpcs	0, 0, cr0, cr2, cr0, {0}
    2e74:	0000e801 	andeq	lr, r0, r1, lsl #16
    2e78:	74910200 	ldrvc	r0, [r1], #512	; 0x200
    2e7c:	001c961a 	andseq	r9, ip, sl, lsl r6
    2e80:	001c9e00 	andseq	r9, ip, r0, lsl #28
    2e84:	0008af00 	andeq	sl, r8, r0, lsl #30
    2e88:	6d741f00 	ldclvs	15, cr1, [r4, #-0]
    2e8c:	30020070 	andcc	r0, r2, r0, ror r0
    2e90:	00007b01 	andeq	r7, r0, r1, lsl #22
    2e94:	00530100 	subseq	r0, r3, r0, lsl #2
    2e98:	001cbe1b 	andseq	fp, ip, fp, lsl lr
    2e9c:	001cc600 	andseq	ip, ip, r0, lsl #12
    2ea0:	6d741f00 	ldclvs	15, cr1, [r4, #-0]
    2ea4:	33020070 	movwcc	r0, #8304	; 0x2070
    2ea8:	00007b01 	andeq	r7, r0, r1, lsl #22
    2eac:	00530100 	subseq	r0, r3, r0, lsl #2
    2eb0:	17011d00 	strne	r1, [r1, -r0, lsl #26]
    2eb4:	02000011 	andeq	r0, r0, #17
    2eb8:	d001013d 	andle	r0, r1, sp, lsr r1
    2ebc:	0400001c 	streq	r0, [r0], #-28	; 0xffffffe4
    2ec0:	7c00001d 	stcvc	0, cr0, [r0], {29}
    2ec4:	1700000e 	strne	r0, [r0, -lr]
    2ec8:	1a000009 	bne	2ef4 <_data_load+0x204>
    2ecc:	00001cd2 	ldrdeq	r1, [r0], -r2
    2ed0:	00001cda 	ldrdeq	r1, [r0], -sl
    2ed4:	000008fe 	strdeq	r0, [r0], -lr
    2ed8:	706d741f 	rsbvc	r7, sp, pc, lsl r4
    2edc:	013f0200 	teqeq	pc, r0, lsl #4
    2ee0:	0000007b 	andeq	r0, r0, fp, ror r0
    2ee4:	1b005301 	blne	17af0 <_data_load+0x14e00>
    2ee8:	00001cfa 	strdeq	r1, [r0], -sl
    2eec:	00001d02 	andeq	r1, r0, r2, lsl #26
    2ef0:	706d741f 	rsbvc	r7, sp, pc, lsl r4
    2ef4:	01410200 	mrseq	r0, (UNDEF: 97)
    2ef8:	0000007b 	andeq	r0, r0, fp, ror r0
    2efc:	00005301 	andeq	r5, r0, r1, lsl #6
    2f00:	1068011d 	rsbne	r0, r8, sp, lsl r1
    2f04:	52020000 	andpl	r0, r2, #0
    2f08:	1d100101 	ldfnes	f0, [r0, #-4]
    2f0c:	1d280000 	stcne	0, cr0, [r8, #-0]
    2f10:	0e9c0000 	cdpeq	0, 9, cr0, cr12, cr0, {0}
    2f14:	09590000 	ldmdbeq	r9, {}^	; <UNPREDICTABLE>
    2f18:	6d1e0000 	ldcvs	0, cr0, [lr, #-0]
    2f1c:	02006773 	andeq	r6, r0, #30146560	; 0x1cc0000
    2f20:	00d20152 	sbcseq	r0, r2, r2, asr r1
    2f24:	91020000 	mrsls	r0, (UNDEF: 2)
    2f28:	1d161b74 	vldrne	d1, [r6, #-464]	; 0xfffffe30
    2f2c:	1d1e0000 	ldcne	0, cr0, [lr, #-0]
    2f30:	741f0000 	ldrvc	r0, [pc], #-0	; 2f38 <_data_load+0x248>
    2f34:	0200706d 	andeq	r7, r0, #109	; 0x6d
    2f38:	007b0154 	rsbseq	r0, fp, r4, asr r1
    2f3c:	53010000 	movwpl	r0, #4096	; 0x1000
    2f40:	011d0000 	tsteq	sp, r0
    2f44:	0000105d 	andeq	r1, r0, sp, asr r0
    2f48:	01016702 	tsteq	r1, r2, lsl #14
    2f4c:	00001d30 	andeq	r1, r0, r0, lsr sp
    2f50:	00001d98 	muleq	r0, r8, sp
    2f54:	00000ec8 	andeq	r0, r0, r8, asr #29
    2f58:	00000991 	muleq	r0, r1, r9
    2f5c:	67736d1e 			; <UNDEFINED> instruction: 0x67736d1e
    2f60:	01670200 	cmneq	r7, r0, lsl #4
    2f64:	000000d2 	ldrdeq	r0, [r0], -r2
    2f68:	1f6c9102 	svcne	0x006c9102
    2f6c:	02007074 	andeq	r7, r0, #116	; 0x74
    2f70:	02480168 	subeq	r0, r8, #104, 2
    2f74:	91020000 	mrsls	r0, (UNDEF: 2)
    2f78:	01210074 	teqeq	r1, r4, ror r0
    2f7c:	00001102 	andeq	r1, r0, r2, lsl #2
    2f80:	01019d02 	tsteq	r1, r2, lsl #26
    2f84:	000000d2 	ldrdeq	r0, [r0], -r2
    2f88:	00001da0 	andeq	r1, r0, r0, lsr #27
    2f8c:	00001df2 	strdeq	r1, [r0], -r2
    2f90:	00000ef4 	strdeq	r0, [r0], -r4
    2f94:	00000a01 	andeq	r0, r0, r1, lsl #20
    2f98:	0070741e 	rsbseq	r7, r0, lr, lsl r4
    2f9c:	48019d02 	stmdami	r1, {r1, r8, sl, fp, ip, pc}
    2fa0:	02000002 	andeq	r0, r0, #2
    2fa4:	6d1f6c91 	ldcvs	12, cr6, [pc, #-580]	; 2d68 <_data_load+0x78>
    2fa8:	02006773 	andeq	r6, r0, #30146560	; 0x1cc0000
    2fac:	00d2019e 	smullseq	r0, r2, lr, r1
    2fb0:	91020000 	mrsls	r0, (UNDEF: 2)
    2fb4:	1da61a74 	stcne	10, cr1, [r6, #464]!	; 0x1d0
    2fb8:	1dae0000 	stcne	0, cr0, [lr]
    2fbc:	09e80000 	stmibeq	r8!, {}^	; <UNPREDICTABLE>
    2fc0:	741f0000 	ldrvc	r0, [pc], #-0	; 2fc8 <_data_load+0x2d8>
    2fc4:	0200706d 	andeq	r7, r0, #109	; 0x6d
    2fc8:	007b01a2 	rsbseq	r0, fp, r2, lsr #3
    2fcc:	53010000 	movwpl	r0, #4096	; 0x1000
    2fd0:	1ddc1b00 	vldrne	d17, [ip]
    2fd4:	1de40000 	stclne	0, cr0, [r4]
    2fd8:	741f0000 	ldrvc	r0, [pc], #-0	; 2fe0 <_data_load+0x2f0>
    2fdc:	0200706d 	andeq	r7, r0, #109	; 0x6d
    2fe0:	007b01ac 	rsbseq	r0, fp, ip, lsr #3
    2fe4:	53010000 	movwpl	r0, #4096	; 0x1000
    2fe8:	9b220000 	blls	882ff0 <_flash_swap_addr+0x8437f0>
    2fec:	0900000c 	stmdbeq	r0, {r2, r3}
    2ff0:	000400d1 	ldrdeq	r0, [r4], -r1
    2ff4:	22010100 	andcs	r0, r1, #0, 2
    2ff8:	00000e8e 	andeq	r0, r0, lr, lsl #29
    2ffc:	0468680a 	strbteq	r6, [r8], #-2058	; 0xfffff7f6
    3000:	01010000 	mrseq	r0, (UNDEF: 1)
    3004:	000c9b22 	andeq	r9, ip, r2, lsr #22
    3008:	00d10900 	sbcseq	r0, r1, r0, lsl #18
    300c:	01000004 	tsteq	r0, r4
    3010:	0e8e2201 	cdpeq	2, 8, cr2, cr14, cr1, {0}
    3014:	680a0000 	stmdavs	sl, {}	; <UNPREDICTABLE>
    3018:	00000468 	andeq	r0, r0, r8, ror #8
    301c:	53000101 	movwpl	r0, #257	; 0x101
    3020:	02000007 	andeq	r0, r0, #7
    3024:	000bb000 	andeq	fp, fp, r0
    3028:	87010400 	strhi	r0, [r1, -r0, lsl #8]
    302c:	01000002 	tsteq	r0, r2
    3030:	000011dc 	ldrdeq	r1, [r0], -ip
    3034:	00000216 	andeq	r0, r0, r6, lsl r2
	...
    3040:	00000128 	andeq	r0, r0, r8, lsr #2
    3044:	00000ea6 	andeq	r0, r0, r6, lsr #29
    3048:	69050402 	stmdbvs	r5, {r1, sl}
    304c:	0300746e 	movweq	r7, #1134	; 0x46e
    3050:	0000102e 	andeq	r1, r0, lr, lsr #32
    3054:	003bd402 	eorseq	sp, fp, r2, lsl #8
    3058:	04040000 	streq	r0, [r4], #-0
    305c:	0001ed07 	andeq	lr, r1, r7, lsl #26
    3060:	06010400 	streq	r0, [r1], -r0, lsl #8
    3064:	000001ba 			; <UNDEFINED> instruction: 0x000001ba
    3068:	000a3303 	andeq	r3, sl, r3, lsl #6
    306c:	542a0300 	strtpl	r0, [sl], #-768	; 0xfffffd00
    3070:	04000000 	streq	r0, [r0], #-0
    3074:	01b80801 			; <UNDEFINED> instruction: 0x01b80801
    3078:	02040000 	andeq	r0, r4, #0
    307c:	00003105 	andeq	r3, r0, r5, lsl #2
    3080:	07020400 	streq	r0, [r2, -r0, lsl #8]
    3084:	0000026a 	andeq	r0, r0, sl, ror #4
    3088:	00030003 	andeq	r0, r3, r3
    308c:	744f0300 	strbvc	r0, [pc], #-768	; 3094 <_data_load+0x3a4>
    3090:	04000000 	streq	r0, [r0], #-0
    3094:	00f70504 	rscseq	r0, r7, r4, lsl #10
    3098:	ff030000 			; <UNDEFINED> instruction: 0xff030000
    309c:	03000002 	movweq	r0, #2
    30a0:	00008650 	andeq	r8, r0, r0, asr r6
    30a4:	07040400 	streq	r0, [r4, -r0, lsl #8]
    30a8:	000001e8 	andeq	r0, r0, r8, ror #3
    30ac:	f2050804 	vadd.i8	d0, d5, d4
    30b0:	03000000 	movweq	r0, #0
    30b4:	0000001f 	andeq	r0, r0, pc, lsl r0
    30b8:	009f7803 	addseq	r7, pc, r3, lsl #16
    30bc:	08040000 	stmdaeq	r4, {}	; <UNPREDICTABLE>
    30c0:	0001e307 	andeq	lr, r1, r7, lsl #6
    30c4:	0d620300 	stcleq	3, cr0, [r2, #-0]
    30c8:	28040000 	stmdacs	r4, {}	; <UNPREDICTABLE>
    30cc:	00000049 	andeq	r0, r0, r9, asr #32
    30d0:	000d1803 	andeq	r1, sp, r3, lsl #16
    30d4:	49290400 	stmdbmi	r9!, {sl}
    30d8:	03000000 	movweq	r0, #0
    30dc:	00000dd2 	ldrdeq	r0, [r0], -r2
    30e0:	00492a04 	subeq	r2, r9, r4, lsl #20
    30e4:	0e030000 	cdpeq	0, 0, cr0, cr3, cr0, {0}
    30e8:	0400000d 	streq	r0, [r0], #-13
    30ec:	0000492b 	andeq	r4, r0, fp, lsr #18
    30f0:	0de10300 	stcleq	3, cr0, [r1]
    30f4:	2c040000 	stccs	0, cr0, [r4], {-0}
    30f8:	0000007b 	andeq	r0, r0, fp, ror r0
    30fc:	00041f03 	andeq	r1, r4, r3, lsl #30
    3100:	692d0400 	pushvs	{sl}
    3104:	03000000 	movweq	r0, #0
    3108:	00000d76 	andeq	r0, r0, r6, ror sp
    310c:	007b2f04 	rsbseq	r2, fp, r4, lsl #30
    3110:	7d030000 	stcvc	0, cr0, [r3, #-0]
    3114:	04000002 	streq	r0, [r0], #-2
    3118:	00007b31 	andeq	r7, r0, r1, lsr fp
    311c:	0e1b0300 	cdpeq	3, 1, cr0, cr11, cr0, {0}
    3120:	23050000 	movwcs	r0, #20480	; 0x5000
    3124:	00000109 	andeq	r0, r0, r9, lsl #2
    3128:	000e1b05 	andeq	r1, lr, r5, lsl #22
    312c:	57064800 	strpl	r4, [r6, -r0, lsl #16]
    3130:	0000022e 	andeq	r0, r0, lr, lsr #4
    3134:	00115706 	andseq	r5, r1, r6, lsl #14
    3138:	53580600 	cmppl	r8, #0, 12
    313c:	02000002 	andeq	r0, r0, #2
    3140:	da060023 	ble	1831d4 <_flash_swap_addr+0x1439d4>
    3144:	0600000d 	streq	r0, [r0], -sp
    3148:	0002535a 	andeq	r5, r2, sl, asr r3
    314c:	04230200 	strteq	r0, [r3], #-512	; 0xfffffe00
    3150:	000ced06 	andeq	lr, ip, r6, lsl #26
    3154:	d25c0600 	subsle	r0, ip, #0, 12
    3158:	02000000 	andeq	r0, r0, #0
    315c:	bc060823 	stclt	8, cr0, [r6], {35}	; 0x23
    3160:	0600000e 	streq	r0, [r0], -lr
    3164:	00032c5d 	andeq	r2, r3, sp, asr ip
    3168:	0c230200 	sfmeq	f0, 4, [r3], #-0
    316c:	000d2106 	andeq	r2, sp, r6, lsl #2
    3170:	535f0600 	cmppl	pc, #0, 12
    3174:	02000002 	andeq	r0, r0, #2
    3178:	98061023 	stmdals	r6, {r0, r1, r5, ip}
    317c:	0600000d 	streq	r0, [r0], -sp
    3180:	00025360 	andeq	r5, r2, r0, ror #6
    3184:	14230200 	strtne	r0, [r3], #-512	; 0xfffffe00
    3188:	000e9b06 	andeq	r9, lr, r6, lsl #22
    318c:	02670600 	rsbeq	r0, r7, #0, 12
    3190:	02000005 	andeq	r0, r0, #5
    3194:	f3061823 	vsub.i8	d1, d6, d19
    3198:	0600000d 	streq	r0, [r0], -sp
    319c:	0000b172 	andeq	fp, r0, r2, ror r1
    31a0:	1c230200 	sfmne	f0, 4, [r3], #-0
    31a4:	000e1306 	andeq	r1, lr, r6, lsl #6
    31a8:	a6760600 	ldrbtge	r0, [r6], -r0, lsl #12
    31ac:	02000000 	andeq	r0, r0, #0
    31b0:	7d061d23 	stcvc	13, cr1, [r6, #-140]	; 0xffffff74
    31b4:	0600000e 	streq	r0, [r0], -lr
    31b8:	0000bc7b 	andeq	fp, r0, fp, ror ip
    31bc:	1e230200 	cdpne	2, 2, cr0, cr3, cr0, {0}
    31c0:	000dfb06 	andeq	pc, sp, r6, lsl #22
    31c4:	c7810600 	strgt	r0, [r1, r0, lsl #12]
    31c8:	02000000 	andeq	r0, r0, #0
    31cc:	5d061f23 	stcpl	15, cr1, [r6, #-140]	; 0xffffff74
    31d0:	0600000e 	streq	r0, [r0], -lr
    31d4:	00034f88 	andeq	r4, r3, r8, lsl #31
    31d8:	20230200 	eorcs	r0, r3, r0, lsl #4
    31dc:	755f7007 	ldrbvc	r7, [pc, #-7]	; 31dd <_data_load+0x4ed>
    31e0:	cdad0600 	stcgt	6, cr0, [sp]
    31e4:	02000004 	andeq	r0, r0, #4
    31e8:	c2062423 	andgt	r2, r6, #587202560	; 0x23000000
    31ec:	0600000e 	streq	r0, [r0], -lr
    31f0:	00027bb2 			; <UNDEFINED> instruction: 0x00027bb2
    31f4:	28230200 	stmdacs	r3!, {r9}
    31f8:	000e6b06 	andeq	r6, lr, r6, lsl #22
    31fc:	59b80600 	ldmibpl	r8!, {r9, sl}
    3200:	02000002 	andeq	r0, r0, #2
    3204:	8e062c23 	cdphi	12, 0, cr2, cr6, cr3, {1}
    3208:	0600000c 	streq	r0, [r0], -ip
    320c:	0000ddbc 			; <UNDEFINED> instruction: 0x0000ddbc
    3210:	34230200 	strtcc	r0, [r3], #-512	; 0xfffffe00
    3214:	000e2206 	andeq	r2, lr, r6, lsl #4
    3218:	e8c20600 	stmia	r2, {r9, sl}^
    321c:	02000000 	andeq	r0, r0, #0
    3220:	e9063823 	stmdb	r6, {r0, r1, r5, fp, ip, sp}
    3224:	0600000d 	streq	r0, [r0], -sp
    3228:	000514c9 	andeq	r1, r5, r9, asr #9
    322c:	3c230200 	sfmcc	f0, 4, [r3], #-0
    3230:	000e4906 	andeq	r4, lr, r6, lsl #18
    3234:	d2cd0600 	sbcle	r0, sp, #0, 12
    3238:	02000000 	andeq	r0, r0, #0
    323c:	fe064023 	cdp2	0, 0, cr4, cr6, cr3, {1}
    3240:	0600000c 	streq	r0, [r0], -ip
    3244:	000291d3 	ldrdeq	r9, [r2], -r3
    3248:	44230200 	strtmi	r0, [r3], #-512	; 0xfffffe00
    324c:	05080800 	streq	r0, [r8, #-2048]	; 0xfffff800
    3250:	0002535a 	andeq	r5, r2, sl, asr r3
    3254:	11570600 	cmpne	r7, r0, lsl #12
    3258:	5b050000 	blpl	143260 <_flash_swap_addr+0x103a60>
    325c:	00000253 	andeq	r0, r0, r3, asr r2
    3260:	06002302 	streq	r2, [r0], -r2, lsl #6
    3264:	00000dda 	ldrdeq	r0, [r0], -sl
    3268:	02535d05 	subseq	r5, r3, #320	; 0x140
    326c:	23020000 	movwcs	r0, #8192	; 0x2000
    3270:	04090004 	streq	r0, [r9], #-4
    3274:	000000fe 	strdeq	r0, [r0], -lr
    3278:	000da603 	andeq	sl, sp, r3, lsl #12
    327c:	2e5f0500 	cdpcs	5, 5, cr0, cr15, cr0, {0}
    3280:	08000002 	stmdaeq	r0, {r1}
    3284:	7b640504 	blvc	190469c <_flash_swap_addr+0x18c4e9c>
    3288:	06000002 	streq	r0, [r0], -r2
    328c:	00001157 	andeq	r1, r0, r7, asr r1
    3290:	02536605 	subseq	r6, r3, #5242880	; 0x500000
    3294:	23020000 	movwcs	r0, #8192	; 0x2000
    3298:	6a030000 	bvs	c32a0 <_flash_swap_addr+0x83aa0>
    329c:	0500000d 	streq	r0, [r0, #-13]
    32a0:	00026469 	andeq	r6, r2, r9, ror #8
    32a4:	0d410300 	stcleq	3, cr0, [r1, #-0]
    32a8:	de070000 	cdple	0, 0, cr0, cr7, cr0, {0}
    32ac:	00000291 	muleq	r0, r1, r2
    32b0:	b503040a 	strlt	r0, [r3, #-1034]	; 0xfffffbf6
    32b4:	07000003 	streq	r0, [r0, -r3]
    32b8:	000094e4 	andeq	r9, r0, r4, ror #9
    32bc:	0e640b00 	vmuleq.f64	d16, d4, d0
    32c0:	07240000 	streq	r0, [r4, -r0]!
    32c4:	032c0105 	teqeq	ip, #1073741825	; 0x40000001
    32c8:	720c0000 	andvc	r0, ip, #0
    32cc:	18070034 	stmdane	r7, {r2, r4, r5}
    32d0:	00028601 	andeq	r8, r2, r1, lsl #12
    32d4:	00230200 	eoreq	r0, r3, r0, lsl #4
    32d8:	0035720c 	eorseq	r7, r5, ip, lsl #4
    32dc:	86011907 	strhi	r1, [r1], -r7, lsl #18
    32e0:	02000002 	andeq	r0, r0, #2
    32e4:	720c0423 	andvc	r0, ip, #587202560	; 0x23000000
    32e8:	1a070036 	bne	1c33c8 <_flash_swap_addr+0x183bc8>
    32ec:	00028601 	andeq	r8, r2, r1, lsl #12
    32f0:	08230200 	stmdaeq	r3!, {r9}
    32f4:	0037720c 	eorseq	r7, r7, ip, lsl #4
    32f8:	86011b07 	strhi	r1, [r1], -r7, lsl #22
    32fc:	02000002 	andeq	r0, r0, #2
    3300:	720c0c23 	andvc	r0, ip, #8960	; 0x2300
    3304:	1c070038 	stcne	0, cr0, [r7], {56}	; 0x38
    3308:	00028601 	andeq	r8, r2, r1, lsl #12
    330c:	10230200 	eorne	r0, r3, r0, lsl #4
    3310:	0039720c 	eorseq	r7, r9, ip, lsl #4
    3314:	86011d07 	strhi	r1, [r1], -r7, lsl #26
    3318:	02000002 	andeq	r0, r0, #2
    331c:	720c1423 	andvc	r1, ip, #587202560	; 0x23000000
    3320:	07003031 	smladxeq	r0, r1, r0, r3
    3324:	0286011e 	addeq	r0, r6, #-2147483641	; 0x80000007
    3328:	23020000 	movwcs	r0, #8192	; 0x2000
    332c:	31720c18 	cmncc	r2, r8, lsl ip
    3330:	1f070031 	svcne	0x00070031
    3334:	00028601 	andeq	r8, r2, r1, lsl #12
    3338:	1c230200 	sfmne	f0, 4, [r3], #-0
    333c:	00726c0c 	rsbseq	r6, r2, ip, lsl #24
    3340:	86012007 	strhi	r2, [r1], -r7
    3344:	02000002 	andeq	r0, r0, #2
    3348:	0b002023 	bleq	b3dc <_data_load+0x86ec>
    334c:	00000d5a 	andeq	r0, r0, sl, asr sp
    3350:	012a0704 	teqeq	sl, r4, lsl #14
    3354:	00000349 	andeq	r0, r0, r9, asr #6
    3358:	3331720c 	teqcc	r1, #12, 4	; 0xc0000000
    335c:	012b0700 	teqeq	fp, r0, lsl #14
    3360:	00000349 	andeq	r0, r0, r9, asr #6
    3364:	00002302 	andeq	r2, r0, r2, lsl #6
    3368:	029e0409 	addseq	r0, lr, #150994944	; 0x9000000
    336c:	f30d0000 	vhadd.u8	d0, d13, d0
    3370:	05000000 	streq	r0, [r0, #-0]
    3374:	00000d82 	andeq	r0, r0, r2, lsl #27
    3378:	8b250810 	blhi	9453c0 <_flash_swap_addr+0x905bc0>
    337c:	06000003 	streq	r0, [r0], -r3
    3380:	00000d06 	andeq	r0, r0, r6, lsl #26
    3384:	02592608 	subseq	r2, r9, #8, 12	; 0x800000
    3388:	23020000 	movwcs	r0, #8192	; 0x2000
    338c:	0eb40600 	cdpeq	6, 11, cr0, cr4, cr0, {0}
    3390:	28080000 	stmdacs	r8, {}	; <UNPREDICTABLE>
    3394:	00000253 	andeq	r0, r0, r3, asr r2
    3398:	06082302 	streq	r2, [r8], -r2, lsl #6
    339c:	00000e42 	andeq	r0, r0, r2, asr #28
    33a0:	038b2a08 	orreq	r2, fp, #8, 20	; 0x8000
    33a4:	23020000 	movwcs	r0, #8192	; 0x2000
    33a8:	0409000c 	streq	r0, [r9], #-12
    33ac:	00000354 	andeq	r0, r0, r4, asr r3
    33b0:	000d8203 	andeq	r8, sp, r3, lsl #4
    33b4:	542c0800 	strtpl	r0, [ip], #-2048	; 0xfffff800
    33b8:	03000003 	movweq	r0, #3
    33bc:	00001122 	andeq	r1, r0, r2, lsr #2
    33c0:	03a72509 			; <UNDEFINED> instruction: 0x03a72509
    33c4:	04090000 	streq	r0, [r9], #-0
    33c8:	000003ad 	andeq	r0, r0, sp, lsr #7
    33cc:	0291010e 	addseq	r0, r1, #-2147483645	; 0x80000003
    33d0:	03bd0000 			; <UNDEFINED> instruction: 0x03bd0000
    33d4:	300f0000 	andcc	r0, pc, r0
    33d8:	00000000 	andeq	r0, r0, r0
    33dc:	0011a503 	andseq	sl, r1, r3, lsl #10
    33e0:	c82d0a00 	stmdagt	sp!, {r9, fp}
    33e4:	05000003 	streq	r0, [r0, #-3]
    33e8:	00001210 	andeq	r1, r0, r0, lsl r2
    33ec:	ff400a20 			; <UNDEFINED> instruction: 0xff400a20
    33f0:	06000003 	streq	r0, [r0], -r3
    33f4:	000011b8 			; <UNDEFINED> instruction: 0x000011b8
    33f8:	039c410a 	orrseq	r4, ip, #-2147483646	; 0x80000002
    33fc:	23020000 	movwcs	r0, #8192	; 0x2000
    3400:	112f0600 	teqne	pc, r0, lsl #12
    3404:	430a0000 	movwmi	r0, #40960	; 0xa000
    3408:	0000041e 	andeq	r0, r0, lr, lsl r4
    340c:	06082302 	streq	r2, [r8], -r2, lsl #6
    3410:	0000113c 	andeq	r1, r0, ip, lsr r1
    3414:	0391450a 	orrseq	r4, r1, #41943040	; 0x2800000
    3418:	23020000 	movwcs	r0, #8192	; 0x2000
    341c:	04100010 	ldreq	r0, [r0], #-16
    3420:	041e350a 	ldreq	r3, [lr], #-1290	; 0xfffffaf6
    3424:	b3110000 	tstlt	r1, #0
    3428:	0a000011 	beq	3474 <_data_load+0x784>
    342c:	00043f36 	andeq	r3, r4, r6, lsr pc
    3430:	12ee1100 	rscne	r1, lr, #0, 2
    3434:	370a0000 	strcc	r0, [sl, -r0]
    3438:	00000445 	andeq	r0, r0, r5, asr #8
    343c:	11c31200 	bicne	r1, r3, r0, lsl #4
    3440:	0a080000 	beq	203448 <_flash_swap_addr+0x1c3c48>
    3444:	00043f32 	andeq	r3, r4, r2, lsr pc
    3448:	11841100 	orrne	r1, r4, r0, lsl #2
    344c:	330a0000 	movwcc	r0, #40960	; 0xa000
    3450:	00000293 	muleq	r0, r3, r2
    3454:	0a006813 	beq	1d4a8 <_data_load+0x1a7b8>
    3458:	00044b3a 	andeq	r4, r4, sl, lsr fp
    345c:	04090000 	streq	r0, [r9], #-0
    3460:	0000041e 	andeq	r0, r0, lr, lsl r4
    3464:	03bd0409 			; <UNDEFINED> instruction: 0x03bd0409
    3468:	08080000 	stmdaeq	r8, {}	; <UNPREDICTABLE>
    346c:	046e340a 	strbteq	r3, [lr], #-1034	; 0xfffffbf6
    3470:	75070000 	strvc	r0, [r7, #-0]
    3474:	ff380a00 			; <UNDEFINED> instruction: 0xff380a00
    3478:	02000003 	andeq	r0, r0, #3
    347c:	a0060023 	andge	r0, r6, r3, lsr #32
    3480:	0a000011 	beq	34cc <_data_load+0x7dc>
    3484:	00003039 	andeq	r3, r0, r9, lsr r0
    3488:	04230200 	strteq	r0, [r3], #-512	; 0xfffffe00
    348c:	12040500 	andne	r0, r4, #0, 10
    3490:	0b040000 	bleq	103498 <_flash_swap_addr+0xc3c98>
    3494:	00048925 	andeq	r8, r4, r5, lsr #18
    3498:	11b00600 	lslsne	r0, r0, #12
    349c:	260b0000 	strcs	r0, [fp], -r0
    34a0:	00000489 	andeq	r0, r0, r9, lsl #9
    34a4:	00002302 	andeq	r2, r0, r2, lsl #6
    34a8:	046e0409 	strbteq	r0, [lr], #-1033	; 0xfffffbf7
    34ac:	0c080000 	stceq	0, cr0, [r8], {-0}
    34b0:	04c22d0b 	strbeq	r2, [r2], #3339	; 0xd0b
    34b4:	56060000 	strpl	r0, [r6], -r0
    34b8:	0b000011 	bleq	3504 <_data_load+0x814>
    34bc:	0004892e 	andeq	r8, r4, lr, lsr #18
    34c0:	00230200 	eoreq	r0, r3, r0, lsl #4
    34c4:	00119606 	andseq	r9, r1, r6, lsl #12
    34c8:	302f0b00 	eorcc	r0, pc, r0, lsl #22
    34cc:	02000000 	andeq	r0, r0, #0
    34d0:	78060423 	stmdavc	r6, {r0, r1, r5, sl}
    34d4:	0b000011 	bleq	3520 <_data_load+0x830>
    34d8:	00039c31 	andeq	r9, r3, r1, lsr ip
    34dc:	08230200 	stmdaeq	r3!, {r9}
    34e0:	116d0300 	cmnne	sp, r0, lsl #6
    34e4:	330b0000 	movwcc	r0, #45056	; 0xb000
    34e8:	0000048f 	andeq	r0, r0, pc, lsl #9
    34ec:	8f060410 	svchi	0x00060410
    34f0:	00000502 	andeq	r0, r0, r2, lsl #10
    34f4:	000c9411 	andeq	r9, ip, r1, lsl r4
    34f8:	dd960600 	ldcle	6, cr0, [r6]
    34fc:	11000000 	mrsne	r0, (UNDEF: 0)
    3500:	00000cd9 	ldrdeq	r0, [r0], -r9
    3504:	00dd9d06 	sbcseq	r9, sp, r6, lsl #26
    3508:	94110000 	ldrls	r0, [r1], #-0
    350c:	0600000e 	streq	r0, [r0], -lr
    3510:	000291a4 	andeq	r9, r2, r4, lsr #3
    3514:	0e0c1100 	adfeqe	f1, f4, f0
    3518:	ab060000 	blge	183520 <_flash_swap_addr+0x143d20>
    351c:	000000e8 	andeq	r0, r0, r8, ror #1
    3520:	08040900 	stmdaeq	r4, {r8, fp}
    3524:	14000005 	strne	r0, [r0], #-5
    3528:	0000050d 	andeq	r0, r0, sp, lsl #10
    352c:	c1080104 	tstgt	r8, r4, lsl #2
    3530:	09000001 	stmdbeq	r0, {r0}
    3534:	00039104 	andeq	r9, r3, r4, lsl #2
    3538:	11270300 	teqne	r7, r0, lsl #6
    353c:	de060000 	cdple	0, 0, cr0, cr6, cr0, {0}
    3540:	00000525 	andeq	r0, r0, r5, lsr #10
    3544:	052b0409 	streq	r0, [fp, #-1033]!	; 0xfffffbf7
    3548:	010e0000 	mrseq	r0, (UNDEF: 14)
    354c:	000000dd 	ldrdeq	r0, [r0], -sp
    3550:	0000053b 	andeq	r0, r0, fp, lsr r5
    3554:	0002910f 	andeq	r9, r2, pc, lsl #2
    3558:	01150000 	tsteq	r5, r0
    355c:	0000118a 	andeq	r1, r0, sl, lsl #3
    3560:	53012d01 	movwpl	r2, #7425	; 0x1d01
    3564:	00000002 	andeq	r0, r0, r2
    3568:	2a00001e 	bcs	35e8 <_data_load+0x8f8>
    356c:	2000001e 	andcs	r0, r0, lr, lsl r0
    3570:	9800000f 	stmdals	r0, {r0, r1, r2, r3}
    3574:	16000005 	strne	r0, [r0], -r5
    3578:	01007074 	tsteq	r0, r4, ror r0
    357c:	0002532d 	andeq	r5, r2, sp, lsr #6
    3580:	7c910200 	lfmvc	f0, 4, [r1], {0}
    3584:	001e0417 	andseq	r0, lr, r7, lsl r4
    3588:	001e0c00 	andseq	r0, lr, r0, lsl #24
    358c:	00058000 	andeq	r8, r5, r0
    3590:	6d741800 	ldclvs	8, cr1, [r4, #-0]
    3594:	2f010070 	svccs	0x00010070
    3598:	0000007b 	andeq	r0, r0, fp, ror r0
    359c:	19005301 	stmdbne	r0, {r0, r8, r9, ip, lr}
    35a0:	00001e1a 	andeq	r1, r0, sl, lsl lr
    35a4:	00001e22 	andeq	r1, r0, r2, lsr #28
    35a8:	706d7418 	rsbvc	r7, sp, r8, lsl r4
    35ac:	7b320100 	blvc	c839b4 <_flash_swap_addr+0xc441b4>
    35b0:	01000000 	mrseq	r0, (UNDEF: 0)
    35b4:	1a000053 	bne	3708 <_data_load+0xa18>
    35b8:	0011cf01 	andseq	ip, r1, r1, lsl #30
    35bc:	01430100 	mrseq	r0, (UNDEF: 83)
    35c0:	00001e30 	andeq	r1, r0, r0, lsr lr
    35c4:	00001ec0 	andeq	r1, r0, r0, asr #29
    35c8:	00000f40 	andeq	r0, r0, r0, asr #30
    35cc:	000005ff 	strdeq	r0, [r0], -pc	; <UNPREDICTABLE>
    35d0:	00707416 	rsbseq	r7, r0, r6, lsl r4
    35d4:	02534301 	subseq	r4, r3, #67108864	; 0x4000000
    35d8:	91020000 	mrsls	r0, (UNDEF: 2)
    35dc:	0e7f1b6c 	vsubeq.f64	d17, d15, d28
    35e0:	44010000 	strmi	r0, [r1], #-0
    35e4:	000000bc 	strheq	r0, [r0], -ip
    35e8:	17779102 	ldrbne	r9, [r7, -r2, lsl #2]!
    35ec:	00001e36 	andeq	r1, r0, r6, lsr lr
    35f0:	00001e3e 	andeq	r1, r0, lr, lsr lr
    35f4:	000005e7 	andeq	r0, r0, r7, ror #11
    35f8:	706d7418 	rsbvc	r7, sp, r8, lsl r4
    35fc:	7b460100 	blvc	1183a04 <_flash_swap_addr+0x1144204>
    3600:	01000000 	mrseq	r0, (UNDEF: 0)
    3604:	54190053 	ldrpl	r0, [r9], #-83	; 0xffffffad
    3608:	5c00001e 	stcpl	0, cr0, [r0], {30}
    360c:	1800001e 	stmdane	r0, {r1, r2, r3, r4}
    3610:	00706d74 	rsbseq	r6, r0, r4, ror sp
    3614:	007b4901 	rsbseq	r4, fp, r1, lsl #18
    3618:	53010000 	movwpl	r0, #4096	; 0x1000
    361c:	01150000 	tsteq	r5, r0
    3620:	00001142 	andeq	r1, r0, r2, asr #2
    3624:	53017b01 	movwpl	r7, #6913	; 0x1b01
    3628:	c0000002 	andgt	r0, r0, r2
    362c:	1e00001e 	mcrne	0, 0, r0, cr0, cr14, {0}
    3630:	6c00001f 	stcvs	0, cr0, [r0], {31}
    3634:	af00000f 	svcge	0x0000000f
    3638:	1c000006 	stcne	0, cr0, [r0], {6}
    363c:	00001136 	andeq	r1, r0, r6, lsr r1
    3640:	04457b01 	strbeq	r7, [r5], #-2817	; 0xfffff4ff
    3644:	91020000 	mrsls	r0, (UNDEF: 2)
    3648:	11a01c6c 	rorne	r1, ip, #24
    364c:	7b010000 	blvc	43654 <_flash_swap_addr+0x3e54>
    3650:	00000030 	andeq	r0, r0, r0, lsr r0
    3654:	1c689102 	stfnep	f1, [r8], #-8
    3658:	00000cef 	andeq	r0, r0, pc, ror #25
    365c:	00d27c01 	sbcseq	r7, r2, r1, lsl #24
    3660:	91020000 	mrsls	r0, (UNDEF: 2)
    3664:	66701664 	ldrbtvs	r1, [r0], -r4, ror #12
    3668:	1a7c0100 	bne	1f03a70 <_flash_swap_addr+0x1ec4270>
    366c:	02000005 	andeq	r0, r0, #5
    3670:	61166091 			; <UNDEFINED> instruction: 0x61166091
    3674:	01006772 	tsteq	r0, r2, ror r7
    3678:	0002917c 	andeq	r9, r2, ip, ror r1
    367c:	00910200 	addseq	r0, r1, r0, lsl #4
    3680:	70737718 	rsbsvc	r7, r3, r8, lsl r7
    3684:	917d0100 	cmnls	sp, r0, lsl #2
    3688:	02000002 	andeq	r0, r0, #2
    368c:	74187491 	ldrvc	r7, [r8], #-1169	; 0xfffffb6f
    3690:	7e010070 	mcrvc	0, 0, r0, cr1, cr0, {3}
    3694:	00000253 	andeq	r0, r0, r3, asr r2
    3698:	17709102 	ldrbne	r9, [r0, -r2, lsl #2]!
    369c:	00001ee2 	andeq	r1, r0, r2, ror #29
    36a0:	00001eea 	andeq	r1, r0, sl, ror #29
    36a4:	00000697 	muleq	r0, r7, r6
    36a8:	706d7418 	rsbvc	r7, sp, r8, lsl r4
    36ac:	7b8d0100 	blvc	fe343ab4 <_stack_start+0xde333ab4>
    36b0:	01000000 	mrseq	r0, (UNDEF: 0)
    36b4:	0e190053 	mrceq	0, 0, r0, cr9, cr3, {2}
    36b8:	1600001f 			; <UNDEFINED> instruction: 0x1600001f
    36bc:	1800001f 	stmdane	r0, {r0, r1, r2, r3, r4}
    36c0:	00706d74 	rsbseq	r6, r0, r4, ror sp
    36c4:	007b9101 	rsbseq	r9, fp, r1, lsl #2
    36c8:	53010000 	movwpl	r0, #4096	; 0x1000
    36cc:	01150000 	tsteq	r5, r0
    36d0:	0000115e 	andeq	r1, r0, lr, asr r1
    36d4:	5301ac01 	movwpl	sl, #7169	; 0x1c01
    36d8:	20000002 	andcs	r0, r0, r2
    36dc:	8600001f 			; <UNDEFINED> instruction: 0x8600001f
    36e0:	9800001f 	stmdals	r0, {r0, r1, r2, r3, r4}
    36e4:	5000000f 	andpl	r0, r0, pc
    36e8:	16000007 	strne	r0, [r0], -r7
    36ec:	0100706d 	tsteq	r0, sp, rrx
    36f0:	000750ac 	andeq	r5, r7, ip, lsr #1
    36f4:	6c910200 	lfmvs	f0, 4, [r1], {0}
    36f8:	000cef1c 	andeq	lr, ip, ip, lsl pc
    36fc:	d2ac0100 	adcle	r0, ip, #0, 2
    3700:	02000000 	andeq	r0, r0, #0
    3704:	70166891 	mulsvc	r6, r1, r8
    3708:	ad010066 	stcge	0, cr0, [r1, #-408]	; 0xfffffe68
    370c:	0000051a 	andeq	r0, r0, sl, lsl r5
    3710:	16649102 	strbtne	r9, [r4], -r2, lsl #2
    3714:	00677261 	rsbeq	r7, r7, r1, ror #4
    3718:	0291ad01 	addseq	sl, r1, #1, 26	; 0x40
    371c:	91020000 	mrsls	r0, (UNDEF: 2)
    3720:	73771860 	cmnvc	r7, #96, 16	; 0x600000
    3724:	ae010070 	mcrge	0, 0, r0, cr1, cr0, {3}
    3728:	00000291 	muleq	r0, r1, r2
    372c:	18749102 	ldmdane	r4!, {r1, r8, ip, pc}^
    3730:	01007074 	tsteq	r0, r4, ror r0
    3734:	000253af 	andeq	r5, r2, pc, lsr #7
    3738:	70910200 	addsvc	r0, r1, r0, lsl #4
    373c:	001f4017 	andseq	r4, pc, r7, lsl r0	; <UNPREDICTABLE>
    3740:	001f4800 	andseq	r4, pc, r0, lsl #16
    3744:	00073800 	andeq	r3, r7, r0, lsl #16
    3748:	6d741800 	ldclvs	8, cr1, [r4, #-0]
    374c:	c0010070 	andgt	r0, r1, r0, ror r0
    3750:	0000007b 	andeq	r0, r0, fp, ror r0
    3754:	19005301 	stmdbne	r0, {r0, r8, r9, ip, lr}
    3758:	00001f76 	andeq	r1, r0, r6, ror pc
    375c:	00001f7e 	andeq	r1, r0, lr, ror pc
    3760:	706d7418 	rsbvc	r7, sp, r8, lsl r4
    3764:	7bc50100 	blvc	ff143b6c <_stack_start+0xdf133b6c>
    3768:	01000000 	mrseq	r0, (UNDEF: 0)
    376c:	09000053 	stmdbeq	r0, {r0, r1, r4, r6}
    3770:	0004c204 	andeq	ip, r4, r4, lsl #4
    3774:	01d00000 	bicseq	r0, r0, r0
    3778:	00020000 	andeq	r0, r2, r0
    377c:	00000d27 	andeq	r0, r0, r7, lsr #26
    3780:	02870104 	addeq	r0, r7, #4, 2
    3784:	1c010000 	stcne	0, cr0, [r1], {-0}
    3788:	16000012 			; <UNDEFINED> instruction: 0x16000012
    378c:	00000002 	andeq	r0, r0, r2
    3790:	00000000 	andeq	r0, r0, r0
    3794:	50000000 	andpl	r0, r0, r0
    3798:	05000001 	streq	r0, [r0, #-1]
    379c:	02000011 	andeq	r0, r0, #17
    37a0:	6e690504 	cdpvs	5, 6, cr0, cr9, cr4, {0}
    37a4:	2e030074 	mcrcs	0, 0, r0, cr3, cr4, {3}
    37a8:	02000010 	andeq	r0, r0, #16
    37ac:	00003bd4 	ldrdeq	r3, [r0], -r4
    37b0:	07040400 	streq	r0, [r4, -r0, lsl #8]
    37b4:	000001ed 	andeq	r0, r0, sp, ror #3
    37b8:	ba060104 	blt	183bd0 <_flash_swap_addr+0x1443d0>
    37bc:	03000001 	movweq	r0, #1
    37c0:	00000a33 	andeq	r0, r0, r3, lsr sl
    37c4:	00542a03 	subseq	r2, r4, r3, lsl #20
    37c8:	01040000 	mrseq	r0, (UNDEF: 4)
    37cc:	0001b808 	andeq	fp, r1, r8, lsl #16
    37d0:	05020400 	streq	r0, [r2, #-1024]	; 0xfffffc00
    37d4:	00000031 	andeq	r0, r0, r1, lsr r0
    37d8:	6a070204 	bvs	1c3ff0 <_flash_swap_addr+0x1847f0>
    37dc:	04000002 	streq	r0, [r0], #-2
    37e0:	00f70504 	rscseq	r0, r7, r4, lsl #10
    37e4:	ff030000 			; <UNDEFINED> instruction: 0xff030000
    37e8:	03000002 	movweq	r0, #2
    37ec:	00007b50 	andeq	r7, r0, r0, asr fp
    37f0:	07040400 	streq	r0, [r4, -r0, lsl #8]
    37f4:	000001e8 	andeq	r0, r0, r8, ror #3
    37f8:	f2050804 	vadd.i8	d0, d5, d4
    37fc:	04000000 	streq	r0, [r0], #-0
    3800:	01e30708 	mvneq	r0, r8, lsl #14
    3804:	04050000 	streq	r0, [r5], #-0
    3808:	c1080104 	tstgt	r8, r4, lsl #2
    380c:	06000001 	streq	r0, [r0], -r1
    3810:	00004904 	andeq	r4, r0, r4, lsl #18
    3814:	87010700 	strhi	r0, [r1, -r0, lsl #14]
    3818:	01000012 	tsteq	r0, r2, lsl r0
    381c:	1f90013b 	svcne	0x0090013b
    3820:	1fc60000 	svcne	0x00c60000
    3824:	7d020000 	stcvc	0, cr0, [r2, #-0]
    3828:	0000d200 	andeq	sp, r0, r0, lsl #4
    382c:	12590800 	subsne	r0, r9, #0, 16
    3830:	3d010000 	stccc	0, cr0, [r1, #-0]
    3834:	000000d2 	ldrdeq	r0, [r0], -r2
    3838:	4c080101 	stfmis	f0, [r8], {1}
    383c:	01000012 	tsteq	r0, r2, lsl r0
    3840:	0000d23e 	andeq	sp, r0, lr, lsr r2
    3844:	00010100 	andeq	r0, r1, r0, lsl #2
    3848:	00004909 	andeq	r4, r0, r9, lsl #18
    384c:	0000dd00 	andeq	sp, r0, r0, lsl #26
    3850:	0b000a00 	bleq	6058 <_data_load+0x3368>
    3854:	00126701 	andseq	r6, r2, r1, lsl #14
    3858:	01540100 	cmpeq	r4, r0, lsl #2
    385c:	00000090 	muleq	r0, r0, r0
    3860:	00001fd0 	ldrdeq	r1, [r0], -r0
    3864:	00001ff6 	strdeq	r1, [r0], -r6
    3868:	00000fc4 	andeq	r0, r0, r4, asr #31
    386c:	00000147 	andeq	r0, r0, r7, asr #2
    3870:	0011a00c 	andseq	sl, r1, ip
    3874:	30540100 	subscc	r0, r4, r0, lsl #2
    3878:	02000000 	andeq	r0, r0, #0
    387c:	700d6c91 	mulvc	sp, r1, ip
    3880:	90550100 	subsls	r0, r5, r0, lsl #2
    3884:	02000000 	andeq	r0, r0, #0
    3888:	d60e7491 			; <UNDEFINED> instruction: 0xd60e7491
    388c:	de00001f 	mcrle	0, 0, r0, cr0, cr15, {0}
    3890:	2f00001f 	svccs	0x0000001f
    3894:	0d000001 	stceq	0, cr0, [r0, #-4]
    3898:	00706d74 	rsbseq	r6, r0, r4, ror sp
    389c:	00705701 	rsbseq	r5, r0, r1, lsl #14
    38a0:	53010000 	movwpl	r0, #4096	; 0x1000
    38a4:	1fe60f00 	svcne	0x00e60f00
    38a8:	1fee0000 	svcne	0x00ee0000
    38ac:	740d0000 	strvc	r0, [sp], #-0
    38b0:	0100706d 	tsteq	r0, sp, rrx
    38b4:	00007059 	andeq	r7, r0, r9, asr r0
    38b8:	00530100 	subseq	r0, r3, r0, lsl #2
    38bc:	7a010b00 	bvc	464c4 <_flash_swap_addr+0x6cc4>
    38c0:	01000012 	tsteq	r0, r2, lsl r0
    38c4:	00900169 	addseq	r0, r0, r9, ror #2
    38c8:	20000000 	andcs	r0, r0, r0
    38cc:	20620000 	rsbcs	r0, r2, r0
    38d0:	0ff00000 	svceq	0x00f00000	; IMB
    38d4:	017f0000 	cmneq	pc, r0
    38d8:	a00c0000 	andge	r0, ip, r0
    38dc:	01000011 	tsteq	r0, r1, lsl r0
    38e0:	00003069 	andeq	r3, r0, r9, rrx
    38e4:	74910200 	ldrvc	r0, [r1], #512	; 0x200
    38e8:	0100700d 	tsteq	r0, sp
    38ec:	0000906a 	andeq	r9, r0, sl, rrx
    38f0:	7c910200 	lfmvc	f0, 4, [r1], {0}
    38f4:	92011000 	andls	r1, r1, #0
    38f8:	01000012 	tsteq	r0, r2, lsl r0
    38fc:	0030017d 	eorseq	r0, r0, sp, ror r1
    3900:	20700000 	rsbscs	r0, r0, r0
    3904:	208c0000 	addcs	r0, ip, r0
    3908:	7d020000 	stcvc	0, cr0, [r2, #-0]
    390c:	12441100 	subne	r1, r4, #0, 2
    3910:	33010000 	movwcc	r0, #4096	; 0x1000
    3914:	00000099 	muleq	r0, r9, r0
    3918:	07240305 	streq	r0, [r4, -r5, lsl #6]!
    391c:	73112000 	tstvc	r1, #0
    3920:	01000012 	tsteq	r0, r2, lsl r0
    3924:	00009934 	andeq	r9, r0, r4, lsr r9
    3928:	28030500 	stmdacs	r3, {r8, sl}
    392c:	08200007 	stmdaeq	r0!, {r0, r1, r2}
    3930:	00001259 	andeq	r1, r0, r9, asr r2
    3934:	00d23d01 	sbcseq	r3, r2, r1, lsl #26
    3938:	01010000 	mrseq	r0, (UNDEF: 1)
    393c:	00124c08 	andseq	r4, r2, r8, lsl #24
    3940:	d23e0100 	eorsle	r0, lr, #0, 2
    3944:	01000000 	mrseq	r0, (UNDEF: 0)
    3948:	06440001 	strbeq	r0, [r4], -r1
    394c:	00020000 	andeq	r0, r2, r0
    3950:	00000e17 	andeq	r0, r0, r7, lsl lr
    3954:	02870104 	addeq	r0, r7, #4, 2
    3958:	b5010000 	strlt	r0, [r1, #-0]
    395c:	16000012 			; <UNDEFINED> instruction: 0x16000012
    3960:	00000002 	andeq	r0, r0, r2
    3964:	00000000 	andeq	r0, r0, r0
    3968:	78000000 	stmdavc	r0, {}	; <UNPREDICTABLE>
    396c:	93000001 	movwls	r0, #1
    3970:	02000012 	andeq	r0, r0, #18
    3974:	6e690504 	cdpvs	5, 6, cr0, cr9, cr4, {0}
    3978:	2e030074 	mcrcs	0, 0, r0, cr3, cr4, {3}
    397c:	02000010 	andeq	r0, r0, #16
    3980:	00003bd4 	ldrdeq	r3, [r0], -r4
    3984:	07040400 	streq	r0, [r4, -r0, lsl #8]
    3988:	000001ed 	andeq	r0, r0, sp, ror #3
    398c:	ba060104 	blt	183da4 <_flash_swap_addr+0x1445a4>
    3990:	03000001 	movweq	r0, #1
    3994:	00000a33 	andeq	r0, r0, r3, lsr sl
    3998:	00542a03 	subseq	r2, r4, r3, lsl #20
    399c:	01040000 	mrseq	r0, (UNDEF: 4)
    39a0:	0001b808 	andeq	fp, r1, r8, lsl #16
    39a4:	05020400 	streq	r0, [r2, #-1024]	; 0xfffffc00
    39a8:	00000031 	andeq	r0, r0, r1, lsr r0
    39ac:	6a070204 	bvs	1c41c4 <_flash_swap_addr+0x1849c4>
    39b0:	03000002 	movweq	r0, #2
    39b4:	00000300 	andeq	r0, r0, r0, lsl #6
    39b8:	00744f03 	rsbseq	r4, r4, r3, lsl #30
    39bc:	04040000 	streq	r0, [r4], #-0
    39c0:	0000f705 	andeq	pc, r0, r5, lsl #14
    39c4:	02ff0300 	rscseq	r0, pc, #0, 6
    39c8:	50030000 	andpl	r0, r3, r0
    39cc:	00000086 	andeq	r0, r0, r6, lsl #1
    39d0:	e8070404 	stmda	r7, {r2, sl}
    39d4:	04000001 	streq	r0, [r0], #-1
    39d8:	00f20508 	rscseq	r0, r2, r8, lsl #10
    39dc:	1f030000 	svcne	0x00030000
    39e0:	03000000 	movweq	r0, #0
    39e4:	00009f78 	andeq	r9, r0, r8, ror pc
    39e8:	07080400 	streq	r0, [r8, -r0, lsl #8]
    39ec:	000001e3 	andeq	r0, r0, r3, ror #3
    39f0:	000d6203 	andeq	r6, sp, r3, lsl #4
    39f4:	49280400 	stmdbmi	r8!, {sl}
    39f8:	03000000 	movweq	r0, #0
    39fc:	00000d18 	andeq	r0, r0, r8, lsl sp
    3a00:	00492904 	subeq	r2, r9, r4, lsl #18
    3a04:	d2030000 	andle	r0, r3, #0
    3a08:	0400000d 	streq	r0, [r0], #-13
    3a0c:	0000492a 	andeq	r4, r0, sl, lsr #18
    3a10:	0d0e0300 	stceq	3, cr0, [lr, #-0]
    3a14:	2b040000 	blcs	103a1c <_flash_swap_addr+0xc421c>
    3a18:	00000049 	andeq	r0, r0, r9, asr #32
    3a1c:	000de103 	andeq	lr, sp, r3, lsl #2
    3a20:	7b2c0400 	blvc	b04a28 <_flash_swap_addr+0xac5228>
    3a24:	03000000 	movweq	r0, #0
    3a28:	0000041f 	andeq	r0, r0, pc, lsl r4
    3a2c:	00692d04 	rsbeq	r2, r9, r4, lsl #26
    3a30:	76030000 	strvc	r0, [r3], -r0
    3a34:	0400000d 	streq	r0, [r0], #-13
    3a38:	00007b2f 	andeq	r7, r0, pc, lsr #22
    3a3c:	027d0300 	rsbseq	r0, sp, #0, 6
    3a40:	31040000 	mrscc	r0, (UNDEF: 4)
    3a44:	0000007b 	andeq	r0, r0, fp, ror r0
    3a48:	000e1b03 	andeq	r1, lr, r3, lsl #22
    3a4c:	09230500 	stmdbeq	r3!, {r8, sl}
    3a50:	05000001 	streq	r0, [r0, #-1]
    3a54:	00000e1b 	andeq	r0, r0, fp, lsl lr
    3a58:	2e570648 	cdpcs	6, 5, cr0, cr7, cr8, {2}
    3a5c:	06000002 	streq	r0, [r0], -r2
    3a60:	00001157 	andeq	r1, r0, r7, asr r1
    3a64:	02535806 	subseq	r5, r3, #393216	; 0x60000
    3a68:	23020000 	movwcs	r0, #8192	; 0x2000
    3a6c:	0dda0600 	ldcleq	6, cr0, [sl]
    3a70:	5a060000 	bpl	183a78 <_flash_swap_addr+0x144278>
    3a74:	00000253 	andeq	r0, r0, r3, asr r2
    3a78:	06042302 	streq	r2, [r4], -r2, lsl #6
    3a7c:	00000ced 	andeq	r0, r0, sp, ror #25
    3a80:	00d25c06 	sbcseq	r5, r2, r6, lsl #24
    3a84:	23020000 	movwcs	r0, #8192	; 0x2000
    3a88:	0ebc0608 	cdpeq	6, 11, cr0, cr12, cr8, {0}
    3a8c:	5d060000 	stcpl	0, cr0, [r6, #-0]
    3a90:	0000032c 	andeq	r0, r0, ip, lsr #6
    3a94:	060c2302 	streq	r2, [ip], -r2, lsl #6
    3a98:	00000d21 	andeq	r0, r0, r1, lsr #26
    3a9c:	02535f06 	subseq	r5, r3, #6, 30
    3aa0:	23020000 	movwcs	r0, #8192	; 0x2000
    3aa4:	0d980610 	ldceq	6, cr0, [r8, #64]	; 0x40
    3aa8:	60060000 	andvs	r0, r6, r0
    3aac:	00000253 	andeq	r0, r0, r3, asr r2
    3ab0:	06142302 	ldreq	r2, [r4], -r2, lsl #6
    3ab4:	00000e9b 	muleq	r0, fp, lr
    3ab8:	04a36706 	strteq	r6, [r3], #1798	; 0x706
    3abc:	23020000 	movwcs	r0, #8192	; 0x2000
    3ac0:	0df30618 	ldcleq	6, cr0, [r3, #96]!	; 0x60
    3ac4:	72060000 	andvc	r0, r6, #0
    3ac8:	000000b1 	strheq	r0, [r0], -r1
    3acc:	061c2302 	ldreq	r2, [ip], -r2, lsl #6
    3ad0:	00000e13 	andeq	r0, r0, r3, lsl lr
    3ad4:	00a67606 	adceq	r7, r6, r6, lsl #12
    3ad8:	23020000 	movwcs	r0, #8192	; 0x2000
    3adc:	0e7d061d 	mrceq	6, 3, r0, cr13, cr13, {0}
    3ae0:	7b060000 	blvc	183ae8 <_flash_swap_addr+0x1442e8>
    3ae4:	000000bc 	strheq	r0, [r0], -ip
    3ae8:	061e2302 	ldreq	r2, [lr], -r2, lsl #6
    3aec:	00000dfb 	strdeq	r0, [r0], -fp
    3af0:	00c78106 	sbceq	r8, r7, r6, lsl #2
    3af4:	23020000 	movwcs	r0, #8192	; 0x2000
    3af8:	0e5d061f 	mrceq	6, 2, r0, cr13, cr15, {0}
    3afc:	88060000 	stmdahi	r6, {}	; <UNPREDICTABLE>
    3b00:	0000034f 	andeq	r0, r0, pc, asr #6
    3b04:	07202302 	streq	r2, [r0, -r2, lsl #6]!
    3b08:	00755f70 	rsbseq	r5, r5, r0, ror pc
    3b0c:	046ead06 	strbteq	sl, [lr], #-3334	; 0xfffff2fa
    3b10:	23020000 	movwcs	r0, #8192	; 0x2000
    3b14:	0ec20624 	cdpeq	6, 12, cr0, cr2, cr4, {1}
    3b18:	b2060000 	andlt	r0, r6, #0
    3b1c:	0000027b 	andeq	r0, r0, fp, ror r2
    3b20:	06282302 	strteq	r2, [r8], -r2, lsl #6
    3b24:	00000e6b 	andeq	r0, r0, fp, ror #28
    3b28:	0259b806 	subseq	fp, r9, #393216	; 0x60000
    3b2c:	23020000 	movwcs	r0, #8192	; 0x2000
    3b30:	0c8e062c 	stceq	6, cr0, [lr], {44}	; 0x2c
    3b34:	bc060000 	stclt	0, cr0, [r6], {-0}
    3b38:	000000dd 	ldrdeq	r0, [r0], -sp
    3b3c:	06342302 	ldrteq	r2, [r4], -r2, lsl #6
    3b40:	00000e22 	andeq	r0, r0, r2, lsr #28
    3b44:	00e8c206 	rsceq	ip, r8, r6, lsl #4
    3b48:	23020000 	movwcs	r0, #8192	; 0x2000
    3b4c:	0de90638 	stcleq	6, cr0, [r9, #224]!	; 0xe0
    3b50:	c9060000 	stmdbgt	r6, {}	; <UNPREDICTABLE>
    3b54:	000004b5 			; <UNDEFINED> instruction: 0x000004b5
    3b58:	063c2302 	ldrteq	r2, [ip], -r2, lsl #6
    3b5c:	00000e49 	andeq	r0, r0, r9, asr #28
    3b60:	00d2cd06 	sbcseq	ip, r2, r6, lsl #26
    3b64:	23020000 	movwcs	r0, #8192	; 0x2000
    3b68:	0cfe0640 	ldcleq	6, cr0, [lr], #256	; 0x100
    3b6c:	d3060000 	movwle	r0, #24576	; 0x6000
    3b70:	00000291 	muleq	r0, r1, r2
    3b74:	00442302 	subeq	r2, r4, r2, lsl #6
    3b78:	5a050808 	bpl	145ba0 <_flash_swap_addr+0x1063a0>
    3b7c:	00000253 	andeq	r0, r0, r3, asr r2
    3b80:	00115706 	andseq	r5, r1, r6, lsl #14
    3b84:	535b0500 	cmppl	fp, #0, 10
    3b88:	02000002 	andeq	r0, r0, #2
    3b8c:	da060023 	ble	183c20 <_flash_swap_addr+0x144420>
    3b90:	0500000d 	streq	r0, [r0, #-13]
    3b94:	0002535d 	andeq	r5, r2, sp, asr r3
    3b98:	04230200 	strteq	r0, [r3], #-512	; 0xfffffe00
    3b9c:	fe040900 	cdp2	9, 0, cr0, cr4, cr0, {0}
    3ba0:	03000000 	movweq	r0, #0
    3ba4:	00000da6 	andeq	r0, r0, r6, lsr #27
    3ba8:	022e5f05 	eoreq	r5, lr, #5, 30
    3bac:	04080000 	streq	r0, [r8], #-0
    3bb0:	027b6405 	rsbseq	r6, fp, #83886080	; 0x5000000
    3bb4:	57060000 	strpl	r0, [r6, -r0]
    3bb8:	05000011 	streq	r0, [r0, #-17]	; 0xffffffef
    3bbc:	00025366 	andeq	r5, r2, r6, ror #6
    3bc0:	00230200 	eoreq	r0, r3, r0, lsl #4
    3bc4:	0d6a0300 	stcleq	3, cr0, [sl, #-0]
    3bc8:	69050000 	stmdbvs	r5, {}	; <UNPREDICTABLE>
    3bcc:	00000264 	andeq	r0, r0, r4, ror #4
    3bd0:	000d4103 	andeq	r4, sp, r3, lsl #2
    3bd4:	91de0700 	bicsls	r0, lr, r0, lsl #14
    3bd8:	0a000002 	beq	3be8 <_data_load+0xef8>
    3bdc:	03b50304 			; <UNDEFINED> instruction: 0x03b50304
    3be0:	e4070000 	str	r0, [r7], #-0
    3be4:	00000094 	muleq	r0, r4, r0
    3be8:	000e640b 	andeq	r6, lr, fp, lsl #8
    3bec:	05072400 	streq	r2, [r7, #-1024]	; 0xfffffc00
    3bf0:	00032c01 	andeq	r2, r3, r1, lsl #24
    3bf4:	34720c00 	ldrbtcc	r0, [r2], #-3072	; 0xfffff400
    3bf8:	01180700 	tsteq	r8, r0, lsl #14
    3bfc:	00000286 	andeq	r0, r0, r6, lsl #5
    3c00:	0c002302 	stceq	3, cr2, [r0], {2}
    3c04:	07003572 	smlsdxeq	r0, r2, r5, r3
    3c08:	02860119 	addeq	r0, r6, #1073741830	; 0x40000006
    3c0c:	23020000 	movwcs	r0, #8192	; 0x2000
    3c10:	36720c04 	ldrbtcc	r0, [r2], -r4, lsl #24
    3c14:	011a0700 	tsteq	sl, r0, lsl #14
    3c18:	00000286 	andeq	r0, r0, r6, lsl #5
    3c1c:	0c082302 	stceq	3, cr2, [r8], {2}
    3c20:	07003772 	smlsdxeq	r0, r2, r7, r3
    3c24:	0286011b 	addeq	r0, r6, #-1073741818	; 0xc0000006
    3c28:	23020000 	movwcs	r0, #8192	; 0x2000
    3c2c:	38720c0c 	ldmdacc	r2!, {r2, r3, sl, fp}^
    3c30:	011c0700 	tsteq	ip, r0, lsl #14
    3c34:	00000286 	andeq	r0, r0, r6, lsl #5
    3c38:	0c102302 	ldceq	3, cr2, [r0], {2}
    3c3c:	07003972 	smlsdxeq	r0, r2, r9, r3
    3c40:	0286011d 	addeq	r0, r6, #1073741831	; 0x40000007
    3c44:	23020000 	movwcs	r0, #8192	; 0x2000
    3c48:	31720c14 	cmncc	r2, r4, lsl ip
    3c4c:	1e070030 	mcrne	0, 0, r0, cr7, cr0, {1}
    3c50:	00028601 	andeq	r8, r2, r1, lsl #12
    3c54:	18230200 	stmdane	r3!, {r9}
    3c58:	3131720c 	teqcc	r1, ip, lsl #4
    3c5c:	011f0700 	tsteq	pc, r0, lsl #14
    3c60:	00000286 	andeq	r0, r0, r6, lsl #5
    3c64:	0c1c2302 	ldceq	3, cr2, [ip], {2}
    3c68:	0700726c 	streq	r7, [r0, -ip, ror #4]
    3c6c:	02860120 	addeq	r0, r6, #32, 2
    3c70:	23020000 	movwcs	r0, #8192	; 0x2000
    3c74:	5a0b0020 	bpl	2c3cfc <_flash_swap_addr+0x2844fc>
    3c78:	0400000d 	streq	r0, [r0], #-13
    3c7c:	49012a07 	stmdbmi	r1, {r0, r1, r2, r9, fp, sp}
    3c80:	0c000003 	stceq	0, cr0, [r0], {3}
    3c84:	00333172 	eorseq	r3, r3, r2, ror r1
    3c88:	49012b07 	stmdbmi	r1, {r0, r1, r2, r8, r9, fp, sp}
    3c8c:	02000003 	andeq	r0, r0, #3
    3c90:	09000023 	stmdbeq	r0, {r0, r1, r5}
    3c94:	00029e04 	andeq	r9, r2, r4, lsl #28
    3c98:	00f30d00 	rscseq	r0, r3, r0, lsl #26
    3c9c:	82050000 	andhi	r0, r5, #0
    3ca0:	1000000d 	andne	r0, r0, sp
    3ca4:	038b2508 	orreq	r2, fp, #8, 10	; 0x2000000
    3ca8:	06060000 	streq	r0, [r6], -r0
    3cac:	0800000d 	stmdaeq	r0, {r0, r2, r3}
    3cb0:	00025926 	andeq	r5, r2, r6, lsr #18
    3cb4:	00230200 	eoreq	r0, r3, r0, lsl #4
    3cb8:	000eb406 	andeq	fp, lr, r6, lsl #8
    3cbc:	53280800 	teqpl	r8, #0, 16
    3cc0:	02000002 	andeq	r0, r0, #2
    3cc4:	42060823 	andmi	r0, r6, #2293760	; 0x230000
    3cc8:	0800000e 	stmdaeq	r0, {r1, r2, r3}
    3ccc:	00038b2a 	andeq	r8, r3, sl, lsr #22
    3cd0:	0c230200 	sfmeq	f0, 4, [r3], #-0
    3cd4:	54040900 	strpl	r0, [r4], #-2304	; 0xfffff700
    3cd8:	03000003 	movweq	r0, #3
    3cdc:	00000d82 	andeq	r0, r0, r2, lsl #27
    3ce0:	03542c08 	cmpeq	r4, #8, 24	; 0x800
    3ce4:	22030000 	andcs	r0, r3, #0
    3ce8:	09000011 	stmdbeq	r0, {r0, r4}
    3cec:	0003a725 	andeq	sl, r3, r5, lsr #14
    3cf0:	ad040900 	stcge	9, cr0, [r4, #-0]
    3cf4:	0e000003 	cdpeq	0, 0, cr0, cr0, cr3, {0}
    3cf8:	00029101 	andeq	r9, r2, r1, lsl #2
    3cfc:	0003bd00 	andeq	fp, r3, r0, lsl #26
    3d00:	00300f00 	eorseq	r0, r0, r0, lsl #30
    3d04:	03000000 	movweq	r0, #0
    3d08:	000011a5 	andeq	r1, r0, r5, lsr #3
    3d0c:	03c82d0a 	biceq	r2, r8, #640	; 0x280
    3d10:	10050000 	andne	r0, r5, r0
    3d14:	20000012 	andcs	r0, r0, r2, lsl r0
    3d18:	03ff400a 	mvnseq	r4, #10
    3d1c:	b8060000 	stmdalt	r6, {}	; <UNPREDICTABLE>
    3d20:	0a000011 	beq	3d6c <_data_load+0x107c>
    3d24:	00039c41 	andeq	r9, r3, r1, asr #24
    3d28:	00230200 	eoreq	r0, r3, r0, lsl #4
    3d2c:	00112f06 	andseq	r2, r1, r6, lsl #30
    3d30:	1e430a00 	vmlane.f32	s1, s6, s0
    3d34:	02000004 	andeq	r0, r0, #4
    3d38:	3c060823 	stccc	8, cr0, [r6], {35}	; 0x23
    3d3c:	0a000011 	beq	3d88 <_data_load+0x1098>
    3d40:	00039145 	andeq	r9, r3, r5, asr #2
    3d44:	10230200 	eorne	r0, r3, r0, lsl #4
    3d48:	0a041000 	beq	107d50 <_flash_swap_addr+0xc8550>
    3d4c:	00041e35 	andeq	r1, r4, r5, lsr lr
    3d50:	11b31100 			; <UNDEFINED> instruction: 0x11b31100
    3d54:	360a0000 	strcc	r0, [sl], -r0
    3d58:	0000043f 	andeq	r0, r0, pc, lsr r4
    3d5c:	0012ee11 	andseq	lr, r2, r1, lsl lr
    3d60:	45370a00 	ldrmi	r0, [r7, #-2560]!	; 0xfffff600
    3d64:	00000004 	andeq	r0, r0, r4
    3d68:	0011c312 	andseq	ip, r1, r2, lsl r3
    3d6c:	320a0800 	andcc	r0, sl, #0, 16
    3d70:	0000043f 	andeq	r0, r0, pc, lsr r4
    3d74:	00118411 	andseq	r8, r1, r1, lsl r4
    3d78:	93330a00 	teqls	r3, #0, 20
    3d7c:	13000002 	movwne	r0, #2
    3d80:	3a0a0068 	bcc	283f28 <_flash_swap_addr+0x244728>
    3d84:	0000044b 	andeq	r0, r0, fp, asr #8
    3d88:	1e040900 	cdpne	9, 0, cr0, cr4, cr0, {0}
    3d8c:	09000004 	stmdbeq	r0, {r2}
    3d90:	0003bd04 	andeq	fp, r3, r4, lsl #26
    3d94:	0a080800 	beq	205d9c <_flash_swap_addr+0x1c659c>
    3d98:	00046e34 	andeq	r6, r4, r4, lsr lr
    3d9c:	00750700 	rsbseq	r0, r5, r0, lsl #14
    3da0:	03ff380a 	mvnseq	r3, #655360	; 0xa0000
    3da4:	23020000 	movwcs	r0, #8192	; 0x2000
    3da8:	11a00600 	lslne	r0, r0, #12
    3dac:	390a0000 	stmdbcc	sl, {}	; <UNPREDICTABLE>
    3db0:	00000030 	andeq	r0, r0, r0, lsr r0
    3db4:	00042302 	andeq	r2, r4, r2, lsl #6
    3db8:	8f060410 	svchi	0x00060410
    3dbc:	000004a3 	andeq	r0, r0, r3, lsr #9
    3dc0:	000c9411 	andeq	r9, ip, r1, lsl r4
    3dc4:	dd960600 	ldcle	6, cr0, [r6]
    3dc8:	11000000 	mrsne	r0, (UNDEF: 0)
    3dcc:	00000cd9 	ldrdeq	r0, [r0], -r9
    3dd0:	00dd9d06 	sbcseq	r9, sp, r6, lsl #26
    3dd4:	94110000 	ldrls	r0, [r1], #-0
    3dd8:	0600000e 	streq	r0, [r0], -lr
    3ddc:	000291a4 	andeq	r9, r2, r4, lsr #3
    3de0:	0e0c1100 	adfeqe	f1, f4, f0
    3de4:	ab060000 	blge	183dec <_flash_swap_addr+0x1445ec>
    3de8:	000000e8 	andeq	r0, r0, r8, ror #1
    3dec:	a9040900 	stmdbge	r4, {r8, fp}
    3df0:	14000004 	strne	r0, [r0], #-4
    3df4:	000004ae 	andeq	r0, r0, lr, lsr #9
    3df8:	c1080104 	tstgt	r8, r4, lsl #2
    3dfc:	09000001 	stmdbeq	r0, {r0}
    3e00:	00039104 	andeq	r9, r3, r4, lsl #2
    3e04:	06011500 	streq	r1, [r1], -r0, lsl #10
    3e08:	01000013 	tsteq	r0, r3, lsl r0
    3e0c:	20900144 	addscs	r0, r0, r4, asr #2
    3e10:	20cc0000 	sbccs	r0, ip, r0
    3e14:	10100000 	andsne	r0, r0, r0
    3e18:	01160000 	tsteq	r6, r0
    3e1c:	0000129f 	muleq	r0, pc, r2	; <UNPREDICTABLE>
    3e20:	d0015c01 	andle	r5, r1, r1, lsl #24
    3e24:	28000020 	stmdacs	r0, {r5}
    3e28:	30000021 	andcc	r0, r0, r1, lsr #32
    3e2c:	21000010 	tstcs	r0, r0, lsl r0
    3e30:	17000005 	strne	r0, [r0, -r5]
    3e34:	00001136 	andeq	r1, r0, r6, lsr r1
    3e38:	04455c01 	strbeq	r5, [r5], #-3073	; 0xfffff3ff
    3e3c:	91020000 	mrsls	r0, (UNDEF: 2)
    3e40:	7562186c 	strbvc	r1, [r2, #-2156]!	; 0xfffff794
    3e44:	5c010066 	stcpl	0, cr0, [r1], {102}	; 0x66
    3e48:	00000291 	muleq	r0, r1, r2
    3e4c:	17689102 	strbne	r9, [r8, -r2, lsl #2]!
    3e50:	000011a0 	andeq	r1, r0, r0, lsr #3
    3e54:	00305c01 	eorseq	r5, r0, r1, lsl #24
    3e58:	91020000 	mrsls	r0, (UNDEF: 2)
    3e5c:	70681964 	rsbvc	r1, r8, r4, ror #18
    3e60:	3f5d0100 	svccc	0x005d0100
    3e64:	02000004 	andeq	r0, r0, #4
    3e68:	1a007491 	bne	210b4 <_data_load+0x1e3c4>
    3e6c:	0012da01 	andseq	sp, r2, r1, lsl #20
    3e70:	017d0100 	cmneq	sp, r0, lsl #2
    3e74:	00000291 	muleq	r0, r1, r2
    3e78:	00002130 	andeq	r2, r0, r0, lsr r1
    3e7c:	00002224 	andeq	r2, r0, r4, lsr #4
    3e80:	0000105c 	andeq	r1, r0, ip, asr r0
    3e84:	00000582 	andeq	r0, r0, r2, lsl #11
    3e88:	00113617 	andseq	r3, r1, r7, lsl r6
    3e8c:	457d0100 	ldrbmi	r0, [sp, #-256]!	; 0xffffff00
    3e90:	02000004 	andeq	r0, r0, #4
    3e94:	a0176491 	mulsge	r7, r1, r4
    3e98:	01000011 	tsteq	r0, r1, lsl r0
    3e9c:	0000307d 	andeq	r3, r0, sp, ror r0
    3ea0:	60910200 	addsvs	r0, r1, r0, lsl #4
    3ea4:	00707119 	rsbseq	r7, r0, r9, lsl r1
    3ea8:	043f7e01 	ldrteq	r7, [pc], #-3585	; 3eb0 <_data_load+0x11c0>
    3eac:	91020000 	mrsls	r0, (UNDEF: 2)
    3eb0:	70681974 	rsbvc	r1, r8, r4, ror r9
    3eb4:	3f7e0100 	svccc	0x007e0100
    3eb8:	02000004 	andeq	r0, r0, #4
    3ebc:	66197091 			; <UNDEFINED> instruction: 0x66197091
    3ec0:	7e010070 	mcrvc	0, 0, r0, cr1, cr0, {3}
    3ec4:	0000043f 	andeq	r0, r0, pc, lsr r4
    3ec8:	006c9102 	rsbeq	r9, ip, r2, lsl #2
    3ecc:	12aa0116 	adcne	r0, sl, #-2147483643	; 0x80000005
    3ed0:	bb010000 	bllt	43ed8 <_flash_swap_addr+0x46d8>
    3ed4:	00223001 	eoreq	r3, r2, r1
    3ed8:	00231800 	eoreq	r1, r3, r0, lsl #16
    3edc:	00108800 	andseq	r8, r0, r0, lsl #16
    3ee0:	0005d000 	andeq	sp, r5, r0
    3ee4:	00701800 	rsbseq	r1, r0, r0, lsl #16
    3ee8:	0291bb01 	addseq	fp, r1, #1024	; 0x400
    3eec:	91020000 	mrsls	r0, (UNDEF: 2)
    3ef0:	70711964 	rsbsvc	r1, r1, r4, ror #18
    3ef4:	3fbc0100 	svccc	0x00bc0100
    3ef8:	02000004 	andeq	r0, r0, #4
    3efc:	68197491 	ldmdavs	r9, {r0, r4, r7, sl, ip, sp, lr}
    3f00:	bc010070 	stclt	0, cr0, [r1], {112}	; 0x70
    3f04:	0000043f 	andeq	r0, r0, pc, lsr r4
    3f08:	1b709102 	blne	1c28318 <_flash_swap_addr+0x1be8b18>
    3f0c:	00001136 	andeq	r1, r0, r6, lsr r1
    3f10:	0445bd01 	strbeq	fp, [r5], #-3329	; 0xfffff2ff
    3f14:	91020000 	mrsls	r0, (UNDEF: 2)
    3f18:	011a006c 	tsteq	sl, ip, rrx
    3f1c:	000012f3 	strdeq	r1, [r0], -r3
    3f20:	3001f301 	andcc	pc, r1, r1, lsl #6
    3f24:	20000000 	andcs	r0, r0, r0
    3f28:	94000023 	strls	r0, [r0], #-35	; 0xffffffdd
    3f2c:	b4000023 	strlt	r0, [r0], #-35	; 0xffffffdd
    3f30:	30000010 	andcc	r0, r0, r0, lsl r0
    3f34:	17000006 	strne	r0, [r0, -r6]
    3f38:	00001136 	andeq	r1, r0, r6, lsr r1
    3f3c:	0445f301 	strbeq	pc, [r5], #-769	; 0xfffffcff	; <UNPREDICTABLE>
    3f40:	91020000 	mrsls	r0, (UNDEF: 2)
    3f44:	13001764 	movwne	r1, #1892	; 0x764
    3f48:	f3010000 	vhadd.u8	d0, d1, d0
    3f4c:	00000630 	andeq	r0, r0, r0, lsr r6
    3f50:	19609102 	stmdbne	r0!, {r1, r8, ip, pc}^
    3f54:	01007071 	tsteq	r0, r1, ror r0
    3f58:	00043ff4 	strdeq	r3, [r4], -r4
    3f5c:	74910200 	ldrvc	r0, [r1], #512	; 0x200
    3f60:	01006e19 	tsteq	r0, r9, lsl lr
    3f64:	000030f5 	strdeq	r3, [r0], -r5
    3f68:	70910200 	addsvc	r0, r1, r0, lsl #4
    3f6c:	007a7319 	rsbseq	r7, sl, r9, lsl r3
    3f70:	0030f501 	eorseq	pc, r0, r1, lsl #10
    3f74:	91020000 	mrsls	r0, (UNDEF: 2)
    3f78:	0409006c 	streq	r0, [r9], #-108	; 0xffffff94
    3f7c:	00000030 	andeq	r0, r0, r0, lsr r0
    3f80:	0012e61b 	andseq	lr, r2, fp, lsl r6
    3f84:	bd3d0100 	ldflts	f0, [sp, #-0]
    3f88:	05000003 	streq	r0, [r0, #-3]
    3f8c:	00073003 	andeq	r3, r7, r3
    3f90:	02e80020 	rsceq	r0, r8, #32
    3f94:	00020000 	andeq	r0, r2, r0
    3f98:	00000f8f 	andeq	r0, r0, pc, lsl #31
    3f9c:	02870104 	addeq	r0, r7, #4, 2
    3fa0:	45010000 	strmi	r0, [r1, #-0]
    3fa4:	16000013 			; <UNDEFINED> instruction: 0x16000013
    3fa8:	00000002 	andeq	r0, r0, r2
    3fac:	00000000 	andeq	r0, r0, r0
    3fb0:	a8000000 	stmdage	r0, {}	; <UNPREDICTABLE>
    3fb4:	44000001 	strmi	r0, [r0], #-1
    3fb8:	02000015 	andeq	r0, r0, #21
    3fbc:	6e690504 	cdpvs	5, 6, cr0, cr9, cr4, {0}
    3fc0:	2e030074 	mcrcs	0, 0, r0, cr3, cr4, {3}
    3fc4:	02000010 	andeq	r0, r0, #16
    3fc8:	00003bd4 	ldrdeq	r3, [r0], -r4
    3fcc:	07040400 	streq	r0, [r4, -r0, lsl #8]
    3fd0:	000001ed 	andeq	r0, r0, sp, ror #3
    3fd4:	ba060104 	blt	1843ec <_flash_swap_addr+0x144bec>
    3fd8:	03000001 	movweq	r0, #1
    3fdc:	00000a33 	andeq	r0, r0, r3, lsr sl
    3fe0:	00542a03 	subseq	r2, r4, r3, lsl #20
    3fe4:	01040000 	mrseq	r0, (UNDEF: 4)
    3fe8:	0001b808 	andeq	fp, r1, r8, lsl #16
    3fec:	05020400 	streq	r0, [r2, #-1024]	; 0xfffffc00
    3ff0:	00000031 	andeq	r0, r0, r1, lsr r0
    3ff4:	6a070204 	bvs	1c480c <_flash_swap_addr+0x18500c>
    3ff8:	04000002 	streq	r0, [r0], #-2
    3ffc:	00f70504 	rscseq	r0, r7, r4, lsl #10
    4000:	ff030000 			; <UNDEFINED> instruction: 0xff030000
    4004:	03000002 	movweq	r0, #2
    4008:	00007b50 	andeq	r7, r0, r0, asr fp
    400c:	07040400 	streq	r0, [r4, -r0, lsl #8]
    4010:	000001e8 	andeq	r0, r0, r8, ror #3
    4014:	f2050804 	vadd.i8	d0, d5, d4
    4018:	04000000 	streq	r0, [r0], #-0
    401c:	01e30708 	mvneq	r0, r8, lsl #14
    4020:	04050000 	streq	r0, [r5], #-0
    4024:	00112203 	andseq	r2, r1, r3, lsl #4
    4028:	9d250400 	cfstrsls	mvf0, [r5, #-0]
    402c:	06000000 	streq	r0, [r0], -r0
    4030:	0000a304 	andeq	sl, r0, r4, lsl #6
    4034:	90010700 	andls	r0, r1, r0, lsl #14
    4038:	b3000000 	movwlt	r0, #0
    403c:	08000000 	stmdaeq	r0, {}	; <UNPREDICTABLE>
    4040:	00000030 	andeq	r0, r0, r0, lsr r0
    4044:	12040900 	andne	r0, r4, #0, 18
    4048:	05040000 	streq	r0, [r4, #-0]
    404c:	0000ce25 	andeq	ip, r0, r5, lsr #28
    4050:	11b00a00 	lslsne	r0, r0, #20
    4054:	26050000 	strcs	r0, [r5], -r0
    4058:	000000ce 	andeq	r0, r0, lr, asr #1
    405c:	00002302 	andeq	r2, r0, r2, lsl #6
    4060:	00b30406 	adcseq	r0, r3, r6, lsl #8
    4064:	0c0b0000 	stceq	0, cr0, [fp], {-0}
    4068:	01072d05 	tsteq	r7, r5, lsl #26
    406c:	560a0000 	strpl	r0, [sl], -r0
    4070:	05000011 	streq	r0, [r0, #-17]	; 0xffffffef
    4074:	0000ce2e 	andeq	ip, r0, lr, lsr #28
    4078:	00230200 	eoreq	r0, r3, r0, lsl #4
    407c:	0011960a 	andseq	r9, r1, sl, lsl #12
    4080:	302f0500 	eorcc	r0, pc, r0, lsl #10
    4084:	02000000 	andeq	r0, r0, #0
    4088:	780a0423 	stmdavc	sl, {r0, r1, r5, sl}
    408c:	05000011 	streq	r0, [r0, #-17]	; 0xffffffef
    4090:	00009231 	andeq	r9, r0, r1, lsr r2
    4094:	08230200 	stmdaeq	r3!, {r9}
    4098:	116d0300 	cmnne	sp, r0, lsl #6
    409c:	33050000 	movwcc	r0, #20480	; 0x5000
    40a0:	000000d4 	ldrdeq	r0, [r0], -r4
    40a4:	c1080104 	tstgt	r8, r4, lsl #2
    40a8:	0c000001 	stceq	0, cr0, [r0], {1}
    40ac:	00137a01 	andseq	r7, r3, r1, lsl #20
    40b0:	01390100 	teqeq	r9, r0, lsl #2
    40b4:	000023a0 	andeq	r2, r0, r0, lsr #7
    40b8:	000023ca 	andeq	r2, r0, sl, asr #7
    40bc:	000010e0 	andeq	r1, r0, r0, ror #1
    40c0:	0000015c 	andeq	r0, r0, ip, asr r1
    40c4:	00706d0d 	rsbseq	r6, r0, sp, lsl #26
    40c8:	015c3901 	cmpeq	ip, r1, lsl #18
    40cc:	91020000 	mrsls	r0, (UNDEF: 2)
    40d0:	11a00e7c 	rorne	r0, ip, lr
    40d4:	39010000 	stmdbcc	r1, {}	; <UNPREDICTABLE>
    40d8:	00000030 	andeq	r0, r0, r0, lsr r0
    40dc:	0e789102 	expeqe	f1, f2
    40e0:	000011ba 			; <UNDEFINED> instruction: 0x000011ba
    40e4:	00923901 	addseq	r3, r2, r1, lsl #18
    40e8:	91020000 	mrsls	r0, (UNDEF: 2)
    40ec:	04060074 	streq	r0, [r6], #-116	; 0xffffff8c
    40f0:	00000107 	andeq	r0, r0, r7, lsl #2
    40f4:	1311010c 	tstne	r1, #12, 2
    40f8:	4f010000 	svcmi	0x00010000
    40fc:	0023d001 	eoreq	sp, r3, r1
    4100:	00240a00 	eoreq	r0, r4, r0, lsl #20
    4104:	00110000 	andseq	r0, r1, r0
    4108:	0001a100 	andeq	sl, r1, r0, lsl #2
    410c:	706d0d00 	rsbvc	r0, sp, r0, lsl #26
    4110:	5c4f0100 	stfple	f0, [pc], {-0}
    4114:	02000001 	andeq	r0, r0, #1
    4118:	700d7491 	mulvc	sp, r1, r4
    411c:	904f0100 	subls	r0, pc, r0, lsl #2
    4120:	02000000 	andeq	r0, r0, #0
    4124:	6e0d7091 	mcrvs	0, 0, r7, cr13, cr1, {4}
    4128:	304f0100 	subcc	r0, pc, r0, lsl #2
    412c:	02000000 	andeq	r0, r0, #0
    4130:	0f006c91 	svceq	0x00006c91
    4134:	00133801 	andseq	r3, r3, r1, lsl #16
    4138:	01640100 	cmneq	r4, r0, lsl #2
    413c:	00000090 	muleq	r0, r0, r0
    4140:	00002410 	andeq	r2, r0, r0, lsl r4
    4144:	0000244c 	andeq	r2, r0, ip, asr #8
    4148:	0000112c 	andeq	r1, r0, ip, lsr #2
    414c:	000001da 	ldrdeq	r0, [r0], -sl
    4150:	00706d0d 	rsbseq	r6, r0, sp, lsl #26
    4154:	015c6401 	cmpeq	ip, r1, lsl #8
    4158:	91020000 	mrsls	r0, (UNDEF: 2)
    415c:	0e96106c 	cdpeq	0, 9, cr1, cr6, cr12, {3}
    4160:	65010000 	strvs	r0, [r1, #-0]
    4164:	00000090 	muleq	r0, r0, r0
    4168:	00749102 	rsbseq	r9, r4, r2, lsl #2
    416c:	136e010f 	cmnne	lr, #-1073741821	; 0xc0000003
    4170:	7b010000 	blvc	44178 <_flash_swap_addr+0x4978>
    4174:	00009001 	andeq	r9, r0, r1
    4178:	00245000 	eoreq	r5, r4, r0
    417c:	00247600 	eoreq	r7, r4, r0, lsl #12
    4180:	00115800 	andseq	r5, r1, r0, lsl #16
    4184:	00024500 	andeq	r4, r2, r0, lsl #10
    4188:	706d0d00 	rsbvc	r0, sp, r0, lsl #26
    418c:	5c7b0100 	ldfple	f0, [fp], #-0
    4190:	02000001 	andeq	r0, r0, #1
    4194:	96106c91 			; <UNDEFINED> instruction: 0x96106c91
    4198:	0100000e 	tsteq	r0, lr
    419c:	0000907c 	andeq	r9, r0, ip, ror r0
    41a0:	74910200 	ldrvc	r0, [r1], #512	; 0x200
    41a4:	00245611 	eoreq	r5, r4, r1, lsl r6
    41a8:	00245e00 	eoreq	r5, r4, r0, lsl #28
    41ac:	00022d00 	andeq	r2, r2, r0, lsl #26
    41b0:	6d741200 	lfmvs	f1, 2, [r4, #-0]
    41b4:	7e010070 	mcrvc	0, 0, r0, cr1, cr0, {3}
    41b8:	00000070 	andeq	r0, r0, r0, ror r0
    41bc:	13005301 	movwne	r5, #769	; 0x301
    41c0:	00002466 	andeq	r2, r0, r6, ror #8
    41c4:	0000246e 	andeq	r2, r0, lr, ror #8
    41c8:	706d7412 	rsbvc	r7, sp, r2, lsl r4
    41cc:	70800100 	addvc	r0, r0, r0, lsl #2
    41d0:	01000000 	mrseq	r0, (UNDEF: 0)
    41d4:	0c000053 	stceq	0, cr0, [r0], {83}	; 0x53
    41d8:	00132101 	andseq	r2, r3, r1, lsl #2
    41dc:	01900100 	orrseq	r0, r0, r0, lsl #2
    41e0:	00002480 	andeq	r2, r0, r0, lsl #9
    41e4:	000024a6 	andeq	r2, r0, r6, lsr #9
    41e8:	00001184 	andeq	r1, r0, r4, lsl #3
    41ec:	00000288 	andeq	r0, r0, r8, lsl #5
    41f0:	00706d0d 	rsbseq	r6, r0, sp, lsl #26
    41f4:	015c9001 	cmpeq	ip, r1
    41f8:	91020000 	mrsls	r0, (UNDEF: 2)
    41fc:	0e960e74 	mrceq	14, 4, r0, cr6, cr4, {3}
    4200:	90010000 	andls	r0, r1, r0
    4204:	00000090 	muleq	r0, r0, r0
    4208:	12709102 	rsbsne	r9, r0, #-2147483648	; 0x80000000
    420c:	00706870 	rsbseq	r6, r0, r0, ror r8
    4210:	00ce9101 	sbceq	r9, lr, r1, lsl #2
    4214:	91020000 	mrsls	r0, (UNDEF: 2)
    4218:	0114007c 	tsteq	r4, ip, ror r0
    421c:	0000132d 	andeq	r1, r0, sp, lsr #6
    4220:	b001a601 	andlt	sl, r1, r1, lsl #12
    4224:	d4000024 	strle	r0, [r0], #-36	; 0xffffffdc
    4228:	a4000024 	strge	r0, [r0], #-36	; 0xffffffdc
    422c:	0d000011 	stceq	0, cr0, [r0, #-68]	; 0xffffffbc
    4230:	0100706d 	tsteq	r0, sp, rrx
    4234:	00015ca6 	andeq	r5, r1, r6, lsr #25
    4238:	74910200 	ldrvc	r0, [r1], #512	; 0x200
    423c:	000e960e 	andeq	r9, lr, lr, lsl #12
    4240:	90a60100 	adcls	r0, r6, r0, lsl #2
    4244:	02000000 	andeq	r0, r0, #0
    4248:	b8117091 	ldmdalt	r1, {r0, r4, r7, ip, sp, lr}
    424c:	c0000024 	andgt	r0, r0, r4, lsr #32
    4250:	d3000024 	movwle	r0, #36	; 0x24
    4254:	12000002 	andne	r0, r0, #2
    4258:	00706d74 	rsbseq	r6, r0, r4, ror sp
    425c:	0070a801 	rsbseq	sl, r0, r1, lsl #16
    4260:	53010000 	movwpl	r0, #4096	; 0x1000
    4264:	24c81300 	strbcs	r1, [r8], #768	; 0x300
    4268:	24d00000 	ldrbcs	r0, [r0], #0
    426c:	74120000 	ldrvc	r0, [r2], #-0
    4270:	0100706d 	tsteq	r0, sp, rrx
    4274:	000070aa 	andeq	r7, r0, sl, lsr #1
    4278:	00530100 	subseq	r0, r3, r0, lsl #2
    427c:	07dd0000 	ldrbeq	r0, [sp, r0]
    4280:	00020000 	andeq	r0, r2, r0
    4284:	000010aa 	andeq	r1, r0, sl, lsr #1
    4288:	02870104 	addeq	r0, r7, #4, 2
    428c:	85010000 	strhi	r0, [r1, #-0]
    4290:	16000013 			; <UNDEFINED> instruction: 0x16000013
    4294:	00000002 	andeq	r0, r0, r2
    4298:	00000000 	andeq	r0, r0, r0
    429c:	e0000000 	and	r0, r0, r0
    42a0:	5e000001 	cdppl	0, 0, cr0, cr0, cr1, {0}
    42a4:	02000017 	andeq	r0, r0, #23
    42a8:	6e690504 	cdpvs	5, 6, cr0, cr9, cr4, {0}
    42ac:	04030074 	streq	r0, [r3], #-116	; 0xffffff8c
    42b0:	0001ed07 	andeq	lr, r1, r7, lsl #26
    42b4:	06010300 	streq	r0, [r1], -r0, lsl #6
    42b8:	000001ba 			; <UNDEFINED> instruction: 0x000001ba
    42bc:	000a3304 	andeq	r3, sl, r4, lsl #6
    42c0:	492a0200 	stmdbmi	sl!, {r9}
    42c4:	03000000 	movweq	r0, #0
    42c8:	01b80801 			; <UNDEFINED> instruction: 0x01b80801
    42cc:	02030000 	andeq	r0, r3, #0
    42d0:	00003105 	andeq	r3, r0, r5, lsl #2
    42d4:	07020300 	streq	r0, [r2, -r0, lsl #6]
    42d8:	0000026a 	andeq	r0, r0, sl, ror #4
    42dc:	00030004 	andeq	r0, r3, r4
    42e0:	694f0200 	stmdbvs	pc, {r9}^	; <UNPREDICTABLE>
    42e4:	03000000 	movweq	r0, #0
    42e8:	00f70504 	rscseq	r0, r7, r4, lsl #10
    42ec:	ff040000 			; <UNDEFINED> instruction: 0xff040000
    42f0:	02000002 	andeq	r0, r0, #2
    42f4:	00007b50 	andeq	r7, r0, r0, asr fp
    42f8:	07040300 	streq	r0, [r4, -r0, lsl #6]
    42fc:	000001e8 	andeq	r0, r0, r8, ror #3
    4300:	f2050803 	vadd.i8	d0, d5, d3
    4304:	03000000 	movweq	r0, #0
    4308:	01e30708 	mvneq	r0, r8, lsl #14
    430c:	62040000 	andvs	r0, r4, #0
    4310:	0300000d 	movweq	r0, #13
    4314:	00003e28 	andeq	r3, r0, r8, lsr #28
    4318:	0d180400 	cfldrseq	mvf0, [r8, #-0]
    431c:	29030000 	stmdbcs	r3, {}	; <UNPREDICTABLE>
    4320:	0000003e 	andeq	r0, r0, lr, lsr r0
    4324:	000dd204 	andeq	sp, sp, r4, lsl #4
    4328:	3e2a0300 	cdpcc	3, 2, cr0, cr10, cr0, {0}
    432c:	04000000 	streq	r0, [r0], #-0
    4330:	00000d0e 	andeq	r0, r0, lr, lsl #26
    4334:	003e2b03 	eorseq	r2, lr, r3, lsl #22
    4338:	e1040000 	mrs	r0, (UNDEF: 4)
    433c:	0300000d 	movweq	r0, #13
    4340:	0000702c 	andeq	r7, r0, ip, lsr #32
    4344:	041f0400 	ldreq	r0, [pc], #-1024	; 434c <_data_load+0x165c>
    4348:	2d030000 	stccs	0, cr0, [r3, #-0]
    434c:	0000005e 	andeq	r0, r0, lr, asr r0
    4350:	000d7604 	andeq	r7, sp, r4, lsl #12
    4354:	702f0300 	eorvc	r0, pc, r0, lsl #6
    4358:	04000000 	streq	r0, [r0], #-0
    435c:	0000027d 	andeq	r0, r0, sp, ror r2
    4360:	00703103 	rsbseq	r3, r0, r3, lsl #2
    4364:	1b040000 	blne	10436c <_flash_swap_addr+0xc4b6c>
    4368:	0400000e 	streq	r0, [r0], #-14
    436c:	0000f323 	andeq	pc, r0, r3, lsr #6
    4370:	0e1b0500 	cfmul32eq	mvfx0, mvfx11, mvfx0
    4374:	05480000 	strbeq	r0, [r8, #-0]
    4378:	00021857 	andeq	r1, r2, r7, asr r8
    437c:	11570600 	cmpne	r7, r0, lsl #12
    4380:	58050000 	stmdapl	r5, {}	; <UNPREDICTABLE>
    4384:	0000023d 	andeq	r0, r0, sp, lsr r2
    4388:	06002302 	streq	r2, [r0], -r2, lsl #6
    438c:	00000dda 	ldrdeq	r0, [r0], -sl
    4390:	023d5a05 	eorseq	r5, sp, #20480	; 0x5000
    4394:	23020000 	movwcs	r0, #8192	; 0x2000
    4398:	0ced0604 	stcleq	6, cr0, [sp], #16
    439c:	5c050000 	stcpl	0, cr0, [r5], {-0}
    43a0:	000000bc 	strheq	r0, [r0], -ip
    43a4:	06082302 	streq	r2, [r8], -r2, lsl #6
    43a8:	00000ebc 			; <UNDEFINED> instruction: 0x00000ebc
    43ac:	03835d05 	orreq	r5, r3, #320	; 0x140
    43b0:	23020000 	movwcs	r0, #8192	; 0x2000
    43b4:	0d21060c 	stceq	6, cr0, [r1, #-48]!	; 0xffffffd0
    43b8:	5f050000 	svcpl	0x00050000
    43bc:	0000023d 	andeq	r0, r0, sp, lsr r2
    43c0:	06102302 	ldreq	r2, [r0], -r2, lsl #6
    43c4:	00000d98 	muleq	r0, r8, sp
    43c8:	023d6005 	eorseq	r6, sp, #5
    43cc:	23020000 	movwcs	r0, #8192	; 0x2000
    43d0:	0e9b0614 	mrceq	6, 4, r0, cr11, cr4, {0}
    43d4:	67050000 	strvs	r0, [r5, -r0]
    43d8:	00000629 	andeq	r0, r0, r9, lsr #12
    43dc:	06182302 	ldreq	r2, [r8], -r2, lsl #6
    43e0:	00000df3 	strdeq	r0, [r0], -r3
    43e4:	009b7205 	addseq	r7, fp, r5, lsl #4
    43e8:	23020000 	movwcs	r0, #8192	; 0x2000
    43ec:	0e13061c 	mrceq	6, 0, r0, cr3, cr12, {0}
    43f0:	76050000 	strvc	r0, [r5], -r0
    43f4:	00000090 	muleq	r0, r0, r0
    43f8:	061d2302 	ldreq	r2, [sp], -r2, lsl #6
    43fc:	00000e7d 	andeq	r0, r0, sp, ror lr
    4400:	00a67b05 	adceq	r7, r6, r5, lsl #22
    4404:	23020000 	movwcs	r0, #8192	; 0x2000
    4408:	0dfb061e 	ldcleq	6, cr0, [fp, #120]!	; 0x78
    440c:	81050000 	mrshi	r0, (UNDEF: 5)
    4410:	000000b1 	strheq	r0, [r0], -r1
    4414:	061f2302 	ldreq	r2, [pc], -r2, lsl #6
    4418:	00000e5d 	andeq	r0, r0, sp, asr lr
    441c:	053f8805 	ldreq	r8, [pc, #-2053]!	; 3c1f <_data_load+0xf2f>
    4420:	23020000 	movwcs	r0, #8192	; 0x2000
    4424:	5f700720 	svcpl	0x00700720
    4428:	ad050075 	stcge	0, cr0, [r5, #-468]	; 0xfffffe2c
    442c:	000005f4 	strdeq	r0, [r0], -r4
    4430:	06242302 	strteq	r2, [r4], -r2, lsl #6
    4434:	00000ec2 	andeq	r0, r0, r2, asr #29
    4438:	0265b205 	rsbeq	fp, r5, #1342177280	; 0x50000000
    443c:	23020000 	movwcs	r0, #8192	; 0x2000
    4440:	0e6b0628 	cdpeq	6, 6, cr0, cr11, cr8, {1}
    4444:	b8050000 	stmdalt	r5, {}	; <UNPREDICTABLE>
    4448:	00000243 	andeq	r0, r0, r3, asr #4
    444c:	062c2302 	strteq	r2, [ip], -r2, lsl #6
    4450:	00000c8e 	andeq	r0, r0, lr, lsl #25
    4454:	00c7bc05 	sbceq	fp, r7, r5, lsl #24
    4458:	23020000 	movwcs	r0, #8192	; 0x2000
    445c:	0e220634 	mcreq	6, 1, r0, cr2, cr4, {1}
    4460:	c2050000 	andgt	r0, r5, #0
    4464:	000000d2 	ldrdeq	r0, [r0], -r2
    4468:	06382302 	ldrteq	r2, [r8], -r2, lsl #6
    446c:	00000de9 	andeq	r0, r0, r9, ror #27
    4470:	063bc905 	ldrteq	ip, [fp], -r5, lsl #18
    4474:	23020000 	movwcs	r0, #8192	; 0x2000
    4478:	0e49063c 	mcreq	6, 2, r0, cr9, cr12, {1}
    447c:	cd050000 	stcgt	0, cr0, [r5, #-0]
    4480:	000000bc 	strheq	r0, [r0], -ip
    4484:	06402302 	strbeq	r2, [r0], -r2, lsl #6
    4488:	00000cfe 	strdeq	r0, [r0], -lr
    448c:	027bd305 	rsbseq	sp, fp, #335544320	; 0x14000000
    4490:	23020000 	movwcs	r0, #8192	; 0x2000
    4494:	08080044 	stmdaeq	r8, {r2, r6}
    4498:	023d5a04 	eorseq	r5, sp, #4, 20	; 0x4000
    449c:	57060000 	strpl	r0, [r6, -r0]
    44a0:	04000011 	streq	r0, [r0], #-17	; 0xffffffef
    44a4:	00023d5b 	andeq	r3, r2, fp, asr sp
    44a8:	00230200 	eoreq	r0, r3, r0, lsl #4
    44ac:	000dda06 	andeq	sp, sp, r6, lsl #20
    44b0:	3d5d0400 	cfldrdcc	mvd0, [sp, #-0]
    44b4:	02000002 	andeq	r0, r0, #2
    44b8:	09000423 	stmdbeq	r0, {r0, r1, r5, sl}
    44bc:	0000e804 	andeq	lr, r0, r4, lsl #16
    44c0:	0da60400 	cfstrseq	mvf0, [r6]
    44c4:	5f040000 	svcpl	0x00040000
    44c8:	00000218 	andeq	r0, r0, r8, lsl r2
    44cc:	64040408 	strvs	r0, [r4], #-1032	; 0xfffffbf8
    44d0:	00000265 	andeq	r0, r0, r5, ror #4
    44d4:	00115706 	andseq	r5, r1, r6, lsl #14
    44d8:	3d660400 	cfstrdcc	mvd0, [r6, #-0]
    44dc:	02000002 	andeq	r0, r0, #2
    44e0:	04000023 	streq	r0, [r0], #-35	; 0xffffffdd
    44e4:	00000d6a 	andeq	r0, r0, sl, ror #26
    44e8:	024e6904 	subeq	r6, lr, #4, 18	; 0x10000
    44ec:	41040000 	mrsmi	r0, (UNDEF: 4)
    44f0:	0600000d 	streq	r0, [r0], -sp
    44f4:	00027bde 	ldrdeq	r7, [r2], -lr
    44f8:	05040a00 	streq	r0, [r4, #-2560]	; 0xfffff600
    44fc:	000013e9 	andeq	r1, r0, r9, ror #7
    4500:	f5e60620 			; <UNDEFINED> instruction: 0xf5e60620
    4504:	07000002 	streq	r0, [r0, -r2]
    4508:	06003072 			; <UNDEFINED> instruction: 0x06003072
    450c:	000270e7 	andeq	r7, r2, r7, ror #1
    4510:	00230200 	eoreq	r0, r3, r0, lsl #4
    4514:	00317207 	eorseq	r7, r1, r7, lsl #4
    4518:	0270e806 	rsbseq	lr, r0, #393216	; 0x60000
    451c:	23020000 	movwcs	r0, #8192	; 0x2000
    4520:	32720704 	rsbscc	r0, r2, #4, 14	; 0x100000
    4524:	70e90600 	rscvc	r0, r9, r0, lsl #12
    4528:	02000002 	andeq	r0, r0, #2
    452c:	72070823 	andvc	r0, r7, #2293760	; 0x230000
    4530:	ea060033 	b	184604 <_flash_swap_addr+0x144e04>
    4534:	00000270 	andeq	r0, r0, r0, ror r2
    4538:	070c2302 	streq	r2, [ip, -r2, lsl #6]
    453c:	00323172 	eorseq	r3, r2, r2, ror r1
    4540:	0270eb06 	rsbseq	lr, r0, #6144	; 0x1800
    4544:	23020000 	movwcs	r0, #8192	; 0x2000
    4548:	13e20610 	mvnne	r0, #16, 12	; 0x1000000
    454c:	ec060000 	stc	0, cr0, [r6], {-0}
    4550:	00000270 	andeq	r0, r0, r0, ror r2
    4554:	07142302 	ldreq	r2, [r4, -r2, lsl #6]
    4558:	06006370 			; <UNDEFINED> instruction: 0x06006370
    455c:	000270ed 	andeq	r7, r2, sp, ror #1
    4560:	18230200 	stmdane	r3!, {r9}
    4564:	00145706 	andseq	r5, r4, r6, lsl #14
    4568:	70ee0600 	rscvc	r0, lr, r0, lsl #12
    456c:	02000002 	andeq	r0, r0, #2
    4570:	0b001c23 	bleq	b604 <_data_load+0x8914>
    4574:	00000e64 	andeq	r0, r0, r4, ror #28
    4578:	01050624 	tsteq	r5, r4, lsr #12
    457c:	00000383 	andeq	r0, r0, r3, lsl #7
    4580:	0034720c 	eorseq	r7, r4, ip, lsl #4
    4584:	70011806 	andvc	r1, r1, r6, lsl #16
    4588:	02000002 	andeq	r0, r0, #2
    458c:	720c0023 	andvc	r0, ip, #35	; 0x23
    4590:	19060035 	stmdbne	r6, {r0, r2, r4, r5}
    4594:	00027001 	andeq	r7, r2, r1
    4598:	04230200 	strteq	r0, [r3], #-512	; 0xfffffe00
    459c:	0036720c 	eorseq	r7, r6, ip, lsl #4
    45a0:	70011a06 	andvc	r1, r1, r6, lsl #20
    45a4:	02000002 	andeq	r0, r0, #2
    45a8:	720c0823 	andvc	r0, ip, #2293760	; 0x230000
    45ac:	1b060037 	blne	184690 <_flash_swap_addr+0x144e90>
    45b0:	00027001 	andeq	r7, r2, r1
    45b4:	0c230200 	sfmeq	f0, 4, [r3], #-0
    45b8:	0038720c 	eorseq	r7, r8, ip, lsl #4
    45bc:	70011c06 	andvc	r1, r1, r6, lsl #24
    45c0:	02000002 	andeq	r0, r0, #2
    45c4:	720c1023 	andvc	r1, ip, #35	; 0x23
    45c8:	1d060039 	stcne	0, cr0, [r6, #-228]	; 0xffffff1c
    45cc:	00027001 	andeq	r7, r2, r1
    45d0:	14230200 	strtne	r0, [r3], #-512	; 0xfffffe00
    45d4:	3031720c 	eorscc	r7, r1, ip, lsl #4
    45d8:	011e0600 	tsteq	lr, r0, lsl #12
    45dc:	00000270 	andeq	r0, r0, r0, ror r2
    45e0:	0c182302 	ldceq	3, cr2, [r8], {2}
    45e4:	00313172 	eorseq	r3, r1, r2, ror r1
    45e8:	70011f06 	andvc	r1, r1, r6, lsl #30
    45ec:	02000002 	andeq	r0, r0, #2
    45f0:	6c0c1c23 	stcvs	12, cr1, [ip], {35}	; 0x23
    45f4:	20060072 	andcs	r0, r6, r2, ror r0
    45f8:	00027001 	andeq	r7, r2, r1
    45fc:	20230200 	eorcs	r0, r3, r0, lsl #4
    4600:	0d5a0b00 	vldreq	d16, [sl, #-0]
    4604:	06040000 	streq	r0, [r4], -r0
    4608:	03a0012a 	moveq	r0, #-2147483638	; 0x8000000a
    460c:	720c0000 	andvc	r0, ip, #0
    4610:	06003331 			; <UNDEFINED> instruction: 0x06003331
    4614:	03a0012b 	moveq	r0, #-1073741814	; 0xc000000a
    4618:	23020000 	movwcs	r0, #8192	; 0x2000
    461c:	04090000 	streq	r0, [r9], #-0
    4620:	000002f5 	strdeq	r0, [r0], -r5
    4624:	00007b0d 	andeq	r7, r0, sp, lsl #22
    4628:	078c0800 	streq	r0, [ip, r0, lsl #16]
    462c:	0004db82 	andeq	sp, r4, r2, lsl #23
    4630:	14460600 	strbne	r0, [r6], #-1536	; 0xfffffa00
    4634:	83070000 	movwhi	r0, #28672	; 0x7000
    4638:	000003a6 	andeq	r0, r0, r6, lsr #7
    463c:	06002302 	streq	r2, [r0], -r2, lsl #6
    4640:	00001418 	andeq	r1, r0, r8, lsl r4
    4644:	03a68407 			; <UNDEFINED> instruction: 0x03a68407
    4648:	23020000 	movwcs	r0, #8192	; 0x2000
    464c:	13fd0604 	mvnsne	r0, #4, 12	; 0x400000
    4650:	85070000 	strhi	r0, [r7, #-0]
    4654:	000003a6 	andeq	r0, r0, r6, lsr #7
    4658:	06082302 	streq	r2, [r8], -r2, lsl #6
    465c:	0000141d 	andeq	r1, r0, sp, lsl r4
    4660:	03a68607 			; <UNDEFINED> instruction: 0x03a68607
    4664:	23020000 	movwcs	r0, #8192	; 0x2000
    4668:	4353070c 	cmpmi	r3, #12, 14	; 0x300000
    466c:	87070052 	smlsdhi	r7, r2, r0, r0
    4670:	000003a6 	andeq	r0, r0, r6, lsr #7
    4674:	07102302 	ldreq	r2, [r0, -r2, lsl #6]
    4678:	00524343 	subseq	r4, r2, r3, asr #6
    467c:	03a68807 			; <UNDEFINED> instruction: 0x03a68807
    4680:	23020000 	movwcs	r0, #8192	; 0x2000
    4684:	146e0614 	strbtne	r0, [lr], #-1556	; 0xfffff9ec
    4688:	89070000 	stmdbhi	r7, {}	; <UNPREDICTABLE>
    468c:	000004eb 	andeq	r0, r0, fp, ror #9
    4690:	06182302 	ldreq	r2, [r8], -r2, lsl #6
    4694:	00001451 	andeq	r1, r0, r1, asr r4
    4698:	03a68a07 			; <UNDEFINED> instruction: 0x03a68a07
    469c:	23020000 	movwcs	r0, #8192	; 0x2000
    46a0:	14410624 	strbne	r0, [r1], #-1572	; 0xfffff9dc
    46a4:	8b070000 	blhi	1c46ac <_flash_swap_addr+0x184eac>
    46a8:	000003a6 	andeq	r0, r0, r6, lsr #7
    46ac:	06282302 	strteq	r2, [r8], -r2, lsl #6
    46b0:	00001489 	andeq	r1, r0, r9, lsl #9
    46b4:	03a68c07 			; <UNDEFINED> instruction: 0x03a68c07
    46b8:	23020000 	movwcs	r0, #8192	; 0x2000
    46bc:	1423062c 	strtne	r0, [r3], #-1580	; 0xfffff9d4
    46c0:	8d070000 	stchi	0, cr0, [r7, #-0]
    46c4:	000003a6 	andeq	r0, r0, r6, lsr #7
    46c8:	06302302 	ldrteq	r2, [r0], -r2, lsl #6
    46cc:	00001428 	andeq	r1, r0, r8, lsr #8
    46d0:	03a68e07 			; <UNDEFINED> instruction: 0x03a68e07
    46d4:	23020000 	movwcs	r0, #8192	; 0x2000
    46d8:	13dd0634 	bicsne	r0, sp, #52, 12	; 0x3400000
    46dc:	8f070000 	svchi	0x00070000
    46e0:	000003a6 	andeq	r0, r0, r6, lsr #7
    46e4:	06382302 	ldrteq	r2, [r8], -r2, lsl #6
    46e8:	0000145c 	andeq	r1, r0, ip, asr r4
    46ec:	03a69007 			; <UNDEFINED> instruction: 0x03a69007
    46f0:	23020000 	movwcs	r0, #8192	; 0x2000
    46f4:	4650073c 			; <UNDEFINED> instruction: 0x4650073c
    46f8:	91070052 	qaddls	r0, r2, r7
    46fc:	00000500 	andeq	r0, r0, r0, lsl #10
    4700:	07402302 	strbeq	r2, [r0, -r2, lsl #6]
    4704:	00524644 	subseq	r4, r2, r4, asr #12
    4708:	03a69207 			; <UNDEFINED> instruction: 0x03a69207
    470c:	23020000 	movwcs	r0, #8192	; 0x2000
    4710:	44410748 	strbmi	r0, [r1], #-1864	; 0xfffff8b8
    4714:	93070052 	movwls	r0, #28754	; 0x7052
    4718:	000003a6 	andeq	r0, r0, r6, lsr #7
    471c:	064c2302 	strbeq	r2, [ip], -r2, lsl #6
    4720:	00001473 	andeq	r1, r0, r3, ror r4
    4724:	05159407 	ldreq	r9, [r5, #-1031]	; 0xfffffbf9
    4728:	23020000 	movwcs	r0, #8192	; 0x2000
    472c:	41530750 	cmpmi	r3, r0, asr r7
    4730:	95070052 	strls	r0, [r7, #-82]	; 0xffffffae
    4734:	0000052a 	andeq	r0, r0, sl, lsr #10
    4738:	06602302 	strbteq	r2, [r0], -r2, lsl #6
    473c:	000009e9 	andeq	r0, r0, r9, ror #19
    4740:	052f9607 	streq	r9, [pc, #-1543]!	; 4141 <_data_load+0x1451>
    4744:	23020000 	movwcs	r0, #8192	; 0x2000
    4748:	14830674 	strne	r0, [r3], #1652	; 0x674
    474c:	97070000 	strls	r0, [r7, -r0]
    4750:	000003a6 	andeq	r0, r0, r6, lsr #7
    4754:	01882303 	orreq	r2, r8, r3, lsl #6
    4758:	007b0e00 	rsbseq	r0, fp, r0, lsl #28
    475c:	04eb0000 	strbteq	r0, [fp], #0
    4760:	300f0000 	andcc	r0, pc, r0
    4764:	02000000 	andeq	r0, r0, #0
    4768:	04db0d00 	ldrbeq	r0, [fp], #3328	; 0xd00
    476c:	7b0e0000 	blvc	384774 <_flash_swap_addr+0x344f74>
    4770:	00000000 	andeq	r0, r0, r0
    4774:	0f000005 	svceq	0x00000005
    4778:	00000030 	andeq	r0, r0, r0, lsr r0
    477c:	f00d0001 			; <UNDEFINED> instruction: 0xf00d0001
    4780:	0e000004 	cdpeq	0, 0, cr0, cr0, cr4, {0}
    4784:	0000007b 	andeq	r0, r0, fp, ror r0
    4788:	00000515 	andeq	r0, r0, r5, lsl r5
    478c:	0000300f 	andeq	r3, r0, pc
    4790:	0d000300 	stceq	3, cr0, [r0, #-0]
    4794:	00000505 	andeq	r0, r0, r5, lsl #10
    4798:	00007b0e 	andeq	r7, r0, lr, lsl #22
    479c:	00052a00 	andeq	r2, r5, r0, lsl #20
    47a0:	00300f00 	eorseq	r0, r0, r0, lsl #30
    47a4:	00040000 	andeq	r0, r4, r0
    47a8:	00051a0d 	andeq	r1, r5, sp, lsl #20
    47ac:	051a0d00 	ldreq	r0, [sl, #-3328]	; 0xfffff300
    47b0:	b4040000 	strlt	r0, [r4], #-0
    47b4:	07000013 	smladeq	r0, r3, r0, r0
    47b8:	0003ab98 	muleq	r3, r8, fp
    47bc:	00dd0d00 	sbcseq	r0, sp, r0, lsl #26
    47c0:	1c080000 	stcne	0, cr0, [r8], {-0}
    47c4:	05a15708 	streq	r5, [r1, #1800]!	; 0x708
    47c8:	2d060000 	stccs	0, cr0, [r6, #-0]
    47cc:	0800000e 	stmdaeq	r0, {r1, r2, r3}
    47d0:	00024358 	andeq	r4, r2, r8, asr r3
    47d4:	00230200 	eoreq	r0, r3, r0, lsl #4
    47d8:	000e0506 	andeq	r0, lr, r6, lsl #10
    47dc:	bc590800 	mrrclt	8, 0, r0, r9, cr0
    47e0:	02000000 	andeq	r0, r0, #0
    47e4:	a0060823 	andge	r0, r6, r3, lsr #16
    47e8:	0800000d 	stmdaeq	r0, {r0, r2, r3}
    47ec:	0003835b 	andeq	r8, r3, fp, asr r3
    47f0:	0c230200 	sfmeq	f0, 4, [r3], #-0
    47f4:	000d3906 	andeq	r3, sp, r6, lsl #18
    47f8:	3d5e0800 	ldclcc	8, cr0, [lr, #-0]
    47fc:	02000002 	andeq	r0, r0, #2
    4800:	bd061023 	stclt	0, cr1, [r6, #-140]	; 0xffffff74
    4804:	0800000d 	stmdaeq	r0, {r0, r2, r3}
    4808:	00023d5f 	andeq	r3, r2, pc, asr sp
    480c:	14230200 	strtne	r0, [r3], #-512	; 0xfffffe00
    4810:	000db306 	andeq	fp, sp, r6, lsl #6
    4814:	3d620800 	stclcc	8, cr0, [r2, #-0]
    4818:	02000002 	andeq	r0, r0, #2
    481c:	04001823 	streq	r1, [r0], #-2083	; 0xfffff7dd
    4820:	00000e84 	andeq	r0, r0, r4, lsl #29
    4824:	05446408 	strbeq	r6, [r4, #-1032]	; 0xfffffbf8
    4828:	82050000 	andhi	r0, r5, #0
    482c:	1000000d 	andne	r0, r0, sp
    4830:	05e32509 	strbeq	r2, [r3, #1289]!	; 0x509
    4834:	06060000 	streq	r0, [r6], -r0
    4838:	0900000d 	stmdbeq	r0, {r0, r2, r3}
    483c:	00024326 	andeq	r4, r2, r6, lsr #6
    4840:	00230200 	eoreq	r0, r3, r0, lsl #4
    4844:	000eb406 	andeq	fp, lr, r6, lsl #8
    4848:	3d280900 	stccc	9, cr0, [r8, #-0]
    484c:	02000002 	andeq	r0, r0, #2
    4850:	42060823 	andmi	r0, r6, #2293760	; 0x230000
    4854:	0900000e 	stmdbeq	r0, {r1, r2, r3}
    4858:	0005e32a 	andeq	lr, r5, sl, lsr #6
    485c:	0c230200 	sfmeq	f0, 4, [r3], #-0
    4860:	ac040900 	stcge	9, cr0, [r4], {-0}
    4864:	04000005 	streq	r0, [r0], #-5
    4868:	00000d82 	andeq	r0, r0, r2, lsl #27
    486c:	05ac2c09 	streq	r2, [ip, #3081]!	; 0xc09
    4870:	04100000 	ldreq	r0, [r0], #-0
    4874:	06298f05 	strteq	r8, [r9], -r5, lsl #30
    4878:	94110000 	ldrls	r0, [r1], #-0
    487c:	0500000c 	streq	r0, [r0, #-12]
    4880:	0000c796 	muleq	r0, r6, r7
    4884:	0cd91100 	ldfeqe	f1, [r9], {0}
    4888:	9d050000 	stcls	0, cr0, [r5, #-0]
    488c:	000000c7 	andeq	r0, r0, r7, asr #1
    4890:	000e9411 	andeq	r9, lr, r1, lsl r4
    4894:	7ba40500 	blvc	fe905c9c <_stack_start+0xde8f5c9c>
    4898:	11000002 	tstne	r0, r2
    489c:	00000e0c 	andeq	r0, r0, ip, lsl #28
    48a0:	00d2ab05 	sbcseq	sl, r2, r5, lsl #22
    48a4:	09000000 	stmdbeq	r0, {}	; <UNPREDICTABLE>
    48a8:	00062f04 	andeq	r2, r6, r4, lsl #30
    48ac:	06341200 	ldrteq	r1, [r4], -r0, lsl #4
    48b0:	01030000 	mrseq	r0, (UNDEF: 3)
    48b4:	0001c108 	andeq	ip, r1, r8, lsl #2
    48b8:	e9040900 	stmdb	r4, {r8, fp}
    48bc:	13000005 	movwne	r0, #5
    48c0:	0013bc01 	andseq	fp, r3, r1, lsl #24
    48c4:	01280100 	teqeq	r8, r0, lsl #2
    48c8:	000024e0 	andeq	r2, r0, r0, ror #9
    48cc:	000024fc 	strdeq	r2, [r0], -ip
    48d0:	000011d0 	ldrdeq	r1, [r0], -r0
    48d4:	0000068d 	andeq	r0, r0, sp, lsl #13
    48d8:	0024e214 	eoreq	lr, r4, r4, lsl r2
    48dc:	0024ea00 	eoreq	lr, r4, r0, lsl #20
    48e0:	00067500 	andeq	r7, r6, r0, lsl #10
    48e4:	6d741500 	cfldr64vs	mvdx1, [r4, #-0]
    48e8:	2c010070 	stccs	0, cr0, [r1], {112}	; 0x70
    48ec:	00000070 	andeq	r0, r0, r0, ror r0
    48f0:	16005301 	strne	r5, [r0], -r1, lsl #6
    48f4:	000024ee 	andeq	r2, r0, lr, ror #9
    48f8:	000024f6 	strdeq	r2, [r0], -r6
    48fc:	706d7415 	rsbvc	r7, sp, r5, lsl r4
    4900:	702e0100 	eorvc	r0, lr, r0, lsl #2
    4904:	01000000 	mrseq	r0, (UNDEF: 0)
    4908:	13000053 	movwne	r0, #83	; 0x53
    490c:	00146101 	andseq	r6, r4, r1, lsl #2
    4910:	013a0100 	teqeq	sl, r0, lsl #2
    4914:	00002500 	andeq	r2, r0, r0, lsl #10
    4918:	00002526 	andeq	r2, r0, r6, lsr #10
    491c:	000011f0 	strdeq	r1, [r0], -r0
    4920:	000006cc 	andeq	r0, r0, ip, asr #13
    4924:	00144c17 	andseq	r4, r4, r7, lsl ip
    4928:	cc3b0100 	ldfgts	f0, [fp], #-0
    492c:	02000006 	andeq	r0, r0, #6
    4930:	18167491 	ldmdane	r6, {r0, r4, r7, sl, ip, sp, lr}
    4934:	20000025 	andcs	r0, r0, r5, lsr #32
    4938:	15000025 	strne	r0, [r0, #-37]	; 0xffffffdb
    493c:	00706d74 	rsbseq	r6, r0, r4, ror sp
    4940:	00704a01 	rsbseq	r4, r0, r1, lsl #20
    4944:	53010000 	movwpl	r0, #4096	; 0x1000
    4948:	04090000 	streq	r0, [r9], #-0
    494c:	0000027d 	andeq	r0, r0, sp, ror r2
    4950:	14780118 	ldrbtne	r0, [r8], #-280	; 0xfffffee8
    4954:	6f010000 	svcvs	0x00010000
    4958:	00253001 	eoreq	r3, r5, r1
    495c:	00257800 	eoreq	r7, r5, r0, lsl #16
    4960:	00121c00 	andseq	r1, r2, r0, lsl #24
    4964:	2e011300 	cdpcs	3, 0, cr1, cr1, cr0, {0}
    4968:	01000014 	tsteq	r0, r4, lsl r0
    496c:	2580018d 	strcs	r0, [r0, #397]	; 0x18d
    4970:	263e0000 	ldrtcs	r0, [lr], -r0
    4974:	123c0000 	eorsne	r0, ip, #0
    4978:	074f0000 	strbeq	r0, [pc, -r0]
    497c:	84140000 	ldrhi	r0, [r4], #-0
    4980:	8c000025 	stchi	0, cr0, [r0], {37}	; 0x25
    4984:	1b000025 	blne	4a20 <_data_load+0x1d30>
    4988:	15000007 	strne	r0, [r0, #-7]
    498c:	00706d74 	rsbseq	r6, r0, r4, ror sp
    4990:	00708f01 	rsbseq	r8, r0, r1, lsl #30
    4994:	53010000 	movwpl	r0, #4096	; 0x1000
    4998:	259e1400 	ldrcs	r1, [lr, #1024]	; 0x400
    499c:	26300000 	ldrtcs	r0, [r0], -r0
    49a0:	07370000 	ldreq	r0, [r7, -r0]!
    49a4:	4c170000 	ldcmi	0, cr0, [r7], {-0}
    49a8:	01000014 	tsteq	r0, r4, lsl r0
    49ac:	0006cc91 	muleq	r6, r1, ip
    49b0:	74910200 	ldrvc	r0, [r1], #512	; 0x200
    49b4:	26301600 	ldrtcs	r1, [r0], -r0, lsl #12
    49b8:	26380000 	ldrtcs	r0, [r8], -r0
    49bc:	74150000 	ldrvc	r0, [r5], #-0
    49c0:	0100706d 	tsteq	r0, sp, rrx
    49c4:	000070be 	strheq	r7, [r0], -lr
    49c8:	00530100 	subseq	r0, r3, r0, lsl #2
    49cc:	02011900 	andeq	r1, r1, #0, 18
    49d0:	01000014 	tsteq	r0, r4, lsl r0
    49d4:	264001c8 	strbcs	r0, [r0], -r8, asr #3
    49d8:	26460000 	strbcs	r0, [r6], -r0
    49dc:	7d020000 	stcvc	0, cr0, [r2, #-0]
    49e0:	f0011a00 			; <UNDEFINED> instruction: 0xf0011a00
    49e4:	01000013 	tsteq	r0, r3, lsl r0
    49e8:	265001e5 	ldrbcs	r0, [r0], -r5, ror #3
    49ec:	26640000 	strbtcs	r0, [r4], -r0
    49f0:	7d020000 	stcvc	0, cr0, [r2, #-0]
    49f4:	00079600 	andeq	r9, r7, r0, lsl #12
    49f8:	746e1b00 	strbtvc	r1, [lr], #-2816	; 0xfffff500
    49fc:	e5010070 	str	r0, [r1, #-112]	; 0xffffff90
    4a00:	0000023d 	andeq	r0, r0, sp, lsr r2
    4a04:	6f1b5301 	svcvs	0x001b5301
    4a08:	01007074 	tsteq	r0, r4, ror r0
    4a0c:	00023de5 	andeq	r3, r2, r5, ror #27
    4a10:	00520100 	subseq	r0, r2, r0, lsl #2
    4a14:	13ca011a 	bicne	r0, sl, #-2147483642	; 0x80000006
    4a18:	fc010000 	stc2	0, cr0, [r1], {-0}
    4a1c:	00267001 	eoreq	r7, r6, r1
    4a20:	00268200 	eoreq	r8, r6, r0, lsl #4
    4a24:	007d0200 	rsbseq	r0, sp, r0, lsl #4
    4a28:	000007c6 	andeq	r0, r0, r6, asr #15
    4a2c:	00267016 	eoreq	r7, r6, r6, lsl r0
    4a30:	00267800 	eoreq	r7, r6, r0, lsl #16
    4a34:	6d741500 	cfldr64vs	mvdx1, [r4, #-0]
    4a38:	fe010070 	mcr2	0, 0, r0, cr1, cr0, {3}
    4a3c:	00000070 	andeq	r0, r0, r0, ror r0
    4a40:	00005301 	andeq	r5, r0, r1, lsl #6
    4a44:	000e8e1c 	andeq	r8, lr, ip, lsl lr
    4a48:	a1680800 	cmnge	r8, r0, lsl #16
    4a4c:	01000005 	tsteq	r0, r5
    4a50:	0e8e1c01 	cdpeq	12, 8, cr1, cr14, cr1, {0}
    4a54:	68080000 	stmdavs	r8, {}	; <UNPREDICTABLE>
    4a58:	000005a1 	andeq	r0, r0, r1, lsr #11
    4a5c:	2d000101 	stfcss	f0, [r0, #-4]
    4a60:	02000004 	andeq	r0, r0, #4
    4a64:	00122f00 	andseq	r2, r2, r0, lsl #30
    4a68:	87010400 	strhi	r0, [r1, -r0, lsl #8]
    4a6c:	01000002 	tsteq	r0, r2
    4a70:	0000148e 	andeq	r1, r0, lr, lsl #9
    4a74:	00000216 	andeq	r0, r0, r6, lsl r2
	...
    4a80:	00000220 	andeq	r0, r0, r0, lsr #4
    4a84:	00001985 	andeq	r1, r0, r5, lsl #19
    4a88:	69050402 	stmdbvs	r5, {r1, sl}
    4a8c:	0300746e 	movweq	r7, #1134	; 0x46e
    4a90:	01ed0704 	mvneq	r0, r4, lsl #14
    4a94:	01030000 	mrseq	r0, (UNDEF: 3)
    4a98:	0001ba06 	andeq	fp, r1, r6, lsl #20
    4a9c:	08010300 	stmdaeq	r1, {r8, r9}
    4aa0:	000001b8 			; <UNDEFINED> instruction: 0x000001b8
    4aa4:	31050203 	tstcc	r5, r3, lsl #4
    4aa8:	03000000 	movweq	r0, #0
    4aac:	026a0702 	rsbeq	r0, sl, #524288	; 0x80000
    4ab0:	04030000 	streq	r0, [r3], #-0
    4ab4:	0000f705 	andeq	pc, r0, r5, lsl #14
    4ab8:	02ff0400 	rscseq	r0, pc, #0, 8
    4abc:	50030000 	andpl	r0, r3, r0
    4ac0:	00000065 	andeq	r0, r0, r5, rrx
    4ac4:	e8070403 	stmda	r7, {r0, r1, sl}
    4ac8:	03000001 	movweq	r0, #1
    4acc:	00f20508 	rscseq	r0, r2, r8, lsl #10
    4ad0:	08030000 	stmdaeq	r3, {}	; <UNPREDICTABLE>
    4ad4:	0001e307 	andeq	lr, r1, r7, lsl #6
    4ad8:	00650500 	rsbeq	r0, r5, r0, lsl #10
    4adc:	04060000 	streq	r0, [r6], #-0
    4ae0:	4a63020e 	bmi	18c5320 <_flash_swap_addr+0x1885b20>
    4ae4:	07000001 	streq	r0, [r0, -r1]
    4ae8:	00001511 	andeq	r1, r0, r1, lsl r5
    4aec:	015a6402 	cmpeq	sl, r2, lsl #8
    4af0:	23020000 	movwcs	r0, #8192	; 0x2000
    4af4:	09e90700 	stmibeq	r9!, {r8, r9, sl}^
    4af8:	65020000 	strvs	r0, [r2, #-0]
    4afc:	0000016f 	andeq	r0, r0, pc, ror #2
    4b00:	07202302 	streq	r2, [r0, -r2, lsl #6]!
    4b04:	000014da 	ldrdeq	r1, [r0], -sl
    4b08:	01746602 	cmneq	r4, r2, lsl #12
    4b0c:	23030000 	movwcs	r0, #12288	; 0x3000
    4b10:	f2070180 	vrhadd.s8	d0, d23, d0
    4b14:	02000009 	andeq	r0, r0, #9
    4b18:	00017967 	andeq	r7, r1, r7, ror #18
    4b1c:	a0230300 	eorge	r0, r3, r0, lsl #6
    4b20:	15040701 	strne	r0, [r4, #-1793]	; 0xfffff8ff
    4b24:	68020000 	stmdavs	r2, {}	; <UNPREDICTABLE>
    4b28:	0000017e 	andeq	r0, r0, lr, ror r1
    4b2c:	02802303 	addeq	r2, r0, #201326592	; 0xc000000
    4b30:	0014df07 	andseq	sp, r4, r7, lsl #30
    4b34:	83690200 	cmnhi	r9, #0, 4
    4b38:	03000001 	movweq	r0, #1
    4b3c:	0702a023 	streq	sl, [r2, -r3, lsr #32]
    4b40:	000014ba 			; <UNDEFINED> instruction: 0x000014ba
    4b44:	01886a02 	orreq	r6, r8, r2, lsl #20
    4b48:	23030000 	movwcs	r0, #12288	; 0x3000
    4b4c:	e7070380 	str	r0, [r7, -r0, lsl #7]
    4b50:	02000014 	andeq	r0, r0, #20
    4b54:	00018d6b 	andeq	r8, r1, fp, ror #26
    4b58:	a0230300 	eorge	r0, r3, r0, lsl #6
    4b5c:	15330703 	ldrne	r0, [r3, #-1795]!	; 0xfffff8fd
    4b60:	6c020000 	stcvs	0, cr0, [r2], {-0}
    4b64:	00000192 	muleq	r0, r2, r1
    4b68:	04802303 	streq	r2, [r0], #771	; 0x303
    4b6c:	0014ef07 	andseq	lr, r4, r7, lsl #30
    4b70:	a76d0200 	strbge	r0, [sp, -r0, lsl #4]!
    4b74:	03000001 	movweq	r0, #1
    4b78:	0804a023 	stmdaeq	r4, {r0, r1, r5, sp, pc}
    4b7c:	00525049 	subseq	r5, r2, r9, asr #32
    4b80:	01bc6e02 			; <UNDEFINED> instruction: 0x01bc6e02
    4b84:	23030000 	movwcs	r0, #12288	; 0x3000
    4b88:	f7070680 			; <UNDEFINED> instruction: 0xf7070680
    4b8c:	02000014 	andeq	r0, r0, #20
    4b90:	0001d26f 	andeq	sp, r1, pc, ror #4
    4b94:	f0230300 			; <UNDEFINED> instruction: 0xf0230300
    4b98:	14ff0707 	ldrbtne	r0, [pc], #1799	; 4ba0 <_data_load+0x1eb0>
    4b9c:	70020000 	andvc	r0, r2, r0
    4ba0:	0000007a 	andeq	r0, r0, sl, ror r0
    4ba4:	1c802303 	stcne	3, cr2, [r0], {3}
    4ba8:	00650900 	rsbeq	r0, r5, r0, lsl #18
    4bac:	015a0000 	cmpeq	sl, r0
    4bb0:	300a0000 	andcc	r0, sl, r0
    4bb4:	07000000 	streq	r0, [r0, -r0]
    4bb8:	014a0500 	cmpeq	sl, r0, lsl #10
    4bbc:	65090000 	strvs	r0, [r9, #-0]
    4bc0:	6f000000 	svcvs	0x00000000
    4bc4:	0a000001 	beq	4bd0 <_data_load+0x1ee0>
    4bc8:	00000030 	andeq	r0, r0, r0, lsr r0
    4bcc:	5f050017 	svcpl	0x00050017
    4bd0:	05000001 	streq	r0, [r0, #-1]
    4bd4:	0000014a 	andeq	r0, r0, sl, asr #2
    4bd8:	00015f05 	andeq	r5, r1, r5, lsl #30
    4bdc:	014a0500 	cmpeq	sl, r0, lsl #10
    4be0:	5f050000 	svcpl	0x00050000
    4be4:	05000001 	streq	r0, [r0, #-1]
    4be8:	0000014a 	andeq	r0, r0, sl, asr #2
    4bec:	00015f05 	andeq	r5, r1, r5, lsl #30
    4bf0:	014a0500 	cmpeq	sl, r0, lsl #10
    4bf4:	65090000 	strvs	r0, [r9, #-0]
    4bf8:	a7000000 	strge	r0, [r0, -r0]
    4bfc:	0a000001 	beq	4c08 <_data_load+0x1f18>
    4c00:	00000030 	andeq	r0, r0, r0, lsr r0
    4c04:	97050037 	smladxls	r5, r7, r0, r0
    4c08:	09000001 	stmdbeq	r0, {r0}
    4c0c:	00000065 	andeq	r0, r0, r5, rrx
    4c10:	000001bc 			; <UNDEFINED> instruction: 0x000001bc
    4c14:	0000300a 	andeq	r3, r0, sl
    4c18:	05003b00 	streq	r3, [r0, #-2816]	; 0xfffff500
    4c1c:	000001ac 	andeq	r0, r0, ip, lsr #3
    4c20:	00006509 	andeq	r6, r0, r9, lsl #10
    4c24:	0001d200 	andeq	sp, r1, r0, lsl #4
    4c28:	00300b00 	eorseq	r0, r0, r0, lsl #22
    4c2c:	02830000 	addeq	r0, r3, #0
    4c30:	01c10500 	biceq	r0, r1, r0, lsl #10
    4c34:	d1040000 	mrsle	r0, (UNDEF: 4)
    4c38:	02000014 	andeq	r0, r0, #20
    4c3c:	00007f71 	andeq	r7, r0, r1, ror pc
    4c40:	028c0c00 	addeq	r0, ip, #0, 24
    4c44:	00031282 	andeq	r1, r3, r2, lsl #5
    4c48:	14460700 	strbne	r0, [r6], #-1792	; 0xfffff900
    4c4c:	83020000 	movwhi	r0, #8192	; 0x2000
    4c50:	0000007a 	andeq	r0, r0, sl, ror r0
    4c54:	07002302 	streq	r2, [r0, -r2, lsl #6]
    4c58:	00001418 	andeq	r1, r0, r8, lsl r4
    4c5c:	007a8402 	rsbseq	r8, sl, r2, lsl #8
    4c60:	23020000 	movwcs	r0, #8192	; 0x2000
    4c64:	13fd0704 	mvnsne	r0, #4, 14	; 0x100000
    4c68:	85020000 	strhi	r0, [r2, #-0]
    4c6c:	0000007a 	andeq	r0, r0, sl, ror r0
    4c70:	07082302 	streq	r2, [r8, -r2, lsl #6]
    4c74:	0000141d 	andeq	r1, r0, sp, lsl r4
    4c78:	007a8602 	rsbseq	r8, sl, r2, lsl #12
    4c7c:	23020000 	movwcs	r0, #8192	; 0x2000
    4c80:	4353080c 	cmpmi	r3, #12, 16	; 0xc0000
    4c84:	87020052 	smlsdhi	r2, r2, r0, r0
    4c88:	0000007a 	andeq	r0, r0, sl, ror r0
    4c8c:	08102302 	ldmdaeq	r0, {r1, r8, r9, sp}
    4c90:	00524343 	subseq	r4, r2, r3, asr #6
    4c94:	007a8802 	rsbseq	r8, sl, r2, lsl #16
    4c98:	23020000 	movwcs	r0, #8192	; 0x2000
    4c9c:	146e0714 	strbtne	r0, [lr], #-1812	; 0xfffff8ec
    4ca0:	89020000 	stmdbhi	r2, {}	; <UNPREDICTABLE>
    4ca4:	00000322 	andeq	r0, r0, r2, lsr #6
    4ca8:	07182302 	ldreq	r2, [r8, -r2, lsl #6]
    4cac:	00001451 	andeq	r1, r0, r1, asr r4
    4cb0:	007a8a02 	rsbseq	r8, sl, r2, lsl #20
    4cb4:	23020000 	movwcs	r0, #8192	; 0x2000
    4cb8:	14410724 	strbne	r0, [r1], #-1828	; 0xfffff8dc
    4cbc:	8b020000 	blhi	84cc4 <_flash_swap_addr+0x454c4>
    4cc0:	0000007a 	andeq	r0, r0, sl, ror r0
    4cc4:	07282302 	streq	r2, [r8, -r2, lsl #6]!
    4cc8:	00001489 	andeq	r1, r0, r9, lsl #9
    4ccc:	007a8c02 	rsbseq	r8, sl, r2, lsl #24
    4cd0:	23020000 	movwcs	r0, #8192	; 0x2000
    4cd4:	1423072c 	strtne	r0, [r3], #-1836	; 0xfffff8d4
    4cd8:	8d020000 	stchi	0, cr0, [r2, #-0]
    4cdc:	0000007a 	andeq	r0, r0, sl, ror r0
    4ce0:	07302302 	ldreq	r2, [r0, -r2, lsl #6]!
    4ce4:	00001428 	andeq	r1, r0, r8, lsr #8
    4ce8:	007a8e02 	rsbseq	r8, sl, r2, lsl #28
    4cec:	23020000 	movwcs	r0, #8192	; 0x2000
    4cf0:	13dd0734 	bicsne	r0, sp, #52, 14	; 0xd00000
    4cf4:	8f020000 	svchi	0x00020000
    4cf8:	0000007a 	andeq	r0, r0, sl, ror r0
    4cfc:	07382302 	ldreq	r2, [r8, -r2, lsl #6]!
    4d00:	0000145c 	andeq	r1, r0, ip, asr r4
    4d04:	007a9002 	rsbseq	r9, sl, r2
    4d08:	23020000 	movwcs	r0, #8192	; 0x2000
    4d0c:	4650083c 			; <UNDEFINED> instruction: 0x4650083c
    4d10:	91020052 	qaddls	r0, r2, r2
    4d14:	00000337 	andeq	r0, r0, r7, lsr r3
    4d18:	08402302 	stmdaeq	r0, {r1, r8, r9, sp}^
    4d1c:	00524644 	subseq	r4, r2, r4, asr #12
    4d20:	007a9202 	rsbseq	r9, sl, r2, lsl #4
    4d24:	23020000 	movwcs	r0, #8192	; 0x2000
    4d28:	44410848 	strbmi	r0, [r1], #-2120	; 0xfffff7b8
    4d2c:	93020052 	movwls	r0, #8274	; 0x2052
    4d30:	0000007a 	andeq	r0, r0, sl, ror r0
    4d34:	074c2302 	strbeq	r2, [ip, -r2, lsl #6]
    4d38:	00001473 	andeq	r1, r0, r3, ror r4
    4d3c:	034c9402 	movteq	r9, #50178	; 0xc402
    4d40:	23020000 	movwcs	r0, #8192	; 0x2000
    4d44:	41530850 	cmpmi	r3, r0, asr r8
    4d48:	95020052 	strls	r0, [r2, #-82]	; 0xffffffae
    4d4c:	00000361 	andeq	r0, r0, r1, ror #6
    4d50:	07602302 	strbeq	r2, [r0, -r2, lsl #6]!
    4d54:	000009e9 	andeq	r0, r0, r9, ror #19
    4d58:	03669602 	cmneq	r6, #2097152	; 0x200000
    4d5c:	23020000 	movwcs	r0, #8192	; 0x2000
    4d60:	14830774 	strne	r0, [r3], #1908	; 0x774
    4d64:	97020000 	strls	r0, [r2, -r0]
    4d68:	0000007a 	andeq	r0, r0, sl, ror r0
    4d6c:	01882303 	orreq	r2, r8, r3, lsl #6
    4d70:	00650900 	rsbeq	r0, r5, r0, lsl #18
    4d74:	03220000 	teqeq	r2, #0
    4d78:	300a0000 	andcc	r0, sl, r0
    4d7c:	02000000 	andeq	r0, r0, #0
    4d80:	03120500 	tsteq	r2, #0, 10
    4d84:	65090000 	strvs	r0, [r9, #-0]
    4d88:	37000000 	strcc	r0, [r0, -r0]
    4d8c:	0a000003 	beq	4da0 <_data_load+0x20b0>
    4d90:	00000030 	andeq	r0, r0, r0, lsr r0
    4d94:	27050001 	strcs	r0, [r5, -r1]
    4d98:	09000003 	stmdbeq	r0, {r0, r1}
    4d9c:	00000065 	andeq	r0, r0, r5, rrx
    4da0:	0000034c 	andeq	r0, r0, ip, asr #6
    4da4:	0000300a 	andeq	r3, r0, sl
    4da8:	05000300 	streq	r0, [r0, #-768]	; 0xfffffd00
    4dac:	0000033c 	andeq	r0, r0, ip, lsr r3
    4db0:	00006509 	andeq	r6, r0, r9, lsl #10
    4db4:	00036100 	andeq	r6, r3, r0, lsl #2
    4db8:	00300a00 	eorseq	r0, r0, r0, lsl #20
    4dbc:	00040000 	andeq	r0, r4, r0
    4dc0:	00035105 	andeq	r5, r3, r5, lsl #2
    4dc4:	03510500 	cmpeq	r1, #0, 10
    4dc8:	b4040000 	strlt	r0, [r4], #-0
    4dcc:	02000013 	andeq	r0, r0, #19
    4dd0:	0001e298 	muleq	r1, r8, r2
    4dd4:	08010300 	stmdaeq	r1, {r8, r9}
    4dd8:	000001c1 	andeq	r0, r0, r1, asr #3
    4ddc:	1538010d 	ldrne	r0, [r8, #-269]!	; 0xfffffef3
    4de0:	27010000 	strcs	r0, [r1, -r0]
    4de4:	00269001 	eoreq	r9, r6, r1
    4de8:	00273400 	eoreq	r3, r7, r0, lsl #8
    4dec:	00126800 	andseq	r6, r2, r0, lsl #16
    4df0:	0003be00 	andeq	fp, r3, r0, lsl #28
    4df4:	006e0e00 	rsbeq	r0, lr, r0, lsl #28
    4df8:	005a2701 	subseq	r2, sl, r1, lsl #14
    4dfc:	91020000 	mrsls	r0, (UNDEF: 2)
    4e00:	0cef0f6c 	stcleq	15, cr0, [pc], #432	; 4fb8 <_data_load+0x22c8>
    4e04:	27010000 	strcs	r0, [r1, -r0]
    4e08:	0000005a 	andeq	r0, r0, sl, asr r0
    4e0c:	10689102 	rsbne	r9, r8, r2, lsl #2
    4e10:	01006873 	tsteq	r0, r3, ror r8
    4e14:	00003028 	andeq	r3, r0, r8, lsr #32
    4e18:	74910200 	ldrvc	r0, [r1], #512	; 0x200
    4e1c:	bf010d00 	svclt	0x00010d00
    4e20:	01000014 	tsteq	r0, r4, lsl r0
    4e24:	27400135 	smlaldxcs	r0, r0, r5, r1	; <UNPREDICTABLE>
    4e28:	27b80000 	ldrcs	r0, [r8, r0]!
    4e2c:	12940000 	addsne	r0, r4, #0
    4e30:	03f10000 	mvnseq	r0, #0
    4e34:	6e0e0000 	cdpvs	0, 0, cr0, cr14, cr0, {0}
    4e38:	5a350100 	bpl	d45240 <_flash_swap_addr+0xd05a40>
    4e3c:	02000000 	andeq	r0, r0, #0
    4e40:	73106c91 	tstvc	r0, #37120	; 0x9100
    4e44:	36010068 	strcc	r0, [r1], -r8, rrx
    4e48:	00000030 	andeq	r0, r0, r0, lsr r0
    4e4c:	00749102 	rsbseq	r9, r4, r2, lsl #2
    4e50:	15160111 	ldrne	r0, [r6, #-273]	; 0xfffffeef
    4e54:	43010000 	movwmi	r0, #4096	; 0x1000
    4e58:	0027c001 	eoreq	ip, r7, r1
    4e5c:	00282000 	eoreq	r2, r8, r0
    4e60:	0012c000 	andseq	ip, r2, r0
    4e64:	15090f00 	strne	r0, [r9, #-3840]	; 0xfffff100
    4e68:	43010000 	movwmi	r0, #4096	; 0x1000
    4e6c:	0000005a 	andeq	r0, r0, sl, asr r0
    4e70:	0f6c9102 	svceq	0x006c9102
    4e74:	00000cef 	andeq	r0, r0, pc, ror #25
    4e78:	005a4301 	subseq	r4, sl, r1, lsl #6
    4e7c:	91020000 	mrsls	r0, (UNDEF: 2)
    4e80:	68731068 	ldmdavs	r3!, {r3, r5, r6, ip}^
    4e84:	30440100 	subcc	r0, r4, r0, lsl #2
    4e88:	02000000 	andeq	r0, r0, #0
    4e8c:	00007491 	muleq	r0, r1, r4
    4e90:	00000805 	andeq	r0, r0, r5, lsl #16
    4e94:	131b0002 	tstne	fp, #2
    4e98:	01040000 	mrseq	r0, (UNDEF: 4)
    4e9c:	00000287 	andeq	r0, r0, r7, lsl #5
    4ea0:	0015b701 	andseq	fp, r5, r1, lsl #14
    4ea4:	00021600 	andeq	r1, r2, r0, lsl #12
	...
    4eb0:	00024000 	andeq	r4, r2, r0
    4eb4:	001aa700 	andseq	sl, sl, r0, lsl #14
    4eb8:	05040200 	streq	r0, [r4, #-512]	; 0xfffffe00
    4ebc:	00746e69 	rsbseq	r6, r4, r9, ror #28
    4ec0:	ed070403 	cfstrs	mvf0, [r7, #-12]
    4ec4:	03000001 	movweq	r0, #1
    4ec8:	01ba0601 			; <UNDEFINED> instruction: 0x01ba0601
    4ecc:	33040000 	movwcc	r0, #16384	; 0x4000
    4ed0:	0300000a 	movweq	r0, #10
    4ed4:	0000492a 	andeq	r4, r0, sl, lsr #18
    4ed8:	08010300 	stmdaeq	r1, {r8, r9}
    4edc:	000001b8 			; <UNDEFINED> instruction: 0x000001b8
    4ee0:	31050203 	tstcc	r5, r3, lsl #4
    4ee4:	03000000 	movweq	r0, #0
    4ee8:	026a0702 	rsbeq	r0, sl, #524288	; 0x80000
    4eec:	00040000 	andeq	r0, r4, r0
    4ef0:	03000003 	movweq	r0, #3
    4ef4:	0000694f 	andeq	r6, r0, pc, asr #18
    4ef8:	05040300 	streq	r0, [r4, #-768]	; 0xfffffd00
    4efc:	000000f7 	strdeq	r0, [r0], -r7
    4f00:	0002ff04 	andeq	pc, r2, r4, lsl #30
    4f04:	7b500300 	blvc	1405b0c <_flash_swap_addr+0x13c630c>
    4f08:	03000000 	movweq	r0, #0
    4f0c:	01e80704 	mvneq	r0, r4, lsl #14
    4f10:	08030000 	stmdaeq	r3, {}	; <UNPREDICTABLE>
    4f14:	0000f205 	andeq	pc, r0, r5, lsl #4
    4f18:	07080300 	streq	r0, [r8, -r0, lsl #6]
    4f1c:	000001e3 	andeq	r0, r0, r3, ror #3
    4f20:	000ed504 	andeq	sp, lr, r4, lsl #10
    4f24:	5e270400 	cdppl	4, 2, cr0, cr7, cr0, {0}
    4f28:	04000000 	streq	r0, [r0], #-0
    4f2c:	00000d62 	andeq	r0, r0, r2, ror #26
    4f30:	003e2804 	eorseq	r2, lr, r4, lsl #16
    4f34:	18040000 	stmdane	r4, {}	; <UNPREDICTABLE>
    4f38:	0400000d 	streq	r0, [r0], #-13
    4f3c:	00003e29 	andeq	r3, r0, r9, lsr #28
    4f40:	0dd20400 	cfldrdeq	mvd0, [r2]
    4f44:	2a040000 	bcs	104f4c <_flash_swap_addr+0xc574c>
    4f48:	0000003e 	andeq	r0, r0, lr, lsr r0
    4f4c:	000d0e04 	andeq	r0, sp, r4, lsl #28
    4f50:	3e2b0400 	cdpcc	4, 2, cr0, cr11, cr0, {0}
    4f54:	04000000 	streq	r0, [r0], #-0
    4f58:	00000de1 	andeq	r0, r0, r1, ror #27
    4f5c:	00702c04 	rsbseq	r2, r0, r4, lsl #24
    4f60:	1f040000 	svcne	0x00040000
    4f64:	04000004 	streq	r0, [r0], #-4
    4f68:	00005e2d 	andeq	r5, r0, sp, lsr #28
    4f6c:	0d760400 	cfldrdeq	mvd0, [r6, #-0]
    4f70:	2f040000 	svccs	0x00040000
    4f74:	00000070 	andeq	r0, r0, r0, ror r0
    4f78:	00027d04 	andeq	r7, r2, r4, lsl #26
    4f7c:	70310400 	eorsvc	r0, r1, r0, lsl #8
    4f80:	04000000 	streq	r0, [r0], #-0
    4f84:	00000e1b 	andeq	r0, r0, fp, lsl lr
    4f88:	00fe2305 	rscseq	r2, lr, r5, lsl #6
    4f8c:	1b050000 	blne	144f94 <_flash_swap_addr+0x105794>
    4f90:	4800000e 	stmdami	r0, {r1, r2, r3}
    4f94:	02235706 	eoreq	r5, r3, #1572864	; 0x180000
    4f98:	57060000 	strpl	r0, [r6, -r0]
    4f9c:	06000011 			; <UNDEFINED> instruction: 0x06000011
    4fa0:	00024858 	andeq	r4, r2, r8, asr r8
    4fa4:	00230200 	eoreq	r0, r3, r0, lsl #4
    4fa8:	000dda06 	andeq	sp, sp, r6, lsl #20
    4fac:	485a0600 	ldmdami	sl, {r9, sl}^
    4fb0:	02000002 	andeq	r0, r0, #2
    4fb4:	ed060423 	cfstrs	mvf0, [r6, #-140]	; 0xffffff74
    4fb8:	0600000c 	streq	r0, [r0], -ip
    4fbc:	0000c75c 	andeq	ip, r0, ip, asr r7
    4fc0:	08230200 	stmdaeq	r3!, {r9}
    4fc4:	000ebc06 	andeq	fp, lr, r6, lsl #24
    4fc8:	165d0600 	ldrbne	r0, [sp], -r0, lsl #12
    4fcc:	02000003 	andeq	r0, r0, #3
    4fd0:	21060c23 	tstcs	r6, r3, lsr #24
    4fd4:	0600000d 	streq	r0, [r0], -sp
    4fd8:	0002485f 	andeq	r4, r2, pc, asr r8
    4fdc:	10230200 	eorne	r0, r3, r0, lsl #4
    4fe0:	000d9806 	andeq	r9, sp, r6, lsl #16
    4fe4:	48600600 	stmdami	r0!, {r9, sl}^
    4fe8:	02000002 	andeq	r0, r0, #2
    4fec:	9b061423 	blls	18a080 <_flash_swap_addr+0x14a880>
    4ff0:	0600000e 	streq	r0, [r0], -lr
    4ff4:	00042367 	andeq	r2, r4, r7, ror #6
    4ff8:	18230200 	stmdane	r3!, {r9}
    4ffc:	000df306 	andeq	pc, sp, r6, lsl #6
    5000:	a6720600 	ldrbtge	r0, [r2], -r0, lsl #12
    5004:	02000000 	andeq	r0, r0, #0
    5008:	13061c23 	movwne	r1, #27683	; 0x6c23
    500c:	0600000e 	streq	r0, [r0], -lr
    5010:	00009b76 	andeq	r9, r0, r6, ror fp
    5014:	1d230200 	sfmne	f0, 4, [r3, #-0]
    5018:	000e7d06 	andeq	r7, lr, r6, lsl #26
    501c:	b17b0600 	cmnlt	fp, r0, lsl #12
    5020:	02000000 	andeq	r0, r0, #0
    5024:	fb061e23 	blx	18c8ba <_flash_swap_addr+0x14d0ba>
    5028:	0600000d 	streq	r0, [r0], -sp
    502c:	0000bc81 	andeq	fp, r0, r1, lsl #25
    5030:	1f230200 	svcne	0x00230200
    5034:	000e5d06 	andeq	r5, lr, r6, lsl #26
    5038:	39880600 	stmibcc	r8, {r9, sl}
    503c:	02000003 	andeq	r0, r0, #3
    5040:	70072023 	andvc	r2, r7, r3, lsr #32
    5044:	0600755f 			; <UNDEFINED> instruction: 0x0600755f
    5048:	0003eead 	andeq	lr, r3, sp, lsr #29
    504c:	24230200 	strtcs	r0, [r3], #-512	; 0xfffffe00
    5050:	000ec206 	andeq	ip, lr, r6, lsl #4
    5054:	70b20600 	adcsvc	r0, r2, r0, lsl #12
    5058:	02000002 	andeq	r0, r0, #2
    505c:	6b062823 	blvs	18f0f0 <_flash_swap_addr+0x14f8f0>
    5060:	0600000e 	streq	r0, [r0], -lr
    5064:	00024eb8 			; <UNDEFINED> instruction: 0x00024eb8
    5068:	2c230200 	sfmcs	f0, 4, [r3], #-0
    506c:	000c8e06 	andeq	r8, ip, r6, lsl #28
    5070:	d2bc0600 	adcsle	r0, ip, #0, 12
    5074:	02000000 	andeq	r0, r0, #0
    5078:	22063423 	andcs	r3, r6, #587202560	; 0x23000000
    507c:	0600000e 	streq	r0, [r0], -lr
    5080:	0000ddc2 	andeq	sp, r0, r2, asr #27
    5084:	38230200 	stmdacc	r3!, {r9}
    5088:	000de906 	andeq	lr, sp, r6, lsl #18
    508c:	35c90600 	strbcc	r0, [r9, #1536]	; 0x600
    5090:	02000004 	andeq	r0, r0, #4
    5094:	49063c23 	stmdbmi	r6, {r0, r1, r5, sl, fp, ip, sp}
    5098:	0600000e 	streq	r0, [r0], -lr
    509c:	0000c7cd 	andeq	ip, r0, sp, asr #15
    50a0:	40230200 	eormi	r0, r3, r0, lsl #4
    50a4:	000cfe06 	andeq	pc, ip, r6, lsl #28
    50a8:	86d30600 	ldrbhi	r0, [r3], r0, lsl #12
    50ac:	02000002 	andeq	r0, r0, #2
    50b0:	08004423 	stmdaeq	r0, {r0, r1, r5, sl, lr}
    50b4:	485a0508 	ldmdami	sl, {r3, r8, sl}^
    50b8:	06000002 	streq	r0, [r0], -r2
    50bc:	00001157 	andeq	r1, r0, r7, asr r1
    50c0:	02485b05 	subeq	r5, r8, #5120	; 0x1400
    50c4:	23020000 	movwcs	r0, #8192	; 0x2000
    50c8:	0dda0600 	ldcleq	6, cr0, [sl]
    50cc:	5d050000 	stcpl	0, cr0, [r5, #-0]
    50d0:	00000248 	andeq	r0, r0, r8, asr #4
    50d4:	00042302 	andeq	r2, r4, r2, lsl #6
    50d8:	00f30409 	rscseq	r0, r3, r9, lsl #8
    50dc:	a6040000 	strge	r0, [r4], -r0
    50e0:	0500000d 	streq	r0, [r0, #-13]
    50e4:	0002235f 	andeq	r2, r2, pc, asr r3
    50e8:	05040800 	streq	r0, [r4, #-2048]	; 0xfffff800
    50ec:	00027064 	andeq	r7, r2, r4, rrx
    50f0:	11570600 	cmpne	r7, r0, lsl #12
    50f4:	66050000 	strvs	r0, [r5], -r0
    50f8:	00000248 	andeq	r0, r0, r8, asr #4
    50fc:	00002302 	andeq	r2, r0, r2, lsl #6
    5100:	000d6a04 	andeq	r6, sp, r4, lsl #20
    5104:	59690500 	stmdbpl	r9!, {r8, sl}^
    5108:	04000002 	streq	r0, [r0], #-2
    510c:	00000d41 	andeq	r0, r0, r1, asr #26
    5110:	0286de07 	addeq	sp, r6, #7, 28	; 0x70
    5114:	040a0000 	streq	r0, [sl], #-0
    5118:	000e640b 	andeq	r6, lr, fp, lsl #8
    511c:	05072400 	streq	r2, [r7, #-1024]	; 0xfffffc00
    5120:	00031601 	andeq	r1, r3, r1, lsl #12
    5124:	34720c00 	ldrbtcc	r0, [r2], #-3072	; 0xfffff400
    5128:	01180700 	tsteq	r8, r0, lsl #14
    512c:	0000027b 	andeq	r0, r0, fp, ror r2
    5130:	0c002302 	stceq	3, cr2, [r0], {2}
    5134:	07003572 	smlsdxeq	r0, r2, r5, r3
    5138:	027b0119 	rsbseq	r0, fp, #1073741830	; 0x40000006
    513c:	23020000 	movwcs	r0, #8192	; 0x2000
    5140:	36720c04 	ldrbtcc	r0, [r2], -r4, lsl #24
    5144:	011a0700 	tsteq	sl, r0, lsl #14
    5148:	0000027b 	andeq	r0, r0, fp, ror r2
    514c:	0c082302 	stceq	3, cr2, [r8], {2}
    5150:	07003772 	smlsdxeq	r0, r2, r7, r3
    5154:	027b011b 	rsbseq	r0, fp, #-1073741818	; 0xc0000006
    5158:	23020000 	movwcs	r0, #8192	; 0x2000
    515c:	38720c0c 	ldmdacc	r2!, {r2, r3, sl, fp}^
    5160:	011c0700 	tsteq	ip, r0, lsl #14
    5164:	0000027b 	andeq	r0, r0, fp, ror r2
    5168:	0c102302 	ldceq	3, cr2, [r0], {2}
    516c:	07003972 	smlsdxeq	r0, r2, r9, r3
    5170:	027b011d 	rsbseq	r0, fp, #1073741831	; 0x40000007
    5174:	23020000 	movwcs	r0, #8192	; 0x2000
    5178:	31720c14 	cmncc	r2, r4, lsl ip
    517c:	1e070030 	mcrne	0, 0, r0, cr7, cr0, {1}
    5180:	00027b01 	andeq	r7, r2, r1, lsl #22
    5184:	18230200 	stmdane	r3!, {r9}
    5188:	3131720c 	teqcc	r1, ip, lsl #4
    518c:	011f0700 	tsteq	pc, r0, lsl #14
    5190:	0000027b 	andeq	r0, r0, fp, ror r2
    5194:	0c1c2302 	ldceq	3, cr2, [ip], {2}
    5198:	0700726c 	streq	r7, [r0, -ip, ror #4]
    519c:	027b0120 	rsbseq	r0, fp, #32, 2
    51a0:	23020000 	movwcs	r0, #8192	; 0x2000
    51a4:	5a0b0020 	bpl	2c522c <_flash_swap_addr+0x285a2c>
    51a8:	0400000d 	streq	r0, [r0], #-13
    51ac:	33012a07 	movwcc	r2, #6663	; 0x1a07
    51b0:	0c000003 	stceq	0, cr0, [r0], {3}
    51b4:	00333172 	eorseq	r3, r3, r2, ror r1
    51b8:	33012b07 	movwcc	r2, #6919	; 0x1b07
    51bc:	02000003 	andeq	r0, r0, #3
    51c0:	09000023 	stmdbeq	r0, {r0, r1, r5}
    51c4:	00028804 	andeq	r8, r2, r4, lsl #16
    51c8:	00e80d00 	rsceq	r0, r8, r0, lsl #26
    51cc:	1c080000 	stcne	0, cr0, [r8], {-0}
    51d0:	039b5708 	orrseq	r5, fp, #8, 14	; 0x200000
    51d4:	2d060000 	stccs	0, cr0, [r6, #-0]
    51d8:	0800000e 	stmdaeq	r0, {r1, r2, r3}
    51dc:	00024e58 	andeq	r4, r2, r8, asr lr
    51e0:	00230200 	eoreq	r0, r3, r0, lsl #4
    51e4:	000e0506 	andeq	r0, lr, r6, lsl #10
    51e8:	c7590800 	ldrbgt	r0, [r9, -r0, lsl #16]
    51ec:	02000000 	andeq	r0, r0, #0
    51f0:	a0060823 	andge	r0, r6, r3, lsr #16
    51f4:	0800000d 	stmdaeq	r0, {r0, r2, r3}
    51f8:	0003165b 	andeq	r1, r3, fp, asr r6
    51fc:	0c230200 	sfmeq	f0, 4, [r3], #-0
    5200:	000d3906 	andeq	r3, sp, r6, lsl #18
    5204:	485e0800 	ldmdami	lr, {fp}^
    5208:	02000002 	andeq	r0, r0, #2
    520c:	bd061023 	stclt	0, cr1, [r6, #-140]	; 0xffffff74
    5210:	0800000d 	stmdaeq	r0, {r0, r2, r3}
    5214:	0002485f 	andeq	r4, r2, pc, asr r8
    5218:	14230200 	strtne	r0, [r3], #-512	; 0xfffffe00
    521c:	000db306 	andeq	fp, sp, r6, lsl #6
    5220:	48620800 	stmdami	r2!, {fp}^
    5224:	02000002 	andeq	r0, r0, #2
    5228:	04001823 	streq	r1, [r0], #-2083	; 0xfffff7dd
    522c:	00000e84 	andeq	r0, r0, r4, lsl #29
    5230:	033e6408 	teqeq	lr, #8, 8	; 0x8000000
    5234:	82050000 	andhi	r0, r5, #0
    5238:	1000000d 	andne	r0, r0, sp
    523c:	03dd2509 	bicseq	r2, sp, #37748736	; 0x2400000
    5240:	06060000 	streq	r0, [r6], -r0
    5244:	0900000d 	stmdbeq	r0, {r0, r2, r3}
    5248:	00024e26 	andeq	r4, r2, r6, lsr #28
    524c:	00230200 	eoreq	r0, r3, r0, lsl #4
    5250:	000eb406 	andeq	fp, lr, r6, lsl #8
    5254:	48280900 	stmdami	r8!, {r8, fp}
    5258:	02000002 	andeq	r0, r0, #2
    525c:	42060823 	andmi	r0, r6, #2293760	; 0x230000
    5260:	0900000e 	stmdbeq	r0, {r1, r2, r3}
    5264:	0003dd2a 	andeq	sp, r3, sl, lsr #26
    5268:	0c230200 	sfmeq	f0, 4, [r3], #-0
    526c:	a6040900 	strge	r0, [r4], -r0, lsl #18
    5270:	04000003 	streq	r0, [r0], #-3
    5274:	00000d82 	andeq	r0, r0, r2, lsl #27
    5278:	03a62c09 			; <UNDEFINED> instruction: 0x03a62c09
    527c:	040e0000 	streq	r0, [lr], #-0
    5280:	04238f06 	strteq	r8, [r3], #-3846	; 0xfffff0fa
    5284:	940f0000 	strls	r0, [pc], #-0	; 528c <_data_load+0x259c>
    5288:	0600000c 	streq	r0, [r0], -ip
    528c:	0000d296 	muleq	r0, r6, r2
    5290:	0cd90f00 	ldcleq	15, cr0, [r9], {0}
    5294:	9d060000 	stcls	0, cr0, [r6, #-0]
    5298:	000000d2 	ldrdeq	r0, [r0], -r2
    529c:	000e940f 	andeq	r9, lr, pc, lsl #8
    52a0:	86a40600 	strthi	r0, [r4], r0, lsl #12
    52a4:	0f000002 	svceq	0x00000002
    52a8:	00000e0c 	andeq	r0, r0, ip, lsl #28
    52ac:	00ddab06 	sbcseq	sl, sp, r6, lsl #22
    52b0:	09000000 	stmdbeq	r0, {}	; <UNPREDICTABLE>
    52b4:	00042904 	andeq	r2, r4, r4, lsl #18
    52b8:	042e1000 	strteq	r1, [lr], #-0
    52bc:	01030000 	mrseq	r0, (UNDEF: 3)
    52c0:	0001c108 	andeq	ip, r1, r8, lsl #2
    52c4:	e3040900 	movw	r0, #18688	; 0x4900
    52c8:	11000003 	tstne	r0, r3
    52cc:	0000157b 	andeq	r1, r0, fp, ror r5
    52d0:	20012201 	andcs	r2, r1, r1, lsl #4
    52d4:	66000028 	strvs	r0, [r0], -r8, lsr #32
    52d8:	ec000028 	stc	0, cr0, [r0], {40}	; 0x28
    52dc:	7c000012 	stcvc	0, cr0, [r0], {18}
    52e0:	12000004 	andne	r0, r0, #4
    52e4:	01007074 	tsteq	r0, r4, ror r0
    52e8:	00024822 	andeq	r4, r2, r2, lsr #16
    52ec:	74910200 	ldrvc	r0, [r1], #512	; 0x200
    52f0:	70717412 	rsbsvc	r7, r1, r2, lsl r4
    52f4:	7c220100 	stfvcs	f0, [r2], #-0
    52f8:	02000004 	andeq	r0, r0, #4
    52fc:	63137091 	tstvs	r3, #145	; 0x91
    5300:	24010070 	strcs	r0, [r1], #-112	; 0xffffff90
    5304:	00000248 	andeq	r0, r0, r8, asr #4
    5308:	007c9102 	rsbseq	r9, ip, r2, lsl #2
    530c:	024e0409 	subeq	r0, lr, #150994944	; 0x9000000
    5310:	f7140000 			; <UNDEFINED> instruction: 0xf7140000
    5314:	0100000f 	tsteq	r0, pc
    5318:	02480134 	subeq	r0, r8, #52, 2
    531c:	28700000 	ldmdacs	r0!, {}^	; <UNPREDICTABLE>
    5320:	28920000 	ldmcs	r2, {}	; <UNPREDICTABLE>
    5324:	130c0000 	movwne	r0, #49152	; 0xc000
    5328:	04ba0000 	ldrteq	r0, [sl], #0
    532c:	74120000 	ldrvc	r0, [r2], #-0
    5330:	01007071 	tsteq	r0, r1, ror r0
    5334:	00047c34 	andeq	r7, r4, r4, lsr ip
    5338:	74910200 	ldrvc	r0, [r1], #512	; 0x200
    533c:	00707413 	rsbseq	r7, r0, r3, lsl r4
    5340:	02483501 	subeq	r3, r8, #4194304	; 0x400000
    5344:	91020000 	mrsls	r0, (UNDEF: 2)
    5348:	b314007c 	tstlt	r4, #124	; 0x7c
    534c:	0100000f 	tsteq	r0, pc
    5350:	02480142 	subeq	r0, r8, #-2147483632	; 0x80000010
    5354:	28a00000 	stmiacs	r0!, {}	; <UNPREDICTABLE>
    5358:	28c00000 	stmiacs	r0, {}^	; <UNPREDICTABLE>
    535c:	132c0000 	teqne	ip, #0
    5360:	04e40000 	strbteq	r0, [r4], #0
    5364:	74120000 	ldrvc	r0, [r2], #-0
    5368:	42010070 	andmi	r0, r1, #112	; 0x70
    536c:	00000248 	andeq	r0, r0, r8, asr #4
    5370:	007c9102 	rsbseq	r9, ip, r2, lsl #2
    5374:	15ad0115 	strne	r0, [sp, #277]!	; 0x115
    5378:	4f020000 	svcmi	0x00020000
    537c:	0028c001 	eoreq	ip, r8, r1
    5380:	0028de00 	eoreq	sp, r8, r0, lsl #28
    5384:	00134c00 	andseq	r4, r3, r0, lsl #24
    5388:	00050b00 	andeq	r0, r5, r0, lsl #22
    538c:	706d1200 	rsbvc	r1, sp, r0, lsl #4
    5390:	354f0200 	strbcc	r0, [pc, #-512]	; 5198 <_data_load+0x24a8>
    5394:	02000004 	andeq	r0, r0, #4
    5398:	15007c91 	strne	r7, [r0, #-3217]	; 0xfffff36f
    539c:	0015a301 	andseq	sl, r5, r1, lsl #6
    53a0:	01600200 	cmneq	r0, r0, lsl #4
    53a4:	000028e0 	andeq	r2, r0, r0, ror #17
    53a8:	00002900 	andeq	r2, r0, r0, lsl #18
    53ac:	0000136c 	andeq	r1, r0, ip, ror #6
    53b0:	00000564 	andeq	r0, r0, r4, ror #10
    53b4:	00706d12 	rsbseq	r6, r0, r2, lsl sp
    53b8:	04356002 	ldrteq	r6, [r5], #-2
    53bc:	91020000 	mrsls	r0, (UNDEF: 2)
    53c0:	28e61674 	stmiacs	r6!, {r2, r4, r5, r6, r9, sl, ip}^
    53c4:	28ee0000 	stmiacs	lr!, {}^	; <UNPREDICTABLE>
    53c8:	054c0000 	strbeq	r0, [ip, #-0]
    53cc:	74130000 	ldrvc	r0, [r3], #-0
    53d0:	0200706d 	andeq	r7, r0, #109	; 0x6d
    53d4:	00007062 	andeq	r7, r0, r2, rrx
    53d8:	00530100 	subseq	r0, r3, r0, lsl #2
    53dc:	0028f417 	eoreq	pc, r8, r7, lsl r4	; <UNPREDICTABLE>
    53e0:	0028fc00 	eoreq	pc, r8, r0, lsl #24
    53e4:	6d741300 	ldclvs	3, cr1, [r4, #-0]
    53e8:	66020070 			; <UNDEFINED> instruction: 0x66020070
    53ec:	00000070 	andeq	r0, r0, r0, ror r0
    53f0:	00005301 	andeq	r5, r0, r1, lsl #6
    53f4:	15550115 	ldrbne	r0, [r5, #-277]	; 0xfffffeeb
    53f8:	72020000 	andvc	r0, r2, #0
    53fc:	00290001 	eoreq	r0, r9, r1
    5400:	0029c000 	eoreq	ip, r9, r0
    5404:	00139800 	andseq	r9, r3, r0, lsl #16
    5408:	0005b000 	andeq	fp, r5, r0
    540c:	706d1200 	rsbvc	r1, sp, r0, lsl #4
    5410:	35720200 	ldrbcc	r0, [r2, #-512]!	; 0xfffffe00
    5414:	02000004 	andeq	r0, r0, #4
    5418:	63136c91 	tstvs	r3, #37120	; 0x9100
    541c:	02007074 	andeq	r7, r0, #116	; 0x74
    5420:	00024873 	andeq	r4, r2, r3, ror r8
    5424:	70910200 	addsvc	r0, r1, r0, lsl #4
    5428:	00291a17 	eoreq	r1, r9, r7, lsl sl
    542c:	0029a800 	eoreq	sl, r9, r0, lsl #16
    5430:	70741300 	rsbsvc	r1, r4, r0, lsl #6
    5434:	487d0200 	ldmdami	sp!, {r9}^
    5438:	02000002 	andeq	r0, r0, #2
    543c:	00007491 	muleq	r0, r1, r4
    5440:	15960118 	ldrne	r0, [r6, #280]	; 0x118
    5444:	c7020000 	strgt	r0, [r2, -r0]
    5448:	00009001 	andeq	r9, r0, r1
    544c:	0029c000 	eoreq	ip, r9, r0
    5450:	0029e600 	eoreq	lr, r9, r0, lsl #12
    5454:	0013c400 	andseq	ip, r3, r0, lsl #8
    5458:	00061900 	andeq	r1, r6, r0, lsl #18
    545c:	706d1200 	rsbvc	r1, sp, r0, lsl #4
    5460:	35c70200 	strbcc	r0, [r7, #512]	; 0x200
    5464:	02000004 	andeq	r0, r0, #4
    5468:	62136c91 	andsvs	r6, r3, #37120	; 0x9100
    546c:	90c80200 	sbcls	r0, r8, r0, lsl #4
    5470:	02000000 	andeq	r0, r0, #0
    5474:	c6167491 			; <UNDEFINED> instruction: 0xc6167491
    5478:	ce000029 	cdpgt	0, 0, cr0, cr0, cr9, {1}
    547c:	01000029 	tsteq	r0, r9, lsr #32
    5480:	13000006 	movwne	r0, #6
    5484:	00706d74 	rsbseq	r6, r0, r4, ror sp
    5488:	0070ca02 	rsbseq	ip, r0, r2, lsl #20
    548c:	53010000 	movwpl	r0, #4096	; 0x1000
    5490:	29d61700 	ldmibcs	r6, {r8, r9, sl, ip}^
    5494:	29de0000 	ldmibcs	lr, {}^	; <UNPREDICTABLE>
    5498:	74130000 	ldrvc	r0, [r3], #-0
    549c:	0200706d 	andeq	r7, r0, #109	; 0x6d
    54a0:	000070ce 	andeq	r7, r0, lr, asr #1
    54a4:	00530100 	subseq	r0, r3, r0, lsl #2
    54a8:	60011800 	andvs	r1, r1, r0, lsl #16
    54ac:	02000015 	andeq	r0, r0, #21
    54b0:	009001e3 	addseq	r0, r0, r3, ror #3
    54b4:	29f00000 	ldmibcs	r0!, {}^	; <UNPREDICTABLE>
    54b8:	2a380000 	bcs	e054c0 <_flash_swap_addr+0xdc5cc0>
    54bc:	13f00000 	mvnsne	r0, #0
    54c0:	06440000 	strbeq	r0, [r4], -r0
    54c4:	6d120000 	ldcvs	0, cr0, [r2, #-0]
    54c8:	e3020070 	movw	r0, #8304	; 0x2070
    54cc:	00000435 	andeq	r0, r0, r5, lsr r4
    54d0:	007c9102 	rsbseq	r9, ip, r2, lsl #2
    54d4:	15490118 	strbne	r0, [r9, #-280]	; 0xfffffee8
    54d8:	fa020000 	blx	854e0 <_flash_swap_addr+0x45ce0>
    54dc:	00043501 	andeq	r3, r4, r1, lsl #10
    54e0:	002a4000 	eoreq	r4, sl, r0
    54e4:	002af000 	eoreq	pc, sl, r0
    54e8:	00141000 	andseq	r1, r4, r0
    54ec:	0006e900 	andeq	lr, r6, r0, lsl #18
    54f0:	74631300 	strbtvc	r1, [r3], #-768	; 0xfffffd00
    54f4:	fb020070 	blx	856be <_flash_swap_addr+0x45ebe>
    54f8:	00000248 	andeq	r0, r0, r8, asr #4
    54fc:	136c9102 	cmnne	ip, #-2147483648	; 0x80000000
    5500:	00706d75 	rsbseq	r6, r0, r5, ror sp
    5504:	0435fc02 	ldrteq	pc, [r5], #-3074	; 0xfffff3fe	; <UNPREDICTABLE>
    5508:	91020000 	mrsls	r0, (UNDEF: 2)
    550c:	706d1368 	rsbvc	r1, sp, r8, ror #6
    5510:	35fc0200 	ldrbcc	r0, [ip, #512]!	; 0x200
    5514:	02000004 	andeq	r0, r0, #4
    5518:	50167491 	mulspl	r6, r1, r4
    551c:	5800002a 	stmdapl	r0, {r1, r3, r5}
    5520:	a500002a 	strge	r0, [r0, #-42]	; 0xffffffd6
    5524:	13000006 	movwne	r0, #6
    5528:	00706d74 	rsbseq	r6, r0, r4, ror sp
    552c:	0070fe02 	rsbseq	pc, r0, r2, lsl #28
    5530:	53010000 	movwpl	r0, #4096	; 0x1000
    5534:	2a701600 	bcs	1c0ad3c <_flash_swap_addr+0x1bcb53c>
    5538:	2ad80000 	bcs	ff605540 <_stack_start+0xdf5f5540>
    553c:	06d00000 	ldrbeq	r0, [r0], r0
    5540:	74190000 	ldrvc	r0, [r9], #-0
    5544:	0b020070 	bleq	8570c <_flash_swap_addr+0x45f0c>
    5548:	00024801 	andeq	r4, r2, r1, lsl #16
    554c:	64910200 	ldrvs	r0, [r1], #512	; 0x200
    5550:	00109c1a 	andseq	r9, r0, sl, lsl ip
    5554:	010f0200 	mrseq	r0, (UNDEF: 47)
    5558:	000000c7 	andeq	r0, r0, r7, asr #1
    555c:	00709102 	rsbseq	r9, r0, r2, lsl #2
    5560:	002ae017 	eoreq	lr, sl, r7, lsl r0
    5564:	002ae800 	eoreq	lr, sl, r0, lsl #16
    5568:	6d741900 	ldclvs	9, cr1, [r4, #-0]
    556c:	26020070 			; <UNDEFINED> instruction: 0x26020070
    5570:	00007001 	andeq	r7, r0, r1
    5574:	00530100 	subseq	r0, r3, r0, lsl #2
    5578:	6e011b00 	vmlavs.f64	d1, d1, d0
    557c:	02000015 	andeq	r0, r0, #21
    5580:	35010136 	strcc	r0, [r1, #-310]	; 0xfffffeca
    5584:	f0000004 			; <UNDEFINED> instruction: 0xf0000004
    5588:	8c00002a 	stchi	0, cr0, [r0], {42}	; 0x2a
    558c:	3c00002b 	stccc	0, cr0, [r0], {43}	; 0x2b
    5590:	5b000014 	blpl	55e8 <_data_load+0x28f8>
    5594:	19000007 	stmdbne	r0, {r0, r1, r2}
    5598:	00707463 	rsbseq	r7, r0, r3, ror #8
    559c:	48013702 	stmdami	r1, {r1, r8, r9, sl, ip, sp}
    55a0:	02000002 	andeq	r0, r0, #2
    55a4:	75196c91 	ldrvc	r6, [r9, #-3217]	; 0xfffff36f
    55a8:	0200706d 	andeq	r7, r0, #109	; 0x6d
    55ac:	04350138 	ldrteq	r0, [r5], #-312	; 0xfffffec8
    55b0:	91020000 	mrsls	r0, (UNDEF: 2)
    55b4:	706d1968 	rsbvc	r1, sp, r8, ror #18
    55b8:	01380200 	teqeq	r8, r0, lsl #4
    55bc:	00000435 	andeq	r0, r0, r5, lsr r4
    55c0:	17749102 	ldrbne	r9, [r4, -r2, lsl #2]!
    55c4:	00002b18 	andeq	r2, r0, r8, lsl fp
    55c8:	00002b7c 	andeq	r2, r0, ip, ror fp
    55cc:	00707419 	rsbseq	r7, r0, r9, lsl r4
    55d0:	48014802 	stmdami	r1, {r1, fp, lr}
    55d4:	02000002 	andeq	r0, r0, #2
    55d8:	9c1a6491 	cfldrsls	mvf6, [sl], {145}	; 0x91
    55dc:	02000010 	andeq	r0, r0, #16
    55e0:	00c7014c 	sbceq	r0, r7, ip, asr #2
    55e4:	91020000 	mrsls	r0, (UNDEF: 2)
    55e8:	1c000070 	stcne	0, cr0, [r0], {112}	; 0x70
    55ec:	00158701 	andseq	r8, r5, r1, lsl #14
    55f0:	016f0200 	cmneq	pc, r0, lsl #4
    55f4:	002b9001 	eoreq	r9, fp, r1
    55f8:	002c1600 	eoreq	r1, ip, r0, lsl #12
    55fc:	00146800 	andseq	r6, r4, r0, lsl #16
    5600:	0007ee00 	andeq	lr, r7, r0, lsl #28
    5604:	74631900 	strbtvc	r1, [r3], #-2304	; 0xfffff700
    5608:	70020070 	andvc	r0, r2, r0, ror r0
    560c:	00024801 	andeq	r4, r2, r1, lsl #16
    5610:	74910200 	ldrvc	r0, [r1], #512	; 0x200
    5614:	002ba016 	eoreq	sl, fp, r6, lsl r0
    5618:	002ba800 	eoreq	sl, fp, r0, lsl #16
    561c:	0007a000 	andeq	sl, r7, r0
    5620:	6d741900 	ldclvs	9, cr1, [r4, #-0]
    5624:	72020070 	andvc	r0, r2, #112	; 0x70
    5628:	00007001 	andeq	r7, r0, r1
    562c:	00530100 	subseq	r0, r3, r0, lsl #2
    5630:	002bb016 	eoreq	fp, fp, r6, lsl r0
    5634:	002bf600 	eoreq	pc, fp, r0, lsl #12
    5638:	0007d500 	andeq	sp, r7, r0, lsl #10
    563c:	6d751900 	ldclvs	9, cr1, [r5, #-0]
    5640:	75020070 	strvc	r0, [r2, #-112]	; 0xffffff90
    5644:	00043501 	andeq	r3, r4, r1, lsl #10
    5648:	70910200 	addsvc	r0, r1, r0, lsl #4
    564c:	002bc817 	eoreq	ip, fp, r7, lsl r8
    5650:	002bee00 	eoreq	lr, fp, r0, lsl #28
    5654:	70741900 	rsbsvc	r1, r4, r0, lsl #18
    5658:	01780200 	cmneq	r8, r0, lsl #4
    565c:	00000248 	andeq	r0, r0, r8, asr #4
    5660:	006c9102 	rsbeq	r9, ip, r2, lsl #2
    5664:	2c0a1700 	stccs	7, cr1, [sl], {-0}
    5668:	2c120000 	ldccs	0, cr0, [r2], {-0}
    566c:	74190000 	ldrvc	r0, [r9], #-0
    5670:	0200706d 	andeq	r7, r0, #109	; 0x6d
    5674:	00700184 	rsbseq	r0, r0, r4, lsl #3
    5678:	53010000 	movwpl	r0, #4096	; 0x1000
    567c:	8e1d0000 	cdphi	0, 1, cr0, cr13, cr0, {0}
    5680:	0800000e 	stmdaeq	r0, {r1, r2, r3}
    5684:	00039b68 	andeq	r9, r3, r8, ror #22
    5688:	1d010100 	stfnes	f0, [r1, #-0]
    568c:	00000e8e 	andeq	r0, r0, lr, lsl #29
    5690:	039b6808 	orrseq	r6, fp, #8, 16	; 0x80000
    5694:	01010000 	mrseq	r0, (UNDEF: 1)
	...

Disassembly of section .debug_abbrev:

00000000 <.debug_abbrev>:
       0:	10001101 	andne	r1, r0, r1, lsl #2
       4:	12011106 	andne	r1, r1, #-2147483647	; 0x80000001
       8:	1b080301 	blne	200c14 <_flash_swap_addr+0x1c1414>
       c:	13082508 	movwne	r2, #34056	; 0x8508
      10:	00000005 	andeq	r0, r0, r5
      14:	25011101 	strcs	r1, [r1, #-257]	; 0xfffffeff
      18:	030b130e 	movweq	r1, #45838	; 0xb30e
      1c:	110e1b0e 	tstne	lr, lr, lsl #22
      20:	10011201 	andne	r1, r1, r1, lsl #4
      24:	02000006 	andeq	r0, r0, #6
      28:	0b0b0024 	bleq	2c00c0 <_flash_swap_addr+0x2808c0>
      2c:	08030b3e 	stmdaeq	r3, {r1, r2, r3, r4, r5, r8, r9, fp}
      30:	24030000 	strcs	r0, [r3], #-0
      34:	3e0b0b00 	vmlacc.f64	d0, d11, d0
      38:	000e030b 	andeq	r0, lr, fp, lsl #6
      3c:	00160400 	andseq	r0, r6, r0, lsl #8
      40:	0b3a0e03 	bleq	e83854 <_flash_swap_addr+0xe44054>
      44:	13490b3b 	movtne	r0, #39739	; 0x9b3b
      48:	0f050000 	svceq	0x00050000
      4c:	000b0b00 	andeq	r0, fp, r0, lsl #22
      50:	000f0600 	andeq	r0, pc, r0, lsl #12
      54:	13490b0b 	movtne	r0, #39691	; 0x9b0b
      58:	26070000 	strcs	r0, [r7], -r0
      5c:	00134900 	andseq	r4, r3, r0, lsl #18
      60:	01040800 	tsteq	r4, r0, lsl #16
      64:	0b3a0b0b 	bleq	e82c98 <_flash_swap_addr+0xe43498>
      68:	13010b3b 	movwne	r0, #6971	; 0x1b3b
      6c:	28090000 	stmdacs	r9, {}	; <UNPREDICTABLE>
      70:	1c0e0300 	stcne	3, cr0, [lr], {-0}
      74:	0a00000d 	beq	b0 <_vector_rom+0xb0>
      78:	0b0b0104 	bleq	2c0490 <_flash_swap_addr+0x280c90>
      7c:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xfffff4c6
      80:	00001301 	andeq	r1, r0, r1, lsl #6
      84:	3f012e0b 	svccc	0x00012e0b
      88:	3a0e030c 	bcc	380cc0 <_flash_swap_addr+0x3414c0>
      8c:	270b3b0b 	strcs	r3, [fp, -fp, lsl #22]
      90:	1201110c 	andne	r1, r1, #12, 2
      94:	01064001 	tsteq	r6, r1
      98:	0c000013 	stceq	0, cr0, [r0], {19}
      9c:	0e030005 	cdpeq	0, 0, cr0, cr3, cr5, {0}
      a0:	0b3b0b3a 	bleq	ec2d90 <_flash_swap_addr+0xe83590>
      a4:	0a021349 	beq	84dd0 <_flash_swap_addr+0x455d0>
      a8:	2e0d0000 	cdpcs	0, 0, cr0, cr13, cr0, {0}
      ac:	3a0e0301 	bcc	380cb8 <_flash_swap_addr+0x3414b8>
      b0:	270b3b0b 	strcs	r3, [fp, -fp, lsl #22]
      b4:	1113490c 	tstne	r3, ip, lsl #18
      b8:	40011201 	andmi	r1, r1, r1, lsl #4
      bc:	00130106 	andseq	r0, r3, r6, lsl #2
      c0:	00050e00 	andeq	r0, r5, r0, lsl #28
      c4:	0b3a0803 	bleq	e820d8 <_flash_swap_addr+0xe428d8>
      c8:	13490b3b 	movtne	r0, #39739	; 0x9b3b
      cc:	00000a02 	andeq	r0, r0, r2, lsl #20
      d0:	03002e0f 	movweq	r2, #3599	; 0xe0f
      d4:	3b0b3a0e 	blcc	2ce914 <_flash_swap_addr+0x28f114>
      d8:	110c270b 	tstne	ip, fp, lsl #14
      dc:	40011201 	andmi	r1, r1, r1, lsl #4
      e0:	10000006 	andne	r0, r0, r6
      e4:	0e03012e 	adfeqsp	f0, f3, #0.5
      e8:	0b3b0b3a 	bleq	ec2dd8 <_flash_swap_addr+0xe835d8>
      ec:	01110c27 	tsteq	r1, r7, lsr #24
      f0:	06400112 			; <UNDEFINED> instruction: 0x06400112
      f4:	00001301 	andeq	r1, r0, r1, lsl #6
      f8:	03003411 	movweq	r3, #1041	; 0x411
      fc:	3b0b3a0e 	blcc	2ce93c <_flash_swap_addr+0x28f13c>
     100:	0213490b 	andseq	r4, r3, #180224	; 0x2c000
     104:	1200000a 	andne	r0, r0, #10
     108:	0c3f002e 	ldceq	0, cr0, [pc], #-184	; 58 <_vector_rom+0x58>
     10c:	0b3a0e03 	bleq	e83920 <_flash_swap_addr+0xe44120>
     110:	0c270b3b 	stceq	11, cr0, [r7], #-236	; 0xffffff14
     114:	01111349 	tsteq	r1, r9, asr #6
     118:	06400112 			; <UNDEFINED> instruction: 0x06400112
     11c:	01130000 	tsteq	r3, r0
     120:	01134901 	tsteq	r3, r1, lsl #18
     124:	14000013 	strne	r0, [r0], #-19	; 0xffffffed
     128:	13490021 	movtne	r0, #36897	; 0x9021
     12c:	00000b2f 	andeq	r0, r0, pc, lsr #22
     130:	01110100 	tsteq	r1, r0, lsl #2
     134:	0b130e25 	bleq	4c39d0 <_flash_swap_addr+0x4841d0>
     138:	0e1b0e03 	cdpeq	14, 1, cr0, cr11, cr3, {0}
     13c:	01120111 	tsteq	r2, r1, lsl r1
     140:	00000610 	andeq	r0, r0, r0, lsl r6
     144:	0b002402 	bleq	9154 <_data_load+0x6464>
     148:	030b3e0b 	movweq	r3, #48651	; 0xbe0b
     14c:	0300000e 	movweq	r0, #14
     150:	0e030016 	mcreq	0, 0, r0, cr3, cr6, {0}
     154:	0b3b0b3a 	bleq	ec2e44 <_flash_swap_addr+0xe83644>
     158:	00001349 	andeq	r1, r0, r9, asr #6
     15c:	0b010404 	bleq	41174 <_flash_swap_addr+0x1974>
     160:	3b0b3a0b 	blcc	2ce994 <_flash_swap_addr+0x28f194>
     164:	00130105 	andseq	r0, r3, r5, lsl #2
     168:	00280500 	eoreq	r0, r8, r0, lsl #10
     16c:	0d1c0e03 	ldceq	14, cr0, [ip, #-12]
     170:	13060000 	movwne	r0, #24576	; 0x6000
     174:	3a0b0b01 	bcc	2c2d80 <_flash_swap_addr+0x283580>
     178:	01053b0b 	tsteq	r5, fp, lsl #22
     17c:	07000013 	smladeq	r0, r3, r0, r0
     180:	0e03000d 	cdpeq	0, 0, cr0, cr3, cr13, {0}
     184:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xfffff4c6
     188:	0a381349 	beq	e04eb4 <_flash_swap_addr+0xdc56b4>
     18c:	16080000 	strne	r0, [r8], -r0
     190:	3a0e0300 	bcc	380d98 <_flash_swap_addr+0x341598>
     194:	49053b0b 	stmdbmi	r5, {r0, r1, r3, r8, r9, fp, ip, sp}
     198:	09000013 	stmdbeq	r0, {r0, r1, r4}
     19c:	0b0b0024 	bleq	2c0234 <_flash_swap_addr+0x280a34>
     1a0:	08030b3e 	stmdaeq	r3, {r1, r2, r3, r4, r5, r8, r9, fp}
     1a4:	040a0000 	streq	r0, [sl], #-0
     1a8:	3a0b0b01 	bcc	2c2db4 <_flash_swap_addr+0x2835b4>
     1ac:	010b3b0b 	tsteq	fp, fp, lsl #22
     1b0:	0b000013 	bleq	204 <_vector_rom+0x204>
     1b4:	0e03012e 	adfeqsp	f0, f3, #0.5
     1b8:	0b3b0b3a 	bleq	ec2ea8 <_flash_swap_addr+0xe836a8>
     1bc:	13490c27 	movtne	r0, #39975	; 0x9c27
     1c0:	01120111 	tsteq	r2, r1, lsl r1
     1c4:	13010640 	movwne	r0, #5696	; 0x1640
     1c8:	050c0000 	streq	r0, [ip, #-0]
     1cc:	3a0e0300 	bcc	380dd4 <_flash_swap_addr+0x3415d4>
     1d0:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     1d4:	000a0213 	andeq	r0, sl, r3, lsl r2
     1d8:	00340d00 	eorseq	r0, r4, r0, lsl #26
     1dc:	0b3a0e03 	bleq	e839f0 <_flash_swap_addr+0xe441f0>
     1e0:	13490b3b 	movtne	r0, #39739	; 0x9b3b
     1e4:	00000a02 	andeq	r0, r0, r2, lsl #20
     1e8:	0b000f0e 	bleq	3e28 <_data_load+0x1138>
     1ec:	0013490b 	andseq	r4, r3, fp, lsl #18
     1f0:	00350f00 	eorseq	r0, r5, r0, lsl #30
     1f4:	00001349 	andeq	r1, r0, r9, asr #6
     1f8:	3f012e10 	svccc	0x00012e10
     1fc:	3a0e030c 	bcc	380e34 <_flash_swap_addr+0x341634>
     200:	270b3b0b 	strcs	r3, [fp, -fp, lsl #22]
     204:	1201110c 	andne	r1, r1, #12, 2
     208:	01064001 	tsteq	r6, r1
     20c:	11000013 	tstne	r0, r3, lsl r0
     210:	08030005 	stmdaeq	r3, {r0, r2}
     214:	0b3b0b3a 	bleq	ec2f04 <_flash_swap_addr+0xe83704>
     218:	0a021349 	beq	84f44 <_flash_swap_addr+0x45744>
     21c:	2e120000 	cdpcs	0, 1, cr0, cr2, cr0, {0}
     220:	030c3f01 	movweq	r3, #52993	; 0xcf01
     224:	3b0b3a0e 	blcc	2cea64 <_flash_swap_addr+0x28f264>
     228:	490c270b 	stmdbmi	ip, {r0, r1, r3, r8, r9, sl, sp}
     22c:	12011113 	andne	r1, r1, #-1073741820	; 0xc0000004
     230:	01064001 	tsteq	r6, r1
     234:	13000013 	movwne	r0, #19
     238:	0c3f012e 	ldfeqs	f0, [pc], #-184	; 188 <_vector_rom+0x188>
     23c:	0b3a0e03 	bleq	e83a50 <_flash_swap_addr+0xe44250>
     240:	0c270b3b 	stceq	11, cr0, [r7], #-236	; 0xffffff14
     244:	01111349 	tsteq	r1, r9, asr #6
     248:	06400112 			; <UNDEFINED> instruction: 0x06400112
     24c:	01000000 	mrseq	r0, (UNDEF: 0)
     250:	0e250111 	mcreq	1, 1, r0, cr5, cr1, {0}
     254:	0e030b13 	vmoveq.32	d3[0], r0
     258:	01110e1b 	tsteq	r1, fp, lsl lr
     25c:	06100112 			; <UNDEFINED> instruction: 0x06100112
     260:	16020000 	strne	r0, [r2], -r0
     264:	3a0e0300 	bcc	380e6c <_flash_swap_addr+0x34166c>
     268:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     26c:	03000013 	movweq	r0, #19
     270:	0b0b0024 	bleq	2c0308 <_flash_swap_addr+0x280b08>
     274:	0e030b3e 	vmoveq.16	d3[0], r0
     278:	04040000 	streq	r0, [r4], #-0
     27c:	3a0b0b01 	bcc	2c2e88 <_flash_swap_addr+0x283688>
     280:	01053b0b 	tsteq	r5, fp, lsl #22
     284:	05000013 	streq	r0, [r0, #-19]	; 0xffffffed
     288:	0e030028 	cdpeq	0, 0, cr0, cr3, cr8, {1}
     28c:	00000d1c 	andeq	r0, r0, ip, lsl sp
     290:	03001606 	movweq	r1, #1542	; 0x606
     294:	3b0b3a0e 	blcc	2cead4 <_flash_swap_addr+0x28f2d4>
     298:	00134905 	andseq	r4, r3, r5, lsl #18
     29c:	01130700 	tsteq	r3, r0, lsl #14
     2a0:	0b3a0b0b 	bleq	e82ed4 <_flash_swap_addr+0xe436d4>
     2a4:	1301053b 	movwne	r0, #5435	; 0x153b
     2a8:	0d080000 	stceq	0, cr0, [r8, #-0]
     2ac:	3a080300 	bcc	200eb4 <_flash_swap_addr+0x1c16b4>
     2b0:	49053b0b 	stmdbmi	r5, {r0, r1, r3, r8, r9, fp, ip, sp}
     2b4:	000a3813 	andeq	r3, sl, r3, lsl r8
     2b8:	000d0900 	andeq	r0, sp, r0, lsl #18
     2bc:	0b3a0e03 	bleq	e83ad0 <_flash_swap_addr+0xe442d0>
     2c0:	1349053b 	movtne	r0, #38203	; 0x953b
     2c4:	00000a38 	andeq	r0, r0, r8, lsr sl
     2c8:	4900260a 	stmdbmi	r0, {r1, r3, r9, sl, sp}
     2cc:	0b000013 	bleq	320 <_vector_rom+0x320>
     2d0:	050b0113 	streq	r0, [fp, #-275]	; 0xfffffeed
     2d4:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xfffff4c6
     2d8:	00001301 	andeq	r1, r0, r1, lsl #6
     2dc:	4901010c 	stmdbmi	r1, {r2, r3, r8}
     2e0:	00130113 	andseq	r0, r3, r3, lsl r1
     2e4:	00210d00 	eoreq	r0, r1, r0, lsl #26
     2e8:	0b2f1349 	bleq	bc5014 <_flash_swap_addr+0xb85814>
     2ec:	240e0000 	strcs	r0, [lr], #-0
     2f0:	3e0b0b00 	vmlacc.f64	d0, d11, d0
     2f4:	0008030b 	andeq	r0, r8, fp, lsl #6
     2f8:	01130f00 	tsteq	r3, r0, lsl #30
     2fc:	0b3a0b0b 	bleq	e82f30 <_flash_swap_addr+0xe43730>
     300:	13010b3b 	movwne	r0, #6971	; 0x1b3b
     304:	0d100000 	ldceq	0, cr0, [r0, #-0]
     308:	3a080300 	bcc	200f10 <_flash_swap_addr+0x1c1710>
     30c:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     310:	000a3813 	andeq	r3, sl, r3, lsl r8
     314:	000f1100 	andeq	r1, pc, r0, lsl #2
     318:	13490b0b 	movtne	r0, #39691	; 0x9b0b
     31c:	35120000 	ldrcc	r0, [r2, #-0]
     320:	00134900 	andseq	r4, r3, r0, lsl #18
     324:	01041300 	mrseq	r1, LR_abt
     328:	0b3a0b0b 	bleq	e82f5c <_flash_swap_addr+0xe4375c>
     32c:	13010b3b 	movwne	r0, #6971	; 0x1b3b
     330:	0d140000 	ldceq	0, cr0, [r4, #-0]
     334:	3a0e0300 	bcc	380f3c <_flash_swap_addr+0x34173c>
     338:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     33c:	000a3813 	andeq	r3, sl, r3, lsl r8
     340:	012e1500 	teqeq	lr, r0, lsl #10
     344:	0b3a0e03 	bleq	e83b58 <_flash_swap_addr+0xe44358>
     348:	0c270b3b 	stceq	11, cr0, [r7], #-236	; 0xffffff14
     34c:	01120111 	tsteq	r2, r1, lsl r1
     350:	13010640 	movwne	r0, #5696	; 0x1640
     354:	05160000 	ldreq	r0, [r6, #-0]
     358:	3a080300 	bcc	200f60 <_flash_swap_addr+0x1c1760>
     35c:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     360:	000a0213 	andeq	r0, sl, r3, lsl r2
     364:	012e1700 	teqeq	lr, r0, lsl #14
     368:	0b3a0e03 	bleq	e83b7c <_flash_swap_addr+0xe4437c>
     36c:	0c27053b 	cfstr32eq	mvfx0, [r7], #-236	; 0xffffff14
     370:	01120111 	tsteq	r2, r1, lsl r1
     374:	13010640 	movwne	r0, #5696	; 0x1640
     378:	05180000 	ldreq	r0, [r8, #-0]
     37c:	3a080300 	bcc	200f84 <_flash_swap_addr+0x1c1784>
     380:	49053b0b 	stmdbmi	r5, {r0, r1, r3, r8, r9, fp, ip, sp}
     384:	000a0213 	andeq	r0, sl, r3, lsl r2
     388:	012e1900 	teqeq	lr, r0, lsl #18
     38c:	0e030c3f 	mcreq	12, 0, r0, cr3, cr15, {1}
     390:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xfffff4c6
     394:	01110c27 	tsteq	r1, r7, lsr #24
     398:	06400112 			; <UNDEFINED> instruction: 0x06400112
     39c:	00001301 	andeq	r1, r0, r1, lsl #6
     3a0:	0300051a 	movweq	r0, #1306	; 0x51a
     3a4:	3b0b3a0e 	blcc	2cebe4 <_flash_swap_addr+0x28f3e4>
     3a8:	02134905 	andseq	r4, r3, #81920	; 0x14000
     3ac:	1b00000a 	blne	3dc <_vector_rom+0x3dc>
     3b0:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
     3b4:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xfffff4c6
     3b8:	0a021349 	beq	850e4 <_flash_swap_addr+0x458e4>
     3bc:	2e1c0000 	cdpcs	0, 1, cr0, cr12, cr0, {0}
     3c0:	030c3f01 	movweq	r3, #52993	; 0xcf01
     3c4:	3b0b3a0e 	blcc	2cec04 <_flash_swap_addr+0x28f404>
     3c8:	490c2705 	stmdbmi	ip, {r0, r2, r8, r9, sl, sp}
     3cc:	12011113 	andne	r1, r1, #-1073741820	; 0xc0000004
     3d0:	01064001 	tsteq	r6, r1
     3d4:	1d000013 	stcne	0, cr0, [r0, #-76]	; 0xffffffb4
     3d8:	0c270115 	stfeqs	f0, [r7], #-84	; 0xffffffac
     3dc:	00001301 	andeq	r1, r0, r1, lsl #6
     3e0:	4900051e 	stmdbmi	r0, {r1, r2, r3, r4, r8, sl}
     3e4:	1f000013 	svcne	0x00000013
     3e8:	0c3f002e 	ldceq	0, cr0, [pc], #-184	; 338 <_vector_rom+0x338>
     3ec:	0b3a0e03 	bleq	e83c00 <_flash_swap_addr+0xe44400>
     3f0:	0111053b 	tsteq	r1, fp, lsr r5
     3f4:	06400112 			; <UNDEFINED> instruction: 0x06400112
     3f8:	34200000 	strtcc	r0, [r0], #-0
     3fc:	3a0e0300 	bcc	381004 <_flash_swap_addr+0x341804>
     400:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     404:	000a0213 	andeq	r0, sl, r3, lsl r2
     408:	00342100 	eorseq	r2, r4, r0, lsl #2
     40c:	0b3a0e03 	bleq	e83c20 <_flash_swap_addr+0xe44420>
    .thumb_func

_default_reset_handler:

unlock_watchdog:
    ldr r6, =0x4005200e
     410:	13490b3b 	movtne	r0, #39739	; 0x9b3b
    ldr r0, =0xc520
    strh r0, [r6]
     414:	0c3c0c3f 	ldceq	12, cr0, [ip], #-252	; 0xffffff04
    ldr r0, =0xd928
    strh r0, [r6]
     418:	34220000 	strtcc	r0, [r2], #-0

disable_watchdog:
    ldr r6, =0x40052000
    ldr r0, =0x01d2
     41c:	3a0e0300 	bcc	381024 <_flash_swap_addr+0x341824>
     * address 0x00000000 (which is the first element in the vector_table) by
     * the hardware. The next three lines are required in case this image
     * is not located at 0x0 (i.e. it is being launched from a bootloader).
     */

    ldr r1, =_vector_table
     420:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    ldr r2, [r1]
    mov	sp,r2
     424:	020c3f13 	andeq	r3, ip, #19, 30	; 0x4c
chibi_setup:
    /*
     * ChibiOS requires a process stack to be initialized.
     */
    ldr r1, =_process_stack_start
    msr PSP, r1
     428:	0000000a 	andeq	r0, r0, sl

    /* TODO: FPU register initialization per crt0.c */
    /*
     * Set up system to run in privileged mode using the PSP stack
     */
    ldr r1, =0x00000002
     42c:	25011101 	strcs	r1, [r1, #-257]	; 0xfffffeff
    msr CONTROL, r1
     430:	030b130e 	movweq	r1, #45838	; 0xb30e
    isb
     434:	110e1b0e 	tstne	lr, lr, lsl #22
     * address and the start address are not the same. This code supports
     * running an entire image out of SRAM.
     */

    ldr r0, =_text_start
    ldr r1, =_text_end
     438:	10011201 	andne	r1, r1, r1, lsl #4
    ldr r2, =_text_load

    cmp r0, r2
     43c:	02000006 	andeq	r0, r0, #6
    beq end_text_loop
     440:	0b0b0024 	bleq	2c04d8 <_flash_swap_addr+0x280cd8>
text_loop:
    cmp r0, r1
    ittt    lt
     444:	0e030b3e 	vmoveq.16	d3[0], r0
    ldrlt   r3, [r2], #4
     448:	16030000 	strne	r0, [r3], -r0
    strlt   r3, [r0], #4
     44c:	3a0e0300 	bcc	381054 <_flash_swap_addr+0x341854>
    blt     text_loop
     450:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    /*
     * Relocate the .ramcode section from FLASH to SRAM.
     */

    ldr r0, =_ramcode_start
    ldr r1, =_ramcode_end
     454:	04000013 	streq	r0, [r0], #-19	; 0xffffffed
    ldr r2, =_ramcode_load

ramcode_loop:
    cmp r0, r1
     458:	0b0b0104 	bleq	2c0870 <_flash_swap_addr+0x281070>
    ittt    lt
    ldrlt   r3, [r2], #4
     45c:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xfffff4c6
    strlt   r3, [r0], #4
     460:	00001301 	andeq	r1, r0, r1, lsl #6
    blt     ramcode_loop
     464:	03002805 	movweq	r2, #2053	; 0x805

    /*
     * Relocate vector table to SRAM.
     */

     ldr r0, =_vector_ram_start
     468:	000d1c0e 	andeq	r1, sp, lr, lsl #24
     ldr r1, =_vector_ram_end
     ldr r2, =_vector_rom
     46c:	01130600 	tsteq	r3, r0, lsl #12
vector_loop:
    cmp r0, r1
    ittt    lt
     470:	0b3a0b0b 	bleq	e830a4 <_flash_swap_addr+0xe438a4>
    ldrlt   r3, [r2], #4
     474:	1301053b 	movwne	r0, #5435	; 0x153b
    strlt   r3, [r0], #4
     478:	0d070000 	stceq	0, cr0, [r7, #-0]
    blt     vector_loop
     47c:	3a0e0300 	bcc	381084 <_flash_swap_addr+0x341884>
    /*
     * Point to the SRAM vector table.
     */

    ldr r1,=0xe000ed08
    ldr r0,=_vector_ram_start
     480:	49053b0b 	stmdbmi	r5, {r0, r1, r3, r8, r9, fp, ip, sp}
     * Note: _data_start contains the SRAM (destination) address and
     *       _text_end contains the (source) address of the .data section
     *       in FLASH.
     */

    ldr r0, =_data_start
     484:	000a3813 	andeq	r3, sl, r3, lsl r8
    ldr r1, =_data_end
    ldr r2, =_data_load
     488:	00160800 	andseq	r0, r6, r0, lsl #16

data_loop:
    cmp r0, r1
    ittt    lt
     48c:	0b3a0e03 	bleq	e83ca0 <_flash_swap_addr+0xe444a0>
    ldrlt   r3, [r2], #4
     490:	1349053b 	movtne	r0, #38203	; 0x953b
    strlt   r3, [r0], #4
     494:	24090000 	strcs	r0, [r9], #-0
    blt     data_loop
     498:	3e0b0b00 	vmlacc.f64	d0, d11, d0
    /*
     * Zero out the .bss section in SRAM.
     */

    ldr r0, =_bss_start
    ldr r1, =_bss_end
     49c:	0008030b 	andeq	r0, r8, fp, lsl #6
    ldr r2, =0x00000000

bss_loop:
    cmp r0, r1
     4a0:	01130a00 	tsteq	r3, r0, lsl #20
    itt     lt
    strlt   r2, [r0], #4
     4a4:	0b3a0b0b 	bleq	e830d8 <_flash_swap_addr+0xe438d8>
    blt     bss_loop
     4a8:	13010b3b 	movwne	r0, #6971	; 0x1b3b

    /*
     * Zero out heap.
     */

    ldr r0, =_heap_start
     4ac:	0d0b0000 	stceq	0, cr0, [fp, #-0]
    ldr r1, =_heap_end

heap_loop:
    cmp r0, r1
     4b0:	3a0e0300 	bcc	3810b8 <_flash_swap_addr+0x3418b8>
    itt     lt
    strlt   r2, [r0], #4
     4b4:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    blt     heap_loop
     4b8:	000a3813 	andeq	r3, sl, r3, lsl r8
    ldr r0, =_stack_start
    ldr r1, =_stack_end
    ldr r2, =0xefefefef
*/

    ldr r0, =_stack_end
     4bc:	002e0c00 	eoreq	r0, lr, r0, lsl #24
    ldr r1, =_stack_start
    ldr r2, =0xefefefef
     4c0:	0e030c3f 	mcreq	12, 0, r0, cr3, cr15, {1}

stack_loop:
    cmp r0, r1
    itt     lt
     4c4:	0b3b0b3a 	bleq	ec31b4 <_flash_swap_addr+0xe839b4>
    strlt   r2, [r0], #4
     4c8:	01120111 	tsteq	r2, r1, lsl r1
    blt     stack_loop
     4cc:	00000640 	andeq	r0, r0, r0, asr #12

call_user_asm_code:
    bl main
     4d0:	3f012e0d 	svccc	0x00012e0d
    /*
     * Epilogue processing would go here.
     */

end_loop:
    b end_loop
     4d4:	3a0e030c 	bcc	38110c <_flash_swap_addr+0x34190c>

    .align 2
    .thumb_func

_default_nmi_handler:
    b _default_nmi_handler
     4d8:	270b3b0b 	strcs	r3, [fp, -fp, lsl #22]

    .align 2
    .thumb_func

_default_fault_handler:
    b _default_fault_handler
     4dc:	1201110c 	andne	r1, r1, #12, 2

    .align 2
    .thumb_func

_default_irq_handler:
    b _default_irq_handler
     4e0:	01064001 	tsteq	r6, r1
    .thumb_func

_default_reset_handler:

unlock_watchdog:
    ldr r6, =0x4005200e
     4e4:	0e000013 	mcreq	0, 0, r0, cr0, cr3, {0}
    ldr r0, =0xc520
     4e8:	0e030005 	cdpeq	0, 0, cr0, cr3, cr5, {0}
    strh r0, [r6]
    ldr r0, =0xd928
     4ec:	0b3b0b3a 	bleq	ec31dc <_flash_swap_addr+0xe839dc>
    strh r0, [r6]

disable_watchdog:
    ldr r6, =0x40052000
     4f0:	0a021349 	beq	8521c <_flash_swap_addr+0x45a1c>
    ldr r0, =0x01d2
     4f4:	0f0f0000 	svceq	0x000f0000
     * address 0x00000000 (which is the first element in the vector_table) by
     * the hardware. The next three lines are required in case this image
     * is not located at 0x0 (i.e. it is being launched from a bootloader).
     */

    ldr r1, =_vector_table
     4f8:	490b0b00 	stmdbmi	fp, {r8, r9, fp}

chibi_setup:
    /*
     * ChibiOS requires a process stack to be initialized.
     */
    ldr r1, =_process_stack_start
     4fc:	10000013 	andne	r0, r0, r3, lsl r0

    /* TODO: FPU register initialization per crt0.c */
    /*
     * Set up system to run in privileged mode using the PSP stack
     */
    ldr r1, =0x00000002
     500:	13490026 	movtne	r0, #36902	; 0x9026
     * Relocate the .text section from FLASH to SRAM only if the load
     * address and the start address are not the same. This code supports
     * running an entire image out of SRAM.
     */

    ldr r0, =_text_start
     504:	2e110000 	cdpcs	0, 1, cr0, cr1, cr0, {0}
    ldr r1, =_text_end
     508:	3a0e0300 	bcc	381110 <_flash_swap_addr+0x341910>
    ldr r2, =_text_load
     50c:	110b3b0b 	tstne	fp, fp, lsl #22

    /*
     * Relocate the .ramcode section from FLASH to SRAM.
     */

    ldr r0, =_ramcode_start
     510:	40011201 	andmi	r1, r1, r1, lsl #4
    ldr r1, =_ramcode_end
     514:	12000006 	andne	r0, r0, #6
    ldr r2, =_ramcode_load
     518:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}

    /*
     * Relocate vector table to SRAM.
     */

     ldr r0, =_vector_ram_start
     51c:	0b3b0b3a 	bleq	ec320c <_flash_swap_addr+0xe83a0c>
     ldr r1, =_vector_ram_end
     520:	0a021349 	beq	8524c <_flash_swap_addr+0x45a4c>
     ldr r2, =_vector_rom
     524:	35130000 	ldrcc	r0, [r3, #-0]

    /*
     * Point to the SRAM vector table.
     */

    ldr r1,=0xe000ed08
     528:	00134900 	andseq	r4, r3, r0, lsl #18
     * Note: _data_start contains the SRAM (destination) address and
     *       _text_end contains the (source) address of the .data section
     *       in FLASH.
     */

    ldr r0, =_data_start
     52c:	11010000 	mrsne	r0, (UNDEF: 1)
    ldr r1, =_data_end
     530:	130e2501 	movwne	r2, #58625	; 0xe501
    ldr r2, =_data_load
     534:	1b0e030b 	blne	381168 <_flash_swap_addr+0x341968>

    /*
     * Zero out the .bss section in SRAM.
     */

    ldr r0, =_bss_start
     538:	5201110e 	andpl	r1, r1, #-2147483645	; 0x80000003
    ldr r1, =_bss_end
     53c:	10065501 	andne	r5, r6, r1, lsl #10
    ldr r2, =0x00000000
     540:	02000006 	andeq	r0, r0, #6

    /*
     * Zero out heap.
     */

    ldr r0, =_heap_start
     544:	0b0b0024 	bleq	2c05dc <_flash_swap_addr+0x280ddc>
    ldr r1, =_heap_end
     548:	08030b3e 	stmdaeq	r3, {r1, r2, r3, r4, r5, r8, r9, fp}
    ldr r0, =_stack_start
    ldr r1, =_stack_end
    ldr r2, =0xefefefef
*/

    ldr r0, =_stack_end
     54c:	24030000 	strcs	r0, [r3], #-0
    ldr r1, =_stack_start
     550:	3e0b0b00 	vmlacc.f64	d0, d11, d0
    ldr r2, =0xefefefef
     554:	000e030b 	andeq	r0, lr, fp, lsl #6
     558:	00160400 	andseq	r0, r6, r0, lsl #8
     55c:	0b3a0e03 	bleq	e83d70 <_flash_swap_addr+0xe44570>
#define TSI_ORANGE_BIT    BIT_5

#define TSI_YELLOW_INDEX  8
#define TSI_YELLOW_BIT    BIT_8

void assert_(const char *file, const int line) { }
     560:	13490b3b 	movtne	r0, #39739	; 0x9b3b
     564:	13050000 	movwne	r0, #20480	; 0x5000
     568:	0b0e0301 	bleq	381174 <_flash_swap_addr+0x341974>
     56c:	3b0b3a0b 	blcc	2ceda0 <_flash_swap_addr+0x28f5a0>
     570:	0013010b 	andseq	r0, r3, fp, lsl #2

static WORKING_AREA(waThread1, 128);
static msg_t Thread1(void *arg) {
     574:	000d0600 	andeq	r0, sp, r0, lsl #12
     578:	0b3a0e03 	bleq	e83d8c <_flash_swap_addr+0xe4458c>
    while (TRUE) {
        chThdSleepMilliseconds(500);
     57c:	13490b3b 	movtne	r0, #39739	; 0x9b3b
     580:	00000a38 	andeq	r0, r0, r8, lsr sl
        gpioToggle(N_LED_YELLOW_PORT, N_LED_YELLOW_PIN);
     584:	03000d07 	movweq	r0, #3335	; 0xd07
     588:	3b0b3a08 	blcc	2cedb0 <_flash_swap_addr+0x28f5b0>
     58c:	3813490b 	ldmdacc	r3, {r0, r1, r3, r8, fp, lr}
     590:	0800000a 	stmdaeq	r0, {r1, r3}
    }
     594:	0b0b0113 	bleq	2c09e8 <_flash_swap_addr+0x2811e8>

    return 0;
}

static void clocksInit(void)
{
     598:	0b3b0b3a 	bleq	ec3288 <_flash_swap_addr+0xe83a88>
     * System:  100 MHz
     * Bus:      50 MHz
     * Flexbus:  50 MHz
     * Flash:    25 MHz
     */
    clockSetDividers(DIVIDE_BY_1, DIVIDE_BY_2, DIVIDE_BY_4, DIVIDE_BY_4);
     59c:	00001301 	andeq	r1, r0, r1, lsl #6
     5a0:	0b000f09 	bleq	41cc <_data_load+0x14dc>
     5a4:	0013490b 	andseq	r4, r3, fp, lsl #18
     5a8:	000f0a00 	andeq	r0, pc, r0, lsl #20
     5ac:	00000b0b 	andeq	r0, r0, fp, lsl #22
    clockConfigMcgOut(MCG_PLL_EXTERNAL_100MHZ);
     5b0:	0301130b 	movweq	r1, #4875	; 0x130b
     5b4:	3a0b0b0e 	bcc	2c31f4 <_flash_swap_addr+0x2839f4>
}
     5b8:	01053b0b 	tsteq	r5, fp, lsl #22

static void systickInit(void)
{
     5bc:	0c000013 	stceq	0, cr0, [r0], {19}
     5c0:	0803000d 	stmdaeq	r3, {r0, r2, r3}
    uint32_t freq = clockGetFreq(CLOCK_CORE);
     5c4:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xfffff4c6
     5c8:	0a381349 	beq	e052f4 <_flash_swap_addr+0xdc5af4>

    NVIC_SYSTICK_RELOAD = freq / CH_FREQUENCY - 1;
     5cc:	150d0000 	strne	r0, [sp, #-0]
     5d0:	010c2701 	tsteq	ip, r1, lsl #14
     5d4:	0e000013 	mcreq	0, 0, r0, cr0, cr3, {0}
     5d8:	13490005 	movtne	r0, #36869	; 0x9005
     5dc:	350f0000 	strcc	r0, [pc, #-0]	; 5e4 <systickInit+0x28>
     5e0:	00134900 	andseq	r4, r3, r0, lsl #18
     5e4:	01171000 	tsteq	r7, r0
     5e8:	0b3a0b0b 	bleq	e8321c <_flash_swap_addr+0xe43a1c>
    NVIC_SYSTICK_VALUE = 0;
     5ec:	13010b3b 	movwne	r0, #6971	; 0x1b3b
     5f0:	0d110000 	ldceq	0, cr0, [r1, #-0]
     5f4:	3a0e0300 	bcc	3811fc <_flash_swap_addr+0x3419fc>
     5f8:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    NVIC_SYSTICK_CONTROL = NVIC_SYSTICK_CONTROL_ENABLE
     5fc:	12000013 	andne	r0, r0, #19
     600:	13490026 	movtne	r0, #36902	; 0x9026
     604:	15130000 	ldrne	r0, [r3, #-0]
                         | NVIC_SYSTICK_CONTROL_TICKINT
                         | NVIC_SYSTICK_CONTROL_CLKSOURCE;
}
     608:	490c2701 	stmdbmi	ip, {r0, r8, r9, sl, sp}
     60c:	00130113 	andseq	r0, r3, r3, lsl r1

int main(void)
{
     610:	012e1400 	teqeq	lr, r0, lsl #8
     614:	0e030c3f 	mcreq	12, 0, r0, cr3, cr15, {1}
    clocksInit();
     618:	0b3b0b3a 	bleq	ec3308 <_flash_swap_addr+0xe83b08>
    systickInit();
     61c:	01110c27 	tsteq	r1, r7, lsr #24
    chSysInit();
     620:	06400112 			; <UNDEFINED> instruction: 0x06400112

    gpioConfig(N_LED_ORANGE_PORT, N_LED_ORANGE_PIN, GPIO_OUTPUT | GPIO_LOW);
     624:	00001301 	andeq	r1, r0, r1, lsl #6
     628:	03000515 	movweq	r0, #1301	; 0x515
     62c:	3b0b3a08 	blcc	2cee54 <_flash_swap_addr+0x28f654>
     630:	0213490b 	andseq	r4, r3, #180224	; 0x2c000
     634:	1600000a 	strne	r0, [r0], -sl
    gpioConfig(N_LED_YELLOW_PORT, N_LED_YELLOW_PIN, GPIO_OUTPUT | GPIO_LOW);
     638:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
     63c:	0b3b0b3a 	bleq	ec332c <_flash_swap_addr+0xe83b2c>
     640:	0a021349 	beq	8536c <_flash_swap_addr+0x45b6c>
     644:	0b170000 	bleq	5c064c <_flash_swap_addr+0x580e4c>
     648:	12011101 	andne	r1, r1, #1073741824	; 0x40000000

    chThdCreateStatic(waThread1, sizeof(waThread1), NORMALPRIO, Thread1, NULL);
     64c:	18000001 	stmdane	r0, {r0}
     650:	08030034 	stmdaeq	r3, {r2, r4, r5}
     654:	0b3b0b3a 	bleq	ec3344 <_flash_swap_addr+0xe83b44>
     658:	0a021349 	beq	85384 <_flash_swap_addr+0x45b84>
     65c:	0b190000 	bleq	640664 <_flash_swap_addr+0x600e64>
     660:	12011101 	andne	r1, r1, #1073741824	; 0x40000000
     664:	00130101 	andseq	r0, r3, r1, lsl #2
     668:	00341a00 	eorseq	r1, r4, r0, lsl #20

    hwInterruptsEnable();
     66c:	0b3a0e03 	bleq	e83e80 <_flash_swap_addr+0xe44680>

    while (TRUE) {
        chThdSleepMilliseconds(123);
     670:	13490b3b 	movtne	r0, #39739	; 0x9b3b
     674:	0c3c0c3f 	ldceq	12, cr0, [ip], #-252	; 0xffffff04
        gpioToggle(N_LED_ORANGE_PORT, N_LED_ORANGE_PIN);
     678:	011b0000 	tsteq	fp, r0
     67c:	01134901 	tsteq	r3, r1, lsl #18
     680:	1c000013 	stcne	0, cr0, [r0], {19}
     684:	13490021 	movtne	r0, #36897	; 0x9021
*
* RETURNS: The corresponding GPIO_BASE_ADDR.
*
*******************************************************************************/
static volatile gpioPort_t *gpioPortGet(uint32_t port)
{
     688:	00000b2f 	andeq	r0, r0, pc, lsr #22
     68c:	0300341d 	movweq	r3, #1053	; 0x41d
    uint32_t addr;

    switch (port) {
     690:	3b0b3a0e 	blcc	2ceed0 <_flash_swap_addr+0x28f6d0>
     694:	3f13490b 	svccc	0x0013490b
     698:	000a020c 	andeq	r0, sl, ip, lsl #4
     69c:	11010000 	mrsne	r0, (UNDEF: 1)
     6a0:	130e2501 	movwne	r2, #58625	; 0xe501
     6a4:	1b0e030b 	blne	3812d8 <_flash_swap_addr+0x341ad8>
     6a8:	5201110e 	andpl	r1, r1, #-2147483645	; 0x80000003
     6ac:	10065501 	andne	r5, r6, r1, lsl #10
     6b0:	02000006 	andeq	r0, r0, #6
     6b4:	0b0b0024 	bleq	2c074c <_flash_swap_addr+0x280f4c>
     6b8:	08030b3e 	stmdaeq	r3, {r1, r2, r3, r4, r5, r8, r9, fp}
     6bc:	24030000 	strcs	r0, [r3], #-0
     6c0:	3e0b0b00 	vmlacc.f64	d0, d11, d0
     6c4:	000e030b 	andeq	r0, lr, fp, lsl #6
     6c8:	00160400 	andseq	r0, r6, r0, lsl #8
     6cc:	0b3a0e03 	bleq	e83ee0 <_flash_swap_addr+0xe446e0>
     6d0:	13490b3b 	movtne	r0, #39739	; 0x9b3b
     6d4:	0f050000 	svceq	0x00050000
     6d8:	000b0b00 	andeq	r0, fp, r0, lsl #22
     6dc:	000f0600 	andeq	r0, pc, r0, lsl #12
    case PORTA: addr = GPIOA_BASE_ADDR; break;
     6e0:	13490b0b 	movtne	r0, #39691	; 0x9b0b
     6e4:	15070000 	strne	r0, [r7, #-0]
     6e8:	010c2701 	tsteq	ip, r1, lsl #14
    case PORTB: addr = GPIOB_BASE_ADDR; break;
     6ec:	08000013 	stmdaeq	r0, {r0, r1, r4}
     6f0:	13490005 	movtne	r0, #36869	; 0x9005
     6f4:	13090000 	movwne	r0, #36864	; 0x9000
    case PORTC: addr = GPIOC_BASE_ADDR; break;
     6f8:	0b0e0301 	bleq	381304 <_flash_swap_addr+0x341b04>
     6fc:	3b0b3a0b 	blcc	2cef30 <_flash_swap_addr+0x28f730>
     700:	0013010b 	andseq	r0, r3, fp, lsl #2
    case PORTD: addr = GPIOD_BASE_ADDR; break;
     704:	000d0a00 	andeq	r0, sp, r0, lsl #20
     708:	0b3a0e03 	bleq	e83f1c <_flash_swap_addr+0xe4471c>
     70c:	13490b3b 	movtne	r0, #39739	; 0x9b3b
    case PORTE: addr = GPIOE_BASE_ADDR; break;
     710:	00000a38 	andeq	r0, r0, r8, lsr sl
     714:	0b01130b 	bleq	45348 <_flash_swap_addr+0x5b48>
     718:	3b0b3a0b 	blcc	2cef4c <_flash_swap_addr+0x28f74c>
    default:
        assert(0);
     71c:	0013010b 	andseq	r0, r3, fp, lsl #2
     720:	00350c00 	eorseq	r0, r5, r0, lsl #24
     724:	00001349 	andeq	r1, r0, r9, asr #6
     728:	3f002e0d 	svccc	0x00002e0d
        return 0;
     72c:	3a0e030c 	bcc	381364 <_flash_swap_addr+0x341b64>
    }

    return ((volatile gpioPort_t *) addr);
     730:	270b3b0b 	strcs	r3, [fp, -fp, lsl #22]
}
     734:	1201110c 	andne	r1, r1, #12, 2
     738:	000a4001 	andeq	r4, sl, r1
*
* RETURNS: Nothing
*
*******************************************************************************/
void gpioConfig(uint32_t port, uint32_t pin, uint32_t opt)
{
     73c:	012e0e00 	teqeq	lr, r0, lsl #28
     740:	0e030c3f 	mcreq	12, 0, r0, cr3, cr15, {1}
     744:	0b3b0b3a 	bleq	ec3434 <_flash_swap_addr+0xe83c34>
    /*
     * Ensure pin number is legal
     */

    assert((pin < 32));
     748:	01110c27 	tsteq	r1, r7, lsr #24
     74c:	06400112 			; <UNDEFINED> instruction: 0x06400112
     750:	00001301 	andeq	r1, r0, r1, lsl #6
     754:	0300050f 	movweq	r0, #1295	; 0x50f
     758:	3b0b3a08 	blcc	2cef80 <_flash_swap_addr+0x28f780>
     75c:	0213490b 	andseq	r4, r3, #180224	; 0x2c000

    /*
     * Config the SIM Clock Gate
     */

    switch (port) {
     760:	1000000a 	andne	r0, r0, sl
     764:	0e030005 	cdpeq	0, 0, cr0, cr3, cr5, {0}
     768:	0b3b0b3a 	bleq	ec3458 <_flash_swap_addr+0xe83c58>
     76c:	0a021349 	beq	85498 <_flash_swap_addr+0x45c98>
     770:	34110000 	ldrcc	r0, [r1], #-0
     774:	3a080300 	bcc	20137c <_flash_swap_addr+0x1c1b7c>
     778:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     77c:	000a0213 	andeq	r0, sl, r3, lsl r2
     780:	012e1200 	teqeq	lr, r0, lsl #4
     784:	0e030c3f 	mcreq	12, 0, r0, cr3, cr15, {1}
     788:	0b3b0b3a 	bleq	ec3478 <_flash_swap_addr+0xe83c78>
     78c:	13490c27 	movtne	r0, #39975	; 0x9c27
     790:	01120111 	tsteq	r2, r1, lsl r1
     794:	13010640 	movwne	r0, #5696	; 0x1640
     798:	34130000 	ldrcc	r0, [r3], #-0
     79c:	3a0e0300 	bcc	3813a4 <_flash_swap_addr+0x341ba4>
     7a0:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     7a4:	000a0213 	andeq	r0, sl, r3, lsl r2
     7a8:	00341400 	eorseq	r1, r4, r0, lsl #8
    case PORTA: SIM_SCGC5 |= SIM_SCGC5_PORTA_ENABLE; break;
     7ac:	0b3a0e03 	bleq	e83fc0 <_flash_swap_addr+0xe447c0>
     7b0:	13490b3b 	movtne	r0, #39739	; 0x9b3b
     7b4:	0c3c0c3f 	ldceq	12, cr0, [ip], #-252	; 0xffffff04
     7b8:	34150000 	ldrcc	r0, [r5], #-0
     7bc:	3a0e0300 	bcc	3813c4 <_flash_swap_addr+0x341bc4>
     7c0:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     7c4:	020c3f13 	andeq	r3, ip, #19, 30	; 0x4c
    case PORTB: SIM_SCGC5 |= SIM_SCGC5_PORTB_ENABLE; break;
     7c8:	0000000a 	andeq	r0, r0, sl
     7cc:	25011101 	strcs	r1, [r1, #-257]	; 0xfffffeff
     7d0:	030b130e 	movweq	r1, #45838	; 0xb30e
     7d4:	110e1b0e 	tstne	lr, lr, lsl #22
     7d8:	55015201 	strpl	r5, [r1, #-513]	; 0xfffffdff
     7dc:	00061006 	andeq	r1, r6, r6
    case PORTC: SIM_SCGC5 |= SIM_SCGC5_PORTC_ENABLE; break;
     7e0:	00240200 	eoreq	r0, r4, r0, lsl #4
     7e4:	0b3e0b0b 	bleq	f83418 <_flash_swap_addr+0xf43c18>
     7e8:	00000803 	andeq	r0, r0, r3, lsl #16
     7ec:	0b002403 	bleq	9800 <_data_load+0x6b10>
     7f0:	030b3e0b 	movweq	r3, #48651	; 0xbe0b
     7f4:	0400000e 	streq	r0, [r0], #-14
     7f8:	0e030016 	mcreq	0, 0, r0, cr3, cr6, {0}
    case PORTD: SIM_SCGC5 |= SIM_SCGC5_PORTD_ENABLE; break;
     7fc:	0b3b0b3a 	bleq	ec34ec <_flash_swap_addr+0xe83cec>
     800:	00001349 	andeq	r1, r0, r9, asr #6
     804:	03011305 	movweq	r1, #4869	; 0x1305
     808:	3a0b0b0e 	bcc	2c3448 <_flash_swap_addr+0x283c48>
     80c:	010b3b0b 	tsteq	fp, fp, lsl #22
     810:	06000013 			; <UNDEFINED> instruction: 0x06000013
    case PORTE: SIM_SCGC5 |= SIM_SCGC5_PORTE_ENABLE; break;
     814:	0e03000d 	cdpeq	0, 0, cr0, cr3, cr13, {0}
     818:	0b3b0b3a 	bleq	ec3508 <_flash_swap_addr+0xe83d08>
     81c:	0a381349 	beq	e05548 <_flash_swap_addr+0xdc5d48>
     820:	0d070000 	stceq	0, cr0, [r7, #-0]
     824:	3a080300 	bcc	20142c <_flash_swap_addr+0x1c1c2c>
     828:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     82c:	000a3813 	andeq	r3, sl, r3, lsl r8
    default:
        assert(0);
     830:	01130800 	tsteq	r3, r0, lsl #16
     834:	0b3a0b0b 	bleq	e83468 <_flash_swap_addr+0xe43c68>
     838:	13010b3b 	movwne	r0, #6971	; 0x1b3b
     83c:	0f090000 	svceq	0x00090000

    /*
     * Configure the Port Controller
     */

    uint32_t portCtrlBits = PORT_MUX_GPIO;
     840:	490b0b00 	stmdbmi	fp, {r8, r9, fp}
     844:	0a000013 	beq	898 <STACK_SIZE+0x98>

    if (opt & GPIO_OUTPUT) {
     848:	0b0b000f 	bleq	2c088c <_flash_swap_addr+0x28108c>
     84c:	130b0000 	movwne	r0, #45056	; 0xb000
        if (opt & GPIO_ODE) {
     850:	0b0e0301 	bleq	38145c <_flash_swap_addr+0x341c5c>
     854:	3b0b3a0b 	blcc	2cf088 <_flash_swap_addr+0x28f888>
     858:	00130105 	andseq	r0, r3, r5, lsl #2
            portCtrlBits |= PORT_ODE;
     85c:	000d0c00 	andeq	r0, sp, r0, lsl #24
     860:	0b3a0803 	bleq	e82874 <_flash_swap_addr+0xe43074>
        } else {
            if (opt & GPIO_DSE)
     864:	1349053b 	movtne	r0, #38203	; 0x953b
     868:	00000a38 	andeq	r0, r0, r8, lsr sl
     86c:	2701150d 	strcs	r1, [r1, -sp, lsl #10]
                portCtrlBits |= PORT_DSE;
     870:	0013010c 	andseq	r0, r3, ip, lsl #2
     874:	00050e00 	andeq	r0, r5, r0, lsl #28
        }

    } else if (opt & GPIO_INPUT) {
     878:	00001349 	andeq	r1, r0, r9, asr #6
     87c:	4900350f 	stmdbmi	r0, {r0, r1, r2, r3, r8, sl, ip, sp}
     880:	10000013 	andne	r0, r0, r3, lsl r0
        if (opt & GPIO_PFE)
     884:	0b0b0117 	bleq	2c0ce8 <_flash_swap_addr+0x2814e8>
     888:	0b3b0b3a 	bleq	ec3578 <_flash_swap_addr+0xe83d78>
     88c:	00001301 	andeq	r1, r0, r1, lsl #6
            portCtrlBits |= PORT_PFE;
     890:	03000d11 	movweq	r0, #3345	; 0xd11
     894:	3b0b3a0e 	blcc	2cf0d4 <_flash_swap_addr+0x28f8d4>

    } else {
        assert(0);
     898:	0013490b 	andseq	r4, r3, fp, lsl #18
     89c:	00261200 	eoreq	r1, r6, r0, lsl #4
     8a0:	00001349 	andeq	r1, r0, r9, asr #6
     8a4:	03012e13 	movweq	r2, #7699	; 0x1e13
        return;
     8a8:	3b0b3a0e 	blcc	2cf0e8 <_flash_swap_addr+0x28f8e8>
    }

    if (opt & GPIO_PULLUP)
     8ac:	490c270b 	stmdbmi	ip, {r0, r1, r3, r8, r9, sl, sp}
     8b0:	12011113 	andne	r1, r1, #-1073741820	; 0xc0000004
        portCtrlBits |= PORT_PULLUP_ENABLE;
     8b4:	01064001 	tsteq	r6, r1
     8b8:	14000013 	strne	r0, [r0], #-19	; 0xffffffed
     8bc:	08030005 	stmdaeq	r3, {r0, r2}
    else if (opt & GPIO_PULLDOWN)
     8c0:	0b3b0b3a 	bleq	ec35b0 <_flash_swap_addr+0xe83db0>
     8c4:	0a021349 	beq	855f0 <_flash_swap_addr+0x45df0>
        portCtrlBits |= PORT_PULLDOWN_ENABLE;
     8c8:	34150000 	ldrcc	r0, [r5], #-0
     8cc:	3a080300 	bcc	2014d4 <_flash_swap_addr+0x1c1cd4>

    PORT_PCR(port, pin) = portCtrlBits;
     8d0:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     8d4:	000a0213 	andeq	r0, sl, r3, lsl r2
     8d8:	002e1600 	eoreq	r1, lr, r0, lsl #12
     8dc:	0e030c3f 	mcreq	12, 0, r0, cr3, cr15, {1}

    /*
     * Configure the GPIO Controller
     */

    volatile gpioPort_t *gpioPort = gpioPortGet(port);
     8e0:	0b3b0b3a 	bleq	ec35d0 <_flash_swap_addr+0xe83dd0>
     8e4:	01110c27 	tsteq	r1, r7, lsr #24
    uint32_t pinBit = 1 << pin;
     8e8:	0a400112 	beq	1000d38 <_flash_swap_addr+0xfc1538>
     8ec:	2e170000 	cdpcs	0, 1, cr0, cr7, cr0, {0}
     8f0:	030c3f01 	movweq	r3, #52993	; 0xcf01

    if (opt & GPIO_OUTPUT) {
     8f4:	3b0b3a0e 	blcc	2cf134 <_flash_swap_addr+0x28f934>
     8f8:	490c270b 	stmdbmi	ip, {r0, r1, r3, r8, r9, sl, sp}
        gpioPort->pddr |= pinBit;
     8fc:	12011113 	andne	r1, r1, #-1073741820	; 0xc0000004
     900:	01064001 	tsteq	r6, r1
     904:	18000013 	stmdane	r0, {r0, r1, r4}
        if (opt & GPIO_HIGH)
     908:	0c3f012e 	ldfeqs	f0, [pc], #-184	; 858 <STACK_SIZE+0x58>
     90c:	0b3a0e03 	bleq	e84120 <_flash_swap_addr+0xe44920>
     910:	0c270b3b 	stceq	11, cr0, [r7], #-236	; 0xffffff14
            gpioPort->psor |= pinBit;
     914:	01120111 	tsteq	r2, r1, lsl r1
     918:	13010640 	movwne	r0, #5696	; 0x1640
     91c:	05190000 	ldreq	r0, [r9, #-0]
        else if (opt & GPIO_LOW)
     920:	3a0e0300 	bcc	381528 <_flash_swap_addr+0x341d28>
     924:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     928:	000a0213 	andeq	r0, sl, r3, lsl r2
            gpioPort->pcor |= pinBit;
     92c:	012e1a00 	teqeq	lr, r0, lsl #20
     930:	0b3a0e03 	bleq	e84144 <_flash_swap_addr+0xe44944>
     934:	0c270b3b 	stceq	11, cr0, [r7], #-236	; 0xffffff14
    }
}
     938:	01120111 	tsteq	r2, r1, lsl r1
     93c:	13010640 	movwne	r0, #5696	; 0x1640

/*******************************************************************************
* gpioSet
*******************************************************************************/
void gpioSet(uint32_t port, uint32_t pin)
{
     940:	0b1b0000 	bleq	6c0948 <_flash_swap_addr+0x681148>
     944:	12011101 	andne	r1, r1, #1073741824	; 0x40000000
     948:	00130101 	andseq	r0, r3, r1, lsl #2
    volatile gpioPort_t *gpioPort = gpioPortGet(port);
     94c:	010b1c00 	tsteq	fp, r0, lsl #24
     950:	01120111 	tsteq	r2, r1, lsl r1
    gpioPort->psor = 1 << pin;
     954:	2e1d0000 	cdpcs	0, 1, cr0, cr13, cr0, {0}
     958:	030c3f00 	movweq	r3, #52992	; 0xcf00
     95c:	3b0b3a0e 	blcc	2cf19c <_flash_swap_addr+0x28f99c>
     960:	110c270b 	tstne	ip, fp, lsl #14
}
     964:	40011201 	andmi	r1, r1, r1, lsl #4
     968:	1e000006 	cdpne	0, 0, cr0, cr0, cr6, {0}

/*******************************************************************************
* gpioClear
*******************************************************************************/
void gpioClear(uint32_t port, uint32_t pin)
{
     96c:	0c3f012e 	ldfeqs	f0, [pc], #-184	; 8bc <STACK_SIZE+0xbc>
     970:	0b3a0e03 	bleq	e84184 <_flash_swap_addr+0xe44984>
     974:	0c27053b 	cfstr32eq	mvfx0, [r7], #-236	; 0xffffff14
    volatile gpioPort_t *gpioPort = gpioPortGet(port);
     978:	01120111 	tsteq	r2, r1, lsl r1
     97c:	13010640 	movwne	r0, #5696	; 0x1640
    gpioPort->pcor = 1 << pin;
     980:	341f0000 	ldrcc	r0, [pc], #-0	; 988 <gpioClear+0x1c>
     984:	3a080300 	bcc	20158c <_flash_swap_addr+0x1c1d8c>
     988:	49053b0b 	stmdbmi	r5, {r0, r1, r3, r8, r9, fp, ip, sp}
     98c:	000a0213 	andeq	r0, sl, r3, lsl r2
}
     990:	002e2000 	eoreq	r2, lr, r0
     994:	0e030c3f 	mcreq	12, 0, r0, cr3, cr15, {1}

/*******************************************************************************
* gpioToggle
*******************************************************************************/
void gpioToggle(uint32_t port, uint32_t pin)
{
     998:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xfffff4c6
     99c:	01110c27 	tsteq	r1, r7, lsr #24
     9a0:	06400112 			; <UNDEFINED> instruction: 0x06400112
    volatile gpioPort_t *gpioPort = gpioPortGet(port);
     9a4:	34210000 	strtcc	r0, [r1], #-0
     9a8:	3a0e0300 	bcc	3815b0 <_flash_swap_addr+0x341db0>
    gpioPort->ptor = 1 << pin;
     9ac:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     9b0:	3c0c3f13 	stccc	15, cr3, [ip], {19}
     9b4:	2200000c 	andcs	r0, r0, #12
     9b8:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
}
     9bc:	0b3b0b3a 	bleq	ec36ac <_flash_swap_addr+0xe83eac>
     9c0:	0c3f1349 	ldceq	3, cr1, [pc], #-292	; 8a4 <STACK_SIZE+0xa4>
*
* RETURNS:
*
*******************************************************************************/
void gpioPortWrite(uint32_t port, uint32_t mask, uint32_t value)
{
     9c4:	00000a02 	andeq	r0, r0, r2, lsl #20
     9c8:	01110100 	tsteq	r1, r0, lsl #2
     9cc:	0b130e25 	bleq	4c4268 <_flash_swap_addr+0x484a68>
}
     9d0:	0e1b0e03 	cdpeq	14, 1, cr0, cr11, cr3, {0}
     9d4:	01520111 	cmpeq	r2, r1, lsl r1
     9d8:	06100655 			; <UNDEFINED> instruction: 0x06100655
*
* RETURNS:
*
*******************************************************************************/
uint32_t gpioPortRead(uint32_t port)
{
     9dc:	24020000 	strcs	r0, [r2], #-0
     9e0:	3e0b0b00 	vmlacc.f64	d0, d11, d0
    return 0;
     9e4:	0008030b 	andeq	r0, r8, fp, lsl #6
}
     9e8:	00160300 	andseq	r0, r6, r0, lsl #6
     9ec:	0b3a0e03 	bleq	e84200 <_flash_swap_addr+0xe44a00>
     9f0:	13490b3b 	movtne	r0, #39739	; 0x9b3b
*
* RETURNS:
*
*******************************************************************************/
uint32_t gpioRead(uint32_t port, uint32_t pin)
{
     9f4:	24040000 	strcs	r0, [r4], #-0
     9f8:	3e0b0b00 	vmlacc.f64	d0, d11, d0
     9fc:	000e030b 	andeq	r0, lr, fp, lsl #6
    volatile gpioPort_t *gpioPort = gpioPortGet(port);
     a00:	01130500 	tsteq	r3, r0, lsl #10
     a04:	0b0b0e03 	bleq	2c4218 <_flash_swap_addr+0x284a18>
    return ((gpioPort->pdir & (1 << pin)) ? TRUE : FALSE);
     a08:	0b3b0b3a 	bleq	ec36f8 <_flash_swap_addr+0xe83ef8>
     a0c:	00001301 	andeq	r1, r0, r1, lsl #6
     a10:	03000d06 	movweq	r0, #3334	; 0xd06
     a14:	3b0b3a0e 	blcc	2cf254 <_flash_swap_addr+0x28fa54>
     a18:	3813490b 	ldmdacc	r3, {r0, r1, r3, r8, fp, lr}
     a1c:	0700000a 	streq	r0, [r0, -sl]
}
     a20:	0803000d 	stmdaeq	r3, {r0, r2, r3}
     a24:	0b3b0b3a 	bleq	ec3714 <_flash_swap_addr+0xe83f14>
    .flashDiv     = FLASH_DIVIDER_DFLT,
};


static void fei2fee(clockConfig_t cc)
{
     a28:	0a381349 	beq	e05754 <_flash_swap_addr+0xdc5f54>
     a2c:	13080000 	movwne	r0, #32768	; 0x8000
     a30:	3a0b0b01 	bcc	2c363c <_flash_swap_addr+0x283e3c>
     * Uno problemo: The largest divide factor available by FRDIV is 1024... And
     * 50MHz / 1024 = 48.3 kHz, which exceeds the 39.0625 kHz range. With our
     * setup, it doesn't seem that we can reach a FEE mode (and I don't want to
     * risk the tower to see what could happen if I did!)
     */
}
     a34:	010b3b0b 	tsteq	fp, fp, lsl #22
     a38:	09000013 	stmdbeq	r0, {r0, r1, r4}

static void fei2pee(clockConfig_t cc)
{
     a3c:	0b0b000f 	bleq	2c0a80 <_flash_swap_addr+0x281280>
     a40:	00001349 	andeq	r1, r0, r9, asr #6
     a44:	0b000f0a 	bleq	4674 <_data_load+0x1984>
                                                    /* External crystal setup */
    /* Select the OSCCLK */
    SIM_SOPT2 &= ~SIM_SOPT2_MCGCLKSEL;
     a48:	0b00000b 	bleq	a7c <fei2pee+0x40>
     a4c:	0e030113 	mcreq	1, 0, r0, cr3, cr3, {0}
     a50:	0b3a0b0b 	bleq	e83684 <_flash_swap_addr+0xe43e84>
     a54:	1301053b 	movwne	r0, #5435	; 0x153b
     a58:	0d0c0000 	stceq	0, cr0, [ip, #-0]
     a5c:	3a080300 	bcc	201664 <_flash_swap_addr+0x1c1e64>
     * Enabling the XTAL for 50MHz
     * RANGE=1, match the frequency of the crystal being used
     * HGO=1,   set for high gain operation (best against noise)
     * EREFS=1, enable the external oscillator
     */
    clock.mcg->c2 = (MCG_C2_RANGE_MASK & (0x1 << 4)) |
     a60:	49053b0b 	stmdbmi	r5, {r0, r1, r3, r8, r9, fp, ip, sp}
     a64:	000a3813 	andeq	r3, sl, r3, lsl r8
     a68:	01150d00 	tsteq	r5, r0, lsl #26
     a6c:	13010c27 	movwne	r0, #7207	; 0x1c27
     * mode from FBE (here we are going to PEE)
     *
     * IREFS=0, select external reference clock and enable the external
     * oscillator.
     */
    clock.mcg->c1 = ((MCG_C1_CLKS_MASK & (0x2 << 6)) |
     a70:	050e0000 	streq	r0, [lr, #-0]
     a74:	00134900 	andseq	r4, r3, r0, lsl #18
     a78:	00350f00 	eorseq	r0, r5, r0, lsl #30
     a7c:	00001349 	andeq	r1, r0, r9, asr #6
                    (MCG_C1_FRDIV_MASK & (0x3 << 3))) &
                    (~MCG_C1_IREFS);

                                                    /* Wait for status update */
    /* Wait for oscillator to initialize */
    while (!(clock.mcg->s & MCG_S_OSCINIT)) {}
     a80:	0b011710 	bleq	466c8 <_flash_swap_addr+0x6ec8>
     a84:	3b0b3a0b 	blcc	2cf2b8 <_flash_swap_addr+0x28fab8>
     a88:	0013010b 	andseq	r0, r3, fp, lsl #2
     a8c:	000d1100 	andeq	r1, sp, r0, lsl #2
     a90:	0b3a0e03 	bleq	e842a4 <_flash_swap_addr+0xe44aa4>
     a94:	13490b3b 	movtne	r0, #39739	; 0x9b3b
    /* Wait for reference clock's to become the external reference */
    while (clock.mcg->s & MCG_S_IREFST) {}
     a98:	26120000 	ldrcs	r0, [r2], -r0
     a9c:	00134900 	andseq	r4, r3, r0, lsl #18
     aa0:	01151300 	tsteq	r5, r0, lsl #6
     aa4:	13490c27 	movtne	r0, #39975	; 0x9c27
     aa8:	00001301 	andeq	r1, r0, r1, lsl #6
     aac:	03012e14 	movweq	r2, #7700	; 0x1e14
    /* Wait for the indicator that MCGOTUCLK is fed by the external ref clock */
    while ((clock.mcg->s & MCG_S_CLKST_MASK) != (0x2 << 2)) {}
     ab0:	3b0b3a0e 	blcc	2cf2f0 <_flash_swap_addr+0x28faf0>
     ab4:	110c270b 	tstne	ip, fp, lsl #14
     ab8:	40011201 	andmi	r1, r1, r1, lsl #4
     abc:	00130106 	andseq	r0, r3, r6, lsl #2
     ac0:	00051500 	andeq	r1, r5, r0, lsl #10
     ac4:	0b3a0803 	bleq	e82ad8 <_flash_swap_addr+0xe432d8>

                                            /* Generate correct PLL frequency */
    clock.mcg->c5 &= 0xE0; /* clear bits */
     ac8:	13490b3b 	movtne	r0, #39739	; 0x9b3b
     acc:	00000a02 	andeq	r0, r0, r2, lsl #20
     ad0:	03012e16 	movweq	r2, #7702	; 0x1e16
     ad4:	3b0b3a0e 	blcc	2cf314 <_flash_swap_addr+0x28fb14>
     ad8:	490c270b 	stmdbmi	ip, {r0, r1, r3, r8, r9, sl, sp}
     adc:	12011113 	andne	r1, r1, #-1073741820	; 0xc0000004
     ae0:	01064001 	tsteq	r6, r1
     ae4:	17000013 	smladne	r0, r3, r0, r0
    clock.mcg->c5 |= clockConfigParam[cc].divider;
     ae8:	08030034 	stmdaeq	r3, {r2, r4, r5}
     aec:	0b3b0b3a 	bleq	ec37dc <_flash_swap_addr+0xe83fdc>
     af0:	0a021349 	beq	8581c <_flash_swap_addr+0x4601c>
     af4:	2e180000 	cdpcs	0, 1, cr0, cr8, cr0, {0}
     af8:	030c3f01 	movweq	r3, #52993	; 0xcf01
     afc:	3b0b3a0e 	blcc	2cf33c <_flash_swap_addr+0x28fb3c>
     b00:	490c270b 	stmdbmi	ip, {r0, r1, r3, r8, r9, sl, sp}
     b04:	12011113 	andne	r1, r1, #-1073741820	; 0xc0000004
     b08:	01064001 	tsteq	r6, r1
     b0c:	19000013 	stmdbne	r0, {r0, r1, r4}
     b10:	0e030005 	cdpeq	0, 0, cr0, cr3, cr5, {0}
     b14:	0b3b0b3a 	bleq	ec3804 <_flash_swap_addr+0xe84004>
    clock.mcg->c6 &= 0xE0;
     b18:	0a021349 	beq	85844 <_flash_swap_addr+0x46044>
     b1c:	0b1a0000 	bleq	680b24 <_flash_swap_addr+0x641324>
     b20:	12011101 	andne	r1, r1, #1073741824	; 0x40000000
     b24:	00130101 	andseq	r0, r3, r1, lsl #2
     b28:	010b1b00 	tsteq	fp, r0, lsl #22
     b2c:	01120111 	tsteq	r2, r1, lsl r1
     b30:	341c0000 	ldrcc	r0, [ip], #-0
     b34:	3a0e0300 	bcc	38173c <_flash_swap_addr+0x341f3c>
    clock.mcg->c6 |= clockConfigParam[cc].multiplier;
     b38:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     b3c:	000a0213 	andeq	r0, sl, r3, lsl r2
     b40:	012e1d00 	teqeq	lr, r0, lsl #26
     b44:	0e030c3f 	mcreq	12, 0, r0, cr3, cr15, {1}
     b48:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xfffff4c6
     b4c:	01110c27 	tsteq	r1, r7, lsr #24
     b50:	06400112 			; <UNDEFINED> instruction: 0x06400112
     b54:	00001301 	andeq	r1, r0, r1, lsl #6
     b58:	0300051e 	movweq	r0, #1310	; 0x51e
     b5c:	3b0b3a08 	blcc	2cf384 <_flash_swap_addr+0x28fb84>
     b60:	02134905 	andseq	r4, r3, #81920	; 0x14000
     b64:	1f00000a 	svcne	0x0000000a
                                                            /* Enter PBE mode */
    /* PLLS=1, select the PLL. */
    clock.mcg->c6 |= MCG_C6_PLLS;
     b68:	08030034 	stmdaeq	r3, {r2, r4, r5}
     b6c:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xfffff4c6
     b70:	0a021349 	beq	8589c <_flash_swap_addr+0x4609c>
     b74:	05200000 	streq	r0, [r0, #-0]!
     b78:	3a0e0300 	bcc	381780 <_flash_swap_addr+0x341f80>
     b7c:	49053b0b 	stmdbmi	r5, {r0, r1, r3, r8, r9, fp, ip, sp}
     b80:	000a0213 	andeq	r0, sl, r3, lsl r2
     b84:	012e2100 	teqeq	lr, r0, lsl #2

                                                    /* Wait for status update */
    /* Wait for the PLL to be the clock source */
    while (!(clock.mcg->s & MCG_S_PLLST)) {}
     b88:	0e030c3f 	mcreq	12, 0, r0, cr3, cr15, {1}
     b8c:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xfffff4c6
     b90:	13490c27 	movtne	r0, #39975	; 0x9c27
     b94:	01120111 	tsteq	r2, r1, lsl r1
     b98:	13010640 	movwne	r0, #5696	; 0x1640
     b9c:	34220000 	strtcc	r0, [r2], #-0
    /* Wait until the PLL has acquired lock on the external frequency */
    while (!(clock.mcg->s & MCG_S_LOCK)) {}
     ba0:	3a0e0300 	bcc	3817a8 <_flash_swap_addr+0x341fa8>
     ba4:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     ba8:	3c0c3f13 	stccc	15, cr3, [ip], {19}
     bac:	0000000c 	andeq	r0, r0, ip
     bb0:	25011101 	strcs	r1, [r1, #-257]	; 0xfffffeff
     bb4:	030b130e 	movweq	r1, #45838	; 0xb30e

                                                            /* Enter PEE mode */
    /* Select the output of the PLL */
    clock.mcg->c1 &= ~MCG_C1_CLKS_MASK;
     bb8:	110e1b0e 	tstne	lr, lr, lsl #22
     bbc:	55015201 	strpl	r5, [r1, #-513]	; 0xfffffdff
     bc0:	00061006 	andeq	r1, r6, r6
     bc4:	00240200 	eoreq	r0, r4, r0, lsl #4
     bc8:	0b3e0b0b 	bleq	f837fc <_flash_swap_addr+0xf43ffc>
     bcc:	00000803 	andeq	r0, r0, r3, lsl #16
     bd0:	03001603 	movweq	r1, #1539	; 0x603
     bd4:	3b0b3a0e 	blcc	2cf414 <_flash_swap_addr+0x28fc14>

                                                    /* Wait for status update */
    /* Wait until output of the PLL is selected */
    while ((clock.mcg->s & MCG_S_CLKST_MASK) != (0x3 << 2)) {}
     bd8:	0013490b 	andseq	r4, r3, fp, lsl #18
     bdc:	00240400 	eoreq	r0, r4, r0, lsl #8
     be0:	0b3e0b0b 	bleq	f83814 <_flash_swap_addr+0xf44014>
     be4:	00000e03 	andeq	r0, r0, r3, lsl #28
     be8:	03011305 	movweq	r1, #4869	; 0x1305
     bec:	3a0b0b0e 	bcc	2c382c <_flash_swap_addr+0x28402c>

    mcgState.currentMode = MODE_PEE;
     bf0:	010b3b0b 	tsteq	fp, fp, lsl #22
     bf4:	06000013 			; <UNDEFINED> instruction: 0x06000013
     bf8:	0e03000d 	cdpeq	0, 0, cr0, cr3, cr13, {0}
}
     bfc:	0b3b0b3a 	bleq	ec38ec <_flash_swap_addr+0xe840ec>
     c00:	0a381349 	beq	e0592c <_flash_swap_addr+0xdc612c>
     c04:	0d070000 	stceq	0, cr0, [r7, #-0]

static void fei2blpi(clockConfig_t cc)
{
     c08:	3a080300 	bcc	201810 <_flash_swap_addr+0x1c2010>
     c0c:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     c10:	000a3813 	andeq	r3, sl, r3, lsl r8
                                                            /* Not configured */
}
     c14:	01130800 	tsteq	r3, r0, lsl #16
     c18:	0b3a0b0b 	bleq	e8384c <_flash_swap_addr+0xe4404c>

static void fei2blpe(clockConfig_t cc)
{
     c1c:	13010b3b 	movwne	r0, #6971	; 0x1b3b
     c20:	0f090000 	svceq	0x00090000
     c24:	490b0b00 	stmdbmi	fp, {r8, r9, fp}
                                                            /* Not configured */
}
     c28:	0a000013 	beq	c7c <fee2blpe+0x10>
     c2c:	0b0b000f 	bleq	2c0c70 <_flash_swap_addr+0x281470>


static void fee2fei(clockConfig_t cc)
{
     c30:	130b0000 	movwne	r0, #45056	; 0xb000
     c34:	0b0e0301 	bleq	381840 <_flash_swap_addr+0x342040>
     c38:	3b0b3a0b 	blcc	2cf46c <_flash_swap_addr+0x28fc6c>
                                                            /* Not configured */
}
     c3c:	00130105 	andseq	r0, r3, r5, lsl #2
     c40:	000d0c00 	andeq	r0, sp, r0, lsl #24

static void fee2pee(clockConfig_t cc)
{
     c44:	0b3a0803 	bleq	e82c58 <_flash_swap_addr+0xe43458>
     c48:	1349053b 	movtne	r0, #38203	; 0x953b
     c4c:	00000a38 	andeq	r0, r0, r8, lsr sl
                                                            /* Not configured */
}
     c50:	4900350d 	stmdbmi	r0, {r0, r2, r3, r8, sl, ip, sp}
     c54:	0e000013 	mcreq	0, 0, r0, cr0, cr3, {0}

static void fee2blpi(clockConfig_t cc)
{
     c58:	0c270115 	stfeqs	f0, [r7], #-84	; 0xffffffac
     c5c:	13011349 	movwne	r1, #4937	; 0x1349
     c60:	050f0000 	streq	r0, [pc, #-0]	; c68 <fee2blpi+0x10>
                                                            /* Not configured */
}
     c64:	00134900 	andseq	r4, r3, r0, lsl #18
     c68:	01171000 	tsteq	r7, r0

static void fee2blpe(clockConfig_t cc)
{
     c6c:	0b3a0b0b 	bleq	e838a0 <_flash_swap_addr+0xe440a0>
     c70:	13010b3b 	movwne	r0, #6971	; 0x1b3b
     c74:	0d110000 	ldceq	0, cr0, [r1, #-0]
                                                            /* Not configured */
}
     c78:	3a0e0300 	bcc	381880 <_flash_swap_addr+0x342080>
     c7c:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}


static void pee2fei(clockConfig_t cc)
{
     c80:	12000013 	andne	r0, r0, #19
     c84:	0e030117 	mcreq	1, 0, r0, cr3, cr7, {0}
     c88:	0b3a0b0b 	bleq	e838bc <_flash_swap_addr+0xe440bc>

                                                            /* Enter PBE mode */
    clock.mcg->c1 = (MCG_C1_CLKS_MASK & (0x2 << 6)); /* Select external clock */
     c8c:	13010b3b 	movwne	r0, #6971	; 0x1b3b
     c90:	0d130000 	ldceq	0, cr0, [r3, #-0]
     c94:	3a080300 	bcc	20189c <_flash_swap_addr+0x1c209c>
     c98:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}

                                                    /* Wait for status update */
    while ((clock.mcg->s & MCG_S_CLKST_MASK) != (0x2 << 2)) {}
     c9c:	14000013 	strne	r0, [r0], #-19	; 0xffffffed
     ca0:	13490026 	movtne	r0, #36902	; 0x9026
     ca4:	2e150000 	cdpcs	0, 1, cr0, cr5, cr0, {0}
     ca8:	030c3f01 	movweq	r3, #52993	; 0xcf01
     cac:	3b0b3a0e 	blcc	2cf4ec <_flash_swap_addr+0x28fcec>
     cb0:	490c270b 	stmdbmi	ip, {r0, r1, r3, r8, r9, sl, sp}

                                                            /* Enter FBE mode */
    /*
     * With the FLL frequency valid, we can now clear the PLLS bit to select FLL
     */
    clock.mcg->c6 &= ~MCG_C6_PLLS;
     cb4:	12011113 	andne	r1, r1, #-1073741820	; 0xc0000004
     cb8:	01064001 	tsteq	r6, r1
     cbc:	16000013 			; <UNDEFINED> instruction: 0x16000013
     cc0:	08030005 	stmdaeq	r3, {r0, r2}
     cc4:	0b3b0b3a 	bleq	ec39b4 <_flash_swap_addr+0xe841b4>
     cc8:	0a021349 	beq	859f4 <_flash_swap_addr+0x461f4>
     ccc:	0b170000 	bleq	5c0cd4 <_flash_swap_addr+0x5814d4>
     cd0:	12011101 	andne	r1, r1, #1073741824	; 0x40000000

                                                    /* Wait for status update */
    /* Wait until the current source is FLL */
    while (clock.mcg->s & MCG_S_PLLST) {}
     cd4:	00130101 	andseq	r0, r3, r1, lsl #2
     cd8:	00341800 	eorseq	r1, r4, r0, lsl #16
     cdc:	0b3a0803 	bleq	e82cf0 <_flash_swap_addr+0xe434f0>
     ce0:	13490b3b 	movtne	r0, #39739	; 0x9b3b
     ce4:	00000a02 	andeq	r0, r0, r2, lsl #20
     ce8:	11010b19 	tstne	r1, r9, lsl fp

                                            /* Generate correct FLL frequency */
    clock.mcg->c4 = clockConfigParam[cc].multiplier;
     cec:	00011201 	andeq	r1, r1, r1, lsl #4
     cf0:	012e1a00 	teqeq	lr, r0, lsl #20
     cf4:	0e030c3f 	mcreq	12, 0, r0, cr3, cr15, {1}
     cf8:	0b3b0b3a 	bleq	ec39e8 <_flash_swap_addr+0xe841e8>
     cfc:	01110c27 	tsteq	r1, r7, lsr #24
     d00:	06400112 			; <UNDEFINED> instruction: 0x06400112
     d04:	00001301 	andeq	r1, r0, r1, lsl #6

                                                            /* Enter FEI mode */
    clock.mcg->c1 = (MCG_C1_CLKS_MASK & (0x0 << 6)) |
     d08:	0300341b 	movweq	r3, #1051	; 0x41b
     d0c:	3b0b3a0e 	blcc	2cf54c <_flash_swap_addr+0x28fd4c>
     d10:	0213490b 	andseq	r4, r3, #180224	; 0x2c000
     d14:	1c00000a 	stcne	0, cr0, [r0], {10}
                    (MCG_C1_IREFS);

                                                    /* Wait for status update */
    /* Wait for reference clock's to become the internal reference */
    while (!(clock.mcg->s & MCG_S_IREFST)) {}
     d18:	0e030005 	cdpeq	0, 0, cr0, cr3, cr5, {0}
     d1c:	0b3b0b3a 	bleq	ec3a0c <_flash_swap_addr+0xe8420c>
     d20:	0a021349 	beq	85a4c <_flash_swap_addr+0x4624c>
     d24:	01000000 	mrseq	r0, (UNDEF: 0)
     d28:	0e250111 	mcreq	1, 1, r0, cr5, cr1, {0}
     d2c:	0e030b13 	vmoveq.32	d3[0], r0
    /* Wait until the output of the FLL is selected */
    while ((clock.mcg->s & MCG_S_CLKST_MASK) != (0x0 << 2)) {}
     d30:	01110e1b 	tsteq	r1, fp, lsl lr
     d34:	06550152 			; <UNDEFINED> instruction: 0x06550152
     d38:	00000610 	andeq	r0, r0, r0, lsl r6
     d3c:	0b002402 	bleq	9d4c <_data_load+0x705c>
     d40:	030b3e0b 	movweq	r3, #48651	; 0xbe0b
     d44:	03000008 	movweq	r0, #8

    mcgState.currentMode = MODE_FEI;
     d48:	0e030016 	mcreq	0, 0, r0, cr3, cr6, {0}
     d4c:	0b3b0b3a 	bleq	ec3a3c <_flash_swap_addr+0xe8423c>
     d50:	00001349 	andeq	r1, r0, r9, asr #6
     d54:	0b002404 	bleq	9d6c <_data_load+0x707c>
}
     d58:	030b3e0b 	movweq	r3, #48651	; 0xbe0b
     d5c:	0500000e 	streq	r0, [r0, #-14]

static void pee2fee(clockConfig_t cc)
{
     d60:	0b0b000f 	bleq	2c0da4 <_flash_swap_addr+0x2815a4>
     d64:	0f060000 	svceq	0x00060000
     d68:	490b0b00 	stmdbmi	fp, {r8, r9, fp}
                                                            /* Not configured */
}
     d6c:	07000013 	smladeq	r0, r3, r0, r0
     d70:	0c3f012e 	ldfeqs	f0, [pc], #-184	; cc0 <pee2fei+0x40>

static void pee2blpi(clockConfig_t cc)
{
     d74:	0b3a0e03 	bleq	e84588 <_flash_swap_addr+0xe44d88>
     d78:	0c270b3b 	stceq	11, cr0, [r7], #-236	; 0xffffff14
     d7c:	01120111 	tsteq	r2, r1, lsl r1
                                                            /* Not configured */
}
     d80:	13010a40 	movwne	r0, #6720	; 0x1a40
     d84:	34080000 	strcc	r0, [r8], #-0

static void pee2blpe(clockConfig_t cc)
{
     d88:	3a0e0300 	bcc	381990 <_flash_swap_addr+0x342190>
     d8c:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     d90:	3c0c3f13 	stccc	15, cr3, [ip], {19}
                                                            /* Not configured */
}
     d94:	0900000c 	stmdbeq	r0, {r2, r3}
     d98:	13490101 	movtne	r0, #37121	; 0x9101


static void blpi2fei(clockConfig_t cc)
{
     d9c:	00001301 	andeq	r1, r0, r1, lsl #6
     da0:	0000210a 	andeq	r2, r0, sl, lsl #2
     da4:	012e0b00 	teqeq	lr, r0, lsl #22
                                                            /* Not configured */
}
     da8:	0e030c3f 	mcreq	12, 0, r0, cr3, cr15, {1}
     dac:	0b3b0b3a 	bleq	ec3a9c <_flash_swap_addr+0xe8429c>

static void blpi2fee(clockConfig_t cc)
{
     db0:	13490c27 	movtne	r0, #39975	; 0x9c27
     db4:	01120111 	tsteq	r2, r1, lsl r1
     db8:	13010640 	movwne	r0, #5696	; 0x1640
                                                            /* Not configured */
}
     dbc:	050c0000 	streq	r0, [ip, #-0]
     dc0:	3a0e0300 	bcc	3819c8 <_flash_swap_addr+0x3421c8>

static void blpi2pee(clockConfig_t cc)
{
     dc4:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     dc8:	000a0213 	andeq	r0, sl, r3, lsl r2
     dcc:	00340d00 	eorseq	r0, r4, r0, lsl #26
                                                            /* Not configured */
}
     dd0:	0b3a0803 	bleq	e82de4 <_flash_swap_addr+0xe435e4>
     dd4:	13490b3b 	movtne	r0, #39739	; 0x9b3b

static void blpi2blpe(clockConfig_t cc)
{
     dd8:	00000a02 	andeq	r0, r0, r2, lsl #20
     ddc:	11010b0e 	tstne	r1, lr, lsl #22
     de0:	01011201 	tsteq	r1, r1, lsl #4
                                                            /* Not configured */
}
     de4:	0f000013 	svceq	0x00000013
     de8:	0111010b 	tsteq	r1, fp, lsl #2


static void blpe2fei(clockConfig_t cc)
{
     dec:	00000112 	andeq	r0, r0, r2, lsl r1
     df0:	3f002e10 	svccc	0x00002e10
     df4:	3a0e030c 	bcc	381a2c <_flash_swap_addr+0x34222c>
                                                            /* Not configured */
}
     df8:	270b3b0b 	strcs	r3, [fp, -fp, lsl #22]
     dfc:	1113490c 	tstne	r3, ip, lsl #18

static void blpe2fee(clockConfig_t cc)
{
     e00:	40011201 	andmi	r1, r1, r1, lsl #4
     e04:	1100000a 	tstne	r0, sl
     e08:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
                                                            /* Not configured */
}
     e0c:	0b3b0b3a 	bleq	ec3afc <_flash_swap_addr+0xe842fc>
     e10:	0a021349 	beq	85b3c <_flash_swap_addr+0x4633c>

static void blpe2pee(clockConfig_t cc)
{
     e14:	01000000 	mrseq	r0, (UNDEF: 0)
     e18:	0e250111 	mcreq	1, 1, r0, cr5, cr1, {0}
     e1c:	0e030b13 	vmoveq.32	d3[0], r0
                                                            /* Not configured */
}
     e20:	01110e1b 	tsteq	r1, fp, lsl lr
     e24:	06550152 			; <UNDEFINED> instruction: 0x06550152

static void blpe2blpi(clockConfig_t cc)
{
     e28:	00000610 	andeq	r0, r0, r0, lsl r6
     e2c:	0b002402 	bleq	9e3c <_data_load+0x714c>
     e30:	030b3e0b 	movweq	r3, #48651	; 0xbe0b
                                                            /* Not configured */
}
     e34:	03000008 	movweq	r0, #8
     e38:	0e030016 	mcreq	0, 0, r0, cr3, cr6, {0}
* system, bus, flexbus, and flash clock frequencies.
*
*******************************************************************************/
void clockSetDividers(divider_t systemDiv, divider_t busDiv,
                                       divider_t flexBusDiv, divider_t flashDiv)
{
     e3c:	0b3b0b3a 	bleq	ec3b2c <_flash_swap_addr+0xe8432c>
     e40:	00001349 	andeq	r1, r0, r9, asr #6
     e44:	0b002404 	bleq	9e5c <_data_load+0x716c>
     e48:	030b3e0b 	movweq	r3, #48651	; 0xbe0b
    int mcgClock = clockFreq.mcgClockFreq;
     e4c:	0500000e 	streq	r0, [r0, #-14]
     e50:	0e030113 	mcreq	1, 0, r0, cr3, cr3, {0}
     e54:	0b3a0b0b 	bleq	e83a88 <_flash_swap_addr+0xe44288>

    /*
     * The asserts are raised when the internal clock requirements (sec. 5.5)
     * are not met.
     */
    assert( (mcgClock / (systemDiv +1)) <= MAX_SYSTEM_FREQ);
     e58:	13010b3b 	movwne	r0, #6971	; 0x1b3b
     e5c:	0d060000 	stceq	0, cr0, [r6, #-0]
     e60:	3a0e0300 	bcc	381a68 <_flash_swap_addr+0x342268>
     e64:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     e68:	000a3813 	andeq	r3, sl, r3, lsl r8
     e6c:	000d0700 	andeq	r0, sp, r0, lsl #14
     e70:	0b3a0803 	bleq	e82e84 <_flash_swap_addr+0xe43684>
     e74:	13490b3b 	movtne	r0, #39739	; 0x9b3b
     e78:	00000a38 	andeq	r0, r0, r8, lsr sl
     e7c:	0b011308 	bleq	45aa4 <_flash_swap_addr+0x62a4>

    assert( (mcgClock / (busDiv    +1)) <= MAX_BUS_FREQ &&
     e80:	3b0b3a0b 	blcc	2cf6b4 <_flash_swap_addr+0x28feb4>
     e84:	0013010b 	andseq	r0, r3, fp, lsl #2
     e88:	000f0900 	andeq	r0, pc, r0, lsl #18
     e8c:	13490b0b 	movtne	r0, #39691	; 0x9b0b
     e90:	0f0a0000 	svceq	0x000a0000
     e94:	000b0b00 	andeq	r0, fp, r0, lsl #22
     e98:	01130b00 	tsteq	r3, r0, lsl #22
     e9c:	0b0b0e03 	bleq	2c46b0 <_flash_swap_addr+0x284eb0>
     ea0:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xfffff4c6
     ea4:	00001301 	andeq	r1, r0, r1, lsl #6
     ea8:	03000d0c 	movweq	r0, #3340	; 0xd0c
     eac:	3b0b3a08 	blcc	2cf6d4 <_flash_swap_addr+0x28fed4>
     eb0:	38134905 	ldmdacc	r3, {r0, r2, r8, fp, lr}
     eb4:	0d00000a 	stceq	0, cr0, [r0, #-40]	; 0xffffffd8
     eb8:	13490035 	movtne	r0, #36917	; 0x9035
     ebc:	150e0000 	strne	r0, [lr, #-0]
     ec0:	490c2701 	stmdbmi	ip, {r0, r8, r9, sl, sp}
            (mcgClock / (busDiv    +1)) <= (mcgClock / (systemDiv+1)));

    assert( (mcgClock / (flashDiv  +1)) <= MAX_FLASH_FREQ &&
     ec4:	00130113 	andseq	r0, r3, r3, lsl r1
     ec8:	00050f00 	andeq	r0, r5, r0, lsl #30
     ecc:	00001349 	andeq	r1, r0, r9, asr #6
     ed0:	0b011710 	bleq	46b18 <_flash_swap_addr+0x7318>
     ed4:	3b0b3a0b 	blcc	2cf708 <_flash_swap_addr+0x28ff08>
     ed8:	0013010b 	andseq	r0, r3, fp, lsl #2
     edc:	000d1100 	andeq	r1, sp, r0, lsl #2
     ee0:	0b3a0e03 	bleq	e846f4 <_flash_swap_addr+0xe44ef4>
     ee4:	13490b3b 	movtne	r0, #39739	; 0x9b3b
     ee8:	17120000 	ldrne	r0, [r2, -r0]
     eec:	0b0e0301 	bleq	381af8 <_flash_swap_addr+0x3422f8>
     ef0:	3b0b3a0b 	blcc	2cf724 <_flash_swap_addr+0x28ff24>
     ef4:	0013010b 	andseq	r0, r3, fp, lsl #2
     ef8:	000d1300 	andeq	r1, sp, r0, lsl #6
     efc:	0b3a0803 	bleq	e82f10 <_flash_swap_addr+0xe43710>
     f00:	13490b3b 	movtne	r0, #39739	; 0x9b3b
     f04:	26140000 	ldrcs	r0, [r4], -r0
            (mcgClock / (flashDiv  +1)) <= (mcgClock / (busDiv+1)));

    assert( (mcgClock / (flexBusDiv+1)) <= (mcgClock / (busDiv+1)));
     f08:	00134900 	andseq	r4, r3, r0, lsl #18
     f0c:	002e1500 	eoreq	r1, lr, r0, lsl #10
     f10:	0e030c3f 	mcreq	12, 0, r0, cr3, cr15, {1}
     f14:	0b3b0b3a 	bleq	ec3c04 <_flash_swap_addr+0xe84404>
     f18:	01110c27 	tsteq	r1, r7, lsr #24
     f1c:	06400112 			; <UNDEFINED> instruction: 0x06400112
     f20:	2e160000 	cdpcs	0, 1, cr0, cr6, cr0, {0}
     f24:	030c3f01 	movweq	r3, #52993	; 0xcf01
     f28:	3b0b3a0e 	blcc	2cf768 <_flash_swap_addr+0x28ff68>
     f2c:	110c270b 	tstne	ip, fp, lsl #14
     f30:	40011201 	andmi	r1, r1, r1, lsl #4

    /* Save the new dividers */
    clockFreq.systemDiv  = systemDiv;
     f34:	00130106 	andseq	r0, r3, r6, lsl #2
     f38:	00051700 	andeq	r1, r5, r0, lsl #14
     f3c:	0b3a0e03 	bleq	e84750 <_flash_swap_addr+0xe44f50>
    clockFreq.busDiv     = busDiv;
     f40:	13490b3b 	movtne	r0, #39739	; 0x9b3b
     f44:	00000a02 	andeq	r0, r0, r2, lsl #20
     f48:	03000518 	movweq	r0, #1304	; 0x518
    clockFreq.flexBusDiv = flexBusDiv;
     f4c:	3b0b3a08 	blcc	2cf774 <_flash_swap_addr+0x28ff74>
     f50:	0213490b 	andseq	r4, r3, #180224	; 0x2c000
     f54:	1900000a 	stmdbne	r0, {r1, r3}
    clockFreq.flashDiv   = flashDiv;
     f58:	08030034 	stmdaeq	r3, {r2, r4, r5}
     f5c:	0b3b0b3a 	bleq	ec3c4c <_flash_swap_addr+0xe8444c>
     f60:	0a021349 	beq	85c8c <_flash_swap_addr+0x4648c>

    /* Set the SIM clock dividers */
    SIM_CLKDIV1 = (systemDiv << 28)  |
     f64:	2e1a0000 	cdpcs	0, 1, cr0, cr10, cr0, {0}
     f68:	030c3f01 	movweq	r3, #52993	; 0xcf01
     f6c:	3b0b3a0e 	blcc	2cf7ac <_flash_swap_addr+0x28ffac>
                  (busDiv << 24)     |
     f70:	490c270b 	stmdbmi	ip, {r0, r1, r3, r8, r9, sl, sp}
     f74:	12011113 	andne	r1, r1, #-1073741820	; 0xc0000004
                  (flexBusDiv << 20) |
     f78:	01064001 	tsteq	r6, r1
     f7c:	1b000013 	blne	fd0 <clockGetFreq+0x3c>
                  (flashDiv << 16);
     f80:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
     f84:	0b3b0b3a 	bleq	ec3c74 <_flash_swap_addr+0xe84474>
    clockFreq.busDiv     = busDiv;
    clockFreq.flexBusDiv = flexBusDiv;
    clockFreq.flashDiv   = flashDiv;

    /* Set the SIM clock dividers */
    SIM_CLKDIV1 = (systemDiv << 28)  |
     f88:	0a021349 	beq	85cb4 <_flash_swap_addr+0x464b4>
                  (busDiv << 24)     |
                  (flexBusDiv << 20) |
                  (flashDiv << 16);
}
     f8c:	01000000 	mrseq	r0, (UNDEF: 0)
     f90:	0e250111 	mcreq	1, 1, r0, cr5, cr1, {0}
*
* Grab the clock frequency for a particular clock source in Hz.
*
*******************************************************************************/
uint32_t clockGetFreq(clockSource_t cs)
{
     f94:	0e030b13 	vmoveq.32	d3[0], r0
     f98:	01110e1b 	tsteq	r1, fp, lsl lr
     f9c:	06550152 			; <UNDEFINED> instruction: 0x06550152
    uint32_t clock;

    switch (cs) {
     fa0:	00000610 	andeq	r0, r0, r0, lsl r6
     fa4:	0b002402 	bleq	9fb4 <_data_load+0x72c4>
     fa8:	030b3e0b 	movweq	r3, #48651	; 0xbe0b
     fac:	03000008 	movweq	r0, #8
     fb0:	0e030016 	mcreq	0, 0, r0, cr3, cr6, {0}
     fb4:	0b3b0b3a 	bleq	ec3ca4 <_flash_swap_addr+0xe844a4>
     fb8:	00001349 	andeq	r1, r0, r9, asr #6
     fbc:	0b002404 	bleq	9fd4 <_data_load+0x72e4>
    case CLOCK_SYSTEM:
        clock = clockFreq.mcgClockFreq / (clockFreq.systemDiv + 1);
     fc0:	030b3e0b 	movweq	r3, #48651	; 0xbe0b
     fc4:	0500000e 	streq	r0, [r0, #-14]
     fc8:	0b0b000f 	bleq	2c100c <_flash_swap_addr+0x28180c>
     fcc:	0f060000 	svceq	0x00060000
     fd0:	490b0b00 	stmdbmi	fp, {r8, r9, fp}
     fd4:	07000013 	smladeq	r0, r3, r0, r0
     fd8:	0c270115 	stfeqs	f0, [r7], #-84	; 0xffffffac
     fdc:	13011349 	movwne	r1, #4937	; 0x1349
        break;
    case CLOCK_BUS:
        clock = clockFreq.mcgClockFreq / (clockFreq.busDiv + 1);
     fe0:	05080000 	streq	r0, [r8, #-0]
     fe4:	00134900 	andseq	r4, r3, r0, lsl #18
     fe8:	01130900 	tsteq	r3, r0, lsl #18
     fec:	0b0b0e03 	bleq	2c4800 <_flash_swap_addr+0x285000>
     ff0:	0b3b0b3a 	bleq	ec3ce0 <_flash_swap_addr+0xe844e0>
     ff4:	00001301 	andeq	r1, r0, r1, lsl #6
     ff8:	03000d0a 	movweq	r0, #3338	; 0xd0a
     ffc:	3b0b3a0e 	blcc	2cf83c <_flash_swap_addr+0x29003c>
        break;
    case CLOCK_FLEXBUS:
        clock = clockFreq.mcgClockFreq / (clockFreq.flexBusDiv + 1);
    1000:	3813490b 	ldmdacc	r3, {r0, r1, r3, r8, fp, lr}
    1004:	0b00000a 	bleq	1034 <clockGetFreq+0xa0>
    1008:	0b0b0113 	bleq	2c145c <_flash_swap_addr+0x281c5c>
    100c:	0b3b0b3a 	bleq	ec3cfc <_flash_swap_addr+0xe844fc>
    1010:	00001301 	andeq	r1, r0, r1, lsl #6
    1014:	3f012e0c 	svccc	0x00012e0c
    1018:	3a0e030c 	bcc	381c50 <_flash_swap_addr+0x342450>
    101c:	270b3b0b 	strcs	r3, [fp, -fp, lsl #22]
        break;
    case CLOCK_FLASH:
        clock = clockFreq.mcgClockFreq / (clockFreq.flashDiv + 1);
    1020:	1201110c 	andne	r1, r1, #12, 2
    1024:	01064001 	tsteq	r6, r1
    1028:	0d000013 	stceq	0, cr0, [r0, #-76]	; 0xffffffb4
    102c:	08030005 	stmdaeq	r3, {r0, r2}
    1030:	0b3b0b3a 	bleq	ec3d20 <_flash_swap_addr+0xe84520>
    1034:	0a021349 	beq	85d60 <_flash_swap_addr+0x46560>
    1038:	050e0000 	streq	r0, [lr, #-0]
    103c:	3a0e0300 	bcc	381c44 <_flash_swap_addr+0x342444>
        break;
    default:
        assert(0);
    1040:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    1044:	000a0213 	andeq	r0, sl, r3, lsl r2
    1048:	012e0f00 	teqeq	lr, r0, lsl #30
    104c:	0e030c3f 	mcreq	12, 0, r0, cr3, cr15, {1}
    }

    return clock;
    1050:	0b3b0b3a 	bleq	ec3d40 <_flash_swap_addr+0xe84540>
}
    1054:	13490c27 	movtne	r0, #39975	; 0x9c27
    1058:	01120111 	tsteq	r2, r1, lsl r1
*        ____ STOP ____ (Entered when MCU enters stop mode, and returns to
*                        previous active mode when exits stop mode )
*
*******************************************************************************/
void clockConfigMcgOut(clockConfig_t clockConfig)
{
    105c:	13010640 	movwne	r0, #5696	; 0x1640
    1060:	34100000 	ldrcc	r0, [r0], #-0
    1064:	3a0e0300 	bcc	381c6c <_flash_swap_addr+0x34246c>
        {  pee2fei,  pee2fee,     NULL,  pee2blpi,  pee2blpe, },
        { blpi2fei, blpi2fee, blpi2pee,      NULL, blpi2blpe, },
        { blpe2fei, blpe2fee, blpe2pee, blpe2blpi,      NULL, },
    };

    assert(clockConfig < MAX_MCG_CLOCK_OPTIONS);
    1068:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    106c:	000a0213 	andeq	r0, sl, r3, lsl r2
    1070:	010b1100 	mrseq	r1, (UNDEF: 27)
    1074:	01120111 	tsteq	r2, r1, lsl r1
    1078:	00001301 	andeq	r1, r0, r1, lsl #6

    mcgState.nextMode = clockConfigParam[clockConfig].clockMode;
    107c:	03003412 	movweq	r3, #1042	; 0x412
    1080:	3b0b3a08 	blcc	2cf8a8 <_flash_swap_addr+0x2900a8>
    1084:	0213490b 	andseq	r4, r3, #180224	; 0x2c000
    1088:	1300000a 	movwne	r0, #10
    108c:	0111010b 	tsteq	r1, fp, lsl #2
    1090:	00000112 	andeq	r0, r0, r2, lsl r1

    jumpTable[mcgState.currentMode][mcgState.nextMode](clockConfig);
    1094:	3f012e14 	svccc	0x00012e14
    1098:	3a0e030c 	bcc	381cd0 <_flash_swap_addr+0x3424d0>
    109c:	270b3b0b 	strcs	r3, [fp, -fp, lsl #22]
    10a0:	1201110c 	andne	r1, r1, #12, 2
    10a4:	00064001 	andeq	r4, r6, r1
    10a8:	11010000 	mrsne	r0, (UNDEF: 1)
    10ac:	130e2501 	movwne	r2, #58625	; 0xe501
    10b0:	1b0e030b 	blne	381ce4 <_flash_swap_addr+0x3424e4>
    10b4:	5201110e 	andpl	r1, r1, #-2147483645	; 0x80000003
    10b8:	10065501 	andne	r5, r6, r1, lsl #10
    10bc:	02000006 	andeq	r0, r0, #6
    10c0:	0b0b0024 	bleq	2c1158 <_flash_swap_addr+0x281958>
    10c4:	08030b3e 	stmdaeq	r3, {r1, r2, r3, r4, r5, r8, r9, fp}

    /* Store the new clock frequency for clockGetFreq() */
    clockFreq.mcgClockFreq = clockConfigParam[clockConfig].clockHz;
    10c8:	24030000 	strcs	r0, [r3], #-0
    10cc:	3e0b0b00 	vmlacc.f64	d0, d11, d0
    10d0:	000e030b 	andeq	r0, lr, fp, lsl #6
    10d4:	00160400 	andseq	r0, r6, r0, lsl #8
    10d8:	0b3a0e03 	bleq	e848ec <_flash_swap_addr+0xe450ec>
    10dc:	13490b3b 	movtne	r0, #39739	; 0x9b3b
    10e0:	13050000 	movwne	r0, #20480	; 0x5000
}
    10e4:	0b0e0301 	bleq	381cf0 <_flash_swap_addr+0x3424f0>
    10e8:	3b0b3a0b 	blcc	2cf91c <_flash_swap_addr+0x29011c>

/*******************************************************************************
* clockConfigMcgIr
*******************************************************************************/
void clockConfigMcgIr()
{
    10ec:	0013010b 	andseq	r0, r3, fp, lsl #2
                                                            /* Not configured */
}
    10f0:	000d0600 	andeq	r0, sp, r0, lsl #12
    10f4:	0b3a0e03 	bleq	e84908 <_flash_swap_addr+0xe45108>

/*******************************************************************************
* clockConfigMcgFf
*******************************************************************************/
void clockConfigMcgFf()
{
    10f8:	13490b3b 	movtne	r0, #39739	; 0x9b3b
                                                            /* Not configured */
}
    10fc:	00000a38 	andeq	r0, r0, r8, lsr sl
    1100:	03000d07 	movweq	r0, #3335	; 0xd07

/*******************************************************************************
* clockConfigMcgFll
*******************************************************************************/
void clockConfigMcgFll()
{
    1104:	3b0b3a08 	blcc	2cf92c <_flash_swap_addr+0x29012c>
                                                            /* Not configured */
}
    1108:	3813490b 	ldmdacc	r3, {r0, r1, r3, r8, fp, lr}
    110c:	0800000a 	stmdaeq	r0, {r1, r3}

/*******************************************************************************
* clockConfigMcgPll
*******************************************************************************/
void clockConfigMcgPll()
{
    1110:	0b0b0113 	bleq	2c1564 <_flash_swap_addr+0x281d64>
                                                            /* Not configured */
}
    1114:	0b3b0b3a 	bleq	ec3e04 <_flash_swap_addr+0xe84604>
    1118:	00001301 	andeq	r1, r0, r1, lsl #6

/*******************************************************************************
* clockConfigOsc
*******************************************************************************/
void clockConfigOsc()
{
    111c:	0b000f09 	bleq	4d48 <_data_load+0x2058>
                                                            /* Not configured */
}
    1120:	0013490b 	andseq	r4, r3, fp, lsl #18
    1124:	000f0a00 	andeq	r0, pc, r0, lsl #20

/*******************************************************************************
* clockConfigOsc32k
*******************************************************************************/
void clockConfigOsc32k()
{
    1128:	00000b0b 	andeq	r0, r0, fp, lsl #22
                                                            /* Not configured */
}
    112c:	0301130b 	movweq	r1, #4875	; 0x130b
    1130:	3a0b0b0e 	bcc	2c3d70 <_flash_swap_addr+0x284570>

/*******************************************************************************
* clockConfigEr32k
*******************************************************************************/
void clockConfigEr32k()
{
    1134:	01053b0b 	tsteq	r5, fp, lsl #22
                                                            /* Not configured */
}
    1138:	0c000013 	stceq	0, cr0, [r0], {19}
    113c:	0803000d 	stmdaeq	r3, {r0, r2, r3}

/*******************************************************************************
* clockConfigRtc
*******************************************************************************/
void clockConfigRtc()
{
    1140:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xfffff4c6
                                                            /* Not configured */
}
    1144:	0a381349 	beq	e05e70 <_flash_swap_addr+0xdc6670>
    1148:	350d0000 	strcc	r0, [sp, #-0]

/*******************************************************************************
* clockConfigLpo
*******************************************************************************/
void clockConfigLpo()
{
    114c:	00134900 	andseq	r4, r3, r0, lsl #18
                                                            /* Not configured */
}
    1150:	01010e00 	tsteq	r1, r0, lsl #28
    1154:	13011349 	movwne	r1, #4937	; 0x1349
*
* RETURNS: Nothing
*
*******************************************************************************/
void watchDogUnlock()
{
    1158:	210f0000 	mrscs	r0, CPSR
        " :
        /* No output */ :
        /* No input  */ :
        "r0", "r1" ); /* Specify which registers we destroy */
#else
    wdPtr->unlock = WDOG_UNLOCK_KEY_1;
    115c:	2f134900 	svccs	0x00134900
    1160:	1000000b 	andne	r0, r0, fp
    1164:	0b0b0117 	bleq	2c15c8 <_flash_swap_addr+0x281dc8>
    1168:	0b3b0b3a 	bleq	ec3e58 <_flash_swap_addr+0xe84658>
    wdPtr->unlock = WDOG_UNLOCK_KEY_2;
    116c:	00001301 	andeq	r1, r0, r1, lsl #6
    1170:	03000d11 	movweq	r0, #3345	; 0xd11
    1174:	3b0b3a0e 	blcc	2cf9b4 <_flash_swap_addr+0x2901b4>
    1178:	0013490b 	andseq	r4, r3, fp, lsl #18
#endif
    /* NOTE: Need to wait one clock cycle before updating any registers */
}
    117c:	00261200 	eoreq	r1, r6, r0, lsl #4
    1180:	00001349 	andeq	r1, r0, r9, asr #6

/*******************************************************************************
* watchDogInit
*******************************************************************************/
void watchDogInit(const watchDogConfig_t *wdCfgPtr)
{
    1184:	3f012e13 	svccc	0x00012e13
    1188:	3a0e030c 	bcc	381dc0 <_flash_swap_addr+0x3425c0>
    watchDogUnlock();
    118c:	270b3b0b 	strcs	r3, [fp, -fp, lsl #22]
        " :
        /* No output */ :
        /* No input  */ :
        "r0", "r1", "r2" ); /* Specify which registers we destroy */
#else
    assert(wdCfgPtr->window < wdCfgPtr->timeout);
    1190:	1201110c 	andne	r1, r1, #12, 2
    1194:	01064001 	tsteq	r6, r1
    1198:	14000013 	strne	r0, [r0], #-19	; 0xffffffed
    119c:	0111010b 	tsteq	r1, fp, lsl #2
    11a0:	13010112 	movwne	r0, #4370	; 0x1112
    11a4:	34150000 	ldrcc	r0, [r5], #-0
    11a8:	3a080300 	bcc	201db0 <_flash_swap_addr+0x1c25b0>

    wdPtr->toValL  = wdCfgPtr->timeout;
    11ac:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    11b0:	000a0213 	andeq	r0, sl, r3, lsl r2
    11b4:	010b1600 	tsteq	fp, r0, lsl #12
    11b8:	01120111 	tsteq	r2, r1, lsl r1
    11bc:	34170000 	ldrcc	r0, [r7], #-0
    wdPtr->toValH  = wdCfgPtr->timeout >> 16;
    11c0:	3a0e0300 	bcc	381dc8 <_flash_swap_addr+0x3425c8>
    11c4:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    11c8:	000a0213 	andeq	r0, sl, r3, lsl r2
    11cc:	002e1800 	eoreq	r1, lr, r0, lsl #16
    11d0:	0e030c3f 	mcreq	12, 0, r0, cr3, cr15, {1}
    wdPtr->stCtrlH = wdCfgPtr->stCtrlFlags;
    11d4:	0b3b0b3a 	bleq	ec3ec4 <_flash_swap_addr+0xe846c4>
    11d8:	01110c27 	tsteq	r1, r7, lsr #24
    11dc:	06400112 			; <UNDEFINED> instruction: 0x06400112
    11e0:	2e190000 	cdpcs	0, 1, cr0, cr9, cr0, {0}
    wdPtr->presc   = wdCfgPtr->prescaler;
    11e4:	030c3f00 	movweq	r3, #52992	; 0xcf00
    11e8:	3b0b3a0e 	blcc	2cfa28 <_flash_swap_addr+0x290228>
    11ec:	110c270b 	tstne	ip, fp, lsl #14
    11f0:	40011201 	andmi	r1, r1, r1, lsl #4
    wdPtr->winL    = wdCfgPtr->window;
    11f4:	1a00000a 	bne	1224 <interruptDisable>
    11f8:	0c3f012e 	ldfeqs	f0, [pc], #-184	; 1148 <clockConfigRtc+0x8>
    11fc:	0b3a0e03 	bleq	e84a10 <_flash_swap_addr+0xe45210>
    1200:	0c270b3b 	stceq	11, cr0, [r7], #-236	; 0xffffff14
    1204:	01120111 	tsteq	r2, r1, lsl r1
    wdPtr->winH    = wdCfgPtr->window >> 16;
    1208:	13010a40 	movwne	r0, #6720	; 0x1a40
    120c:	051b0000 	ldreq	r0, [fp, #-0]
    1210:	3a080300 	bcc	201e18 <_flash_swap_addr+0x1c2618>
    1214:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    1218:	000a0213 	andeq	r0, sl, r3, lsl r2
    }
    if (wdCfgPtr->stCtrlFlags & WDOG_TEST) {
        /* TODO: If anyone cares let me know */
    }
#endif
}
    121c:	00341c00 	eorseq	r1, r4, r0, lsl #24
    1220:	0b3a0e03 	bleq	e84a34 <_flash_swap_addr+0xe45234>

/* RFI: Could probably move these elsewhere for general consumption */
static void interruptDisable()
{
    1224:	13490b3b 	movtne	r0, #39739	; 0x9b3b
    asm volatile("\n\
    1228:	0c3c0c3f 	ldceq	12, cr0, [ip], #-252	; 0xffffff04
        cpsid i\n\
        " :
        /* No output */ :
        /* No input  */ :
        ); /* Specify which registers we destroy */
}
    122c:	01000000 	mrseq	r0, (UNDEF: 0)
static void interruptEnable()
{
    1230:	0e250111 	mcreq	1, 1, r0, cr5, cr1, {0}
    asm volatile("\n\
    1234:	0e030b13 	vmoveq.32	d3[0], r0
        cpsie i\n\
        " :
        /* No output */ :
        /* No input  */ :
        ); /* Specify which registers we destroy */
}
    1238:	01110e1b 	tsteq	r1, fp, lsl lr

/*******************************************************************************
* watchDogKick
*******************************************************************************/
void watchDogKick()
{
    123c:	06550152 			; <UNDEFINED> instruction: 0x06550152
        " :
        /* No output */ :
        /* No input  */ :
        "r0", "r1" ); /* Specify which registers we destroy */
#else
    interruptDisable();
    1240:	00000610 	andeq	r0, r0, r0, lsl r6
    wdPtr->refresh = WDOG_REFRESH_KEY_1;
    1244:	0b002402 	bleq	a254 <_data_load+0x7564>
    1248:	030b3e0b 	movweq	r3, #48651	; 0xbe0b
    124c:	03000008 	movweq	r0, #8
    1250:	0b0b0024 	bleq	2c12e8 <_flash_swap_addr+0x281ae8>
    wdPtr->refresh = WDOG_REFRESH_KEY_2;
    1254:	0e030b3e 	vmoveq.16	d3[0], r0
    1258:	16040000 	strne	r0, [r4], -r0
    125c:	3a0e0300 	bcc	381e64 <_flash_swap_addr+0x342664>
    1260:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    interruptEnable();
    1264:	05000013 	streq	r0, [r0, #-19]	; 0xffffffed
#endif
}
    1268:	13490035 	movtne	r0, #36917	; 0x9035

/*******************************************************************************
* watchDogDisable
*******************************************************************************/
void watchDogDisable()
{
    126c:	13060000 	movwne	r0, #24576	; 0x6000
    watchDogUnlock();
    1270:	3a050b01 	bcc	143e7c <_flash_swap_addr+0x10467c>
        " :
        /* No output */ :
        /* No input  */ :
        "r0", "r1" ); /* Specify which registers we destroy */
#else
    wdPtr->stCtrlH = WDOG_STNDBYEN | WDOG_WAITEN | WDOG_STOPEN
    1274:	010b3b0b 	tsteq	fp, fp, lsl #22
    1278:	07000013 	smladeq	r0, r3, r0, r0
    127c:	0e03000d 	cdpeq	0, 0, cr0, cr3, cr13, {0}
    1280:	0b3b0b3a 	bleq	ec3f70 <_flash_swap_addr+0xe84770>
                   | WDOG_ALLOWUPDATE;
#endif
}
    1284:	0a381349 	beq	e05fb0 <_flash_swap_addr+0xdc67b0>
    1288:	0d080000 	stceq	0, cr0, [r8, #-0]
    128c:	3a080300 	bcc	201e94 <_flash_swap_addr+0x1c2694>
 *          that this thread is executed only if there are no other ready
 *          threads in the system.
 *
 * @param[in] p the thread parameter, unused in this scenario
 */
void _idle_thread(void *p) {
    1290:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}

  (void)p;
  chRegSetThreadName("idle");
    1294:	000a3813 	andeq	r3, sl, r3, lsl r8
    1298:	01010900 	tsteq	r1, r0, lsl #18
    129c:	13011349 	movwne	r1, #4937	; 0x1349
    12a0:	210a0000 	mrscs	r0, (UNDEF: 10)
    12a4:	2f134900 	svccs	0x00134900
  while (TRUE) {
    port_wait_for_interrupt();
    IDLE_LOOP_HOOK();
  }
    12a8:	0b00000b 	bleq	12dc <chSysInit+0x2c>
    12ac:	13490021 	movtne	r0, #36897	; 0x9021
 * @note    This function has special, architecture-dependent, requirements,
 *          see the notes into the various port reference manuals.
 *
 * @special
 */
void chSysInit(void) {
    12b0:	0000052f 	andeq	r0, r0, pc, lsr #10
  static Thread mainthread;
#if CH_DBG_ENABLE_STACK_CHECK
  extern stkalign_t __main_thread_stack_base__;
#endif

  port_init();
    12b4:	0b01130c 	bleq	45eec <_flash_swap_addr+0x66ec>
  _scheduler_init();
    12b8:	3b0b3a0b 	blcc	2cfaec <_flash_swap_addr+0x2902ec>
  _vt_init();
    12bc:	0013010b 	andseq	r0, r3, fp, lsl #2
#if CH_USE_MEMCORE
  _core_init();
    12c0:	012e0d00 	teqeq	lr, r0, lsl #26
#endif
#if CH_USE_HEAP
  _heap_init();
    12c4:	0e030c3f 	mcreq	12, 0, r0, cr3, cr15, {1}
#if CH_DBG_ENABLE_TRACE
  _trace_init();
#endif

  /* Now this instructions flow becomes the main thread.*/
  setcurrp(_thread_init(&mainthread, NORMALPRIO));
    12c8:	0b3b0b3a 	bleq	ec3fb8 <_flash_swap_addr+0xe847b8>
    12cc:	01110c27 	tsteq	r1, r7, lsr #24
    12d0:	06400112 			; <UNDEFINED> instruction: 0x06400112
    12d4:	00001301 	andeq	r1, r0, r1, lsl #6
    12d8:	0300050e 	movweq	r0, #1294	; 0x50e
    12dc:	3b0b3a08 	blcc	2cfb04 <_flash_swap_addr+0x290304>
    12e0:	0213490b 	andseq	r4, r3, #180224	; 0x2c000
  currp->p_state = THD_STATE_CURRENT;
    12e4:	0f00000a 	svceq	0x0000000a
    12e8:	0e030005 	cdpeq	0, 0, cr0, cr3, cr5, {0}
    12ec:	0b3b0b3a 	bleq	ec3fdc <_flash_swap_addr+0xe847dc>
    12f0:	0a021349 	beq	8601c <_flash_swap_addr+0x4681c>
#if CH_DBG_ENABLE_STACK_CHECK
  /* This is a special case because the main thread Thread structure is not
     adjacent to its stack area.*/
  currp->p_stklimit = &__main_thread_stack_base__;
#endif
  chSysEnable();
    12f4:	34100000 	ldrcc	r0, [r0], #-0
    12f8:	3a080300 	bcc	201f00 <_flash_swap_addr+0x1c2700>
    12fc:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}

  chRegSetThreadName("main");
    1300:	000a0213 	andeq	r0, sl, r3, lsl r2
    1304:	012e1100 	teqeq	lr, r0, lsl #2
    1308:	0e030c3f 	mcreq	12, 0, r0, cr3, cr15, {1}
    130c:	0b3b0b3a 	bleq	ec3ffc <_flash_swap_addr+0xe847fc>
    1310:	01110c27 	tsteq	r1, r7, lsr #24

#if !CH_NO_IDLE_THREAD
  /* This thread has the lowest priority in the system, its role is just to
     serve interrupts in its context while keeping the lowest energy saving
     mode compatible with the system status.*/
  chThdCreateStatic(_idle_thread_wa, sizeof(_idle_thread_wa), IDLEPRIO,
    1314:	06400112 			; <UNDEFINED> instruction: 0x06400112
    1318:	01000000 	mrseq	r0, (UNDEF: 0)
    131c:	0e250111 	mcreq	1, 1, r0, cr5, cr1, {0}
    1320:	0e030b13 	vmoveq.32	d3[0], r0
    1324:	01110e1b 	tsteq	r1, fp, lsl lr
    1328:	06550152 			; <UNDEFINED> instruction: 0x06550152
    132c:	00000610 	andeq	r0, r0, r0, lsl r6
    1330:	0b002402 	bleq	a340 <_data_load+0x7650>
                    (tfunc_t)_idle_thread, NULL);
#endif
}
    1334:	030b3e0b 	movweq	r3, #48651	; 0xbe0b
    1338:	03000008 	movweq	r0, #8
    133c:	0b0b0024 	bleq	2c13d4 <_flash_swap_addr+0x281bd4>
 *          and, together with the @p CH_TIME_QUANTUM macro, the round robin
 *          interval.
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {
    1340:	0e030b3e 	vmoveq.16	d3[0], r0

  chDbgCheckClassI();

#if CH_TIME_QUANTUM > 0
  /* Running thread has not used up quantum yet? */
  if (currp->p_preempt > 0)
    1344:	16040000 	strne	r0, [r4], -r0
    1348:	3a0e0300 	bcc	381f50 <_flash_swap_addr+0x342750>
    134c:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    1350:	05000013 	streq	r0, [r0, #-19]	; 0xffffffed
    /* Decrement remaining quantum.*/
    currp->p_preempt--;
    1354:	0e030113 	mcreq	1, 0, r0, cr3, cr3, {0}
    1358:	0b3a0b0b 	bleq	e83f8c <_flash_swap_addr+0xe4478c>
    135c:	13010b3b 	movwne	r0, #6971	; 0x1b3b
    1360:	0d060000 	stceq	0, cr0, [r6, #-0]
    1364:	3a0e0300 	bcc	381f6c <_flash_swap_addr+0x34276c>
#endif
#if CH_DBG_THREADS_PROFILING
  currp->p_time++;
    1368:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    136c:	000a3813 	andeq	r3, sl, r3, lsl r8
    1370:	000d0700 	andeq	r0, sp, r0, lsl #14
    1374:	0b3a0803 	bleq	e83388 <_flash_swap_addr+0xe43b88>
    1378:	13490b3b 	movtne	r0, #39739	; 0x9b3b
#endif
  chVTDoTickI();
    137c:	00000a38 	andeq	r0, r0, r8, lsr sl
    1380:	0b011308 	bleq	45fa8 <_flash_swap_addr+0x67a8>
    1384:	3b0b3a0b 	blcc	2cfbb8 <_flash_swap_addr+0x2903b8>
    1388:	0013010b 	andseq	r0, r3, fp, lsl #2
    138c:	000f0900 	andeq	r0, pc, r0, lsl #18
    1390:	13490b0b 	movtne	r0, #39691	; 0x9b0b
    1394:	0f0a0000 	svceq	0x000a0000
    1398:	000b0b00 	andeq	r0, fp, r0, lsl #22
    139c:	01130b00 	tsteq	r3, r0, lsl #22
    13a0:	0b0b0e03 	bleq	2c4bb4 <_flash_swap_addr+0x2853b4>
    13a4:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xfffff4c6
    13a8:	00001301 	andeq	r1, r0, r1, lsl #6
    13ac:	03000d0c 	movweq	r0, #3340	; 0xd0c
    13b0:	3b0b3a08 	blcc	2cfbd8 <_flash_swap_addr+0x2903d8>
    13b4:	38134905 	ldmdacc	r3, {r0, r2, r8, fp, lr}
    13b8:	0d00000a 	stceq	0, cr0, [r0, #-40]	; 0xffffffd8
    13bc:	13490035 	movtne	r0, #36917	; 0x9035
    13c0:	170e0000 	strne	r0, [lr, -r0]
    13c4:	3a0b0b01 	bcc	2c3fd0 <_flash_swap_addr+0x2847d0>
    13c8:	010b3b0b 	tsteq	fp, fp, lsl #22
    13cc:	0f000013 	svceq	0x00000013
    13d0:	0e03000d 	cdpeq	0, 0, cr0, cr3, cr13, {0}
    13d4:	0b3b0b3a 	bleq	ec40c4 <_flash_swap_addr+0xe848c4>
    13d8:	00001349 	andeq	r1, r0, r9, asr #6
    13dc:	49002610 	stmdbmi	r0, {r4, r9, sl, sp}
    13e0:	11000013 	tstne	r0, r3, lsl r0
    13e4:	0e03012e 	adfeqsp	f0, f3, #0.5
    13e8:	0b3b0b3a 	bleq	ec40d8 <_flash_swap_addr+0xe848d8>
    13ec:	01110c27 	tsteq	r1, r7, lsr #24
    13f0:	06400112 			; <UNDEFINED> instruction: 0x06400112
    13f4:	00001301 	andeq	r1, r0, r1, lsl #6
    13f8:	03000512 	movweq	r0, #1298	; 0x512
    13fc:	3b0b3a08 	blcc	2cfc24 <_flash_swap_addr+0x290424>
    1400:	0213490b 	andseq	r4, r3, #180224	; 0x2c000
    1404:	1300000a 	movwne	r0, #10
    1408:	08030034 	stmdaeq	r3, {r2, r4, r5}
    140c:	0b3b0b3a 	bleq	ec40fc <_flash_swap_addr+0xe848fc>
    1410:	0a021349 	beq	8613c <_flash_swap_addr+0x4693c>
#if defined(SYSTEM_TICK_EVENT_HOOK)
  SYSTEM_TICK_EVENT_HOOK();
#endif
}
    1414:	2e140000 	cdpcs	0, 1, cr0, cr4, cr0, {0}
    1418:	3a0e0301 	bcc	382024 <_flash_swap_addr+0x342824>
    141c:	270b3b0b 	strcs	r3, [fp, -fp, lsl #22]
 *
 * @notapi
 */
void _vt_init(void) {

  vtlist.vt_next = vtlist.vt_prev = (void *)&vtlist;
    1420:	1113490c 	tstne	r3, ip, lsl #18
    1424:	40011201 	andmi	r1, r1, r1, lsl #4
    1428:	00130106 	andseq	r0, r3, r6, lsl #2
    142c:	012e1500 	teqeq	lr, r0, lsl #10
    1430:	0e030c3f 	mcreq	12, 0, r0, cr3, cr15, {1}
    1434:	0b3b0b3a 	bleq	ec4124 <_flash_swap_addr+0xe84924>
    1438:	01110c27 	tsteq	r1, r7, lsr #24
    143c:	06400112 			; <UNDEFINED> instruction: 0x06400112
    1440:	00001301 	andeq	r1, r0, r1, lsl #6
    1444:	11010b16 	tstne	r1, r6, lsl fp
  vtlist.vt_time = (systime_t)-1;
    1448:	01011201 	tsteq	r1, r1, lsl #4
    144c:	17000013 	smladne	r0, r3, r0, r0
    1450:	0111010b 	tsteq	r1, fp, lsl #2
  vtlist.vt_systime = 0;
    1454:	00000112 	andeq	r0, r0, r2, lsl r1
    1458:	3f012e18 	svccc	0x00012e18
    145c:	3a0e030c 	bcc	382094 <_flash_swap_addr+0x342894>
    1460:	270b3b0b 	strcs	r3, [fp, -fp, lsl #22]
    1464:	1113490c 	tstne	r3, ip, lsl #18
    1468:	40011201 	andmi	r1, r1, r1, lsl #4
    146c:	00130106 	andseq	r0, r3, r6, lsl #2
 * @param[in] par       a parameter that will be passed to the callback
 *                      function
 *
 * @iclass
 */
void chVTSetI(VirtualTimer *vtp, systime_t time, vtfunc_t vtfunc, void *par) {
    1470:	00341900 	eorseq	r1, r4, r0, lsl #18
    1474:	0b3a0803 	bleq	e83488 <_flash_swap_addr+0xe43c88>
    1478:	1349053b 	movtne	r0, #38203	; 0x953b
  VirtualTimer *p;

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (time != TIME_IMMEDIATE),
    147c:	00000a02 	andeq	r0, r0, r2, lsl #20
    1480:	0300341a 	movweq	r3, #1050	; 0x41a
    1484:	3b0b3a0e 	blcc	2cfcc4 <_flash_swap_addr+0x2904c4>
    1488:	02134905 	andseq	r4, r3, #81920	; 0x14000
             "chVTSetI");

  vtp->vt_par = par;
    148c:	1b00000a 	blne	14bc <chVTSetI+0x4c>
  vtp->vt_func = vtfunc;
    1490:	0c3f012e 	ldfeqs	f0, [pc], #-184	; 13e0 <chSysTimerHandlerI+0xa0>
    1494:	0b3a0e03 	bleq	e84ca8 <_flash_swap_addr+0xe454a8>
  p = vtlist.vt_next;
    1498:	0c27053b 	cfstr32eq	mvfx0, [r7], #-236	; 0xffffff14
    149c:	01111349 	tsteq	r1, r9, asr #6
    14a0:	06400112 			; <UNDEFINED> instruction: 0x06400112
  while (p->vt_time < time) {
    time -= p->vt_time;
    14a4:	00001301 	andeq	r1, r0, r1, lsl #6
    14a8:	3f012e1c 	svccc	0x00012e1c
    14ac:	3a0e030c 	bcc	3820e4 <_flash_swap_addr+0x3428e4>
    p = p->vt_next;
    14b0:	27053b0b 	strcs	r3, [r5, -fp, lsl #22]
             "chVTSetI");

  vtp->vt_par = par;
  vtp->vt_func = vtfunc;
  p = vtlist.vt_next;
  while (p->vt_time < time) {
    14b4:	1201110c 	andne	r1, r1, #12, 2
    14b8:	01064001 	tsteq	r6, r1
    14bc:	1d000013 	stcne	0, cr0, [r0, #-76]	; 0xffffffb4
    time -= p->vt_time;
    p = p->vt_next;
  }

  vtp->vt_prev = (vtp->vt_next = p)->vt_prev;
    14c0:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
    14c4:	0b3b0b3a 	bleq	ec41b4 <_flash_swap_addr+0xe849b4>
    14c8:	0c3f1349 	ldceq	3, cr1, [pc], #-292	; 13ac <chSysTimerHandlerI+0x6c>
    14cc:	00000c3c 	andeq	r0, r0, ip, lsr ip
	...

Disassembly of section .debug_aranges:

00000000 <.debug_aranges>:
   0:	0000001c 	andeq	r0, r0, ip, lsl r0
   4:	00000002 	andeq	r0, r0, r2
   8:	00040000 	andeq	r0, r4, r0
   c:	00000000 	andeq	r0, r0, r0
  10:	00000410 	andeq	r0, r0, r0, lsl r4
  14:	00000148 	andeq	r0, r0, r8, asr #2
	...
  20:	0000001c 	andeq	r0, r0, ip, lsl r0
  24:	00600002 	rsbeq	r0, r0, r2
  28:	00040000 	andeq	r0, r4, r0
  2c:	00000000 	andeq	r0, r0, r0
  30:	00000560 	andeq	r0, r0, r0, ror #10
  34:	00000128 	andeq	r0, r0, r8, lsr #2
	...
  40:	0000001c 	andeq	r0, r0, ip, lsl r0
  44:	037a0002 	cmneq	sl, #2
  48:	00040000 	andeq	r0, r4, r0
  4c:	00000000 	andeq	r0, r0, r0
  50:	00000688 	andeq	r0, r0, r8, lsl #13
  54:	000003a0 	andeq	r0, r0, r0, lsr #7
	...
  60:	0000001c 	andeq	r0, r0, ip, lsl r0
  64:	072a0002 	streq	r0, [sl, -r2]!
  68:	00040000 	andeq	r0, r4, r0
  6c:	00000000 	andeq	r0, r0, r0
  70:	00000a28 	andeq	r0, r0, r8, lsr #20
  74:	0000072e 	andeq	r0, r0, lr, lsr #14
	...
  80:	0000001c 	andeq	r0, r0, ip, lsl r0
  84:	12740002 	rsbsne	r0, r4, #2
  88:	00040000 	andeq	r0, r4, r0
  8c:	00000000 	andeq	r0, r0, r0
  90:	00001158 	andeq	r1, r0, r8, asr r1
  94:	0000012e 	andeq	r0, r0, lr, lsr #2
	...
  a0:	0000002c 	andeq	r0, r0, ip, lsr #32
  a4:	15510002 	ldrbne	r0, [r1, #-2]
  a8:	00040000 	andeq	r0, r4, r0
  ac:	00000000 	andeq	r0, r0, r0
  b0:	00001290 	muleq	r0, r0, r2
  b4:	0000001a 	andeq	r0, r0, sl, lsl r0
  b8:	000012b0 			; <UNDEFINED> instruction: 0x000012b0
  bc:	00000088 	andeq	r0, r0, r8, lsl #1
  c0:	00001340 	andeq	r1, r0, r0, asr #6
  c4:	000000d8 	ldrdeq	r0, [r0], -r8
	...
  d0:	00000034 	andeq	r0, r0, r4, lsr r0
  d4:	1bcc0002 	blne	ff3000e4 <_stack_start+0xdf2f00e4>
  d8:	00040000 	andeq	r0, r4, r0
  dc:	00000000 	andeq	r0, r0, r0
  e0:	00001420 	andeq	r1, r0, r0, lsr #8
  e4:	00000044 	andeq	r0, r0, r4, asr #32
  e8:	00001470 	andeq	r1, r0, r0, ror r4
  ec:	00000092 	muleq	r0, r2, r0
  f0:	00001510 	andeq	r1, r0, r0, lsl r5
  f4:	00000046 	andeq	r0, r0, r6, asr #32
  f8:	00001560 	andeq	r1, r0, r0, ror #10
  fc:	00000056 	andeq	r0, r0, r6, asr r0
	...
 108:	00000074 	andeq	r0, r0, r4, ror r0
 10c:	1e440002 	cdpne	0, 4, cr0, cr4, cr2, {0}
 110:	00040000 	andeq	r0, r4, r0
 114:	00000000 	andeq	r0, r0, r0
 118:	000015c0 	andeq	r1, r0, r0, asr #11
 11c:	00000022 	andeq	r0, r0, r2, lsr #32
 120:	000015f0 	strdeq	r1, [r0], -r0
 124:	00000020 	andeq	r0, r0, r0, lsr #32
 128:	00001610 	andeq	r1, r0, r0, lsl r6
 12c:	0000005c 	andeq	r0, r0, ip, asr r0
 130:	00001670 	andeq	r1, r0, r0, ror r6
 134:	0000005e 	andeq	r0, r0, lr, asr r0
 138:	000016d0 	ldrdeq	r1, [r0], -r0
 13c:	00000064 	andeq	r0, r0, r4, rrx
 140:	00001740 	andeq	r1, r0, r0, asr #14
 144:	0000008e 	andeq	r0, r0, lr, lsl #1
 148:	000017d0 	ldrdeq	r1, [r0], -r0
 14c:	00000066 	andeq	r0, r0, r6, rrx
 150:	00001840 	andeq	r1, r0, r0, asr #16
 154:	0000005c 	andeq	r0, r0, ip, asr r0
 158:	000018a0 	andeq	r1, r0, r0, lsr #17
 15c:	00000024 	andeq	r0, r0, r4, lsr #32
 160:	000018d0 	ldrdeq	r1, [r0], -r0
 164:	0000005c 	andeq	r0, r0, ip, asr r0
 168:	00001930 	andeq	r1, r0, r0, lsr r9
 16c:	00000090 	muleq	r0, r0, r0
 170:	000019c0 	andeq	r1, r0, r0, asr #19
 174:	0000001e 	andeq	r0, r0, lr, lsl r0
	...
 180:	00000084 	andeq	r0, r0, r4, lsl #1
 184:	25e90002 	strbcs	r0, [r9, #2]!
 188:	00040000 	andeq	r0, r4, r0
 18c:	00000000 	andeq	r0, r0, r0
 190:	000019e0 	andeq	r1, r0, r0, ror #19
 194:	00000018 	andeq	r0, r0, r8, lsl r0
 198:	00001a00 	andeq	r1, r0, r0, lsl #20
 19c:	0000001a 	andeq	r0, r0, sl, lsl r0
 1a0:	00001a20 	andeq	r1, r0, r0, lsr #20
 1a4:	000000ac 	andeq	r0, r0, ip, lsr #1
 1a8:	00001ad0 	ldrdeq	r1, [r0], -r0
 1ac:	00000062 	andeq	r0, r0, r2, rrx
 1b0:	00001b40 	andeq	r1, r0, r0, asr #22
 1b4:	00000040 	andeq	r0, r0, r0, asr #32
 1b8:	00001b80 	andeq	r1, r0, r0, lsl #23
 1bc:	0000007a 	andeq	r0, r0, sl, ror r0
 1c0:	00001c00 	andeq	r1, r0, r0, lsl #24
 1c4:	00000028 	andeq	r0, r0, r8, lsr #32
 1c8:	00001c30 	andeq	r1, r0, r0, lsr ip
 1cc:	00000026 	andeq	r0, r0, r6, lsr #32
 1d0:	00001c60 	andeq	r1, r0, r0, ror #24
 1d4:	00000024 	andeq	r0, r0, r4, lsr #32
 1d8:	00001c90 	muleq	r0, r0, ip
 1dc:	0000003a 	andeq	r0, r0, sl, lsr r0
 1e0:	00001cd0 	ldrdeq	r1, [r0], -r0
 1e4:	00000034 	andeq	r0, r0, r4, lsr r0
 1e8:	00001d10 	andeq	r1, r0, r0, lsl sp
 1ec:	00000018 	andeq	r0, r0, r8, lsl r0
 1f0:	00001d30 	andeq	r1, r0, r0, lsr sp
 1f4:	00000068 	andeq	r0, r0, r8, rrx
 1f8:	00001da0 	andeq	r1, r0, r0, lsr #27
 1fc:	00000052 	andeq	r0, r0, r2, asr r0
	...
 208:	00000034 	andeq	r0, r0, r4, lsr r0
 20c:	301f0002 	andscc	r0, pc, r2
 210:	00040000 	andeq	r0, r4, r0
 214:	00000000 	andeq	r0, r0, r0
 218:	00001e00 	andeq	r1, r0, r0, lsl #28
 21c:	0000002a 	andeq	r0, r0, sl, lsr #32
 220:	00001e30 	andeq	r1, r0, r0, lsr lr
 224:	00000090 	muleq	r0, r0, r0
 228:	00001ec0 	andeq	r1, r0, r0, asr #29
 22c:	0000005e 	andeq	r0, r0, lr, asr r0
 230:	00001f20 	andeq	r1, r0, r0, lsr #30
 234:	00000066 	andeq	r0, r0, r6, rrx
	...
 240:	00000034 	andeq	r0, r0, r4, lsr r0
 244:	37760002 	ldrbcc	r0, [r6, -r2]!
 248:	00040000 	andeq	r0, r4, r0
 24c:	00000000 	andeq	r0, r0, r0
 250:	00001f90 	muleq	r0, r0, pc	; <UNPREDICTABLE>
 254:	00000036 	andeq	r0, r0, r6, lsr r0
 258:	00001fd0 	ldrdeq	r1, [r0], -r0
 25c:	00000026 	andeq	r0, r0, r6, lsr #32
 260:	00002000 	andeq	r2, r0, r0
 264:	00000062 	andeq	r0, r0, r2, rrx
 268:	00002070 	andeq	r2, r0, r0, ror r0
 26c:	0000001c 	andeq	r0, r0, ip, lsl r0
	...
 278:	0000003c 	andeq	r0, r0, ip, lsr r0
 27c:	394a0002 	stmdbcc	sl, {r1}^
 280:	00040000 	andeq	r0, r4, r0
 284:	00000000 	andeq	r0, r0, r0
 288:	00002090 	muleq	r0, r0, r0
 28c:	0000003c 	andeq	r0, r0, ip, lsr r0
 290:	000020d0 	ldrdeq	r2, [r0], -r0
 294:	00000058 	andeq	r0, r0, r8, asr r0
 298:	00002130 	andeq	r2, r0, r0, lsr r1
 29c:	000000f4 	strdeq	r0, [r0], -r4
 2a0:	00002230 	andeq	r2, r0, r0, lsr r2
 2a4:	000000e8 	andeq	r0, r0, r8, ror #1
 2a8:	00002320 	andeq	r2, r0, r0, lsr #6
 2ac:	00000074 	andeq	r0, r0, r4, ror r0
	...
 2b8:	00000044 	andeq	r0, r0, r4, asr #32
 2bc:	3f920002 	svccc	0x00920002
 2c0:	00040000 	andeq	r0, r4, r0
 2c4:	00000000 	andeq	r0, r0, r0
 2c8:	000023a0 	andeq	r2, r0, r0, lsr #7
 2cc:	0000002a 	andeq	r0, r0, sl, lsr #32
 2d0:	000023d0 	ldrdeq	r2, [r0], -r0
 2d4:	0000003a 	andeq	r0, r0, sl, lsr r0
 2d8:	00002410 	andeq	r2, r0, r0, lsl r4
 2dc:	0000003c 	andeq	r0, r0, ip, lsr r0
 2e0:	00002450 	andeq	r2, r0, r0, asr r4
 2e4:	00000026 	andeq	r0, r0, r6, lsr #32
 2e8:	00002480 	andeq	r2, r0, r0, lsl #9
 2ec:	00000026 	andeq	r0, r0, r6, lsr #32
 2f0:	000024b0 			; <UNDEFINED> instruction: 0x000024b0
 2f4:	00000024 	andeq	r0, r0, r4, lsr #32
	...
 300:	0000004c 	andeq	r0, r0, ip, asr #32
 304:	427e0002 	rsbsmi	r0, lr, #2
 308:	00040000 	andeq	r0, r4, r0
 30c:	00000000 	andeq	r0, r0, r0
 310:	000024e0 	andeq	r2, r0, r0, ror #9
 314:	0000001c 	andeq	r0, r0, ip, lsl r0
 318:	00002500 	andeq	r2, r0, r0, lsl #10
 31c:	00000026 	andeq	r0, r0, r6, lsr #32
 320:	00002530 	andeq	r2, r0, r0, lsr r5
 324:	00000048 	andeq	r0, r0, r8, asr #32
 328:	00002580 	andeq	r2, r0, r0, lsl #11
 32c:	000000be 	strheq	r0, [r0], -lr
 330:	00002640 	andeq	r2, r0, r0, asr #12
 334:	00000006 	andeq	r0, r0, r6
 338:	00002650 	andeq	r2, r0, r0, asr r6
 33c:	00000014 	andeq	r0, r0, r4, lsl r0
 340:	00002670 	andeq	r2, r0, r0, ror r6
 344:	00000012 	andeq	r0, r0, r2, lsl r0
	...
 350:	0000002c 	andeq	r0, r0, ip, lsr #32
 354:	4a5f0002 	bmi	17c0364 <_flash_swap_addr+0x1780b64>
 358:	00040000 	andeq	r0, r4, r0
 35c:	00000000 	andeq	r0, r0, r0
 360:	00002690 	muleq	r0, r0, r6
 364:	000000a4 	andeq	r0, r0, r4, lsr #1
 368:	00002740 	andeq	r2, r0, r0, asr #14
 36c:	00000078 	andeq	r0, r0, r8, ror r0
 370:	000027c0 	andeq	r2, r0, r0, asr #15
 374:	00000060 	andeq	r0, r0, r0, rrx
	...
 380:	0000006c 	andeq	r0, r0, ip, rrx
 384:	4e900002 	cdpmi	0, 9, cr0, cr0, cr2, {0}
 388:	00040000 	andeq	r0, r4, r0
 38c:	00000000 	andeq	r0, r0, r0
 390:	00002820 	andeq	r2, r0, r0, lsr #16
 394:	00000046 	andeq	r0, r0, r6, asr #32
 398:	00002870 	andeq	r2, r0, r0, ror r8
 39c:	00000022 	andeq	r0, r0, r2, lsr #32
 3a0:	000028a0 	andeq	r2, r0, r0, lsr #17
 3a4:	00000020 	andeq	r0, r0, r0, lsr #32
 3a8:	000028c0 	andeq	r2, r0, r0, asr #17
 3ac:	0000001e 	andeq	r0, r0, lr, lsl r0
 3b0:	000028e0 	andeq	r2, r0, r0, ror #17
 3b4:	00000020 	andeq	r0, r0, r0, lsr #32
 3b8:	00002900 	andeq	r2, r0, r0, lsl #18
 3bc:	000000c0 	andeq	r0, r0, r0, asr #1
 3c0:	000029c0 	andeq	r2, r0, r0, asr #19
 3c4:	00000026 	andeq	r0, r0, r6, lsr #32
 3c8:	000029f0 	strdeq	r2, [r0], -r0
 3cc:	00000048 	andeq	r0, r0, r8, asr #32
 3d0:	00002a40 	andeq	r2, r0, r0, asr #20
 3d4:	000000b0 	strheq	r0, [r0], -r0	; <UNPREDICTABLE>
 3d8:	00002af0 	strdeq	r2, [r0], -r0
 3dc:	0000009c 	muleq	r0, ip, r0
 3e0:	00002b90 	muleq	r0, r0, fp
 3e4:	00000086 	andeq	r0, r0, r6, lsl #1
	...

Disassembly of section .debug_loc:

00000000 <.debug_loc>:
       0:	00000000 	andeq	r0, r0, r0
       4:	00000002 	andeq	r0, r0, r2
       8:	007d0002 	rsbseq	r0, sp, r2
       c:	00000002 	andeq	r0, r0, r2
      10:	00000004 	andeq	r0, r0, r4
      14:	047d0002 	ldrbteq	r0, [sp], #-2
      18:	00000004 	andeq	r0, r0, r4
      1c:	00000006 	andeq	r0, r0, r6
      20:	107d0002 	rsbsne	r0, sp, r2
      24:	00000006 	andeq	r0, r0, r6
      28:	00000014 	andeq	r0, r0, r4, lsl r0
      2c:	10770002 	rsbsne	r0, r7, r2
	...
      38:	00000014 	andeq	r0, r0, r4, lsl r0
      3c:	00000016 	andeq	r0, r0, r6, lsl r0
      40:	007d0002 	rsbseq	r0, sp, r2
      44:	00000016 	andeq	r0, r0, r6, lsl r0
      48:	00000018 	andeq	r0, r0, r8, lsl r0
      4c:	087d0002 	ldmdaeq	sp!, {r1}^
      50:	00000018 	andeq	r0, r0, r8, lsl r0
      54:	0000001a 	andeq	r0, r0, sl, lsl r0
      58:	107d0002 	rsbsne	r0, sp, r2
      5c:	0000001a 	andeq	r0, r0, sl, lsl r0
      60:	00000036 	andeq	r0, r0, r6, lsr r0
      64:	10770002 	rsbsne	r0, r7, r2
	...
      70:	00000038 	andeq	r0, r0, r8, lsr r0
      74:	0000003a 	andeq	r0, r0, sl, lsr r0
      78:	007d0002 	rsbseq	r0, sp, r2
      7c:	0000003a 	andeq	r0, r0, sl, lsr r0
      80:	0000003c 	andeq	r0, r0, ip, lsr r0
      84:	087d0002 	ldmdaeq	sp!, {r1}^
      88:	0000003c 	andeq	r0, r0, ip, lsr r0
      8c:	0000005a 	andeq	r0, r0, sl, asr r0
      90:	08770002 	ldmdaeq	r7!, {r1}^
	...
      9c:	0000005c 	andeq	r0, r0, ip, asr r0
      a0:	0000005e 	andeq	r0, r0, lr, asr r0
      a4:	007d0002 	rsbseq	r0, sp, r2
      a8:	0000005e 	andeq	r0, r0, lr, asr r0
      ac:	00000060 	andeq	r0, r0, r0, rrx
      b0:	087d0002 	ldmdaeq	sp!, {r1}^
      b4:	00000060 	andeq	r0, r0, r0, rrx
      b8:	00000062 	andeq	r0, r0, r2, rrx
      bc:	107d0002 	rsbsne	r0, sp, r2
      c0:	00000062 	andeq	r0, r0, r2, rrx
      c4:	000000b0 	strheq	r0, [r0], -r0	; <UNPREDICTABLE>
      c8:	10770002 	rsbsne	r0, r7, r2
	...
      d4:	000000b0 	strheq	r0, [r0], -r0	; <UNPREDICTABLE>
      d8:	000000b2 	strheq	r0, [r0], -r2
      dc:	007d0002 	rsbseq	r0, sp, r2
      e0:	000000b2 	strheq	r0, [r0], -r2
      e4:	000000b4 	strheq	r0, [r0], -r4
      e8:	087d0002 	ldmdaeq	sp!, {r1}^
      ec:	000000b4 	strheq	r0, [r0], -r4
      f0:	000000b6 	strheq	r0, [r0], -r6
      f4:	107d0002 	rsbsne	r0, sp, r2
      f8:	000000b6 	strheq	r0, [r0], -r6
      fc:	00000128 	andeq	r0, r0, r8, lsr #2
     100:	08770002 	ldmdaeq	r7!, {r1}^
	...
     110:	00000002 	andeq	r0, r0, r2
     114:	007d0002 	rsbseq	r0, sp, r2
     118:	00000002 	andeq	r0, r0, r2
     11c:	00000004 	andeq	r0, r0, r4
     120:	087d0002 	ldmdaeq	sp!, {r1}^
     124:	00000004 	andeq	r0, r0, r4
     128:	00000006 	andeq	r0, r0, r6
     12c:	187d0002 	ldmdane	sp!, {r1}^
     130:	00000006 	andeq	r0, r0, r6
     134:	000000b4 	strheq	r0, [r0], -r4
     138:	18770002 	ldmdane	r7!, {r1}^
	...
     144:	000000b4 	strheq	r0, [r0], -r4
     148:	000000b6 	strheq	r0, [r0], -r6
     14c:	007d0002 	rsbseq	r0, sp, r2
     150:	000000b6 	strheq	r0, [r0], -r6
     154:	000000b8 	strheq	r0, [r0], -r8
     158:	087d0002 	ldmdaeq	sp!, {r1}^
     15c:	000000b8 	strheq	r0, [r0], -r8
     160:	000000ba 	strheq	r0, [r0], -sl
     164:	287d0002 	ldmdacs	sp!, {r1}^
     168:	000000ba 	strheq	r0, [r0], -sl
     16c:	000002b6 			; <UNDEFINED> instruction: 0x000002b6
     170:	28770002 	ldmdacs	r7!, {r1}^
	...
     17c:	000002b8 			; <UNDEFINED> instruction: 0x000002b8
     180:	000002ba 			; <UNDEFINED> instruction: 0x000002ba
     184:	007d0002 	rsbseq	r0, sp, r2
     188:	000002ba 			; <UNDEFINED> instruction: 0x000002ba
     18c:	000002bc 			; <UNDEFINED> instruction: 0x000002bc
     190:	087d0002 	ldmdaeq	sp!, {r1}^
     194:	000002bc 			; <UNDEFINED> instruction: 0x000002bc
     198:	000002be 			; <UNDEFINED> instruction: 0x000002be
     19c:	187d0002 	ldmdane	sp!, {r1}^
     1a0:	000002be 			; <UNDEFINED> instruction: 0x000002be
     1a4:	000002e2 	andeq	r0, r0, r2, ror #5
     1a8:	18770002 	ldmdane	r7!, {r1}^
	...
     1b4:	000002e4 	andeq	r0, r0, r4, ror #5
     1b8:	000002e6 	andeq	r0, r0, r6, ror #5
     1bc:	007d0002 	rsbseq	r0, sp, r2
     1c0:	000002e6 	andeq	r0, r0, r6, ror #5
     1c4:	000002e8 	andeq	r0, r0, r8, ror #5
     1c8:	087d0002 	ldmdaeq	sp!, {r1}^
     1cc:	000002e8 	andeq	r0, r0, r8, ror #5
     1d0:	000002ea 	andeq	r0, r0, sl, ror #5
     1d4:	187d0002 	ldmdane	sp!, {r1}^
     1d8:	000002ea 	andeq	r0, r0, sl, ror #5
     1dc:	0000030e 	andeq	r0, r0, lr, lsl #6
     1e0:	18770002 	ldmdane	r7!, {r1}^
	...
     1ec:	00000310 	andeq	r0, r0, r0, lsl r3
     1f0:	00000312 	andeq	r0, r0, r2, lsl r3
     1f4:	007d0002 	rsbseq	r0, sp, r2
     1f8:	00000312 	andeq	r0, r0, r2, lsl r3
     1fc:	00000314 	andeq	r0, r0, r4, lsl r3
     200:	087d0002 	ldmdaeq	sp!, {r1}^
     204:	00000314 	andeq	r0, r0, r4, lsl r3
     208:	00000316 	andeq	r0, r0, r6, lsl r3
     20c:	187d0002 	ldmdane	sp!, {r1}^
     210:	00000316 	andeq	r0, r0, r6, lsl r3
     214:	0000033a 	andeq	r0, r0, sl, lsr r3
     218:	18770002 	ldmdane	r7!, {r1}^
	...
     224:	0000033c 	andeq	r0, r0, ip, lsr r3
     228:	0000033e 	andeq	r0, r0, lr, lsr r3
     22c:	007d0002 	rsbseq	r0, sp, r2
     230:	0000033e 	andeq	r0, r0, lr, lsr r3
     234:	00000340 	andeq	r0, r0, r0, asr #6
     238:	047d0002 	ldrbteq	r0, [sp], #-2
     23c:	00000340 	andeq	r0, r0, r0, asr #6
     240:	00000342 	andeq	r0, r0, r2, asr #6
     244:	187d0002 	ldmdane	sp!, {r1}^
     248:	00000342 	andeq	r0, r0, r2, asr #6
     24c:	00000352 	andeq	r0, r0, r2, asr r3
     250:	18770002 	ldmdane	r7!, {r1}^
	...
     25c:	00000354 	andeq	r0, r0, r4, asr r3
     260:	00000356 	andeq	r0, r0, r6, asr r3
     264:	007d0002 	rsbseq	r0, sp, r2
     268:	00000356 	andeq	r0, r0, r6, asr r3
     26c:	00000358 	andeq	r0, r0, r8, asr r3
     270:	047d0002 	ldrbteq	r0, [sp], #-2
     274:	00000358 	andeq	r0, r0, r8, asr r3
     278:	0000035a 	andeq	r0, r0, sl, asr r3
     27c:	107d0002 	rsbsne	r0, sp, r2
     280:	0000035a 	andeq	r0, r0, sl, asr r3
     284:	0000036c 	andeq	r0, r0, ip, ror #6
     288:	10770002 	rsbsne	r0, r7, r2
	...
     294:	0000036c 	andeq	r0, r0, ip, ror #6
     298:	0000036e 	andeq	r0, r0, lr, ror #6
     29c:	007d0002 	rsbseq	r0, sp, r2
     2a0:	0000036e 	andeq	r0, r0, lr, ror #6
     2a4:	00000370 	andeq	r0, r0, r0, ror r3
     2a8:	087d0002 	ldmdaeq	sp!, {r1}^
     2ac:	00000370 	andeq	r0, r0, r0, ror r3
     2b0:	00000372 	andeq	r0, r0, r2, ror r3
     2b4:	187d0002 	ldmdane	sp!, {r1}^
     2b8:	00000372 	andeq	r0, r0, r2, ror r3
     2bc:	000003a0 	andeq	r0, r0, r0, lsr #7
     2c0:	18770002 	ldmdane	r7!, {r1}^
	...
     2d0:	00000002 	andeq	r0, r0, r2
     2d4:	007d0002 	rsbseq	r0, sp, r2
     2d8:	00000002 	andeq	r0, r0, r2
     2dc:	00000004 	andeq	r0, r0, r4
     2e0:	047d0002 	ldrbteq	r0, [sp], #-2
     2e4:	00000004 	andeq	r0, r0, r4
     2e8:	00000006 	andeq	r0, r0, r6
     2ec:	107d0002 	rsbsne	r0, sp, r2
     2f0:	00000006 	andeq	r0, r0, r6
     2f4:	00000014 	andeq	r0, r0, r4, lsl r0
     2f8:	10770002 	rsbsne	r0, r7, r2
	...
     304:	00000014 	andeq	r0, r0, r4, lsl r0
     308:	00000016 	andeq	r0, r0, r6, lsl r0
     30c:	007d0002 	rsbseq	r0, sp, r2
     310:	00000016 	andeq	r0, r0, r6, lsl r0
     314:	00000018 	andeq	r0, r0, r8, lsl r0
     318:	047d0002 	ldrbteq	r0, [sp], #-2
     31c:	00000018 	andeq	r0, r0, r8, lsl r0
     320:	0000001a 	andeq	r0, r0, sl, lsl r0
     324:	107d0002 	rsbsne	r0, sp, r2
     328:	0000001a 	andeq	r0, r0, sl, lsl r0
     32c:	000001de 	ldrdeq	r0, [r0], -lr
     330:	10770002 	rsbsne	r0, r7, r2
	...
     33c:	000001e0 	andeq	r0, r0, r0, ror #3
     340:	000001e2 	andeq	r0, r0, r2, ror #3
     344:	007d0002 	rsbseq	r0, sp, r2
     348:	000001e2 	andeq	r0, r0, r2, ror #3
     34c:	000001e4 	andeq	r0, r0, r4, ror #3
     350:	047d0002 	ldrbteq	r0, [sp], #-2
     354:	000001e4 	andeq	r0, r0, r4, ror #3
     358:	000001e6 	andeq	r0, r0, r6, ror #3
     35c:	107d0002 	rsbsne	r0, sp, r2
     360:	000001e6 	andeq	r0, r0, r6, ror #3
     364:	000001f4 	strdeq	r0, [r0], -r4
     368:	10770002 	rsbsne	r0, r7, r2
	...
     374:	000001f4 	strdeq	r0, [r0], -r4
     378:	000001f6 	strdeq	r0, [r0], -r6
     37c:	007d0002 	rsbseq	r0, sp, r2
     380:	000001f6 	strdeq	r0, [r0], -r6
     384:	000001f8 	strdeq	r0, [r0], -r8
     388:	047d0002 	ldrbteq	r0, [sp], #-2
     38c:	000001f8 	strdeq	r0, [r0], -r8
     390:	000001fa 	strdeq	r0, [r0], -sl
     394:	107d0002 	rsbsne	r0, sp, r2
     398:	000001fa 	strdeq	r0, [r0], -sl
     39c:	00000208 	andeq	r0, r0, r8, lsl #4
     3a0:	10770002 	rsbsne	r0, r7, r2
	...
     3ac:	00000208 	andeq	r0, r0, r8, lsl #4
     3b0:	0000020a 	andeq	r0, r0, sl, lsl #4
     3b4:	007d0002 	rsbseq	r0, sp, r2
     3b8:	0000020a 	andeq	r0, r0, sl, lsl #4
     3bc:	0000020c 	andeq	r0, r0, ip, lsl #4
     3c0:	047d0002 	ldrbteq	r0, [sp], #-2
     3c4:	0000020c 	andeq	r0, r0, ip, lsl #4
     3c8:	0000020e 	andeq	r0, r0, lr, lsl #4
     3cc:	107d0002 	rsbsne	r0, sp, r2
     3d0:	0000020e 	andeq	r0, r0, lr, lsl #4
     3d4:	0000021c 	andeq	r0, r0, ip, lsl r2
     3d8:	10770002 	rsbsne	r0, r7, r2
	...
     3e4:	0000021c 	andeq	r0, r0, ip, lsl r2
     3e8:	0000021e 	andeq	r0, r0, lr, lsl r2
     3ec:	007d0002 	rsbseq	r0, sp, r2
     3f0:	0000021e 	andeq	r0, r0, lr, lsl r2
     3f4:	00000220 	andeq	r0, r0, r0, lsr #4
     3f8:	047d0002 	ldrbteq	r0, [sp], #-2
     3fc:	00000220 	andeq	r0, r0, r0, lsr #4
     400:	00000222 	andeq	r0, r0, r2, lsr #4
     404:	107d0002 	rsbsne	r0, sp, r2
     408:	00000222 	andeq	r0, r0, r2, lsr #4
     40c:	00000230 	andeq	r0, r0, r0, lsr r2
    .thumb_func

_default_reset_handler:

unlock_watchdog:
    ldr r6, =0x4005200e
     410:	10770002 	rsbsne	r0, r7, r2
	...
    ldr r0, =0xd928
    strh r0, [r6]

disable_watchdog:
    ldr r6, =0x40052000
    ldr r0, =0x01d2
     41c:	00000230 	andeq	r0, r0, r0, lsr r2
     * address 0x00000000 (which is the first element in the vector_table) by
     * the hardware. The next three lines are required in case this image
     * is not located at 0x0 (i.e. it is being launched from a bootloader).
     */

    ldr r1, =_vector_table
     420:	00000232 	andeq	r0, r0, r2, lsr r2
    ldr r2, [r1]
    mov	sp,r2
     424:	007d0002 	rsbseq	r0, sp, r2
chibi_setup:
    /*
     * ChibiOS requires a process stack to be initialized.
     */
    ldr r1, =_process_stack_start
    msr PSP, r1
     428:	00000232 	andeq	r0, r0, r2, lsr r2

    /* TODO: FPU register initialization per crt0.c */
    /*
     * Set up system to run in privileged mode using the PSP stack
     */
    ldr r1, =0x00000002
     42c:	00000234 	andeq	r0, r0, r4, lsr r2
    msr CONTROL, r1
     430:	047d0002 	ldrbteq	r0, [sp], #-2
    isb
     434:	00000234 	andeq	r0, r0, r4, lsr r2
     * address and the start address are not the same. This code supports
     * running an entire image out of SRAM.
     */

    ldr r0, =_text_start
    ldr r1, =_text_end
     438:	00000236 	andeq	r0, r0, r6, lsr r2
    ldr r2, =_text_load

    cmp r0, r2
     43c:	107d0002 	rsbsne	r0, sp, r2
    beq end_text_loop
     440:	00000236 	andeq	r0, r0, r6, lsr r2
text_loop:
    cmp r0, r1
    ittt    lt
     444:	00000244 	andeq	r0, r0, r4, asr #4
    ldrlt   r3, [r2], #4
     448:	10770002 	rsbsne	r0, r7, r2
	...
    /*
     * Relocate the .ramcode section from FLASH to SRAM.
     */

    ldr r0, =_ramcode_start
    ldr r1, =_ramcode_end
     454:	00000244 	andeq	r0, r0, r4, asr #4
    ldr r2, =_ramcode_load

ramcode_loop:
    cmp r0, r1
     458:	00000246 	andeq	r0, r0, r6, asr #4
    ittt    lt
    ldrlt   r3, [r2], #4
     45c:	007d0002 	rsbseq	r0, sp, r2
    strlt   r3, [r0], #4
     460:	00000246 	andeq	r0, r0, r6, asr #4
    blt     ramcode_loop
     464:	00000248 	andeq	r0, r0, r8, asr #4

    /*
     * Relocate vector table to SRAM.
     */

     ldr r0, =_vector_ram_start
     468:	047d0002 	ldrbteq	r0, [sp], #-2
     ldr r1, =_vector_ram_end
     ldr r2, =_vector_rom
     46c:	00000248 	andeq	r0, r0, r8, asr #4
vector_loop:
    cmp r0, r1
    ittt    lt
     470:	0000024a 	andeq	r0, r0, sl, asr #4
    ldrlt   r3, [r2], #4
     474:	107d0002 	rsbsne	r0, sp, r2
    strlt   r3, [r0], #4
     478:	0000024a 	andeq	r0, r0, sl, asr #4
    blt     vector_loop
     47c:	00000258 	andeq	r0, r0, r8, asr r2
    /*
     * Point to the SRAM vector table.
     */

    ldr r1,=0xe000ed08
    ldr r0,=_vector_ram_start
     480:	10770002 	rsbsne	r0, r7, r2
	...
    ldr r1, =_data_end
    ldr r2, =_data_load

data_loop:
    cmp r0, r1
    ittt    lt
     48c:	00000258 	andeq	r0, r0, r8, asr r2
    ldrlt   r3, [r2], #4
     490:	0000025a 	andeq	r0, r0, sl, asr r2
    strlt   r3, [r0], #4
     494:	007d0002 	rsbseq	r0, sp, r2
    blt     data_loop
     498:	0000025a 	andeq	r0, r0, sl, asr r2
    /*
     * Zero out the .bss section in SRAM.
     */

    ldr r0, =_bss_start
    ldr r1, =_bss_end
     49c:	0000025c 	andeq	r0, r0, ip, asr r2
    ldr r2, =0x00000000

bss_loop:
    cmp r0, r1
     4a0:	047d0002 	ldrbteq	r0, [sp], #-2
    itt     lt
    strlt   r2, [r0], #4
     4a4:	0000025c 	andeq	r0, r0, ip, asr r2
    blt     bss_loop
     4a8:	0000025e 	andeq	r0, r0, lr, asr r2

    /*
     * Zero out heap.
     */

    ldr r0, =_heap_start
     4ac:	107d0002 	rsbsne	r0, sp, r2
    ldr r1, =_heap_end

heap_loop:
    cmp r0, r1
     4b0:	0000025e 	andeq	r0, r0, lr, asr r2
    itt     lt
    strlt   r2, [r0], #4
     4b4:	00000338 	andeq	r0, r0, r8, lsr r3
    blt     heap_loop
     4b8:	10770002 	rsbsne	r0, r7, r2
	...
    ldr r1, =_stack_start
    ldr r2, =0xefefefef

stack_loop:
    cmp r0, r1
    itt     lt
     4c4:	00000338 	andeq	r0, r0, r8, lsr r3
    strlt   r2, [r0], #4
     4c8:	0000033a 	andeq	r0, r0, sl, lsr r3
    blt     stack_loop
     4cc:	007d0002 	rsbseq	r0, sp, r2

call_user_asm_code:
    bl main
     4d0:	0000033a 	andeq	r0, r0, sl, lsr r3
    /*
     * Epilogue processing would go here.
     */

end_loop:
    b end_loop
     4d4:	0000033c 	andeq	r0, r0, ip, lsr r3

    .align 2
    .thumb_func

_default_nmi_handler:
    b _default_nmi_handler
     4d8:	047d0002 	ldrbteq	r0, [sp], #-2

    .align 2
    .thumb_func

_default_fault_handler:
    b _default_fault_handler
     4dc:	0000033c 	andeq	r0, r0, ip, lsr r3

    .align 2
    .thumb_func

_default_irq_handler:
    b _default_irq_handler
     4e0:	0000033e 	andeq	r0, r0, lr, lsr r3
    .thumb_func

_default_reset_handler:

unlock_watchdog:
    ldr r6, =0x4005200e
     4e4:	107d0002 	rsbsne	r0, sp, r2
    ldr r0, =0xc520
     4e8:	0000033e 	andeq	r0, r0, lr, lsr r3
    strh r0, [r6]
    ldr r0, =0xd928
     4ec:	0000034c 	andeq	r0, r0, ip, asr #6
    strh r0, [r6]

disable_watchdog:
    ldr r6, =0x40052000
     4f0:	10770002 	rsbsne	r0, r7, r2
	...

chibi_setup:
    /*
     * ChibiOS requires a process stack to be initialized.
     */
    ldr r1, =_process_stack_start
     4fc:	0000034c 	andeq	r0, r0, ip, asr #6

    /* TODO: FPU register initialization per crt0.c */
    /*
     * Set up system to run in privileged mode using the PSP stack
     */
    ldr r1, =0x00000002
     500:	0000034e 	andeq	r0, r0, lr, asr #6
     * Relocate the .text section from FLASH to SRAM only if the load
     * address and the start address are not the same. This code supports
     * running an entire image out of SRAM.
     */

    ldr r0, =_text_start
     504:	007d0002 	rsbseq	r0, sp, r2
    ldr r1, =_text_end
     508:	0000034e 	andeq	r0, r0, lr, asr #6
    ldr r2, =_text_load
     50c:	00000350 	andeq	r0, r0, r0, asr r3

    /*
     * Relocate the .ramcode section from FLASH to SRAM.
     */

    ldr r0, =_ramcode_start
     510:	047d0002 	ldrbteq	r0, [sp], #-2
    ldr r1, =_ramcode_end
     514:	00000350 	andeq	r0, r0, r0, asr r3
    ldr r2, =_ramcode_load
     518:	00000352 	andeq	r0, r0, r2, asr r3

    /*
     * Relocate vector table to SRAM.
     */

     ldr r0, =_vector_ram_start
     51c:	107d0002 	rsbsne	r0, sp, r2
     ldr r1, =_vector_ram_end
     520:	00000352 	andeq	r0, r0, r2, asr r3
     ldr r2, =_vector_rom
     524:	00000360 	andeq	r0, r0, r0, ror #6

    /*
     * Point to the SRAM vector table.
     */

    ldr r1,=0xe000ed08
     528:	10770002 	rsbsne	r0, r7, r2
	...
     *       in FLASH.
     */

    ldr r0, =_data_start
    ldr r1, =_data_end
    ldr r2, =_data_load
     534:	00000360 	andeq	r0, r0, r0, ror #6

    /*
     * Zero out the .bss section in SRAM.
     */

    ldr r0, =_bss_start
     538:	00000362 	andeq	r0, r0, r2, ror #6
    ldr r1, =_bss_end
     53c:	007d0002 	rsbseq	r0, sp, r2
    ldr r2, =0x00000000
     540:	00000362 	andeq	r0, r0, r2, ror #6

    /*
     * Zero out heap.
     */

    ldr r0, =_heap_start
     544:	00000364 	andeq	r0, r0, r4, ror #6
    ldr r1, =_heap_end
     548:	047d0002 	ldrbteq	r0, [sp], #-2
    ldr r0, =_stack_start
    ldr r1, =_stack_end
    ldr r2, =0xefefefef
*/

    ldr r0, =_stack_end
     54c:	00000364 	andeq	r0, r0, r4, ror #6
    ldr r1, =_stack_start
     550:	00000366 	andeq	r0, r0, r6, ror #6
    ldr r2, =0xefefefef
     554:	107d0002 	rsbsne	r0, sp, r2
     558:	00000366 	andeq	r0, r0, r6, ror #6
     55c:	00000374 	andeq	r0, r0, r4, ror r3
#define TSI_ORANGE_BIT    BIT_5

#define TSI_YELLOW_INDEX  8
#define TSI_YELLOW_BIT    BIT_8

void assert_(const char *file, const int line) { }
     560:	10770002 	rsbsne	r0, r7, r2
	...
     56c:	00000374 	andeq	r0, r0, r4, ror r3
     570:	00000376 	andeq	r0, r0, r6, ror r3

static WORKING_AREA(waThread1, 128);
static msg_t Thread1(void *arg) {
     574:	007d0002 	rsbseq	r0, sp, r2
     578:	00000376 	andeq	r0, r0, r6, ror r3
    while (TRUE) {
        chThdSleepMilliseconds(500);
     57c:	00000378 	andeq	r0, r0, r8, ror r3
     580:	047d0002 	ldrbteq	r0, [sp], #-2
        gpioToggle(N_LED_YELLOW_PORT, N_LED_YELLOW_PIN);
     584:	00000378 	andeq	r0, r0, r8, ror r3
     588:	0000037a 	andeq	r0, r0, sl, ror r3
     58c:	107d0002 	rsbsne	r0, sp, r2
     590:	0000037a 	andeq	r0, r0, sl, ror r3
    }
     594:	00000388 	andeq	r0, r0, r8, lsl #7

    return 0;
}

static void clocksInit(void)
{
     598:	10770002 	rsbsne	r0, r7, r2
	...
     * System:  100 MHz
     * Bus:      50 MHz
     * Flexbus:  50 MHz
     * Flash:    25 MHz
     */
    clockSetDividers(DIVIDE_BY_1, DIVIDE_BY_2, DIVIDE_BY_4, DIVIDE_BY_4);
     5a4:	00000388 	andeq	r0, r0, r8, lsl #7
     5a8:	0000038a 	andeq	r0, r0, sl, lsl #7
     5ac:	007d0002 	rsbseq	r0, sp, r2
    clockConfigMcgOut(MCG_PLL_EXTERNAL_100MHZ);
     5b0:	0000038a 	andeq	r0, r0, sl, lsl #7
     5b4:	0000038c 	andeq	r0, r0, ip, lsl #7
}
     5b8:	047d0002 	ldrbteq	r0, [sp], #-2

static void systickInit(void)
{
     5bc:	0000038c 	andeq	r0, r0, ip, lsl #7
     5c0:	0000038e 	andeq	r0, r0, lr, lsl #7
    uint32_t freq = clockGetFreq(CLOCK_CORE);
     5c4:	107d0002 	rsbsne	r0, sp, r2
     5c8:	0000038e 	andeq	r0, r0, lr, lsl #7

    NVIC_SYSTICK_RELOAD = freq / CH_FREQUENCY - 1;
     5cc:	0000039c 	muleq	r0, ip, r3
     5d0:	10770002 	rsbsne	r0, r7, r2
	...
     5dc:	0000039c 	muleq	r0, ip, r3
     5e0:	0000039e 	muleq	r0, lr, r3
     5e4:	007d0002 	rsbseq	r0, sp, r2
     5e8:	0000039e 	muleq	r0, lr, r3
    NVIC_SYSTICK_VALUE = 0;
     5ec:	000003a0 	andeq	r0, r0, r0, lsr #7
     5f0:	047d0002 	ldrbteq	r0, [sp], #-2
     5f4:	000003a0 	andeq	r0, r0, r0, lsr #7
     5f8:	000003a2 	andeq	r0, r0, r2, lsr #7
    NVIC_SYSTICK_CONTROL = NVIC_SYSTICK_CONTROL_ENABLE
     5fc:	107d0002 	rsbsne	r0, sp, r2
     600:	000003a2 	andeq	r0, r0, r2, lsr #7
     604:	000003b0 			; <UNDEFINED> instruction: 0x000003b0
                         | NVIC_SYSTICK_CONTROL_TICKINT
                         | NVIC_SYSTICK_CONTROL_CLKSOURCE;
}
     608:	10770002 	rsbsne	r0, r7, r2
	...

int main(void)
{
     614:	000003b0 			; <UNDEFINED> instruction: 0x000003b0
    clocksInit();
     618:	000003b2 			; <UNDEFINED> instruction: 0x000003b2
    systickInit();
     61c:	007d0002 	rsbseq	r0, sp, r2
    chSysInit();
     620:	000003b2 			; <UNDEFINED> instruction: 0x000003b2

    gpioConfig(N_LED_ORANGE_PORT, N_LED_ORANGE_PIN, GPIO_OUTPUT | GPIO_LOW);
     624:	000003b4 			; <UNDEFINED> instruction: 0x000003b4
     628:	047d0002 	ldrbteq	r0, [sp], #-2
     62c:	000003b4 			; <UNDEFINED> instruction: 0x000003b4
     630:	000003b6 			; <UNDEFINED> instruction: 0x000003b6
     634:	107d0002 	rsbsne	r0, sp, r2
    gpioConfig(N_LED_YELLOW_PORT, N_LED_YELLOW_PIN, GPIO_OUTPUT | GPIO_LOW);
     638:	000003b6 			; <UNDEFINED> instruction: 0x000003b6
     63c:	000003c4 	andeq	r0, r0, r4, asr #7
     640:	10770002 	rsbsne	r0, r7, r2
	...

    chThdCreateStatic(waThread1, sizeof(waThread1), NORMALPRIO, Thread1, NULL);
     64c:	000003c4 	andeq	r0, r0, r4, asr #7
     650:	000003c6 	andeq	r0, r0, r6, asr #7
     654:	007d0002 	rsbseq	r0, sp, r2
     658:	000003c6 	andeq	r0, r0, r6, asr #7
     65c:	000003c8 	andeq	r0, r0, r8, asr #7
     660:	047d0002 	ldrbteq	r0, [sp], #-2
     664:	000003c8 	andeq	r0, r0, r8, asr #7
     668:	000003ca 	andeq	r0, r0, sl, asr #7

    hwInterruptsEnable();
     66c:	107d0002 	rsbsne	r0, sp, r2

    while (TRUE) {
        chThdSleepMilliseconds(123);
     670:	000003ca 	andeq	r0, r0, sl, asr #7
     674:	000003d8 	ldrdeq	r0, [r0], -r8
        gpioToggle(N_LED_ORANGE_PORT, N_LED_ORANGE_PIN);
     678:	10770002 	rsbsne	r0, r7, r2
	...
     684:	000003d8 	ldrdeq	r0, [r0], -r8
*
* RETURNS: The corresponding GPIO_BASE_ADDR.
*
*******************************************************************************/
static volatile gpioPort_t *gpioPortGet(uint32_t port)
{
     688:	000003da 	ldrdeq	r0, [r0], -sl
     68c:	007d0002 	rsbseq	r0, sp, r2
    uint32_t addr;

    switch (port) {
     690:	000003da 	ldrdeq	r0, [r0], -sl
     694:	000003dc 	ldrdeq	r0, [r0], -ip
     698:	047d0002 	ldrbteq	r0, [sp], #-2
     69c:	000003dc 	ldrdeq	r0, [r0], -ip
     6a0:	000003de 	ldrdeq	r0, [r0], -lr
     6a4:	107d0002 	rsbsne	r0, sp, r2
     6a8:	000003de 	ldrdeq	r0, [r0], -lr
     6ac:	000003ec 	andeq	r0, r0, ip, ror #7
     6b0:	10770002 	rsbsne	r0, r7, r2
	...
     6bc:	000003ec 	andeq	r0, r0, ip, ror #7
     6c0:	000003ee 	andeq	r0, r0, lr, ror #7
     6c4:	007d0002 	rsbseq	r0, sp, r2
     6c8:	000003ee 	andeq	r0, r0, lr, ror #7
     6cc:	000003f0 	strdeq	r0, [r0], -r0	; <UNPREDICTABLE>
     6d0:	047d0002 	ldrbteq	r0, [sp], #-2
     6d4:	000003f0 	strdeq	r0, [r0], -r0	; <UNPREDICTABLE>
     6d8:	000003f2 	strdeq	r0, [r0], -r2
     6dc:	107d0002 	rsbsne	r0, sp, r2
    case PORTA: addr = GPIOA_BASE_ADDR; break;
     6e0:	000003f2 	strdeq	r0, [r0], -r2
     6e4:	00000400 	andeq	r0, r0, r0, lsl #8
     6e8:	10770002 	rsbsne	r0, r7, r2
	...
    case PORTB: addr = GPIOB_BASE_ADDR; break;
     6f4:	00000400 	andeq	r0, r0, r0, lsl #8
    case PORTC: addr = GPIOC_BASE_ADDR; break;
     6f8:	00000402 	andeq	r0, r0, r2, lsl #8
     6fc:	007d0002 	rsbseq	r0, sp, r2
     700:	00000402 	andeq	r0, r0, r2, lsl #8
    case PORTD: addr = GPIOD_BASE_ADDR; break;
     704:	00000404 	andeq	r0, r0, r4, lsl #8
     708:	047d0002 	ldrbteq	r0, [sp], #-2
     70c:	00000404 	andeq	r0, r0, r4, lsl #8
    case PORTE: addr = GPIOE_BASE_ADDR; break;
     710:	00000406 	andeq	r0, r0, r6, lsl #8
     714:	107d0002 	rsbsne	r0, sp, r2
     718:	00000406 	andeq	r0, r0, r6, lsl #8
    default:
        assert(0);
     71c:	00000414 	andeq	r0, r0, r4, lsl r4
     720:	10770002 	rsbsne	r0, r7, r2
	...
        return 0;
     72c:	00000414 	andeq	r0, r0, r4, lsl r4
    }

    return ((volatile gpioPort_t *) addr);
     730:	00000416 	andeq	r0, r0, r6, lsl r4
}
     734:	007d0002 	rsbseq	r0, sp, r2
     738:	00000416 	andeq	r0, r0, r6, lsl r4
*
* RETURNS: Nothing
*
*******************************************************************************/
void gpioConfig(uint32_t port, uint32_t pin, uint32_t opt)
{
     73c:	00000418 	andeq	r0, r0, r8, lsl r4
     740:	087d0002 	ldmdaeq	sp!, {r1}^
     744:	00000418 	andeq	r0, r0, r8, lsl r4
    /*
     * Ensure pin number is legal
     */

    assert((pin < 32));
     748:	0000041a 	andeq	r0, r0, sl, lsl r4
     74c:	187d0002 	ldmdane	sp!, {r1}^
     750:	0000041a 	andeq	r0, r0, sl, lsl r4
     754:	0000056a 	andeq	r0, r0, sl, ror #10
     758:	18770002 	ldmdane	r7!, {r1}^
	...

    /*
     * Config the SIM Clock Gate
     */

    switch (port) {
     764:	0000056c 	andeq	r0, r0, ip, ror #10
     768:	0000056e 	andeq	r0, r0, lr, ror #10
     76c:	007d0002 	rsbseq	r0, sp, r2
     770:	0000056e 	andeq	r0, r0, lr, ror #10
     774:	00000570 	andeq	r0, r0, r0, ror r5
     778:	087d0002 	ldmdaeq	sp!, {r1}^
     77c:	00000570 	andeq	r0, r0, r0, ror r5
     780:	00000572 	andeq	r0, r0, r2, ror r5
     784:	187d0002 	ldmdane	sp!, {r1}^
     788:	00000572 	andeq	r0, r0, r2, ror r5
     78c:	00000634 	andeq	r0, r0, r4, lsr r6
     790:	18770002 	ldmdane	r7!, {r1}^
	...
     79c:	00000634 	andeq	r0, r0, r4, lsr r6
     7a0:	00000636 	andeq	r0, r0, r6, lsr r6
     7a4:	007d0002 	rsbseq	r0, sp, r2
     7a8:	00000636 	andeq	r0, r0, r6, lsr r6
    case PORTA: SIM_SCGC5 |= SIM_SCGC5_PORTA_ENABLE; break;
     7ac:	00000638 	andeq	r0, r0, r8, lsr r6
     7b0:	087d0002 	ldmdaeq	sp!, {r1}^
     7b4:	00000638 	andeq	r0, r0, r8, lsr r6
     7b8:	0000063a 	andeq	r0, r0, sl, lsr r6
     7bc:	107d0002 	rsbsne	r0, sp, r2
     7c0:	0000063a 	andeq	r0, r0, sl, lsr r6
     7c4:	000006c4 	andeq	r0, r0, r4, asr #13
    case PORTB: SIM_SCGC5 |= SIM_SCGC5_PORTB_ENABLE; break;
     7c8:	10770002 	rsbsne	r0, r7, r2
	...
     7d4:	000006c4 	andeq	r0, r0, r4, asr #13
     7d8:	000006c6 	andeq	r0, r0, r6, asr #13
     7dc:	007d0002 	rsbseq	r0, sp, r2
    case PORTC: SIM_SCGC5 |= SIM_SCGC5_PORTC_ENABLE; break;
     7e0:	000006c6 	andeq	r0, r0, r6, asr #13
     7e4:	000006c8 	andeq	r0, r0, r8, asr #13
     7e8:	047d0002 	ldrbteq	r0, [sp], #-2
     7ec:	000006c8 	andeq	r0, r0, r8, asr #13
     7f0:	000006ce 	andeq	r0, r0, lr, asr #13
     7f4:	04770002 	ldrbteq	r0, [r7], #-2
	...
    case PORTD: SIM_SCGC5 |= SIM_SCGC5_PORTD_ENABLE; break;
     800:	000006d0 	ldrdeq	r0, [r0], -r0	; <UNPREDICTABLE>
     804:	000006d2 	ldrdeq	r0, [r0], -r2
     808:	007d0002 	rsbseq	r0, sp, r2
     80c:	000006d2 	ldrdeq	r0, [r0], -r2
     810:	000006d4 	ldrdeq	r0, [r0], -r4
    case PORTE: SIM_SCGC5 |= SIM_SCGC5_PORTE_ENABLE; break;
     814:	047d0002 	ldrbteq	r0, [sp], #-2
     818:	000006d4 	ldrdeq	r0, [r0], -r4
     81c:	000006da 	ldrdeq	r0, [r0], -sl
     820:	04770002 	ldrbteq	r0, [r7], #-2
	...
     82c:	000006dc 	ldrdeq	r0, [r0], -ip
    default:
        assert(0);
     830:	000006de 	ldrdeq	r0, [r0], -lr
     834:	007d0002 	rsbseq	r0, sp, r2
     838:	000006de 	ldrdeq	r0, [r0], -lr
     83c:	000006e0 	andeq	r0, r0, r0, ror #13

    /*
     * Configure the Port Controller
     */

    uint32_t portCtrlBits = PORT_MUX_GPIO;
     840:	047d0002 	ldrbteq	r0, [sp], #-2
     844:	000006e0 	andeq	r0, r0, r0, ror #13

    if (opt & GPIO_OUTPUT) {
     848:	000006e6 	andeq	r0, r0, r6, ror #13
     84c:	04770002 	ldrbteq	r0, [r7], #-2
	...
        if (opt & GPIO_ODE) {
     858:	000006e8 	andeq	r0, r0, r8, ror #13
            portCtrlBits |= PORT_ODE;
     85c:	000006ea 	andeq	r0, r0, sl, ror #13
     860:	007d0002 	rsbseq	r0, sp, r2
        } else {
            if (opt & GPIO_DSE)
     864:	000006ea 	andeq	r0, r0, sl, ror #13
     868:	000006ec 	andeq	r0, r0, ip, ror #13
     86c:	047d0002 	ldrbteq	r0, [sp], #-2
                portCtrlBits |= PORT_DSE;
     870:	000006ec 	andeq	r0, r0, ip, ror #13
     874:	000006f2 	strdeq	r0, [r0], -r2
        }

    } else if (opt & GPIO_INPUT) {
     878:	04770002 	ldrbteq	r0, [r7], #-2
	...
        if (opt & GPIO_PFE)
     884:	000006f4 	strdeq	r0, [r0], -r4
     888:	000006f6 	strdeq	r0, [r0], -r6
     88c:	007d0002 	rsbseq	r0, sp, r2
            portCtrlBits |= PORT_PFE;
     890:	000006f6 	strdeq	r0, [r0], -r6
     894:	000006f8 	strdeq	r0, [r0], -r8

    } else {
        assert(0);
     898:	047d0002 	ldrbteq	r0, [sp], #-2
     89c:	000006f8 	strdeq	r0, [r0], -r8
     8a0:	000006fe 	strdeq	r0, [r0], -lr
     8a4:	04770002 	ldrbteq	r0, [r7], #-2
	...
        return;
    }

    if (opt & GPIO_PULLUP)
     8b0:	00000700 	andeq	r0, r0, r0, lsl #14
        portCtrlBits |= PORT_PULLUP_ENABLE;
     8b4:	00000702 	andeq	r0, r0, r2, lsl #14
     8b8:	007d0002 	rsbseq	r0, sp, r2
     8bc:	00000702 	andeq	r0, r0, r2, lsl #14
    else if (opt & GPIO_PULLDOWN)
     8c0:	00000704 	andeq	r0, r0, r4, lsl #14
     8c4:	047d0002 	ldrbteq	r0, [sp], #-2
        portCtrlBits |= PORT_PULLDOWN_ENABLE;
     8c8:	00000704 	andeq	r0, r0, r4, lsl #14
     8cc:	0000070a 	andeq	r0, r0, sl, lsl #14

    PORT_PCR(port, pin) = portCtrlBits;
     8d0:	04770002 	ldrbteq	r0, [r7], #-2
	...
     8dc:	0000070c 	andeq	r0, r0, ip, lsl #14

    /*
     * Configure the GPIO Controller
     */

    volatile gpioPort_t *gpioPort = gpioPortGet(port);
     8e0:	0000070e 	andeq	r0, r0, lr, lsl #14
     8e4:	007d0002 	rsbseq	r0, sp, r2
    uint32_t pinBit = 1 << pin;
     8e8:	0000070e 	andeq	r0, r0, lr, lsl #14
     8ec:	00000710 	andeq	r0, r0, r0, lsl r7
     8f0:	047d0002 	ldrbteq	r0, [sp], #-2

    if (opt & GPIO_OUTPUT) {
     8f4:	00000710 	andeq	r0, r0, r0, lsl r7
     8f8:	00000716 	andeq	r0, r0, r6, lsl r7
        gpioPort->pddr |= pinBit;
     8fc:	04770002 	ldrbteq	r0, [r7], #-2
	...
        if (opt & GPIO_HIGH)
     908:	00000718 	andeq	r0, r0, r8, lsl r7
     90c:	0000071a 	andeq	r0, r0, sl, lsl r7
     910:	007d0002 	rsbseq	r0, sp, r2
            gpioPort->psor |= pinBit;
     914:	0000071a 	andeq	r0, r0, sl, lsl r7
     918:	0000071c 	andeq	r0, r0, ip, lsl r7
     91c:	047d0002 	ldrbteq	r0, [sp], #-2
        else if (opt & GPIO_LOW)
     920:	0000071c 	andeq	r0, r0, ip, lsl r7
     924:	00000722 	andeq	r0, r0, r2, lsr #14
     928:	04770002 	ldrbteq	r0, [r7], #-2
	...
            gpioPort->pcor |= pinBit;
     934:	00000724 	andeq	r0, r0, r4, lsr #14
    }
}
     938:	00000726 	andeq	r0, r0, r6, lsr #14
     93c:	007d0002 	rsbseq	r0, sp, r2

/*******************************************************************************
* gpioSet
*******************************************************************************/
void gpioSet(uint32_t port, uint32_t pin)
{
     940:	00000726 	andeq	r0, r0, r6, lsr #14
     944:	00000728 	andeq	r0, r0, r8, lsr #14
     948:	047d0002 	ldrbteq	r0, [sp], #-2
    volatile gpioPort_t *gpioPort = gpioPortGet(port);
     94c:	00000728 	andeq	r0, r0, r8, lsr #14
     950:	0000072e 	andeq	r0, r0, lr, lsr #14
    gpioPort->psor = 1 << pin;
     954:	04770002 	ldrbteq	r0, [r7], #-2
	...
}
     964:	00000002 	andeq	r0, r0, r2
     968:	007d0002 	rsbseq	r0, sp, r2

/*******************************************************************************
* gpioClear
*******************************************************************************/
void gpioClear(uint32_t port, uint32_t pin)
{
     96c:	00000002 	andeq	r0, r0, r2
     970:	00000004 	andeq	r0, r0, r4
     974:	047d0002 	ldrbteq	r0, [sp], #-2
    volatile gpioPort_t *gpioPort = gpioPortGet(port);
     978:	00000004 	andeq	r0, r0, r4
     97c:	0000002a 	andeq	r0, r0, sl, lsr #32
    gpioPort->pcor = 1 << pin;
     980:	04770002 	ldrbteq	r0, [r7], #-2
	...
     98c:	0000002c 	andeq	r0, r0, ip, lsr #32
}
     990:	0000002e 	andeq	r0, r0, lr, lsr #32
     994:	007d0002 	rsbseq	r0, sp, r2

/*******************************************************************************
* gpioToggle
*******************************************************************************/
void gpioToggle(uint32_t port, uint32_t pin)
{
     998:	0000002e 	andeq	r0, r0, lr, lsr #32
     99c:	00000030 	andeq	r0, r0, r0, lsr r0
     9a0:	087d0002 	ldmdaeq	sp!, {r1}^
    volatile gpioPort_t *gpioPort = gpioPortGet(port);
     9a4:	00000030 	andeq	r0, r0, r0, lsr r0
     9a8:	00000032 	andeq	r0, r0, r2, lsr r0
    gpioPort->ptor = 1 << pin;
     9ac:	107d0002 	rsbsne	r0, sp, r2
     9b0:	00000032 	andeq	r0, r0, r2, lsr r0
     9b4:	000000cc 	andeq	r0, r0, ip, asr #1
     9b8:	10770002 	rsbsne	r0, r7, r2
	...
*
* RETURNS:
*
*******************************************************************************/
void gpioPortWrite(uint32_t port, uint32_t mask, uint32_t value)
{
     9c4:	000000cc 	andeq	r0, r0, ip, asr #1
     9c8:	000000ce 	andeq	r0, r0, lr, asr #1
     9cc:	007d0002 	rsbseq	r0, sp, r2
}
     9d0:	000000ce 	andeq	r0, r0, lr, asr #1
     9d4:	000000d0 	ldrdeq	r0, [r0], -r0	; <UNPREDICTABLE>
     9d8:	047d0002 	ldrbteq	r0, [sp], #-2
*
* RETURNS:
*
*******************************************************************************/
uint32_t gpioPortRead(uint32_t port)
{
     9dc:	000000d0 	ldrdeq	r0, [r0], -r0	; <UNPREDICTABLE>
     9e0:	000000d8 	ldrdeq	r0, [r0], -r8
    return 0;
     9e4:	04770002 	ldrbteq	r0, [r7], #-2
	...
}
     9f0:	000000d8 	ldrdeq	r0, [r0], -r8
*
* RETURNS:
*
*******************************************************************************/
uint32_t gpioRead(uint32_t port, uint32_t pin)
{
     9f4:	000000da 	ldrdeq	r0, [r0], -sl
     9f8:	007d0002 	rsbseq	r0, sp, r2
     9fc:	000000da 	ldrdeq	r0, [r0], -sl
    volatile gpioPort_t *gpioPort = gpioPortGet(port);
     a00:	000000dc 	ldrdeq	r0, [r0], -ip
     a04:	047d0002 	ldrbteq	r0, [sp], #-2
    return ((gpioPort->pdir & (1 << pin)) ? TRUE : FALSE);
     a08:	000000dc 	ldrdeq	r0, [r0], -ip
     a0c:	000000e4 	andeq	r0, r0, r4, ror #1
     a10:	04770002 	ldrbteq	r0, [r7], #-2
	...
     a1c:	000000e4 	andeq	r0, r0, r4, ror #1
}
     a20:	000000e6 	andeq	r0, r0, r6, ror #1
     a24:	007d0002 	rsbseq	r0, sp, r2
    .flashDiv     = FLASH_DIVIDER_DFLT,
};


static void fei2fee(clockConfig_t cc)
{
     a28:	000000e6 	andeq	r0, r0, r6, ror #1
     a2c:	000000e8 	andeq	r0, r0, r8, ror #1
     a30:	087d0002 	ldmdaeq	sp!, {r1}^
     * Uno problemo: The largest divide factor available by FRDIV is 1024... And
     * 50MHz / 1024 = 48.3 kHz, which exceeds the 39.0625 kHz range. With our
     * setup, it doesn't seem that we can reach a FEE mode (and I don't want to
     * risk the tower to see what could happen if I did!)
     */
}
     a34:	000000e8 	andeq	r0, r0, r8, ror #1
     a38:	00000112 	andeq	r0, r0, r2, lsl r1

static void fei2pee(clockConfig_t cc)
{
     a3c:	08770002 	ldmdaeq	r7!, {r1}^
	...
                                                    /* External crystal setup */
    /* Select the OSCCLK */
    SIM_SOPT2 &= ~SIM_SOPT2_MCGCLKSEL;
     a48:	00000114 	andeq	r0, r0, r4, lsl r1
     a4c:	00000116 	andeq	r0, r0, r6, lsl r1
     a50:	007d0002 	rsbseq	r0, sp, r2
     a54:	00000116 	andeq	r0, r0, r6, lsl r1
     a58:	00000118 	andeq	r0, r0, r8, lsl r1
     a5c:	087d0002 	ldmdaeq	sp!, {r1}^
     * Enabling the XTAL for 50MHz
     * RANGE=1, match the frequency of the crystal being used
     * HGO=1,   set for high gain operation (best against noise)
     * EREFS=1, enable the external oscillator
     */
    clock.mcg->c2 = (MCG_C2_RANGE_MASK & (0x1 << 4)) |
     a60:	00000118 	andeq	r0, r0, r8, lsl r1
     a64:	0000012e 	andeq	r0, r0, lr, lsr #2
     a68:	08770002 	ldmdaeq	r7!, {r1}^
	...
     * mode from FBE (here we are going to PEE)
     *
     * IREFS=0, select external reference clock and enable the external
     * oscillator.
     */
    clock.mcg->c1 = ((MCG_C1_CLKS_MASK & (0x2 << 6)) |
     a74:	00001290 	muleq	r0, r0, r2
     a78:	00001292 	muleq	r0, r2, r2
     a7c:	007d0002 	rsbseq	r0, sp, r2
                    (MCG_C1_FRDIV_MASK & (0x3 << 3))) &
                    (~MCG_C1_IREFS);

                                                    /* Wait for status update */
    /* Wait for oscillator to initialize */
    while (!(clock.mcg->s & MCG_S_OSCINIT)) {}
     a80:	00001292 	muleq	r0, r2, r2
     a84:	000012aa 	andeq	r1, r0, sl, lsr #5
     a88:	087d0002 	ldmdaeq	sp!, {r1}^
	...
     a94:	000012b0 			; <UNDEFINED> instruction: 0x000012b0
    /* Wait for reference clock's to become the external reference */
    while (clock.mcg->s & MCG_S_IREFST) {}
     a98:	000012b2 			; <UNDEFINED> instruction: 0x000012b2
     a9c:	007d0002 	rsbseq	r0, sp, r2
     aa0:	000012b2 			; <UNDEFINED> instruction: 0x000012b2
     aa4:	000012b4 			; <UNDEFINED> instruction: 0x000012b4
     aa8:	047d0002 	ldrbteq	r0, [sp], #-2
     aac:	000012b4 			; <UNDEFINED> instruction: 0x000012b4
    /* Wait for the indicator that MCGOTUCLK is fed by the external ref clock */
    while ((clock.mcg->s & MCG_S_CLKST_MASK) != (0x2 << 2)) {}
     ab0:	00001338 	andeq	r1, r0, r8, lsr r3
     ab4:	107d0002 	rsbsne	r0, sp, r2
	...
     ac0:	00001340 	andeq	r1, r0, r0, asr #6
     ac4:	00001342 	andeq	r1, r0, r2, asr #6

                                            /* Generate correct PLL frequency */
    clock.mcg->c5 &= 0xE0; /* clear bits */
     ac8:	007d0002 	rsbseq	r0, sp, r2
     acc:	00001342 	andeq	r1, r0, r2, asr #6
     ad0:	00001344 	andeq	r1, r0, r4, asr #6
     ad4:	047d0002 	ldrbteq	r0, [sp], #-2
     ad8:	00001344 	andeq	r1, r0, r4, asr #6
     adc:	00001418 	andeq	r1, r0, r8, lsl r4
     ae0:	107d0002 	rsbsne	r0, sp, r2
	...
    clock.mcg->c5 |= clockConfigParam[cc].divider;
     aec:	00001470 	andeq	r1, r0, r0, ror r4
     af0:	00001472 	andeq	r1, r0, r2, ror r4
     af4:	007d0002 	rsbseq	r0, sp, r2
     af8:	00001472 	andeq	r1, r0, r2, ror r4
     afc:	00001502 	andeq	r1, r0, r2, lsl #10
     b00:	187d0002 	ldmdane	sp!, {r1}^
	...
     b0c:	00001510 	andeq	r1, r0, r0, lsl r5
     b10:	00001512 	andeq	r1, r0, r2, lsl r5
     b14:	007d0002 	rsbseq	r0, sp, r2
    clock.mcg->c6 &= 0xE0;
     b18:	00001512 	andeq	r1, r0, r2, lsl r5
     b1c:	00001556 	andeq	r1, r0, r6, asr r5
     b20:	087d0002 	ldmdaeq	sp!, {r1}^
	...
     b2c:	00001560 	andeq	r1, r0, r0, ror #10
     b30:	00001562 	andeq	r1, r0, r2, ror #10
     b34:	007d0002 	rsbseq	r0, sp, r2
    clock.mcg->c6 |= clockConfigParam[cc].multiplier;
     b38:	00001562 	andeq	r1, r0, r2, ror #10
     b3c:	000015b6 			; <UNDEFINED> instruction: 0x000015b6
     b40:	107d0002 	rsbsne	r0, sp, r2
	...
     b4c:	000015c0 	andeq	r1, r0, r0, asr #11
     b50:	000015c2 	andeq	r1, r0, r2, asr #11
     b54:	007d0002 	rsbseq	r0, sp, r2
     b58:	000015c2 	andeq	r1, r0, r2, asr #11
     b5c:	000015e2 	andeq	r1, r0, r2, ror #11
     b60:	107d0002 	rsbsne	r0, sp, r2
	...
                                                            /* Enter PBE mode */
    /* PLLS=1, select the PLL. */
    clock.mcg->c6 |= MCG_C6_PLLS;
     b6c:	000015f0 	strdeq	r1, [r0], -r0
     b70:	000015f2 	strdeq	r1, [r0], -r2
     b74:	007d0002 	rsbseq	r0, sp, r2
     b78:	000015f2 	strdeq	r1, [r0], -r2
     b7c:	00001610 	andeq	r1, r0, r0, lsl r6
     b80:	087d0002 	ldmdaeq	sp!, {r1}^
	...

                                                    /* Wait for status update */
    /* Wait for the PLL to be the clock source */
    while (!(clock.mcg->s & MCG_S_PLLST)) {}
     b8c:	00001670 	andeq	r1, r0, r0, ror r6
     b90:	00001672 	andeq	r1, r0, r2, ror r6
     b94:	007d0002 	rsbseq	r0, sp, r2
     b98:	00001672 	andeq	r1, r0, r2, ror r6
     b9c:	000016ce 	andeq	r1, r0, lr, asr #13
    /* Wait until the PLL has acquired lock on the external frequency */
    while (!(clock.mcg->s & MCG_S_LOCK)) {}
     ba0:	107d0002 	rsbsne	r0, sp, r2
	...
     bac:	000016d0 	ldrdeq	r1, [r0], -r0
     bb0:	000016d2 	ldrdeq	r1, [r0], -r2
     bb4:	007d0002 	rsbseq	r0, sp, r2

                                                            /* Enter PEE mode */
    /* Select the output of the PLL */
    clock.mcg->c1 &= ~MCG_C1_CLKS_MASK;
     bb8:	000016d2 	ldrdeq	r1, [r0], -r2
     bbc:	000016d4 	ldrdeq	r1, [r0], -r4
     bc0:	047d0002 	ldrbteq	r0, [sp], #-2
     bc4:	000016d4 	ldrdeq	r1, [r0], -r4
     bc8:	00001734 	andeq	r1, r0, r4, lsr r7
     bcc:	187d0002 	ldmdane	sp!, {r1}^
	...

                                                    /* Wait for status update */
    /* Wait until output of the PLL is selected */
    while ((clock.mcg->s & MCG_S_CLKST_MASK) != (0x3 << 2)) {}
     bd8:	00001740 	andeq	r1, r0, r0, asr #14
     bdc:	00001742 	andeq	r1, r0, r2, asr #14
     be0:	007d0002 	rsbseq	r0, sp, r2
     be4:	00001742 	andeq	r1, r0, r2, asr #14
     be8:	00001744 	andeq	r1, r0, r4, asr #14
     bec:	047d0002 	ldrbteq	r0, [sp], #-2

    mcgState.currentMode = MODE_PEE;
     bf0:	00001744 	andeq	r1, r0, r4, asr #14
     bf4:	000017ce 	andeq	r1, r0, lr, asr #15
     bf8:	187d0002 	ldmdane	sp!, {r1}^
	...
}
     c04:	000017d0 	ldrdeq	r1, [r0], -r0

static void fei2blpi(clockConfig_t cc)
{
     c08:	000017d2 	ldrdeq	r1, [r0], -r2
     c0c:	007d0002 	rsbseq	r0, sp, r2
     c10:	000017d2 	ldrdeq	r1, [r0], -r2
                                                            /* Not configured */
}
     c14:	000017d4 	ldrdeq	r1, [r0], -r4
     c18:	047d0002 	ldrbteq	r0, [sp], #-2

static void fei2blpe(clockConfig_t cc)
{
     c1c:	000017d4 	ldrdeq	r1, [r0], -r4
     c20:	00001836 	andeq	r1, r0, r6, lsr r8
     c24:	287d0002 	ldmdacs	sp!, {r1}^
	...
                                                            /* Not configured */
}


static void fee2fei(clockConfig_t cc)
{
     c30:	00001840 	andeq	r1, r0, r0, asr #16
     c34:	00001842 	andeq	r1, r0, r2, asr #16
     c38:	007d0002 	rsbseq	r0, sp, r2
                                                            /* Not configured */
}
     c3c:	00001842 	andeq	r1, r0, r2, asr #16
     c40:	00001844 	andeq	r1, r0, r4, asr #16

static void fee2pee(clockConfig_t cc)
{
     c44:	047d0002 	ldrbteq	r0, [sp], #-2
     c48:	00001844 	andeq	r1, r0, r4, asr #16
     c4c:	0000189c 	muleq	r0, ip, r8
                                                            /* Not configured */
}
     c50:	187d0002 	ldmdane	sp!, {r1}^
	...

static void fee2blpi(clockConfig_t cc)
{
     c5c:	000018a0 	andeq	r1, r0, r0, lsr #17
     c60:	000018a2 	andeq	r1, r0, r2, lsr #17
                                                            /* Not configured */
}
     c64:	007d0002 	rsbseq	r0, sp, r2
     c68:	000018a2 	andeq	r1, r0, r2, lsr #17

static void fee2blpe(clockConfig_t cc)
{
     c6c:	000018c4 	andeq	r1, r0, r4, asr #17
     c70:	087d0002 	ldmdaeq	sp!, {r1}^
	...
                                                            /* Not configured */
}
     c7c:	000018d0 	ldrdeq	r1, [r0], -r0


static void pee2fei(clockConfig_t cc)
{
     c80:	000018d2 	ldrdeq	r1, [r0], -r2
     c84:	007d0002 	rsbseq	r0, sp, r2
     c88:	000018d2 	ldrdeq	r1, [r0], -r2

                                                            /* Enter PBE mode */
    clock.mcg->c1 = (MCG_C1_CLKS_MASK & (0x2 << 6)); /* Select external clock */
     c8c:	000018d4 	ldrdeq	r1, [r0], -r4
     c90:	047d0002 	ldrbteq	r0, [sp], #-2
     c94:	000018d4 	ldrdeq	r1, [r0], -r4
     c98:	0000192c 	andeq	r1, r0, ip, lsr #18

                                                    /* Wait for status update */
    while ((clock.mcg->s & MCG_S_CLKST_MASK) != (0x2 << 2)) {}
     c9c:	107d0002 	rsbsne	r0, sp, r2
	...
     ca8:	00001930 	andeq	r1, r0, r0, lsr r9
     cac:	00001932 	andeq	r1, r0, r2, lsr r9
     cb0:	007d0002 	rsbseq	r0, sp, r2

                                                            /* Enter FBE mode */
    /*
     * With the FLL frequency valid, we can now clear the PLLS bit to select FLL
     */
    clock.mcg->c6 &= ~MCG_C6_PLLS;
     cb4:	00001932 	andeq	r1, r0, r2, lsr r9
     cb8:	00001934 	andeq	r1, r0, r4, lsr r9
     cbc:	047d0002 	ldrbteq	r0, [sp], #-2
     cc0:	00001934 	andeq	r1, r0, r4, lsr r9
     cc4:	000019c0 	andeq	r1, r0, r0, asr #19
     cc8:	107d0002 	rsbsne	r0, sp, r2
	...

                                                    /* Wait for status update */
    /* Wait until the current source is FLL */
    while (clock.mcg->s & MCG_S_PLLST) {}
     cd4:	000019c0 	andeq	r1, r0, r0, asr #19
     cd8:	000019c2 	andeq	r1, r0, r2, asr #19
     cdc:	007d0002 	rsbseq	r0, sp, r2
     ce0:	000019c2 	andeq	r1, r0, r2, asr #19
     ce4:	000019de 	ldrdeq	r1, [r0], -lr
     ce8:	087d0002 	ldmdaeq	sp!, {r1}^
	...

                                            /* Generate correct FLL frequency */
    clock.mcg->c4 = clockConfigParam[cc].multiplier;
     cf4:	000019e0 	andeq	r1, r0, r0, ror #19
     cf8:	000019e2 	andeq	r1, r0, r2, ror #19
     cfc:	007d0002 	rsbseq	r0, sp, r2
     d00:	000019e2 	andeq	r1, r0, r2, ror #19
     d04:	000019f8 	strdeq	r1, [r0], -r8

                                                            /* Enter FEI mode */
    clock.mcg->c1 = (MCG_C1_CLKS_MASK & (0x0 << 6)) |
     d08:	087d0002 	ldmdaeq	sp!, {r1}^
	...
     d14:	00001a00 	andeq	r1, r0, r0, lsl #20
                    (MCG_C1_IREFS);

                                                    /* Wait for status update */
    /* Wait for reference clock's to become the internal reference */
    while (!(clock.mcg->s & MCG_S_IREFST)) {}
     d18:	00001a02 	andeq	r1, r0, r2, lsl #20
     d1c:	007d0002 	rsbseq	r0, sp, r2
     d20:	00001a02 	andeq	r1, r0, r2, lsl #20
     d24:	00001a1a 	andeq	r1, r0, sl, lsl sl
     d28:	107d0002 	rsbsne	r0, sp, r2
	...
    /* Wait until the output of the FLL is selected */
    while ((clock.mcg->s & MCG_S_CLKST_MASK) != (0x0 << 2)) {}
     d34:	00001a20 	andeq	r1, r0, r0, lsr #20
     d38:	00001a22 	andeq	r1, r0, r2, lsr #20
     d3c:	007d0002 	rsbseq	r0, sp, r2
     d40:	00001a22 	andeq	r1, r0, r2, lsr #20
     d44:	00001acc 	andeq	r1, r0, ip, asr #21

    mcgState.currentMode = MODE_FEI;
     d48:	087d0002 	ldmdaeq	sp!, {r1}^
	...
     d54:	00001ad0 	ldrdeq	r1, [r0], -r0
}
     d58:	00001ad2 	ldrdeq	r1, [r0], -r2
     d5c:	007d0002 	rsbseq	r0, sp, r2

static void pee2fee(clockConfig_t cc)
{
     d60:	00001ad2 	ldrdeq	r1, [r0], -r2
     d64:	00001ad4 	ldrdeq	r1, [r0], -r4
     d68:	047d0002 	ldrbteq	r0, [sp], #-2
                                                            /* Not configured */
}
     d6c:	00001ad4 	ldrdeq	r1, [r0], -r4
     d70:	00001b32 	andeq	r1, r0, r2, lsr fp

static void pee2blpi(clockConfig_t cc)
{
     d74:	207d0002 	rsbscs	r0, sp, r2
	...
                                                            /* Not configured */
}
     d80:	00001b40 	andeq	r1, r0, r0, asr #22
     d84:	00001b42 	andeq	r1, r0, r2, asr #22

static void pee2blpe(clockConfig_t cc)
{
     d88:	007d0002 	rsbseq	r0, sp, r2
     d8c:	00001b42 	andeq	r1, r0, r2, asr #22
     d90:	00001b44 	andeq	r1, r0, r4, asr #22
                                                            /* Not configured */
}
     d94:	047d0002 	ldrbteq	r0, [sp], #-2
     d98:	00001b44 	andeq	r1, r0, r4, asr #22


static void blpi2fei(clockConfig_t cc)
{
     d9c:	00001b80 	andeq	r1, r0, r0, lsl #23
     da0:	287d0002 	ldmdacs	sp!, {r1}^
	...
                                                            /* Not configured */
}
     dac:	00001b80 	andeq	r1, r0, r0, lsl #23

static void blpi2fee(clockConfig_t cc)
{
     db0:	00001b82 	andeq	r1, r0, r2, lsl #23
     db4:	007d0002 	rsbseq	r0, sp, r2
     db8:	00001b82 	andeq	r1, r0, r2, lsl #23
                                                            /* Not configured */
}
     dbc:	00001b84 	andeq	r1, r0, r4, lsl #23
     dc0:	047d0002 	ldrbteq	r0, [sp], #-2

static void blpi2pee(clockConfig_t cc)
{
     dc4:	00001b84 	andeq	r1, r0, r4, lsl #23
     dc8:	00001bfa 	strdeq	r1, [r0], -sl
     dcc:	187d0002 	ldmdane	sp!, {r1}^
	...
                                                            /* Not configured */
}

static void blpi2blpe(clockConfig_t cc)
{
     dd8:	00001c00 	andeq	r1, r0, r0, lsl #24
     ddc:	00001c02 	andeq	r1, r0, r2, lsl #24
     de0:	007d0002 	rsbseq	r0, sp, r2
                                                            /* Not configured */
}
     de4:	00001c02 	andeq	r1, r0, r2, lsl #24
     de8:	00001c04 	andeq	r1, r0, r4, lsl #24


static void blpe2fei(clockConfig_t cc)
{
     dec:	047d0002 	ldrbteq	r0, [sp], #-2
     df0:	00001c04 	andeq	r1, r0, r4, lsl #24
     df4:	00001c28 	andeq	r1, r0, r8, lsr #24
                                                            /* Not configured */
}
     df8:	107d0002 	rsbsne	r0, sp, r2
	...

static void blpe2fee(clockConfig_t cc)
{
     e04:	00001c30 	andeq	r1, r0, r0, lsr ip
     e08:	00001c32 	andeq	r1, r0, r2, lsr ip
                                                            /* Not configured */
}
     e0c:	007d0002 	rsbseq	r0, sp, r2
     e10:	00001c32 	andeq	r1, r0, r2, lsr ip

static void blpe2pee(clockConfig_t cc)
{
     e14:	00001c56 	andeq	r1, r0, r6, asr ip
     e18:	087d0002 	ldmdaeq	sp!, {r1}^
	...
                                                            /* Not configured */
}
     e24:	00001c60 	andeq	r1, r0, r0, ror #24

static void blpe2blpi(clockConfig_t cc)
{
     e28:	00001c62 	andeq	r1, r0, r2, ror #24
     e2c:	007d0002 	rsbseq	r0, sp, r2
     e30:	00001c62 	andeq	r1, r0, r2, ror #24
                                                            /* Not configured */
}
     e34:	00001c64 	andeq	r1, r0, r4, ror #24
     e38:	047d0002 	ldrbteq	r0, [sp], #-2
* system, bus, flexbus, and flash clock frequencies.
*
*******************************************************************************/
void clockSetDividers(divider_t systemDiv, divider_t busDiv,
                                       divider_t flexBusDiv, divider_t flashDiv)
{
     e3c:	00001c64 	andeq	r1, r0, r4, ror #24
     e40:	00001c84 	andeq	r1, r0, r4, lsl #25
     e44:	107d0002 	rsbsne	r0, sp, r2
	...
    int mcgClock = clockFreq.mcgClockFreq;
     e50:	00001c90 	muleq	r0, r0, ip
     e54:	00001c92 	muleq	r0, r2, ip

    /*
     * The asserts are raised when the internal clock requirements (sec. 5.5)
     * are not met.
     */
    assert( (mcgClock / (systemDiv +1)) <= MAX_SYSTEM_FREQ);
     e58:	007d0002 	rsbseq	r0, sp, r2
     e5c:	00001c92 	muleq	r0, r2, ip
     e60:	00001c94 	muleq	r0, r4, ip
     e64:	047d0002 	ldrbteq	r0, [sp], #-2
     e68:	00001c94 	muleq	r0, r4, ip
     e6c:	00001cca 	andeq	r1, r0, sl, asr #25
     e70:	107d0002 	rsbsne	r0, sp, r2
	...
     e7c:	00001cd0 	ldrdeq	r1, [r0], -r0

    assert( (mcgClock / (busDiv    +1)) <= MAX_BUS_FREQ &&
     e80:	00001cd2 	ldrdeq	r1, [r0], -r2
     e84:	007d0002 	rsbseq	r0, sp, r2
     e88:	00001cd2 	ldrdeq	r1, [r0], -r2
     e8c:	00001d04 	andeq	r1, r0, r4, lsl #26
     e90:	087d0002 	ldmdaeq	sp!, {r1}^
	...
     e9c:	00001d10 	andeq	r1, r0, r0, lsl sp
     ea0:	00001d12 	andeq	r1, r0, r2, lsl sp
     ea4:	007d0002 	rsbseq	r0, sp, r2
     ea8:	00001d12 	andeq	r1, r0, r2, lsl sp
     eac:	00001d14 	andeq	r1, r0, r4, lsl sp
     eb0:	047d0002 	ldrbteq	r0, [sp], #-2
     eb4:	00001d14 	andeq	r1, r0, r4, lsl sp
     eb8:	00001d28 	andeq	r1, r0, r8, lsr #26
     ebc:	107d0002 	rsbsne	r0, sp, r2
	...
            (mcgClock / (busDiv    +1)) <= (mcgClock / (systemDiv+1)));

    assert( (mcgClock / (flashDiv  +1)) <= MAX_FLASH_FREQ &&
     ec8:	00001d30 	andeq	r1, r0, r0, lsr sp
     ecc:	00001d32 	andeq	r1, r0, r2, lsr sp
     ed0:	007d0002 	rsbseq	r0, sp, r2
     ed4:	00001d32 	andeq	r1, r0, r2, lsr sp
     ed8:	00001d34 	andeq	r1, r0, r4, lsr sp
     edc:	047d0002 	ldrbteq	r0, [sp], #-2
     ee0:	00001d34 	andeq	r1, r0, r4, lsr sp
     ee4:	00001d98 	muleq	r0, r8, sp
     ee8:	187d0002 	ldmdane	sp!, {r1}^
	...
     ef4:	00001da0 	andeq	r1, r0, r0, lsr #27
     ef8:	00001da2 	andeq	r1, r0, r2, lsr #27
     efc:	007d0002 	rsbseq	r0, sp, r2
     f00:	00001da2 	andeq	r1, r0, r2, lsr #27
     f04:	00001da4 	andeq	r1, r0, r4, lsr #27
            (mcgClock / (flashDiv  +1)) <= (mcgClock / (busDiv+1)));

    assert( (mcgClock / (flexBusDiv+1)) <= (mcgClock / (busDiv+1)));
     f08:	047d0002 	ldrbteq	r0, [sp], #-2
     f0c:	00001da4 	andeq	r1, r0, r4, lsr #27
     f10:	00001df2 	strdeq	r1, [r0], -r2
     f14:	187d0002 	ldmdane	sp!, {r1}^
	...
     f20:	00001e00 	andeq	r1, r0, r0, lsl #28
     f24:	00001e02 	andeq	r1, r0, r2, lsl #28
     f28:	007d0002 	rsbseq	r0, sp, r2
     f2c:	00001e02 	andeq	r1, r0, r2, lsl #28
     f30:	00001e2a 	andeq	r1, r0, sl, lsr #28

    /* Save the new dividers */
    clockFreq.systemDiv  = systemDiv;
     f34:	087d0002 	ldmdaeq	sp!, {r1}^
	...
    clockFreq.busDiv     = busDiv;
     f40:	00001e30 	andeq	r1, r0, r0, lsr lr
     f44:	00001e32 	andeq	r1, r0, r2, lsr lr
     f48:	007d0002 	rsbseq	r0, sp, r2
    clockFreq.flexBusDiv = flexBusDiv;
     f4c:	00001e32 	andeq	r1, r0, r2, lsr lr
     f50:	00001e34 	andeq	r1, r0, r4, lsr lr
     f54:	047d0002 	ldrbteq	r0, [sp], #-2
    clockFreq.flashDiv   = flashDiv;
     f58:	00001e34 	andeq	r1, r0, r4, lsr lr
     f5c:	00001ec0 	andeq	r1, r0, r0, asr #29
     f60:	187d0002 	ldmdane	sp!, {r1}^
	...

    /* Set the SIM clock dividers */
    SIM_CLKDIV1 = (systemDiv << 28)  |
     f6c:	00001ec0 	andeq	r1, r0, r0, asr #29
                  (busDiv << 24)     |
     f70:	00001ec2 	andeq	r1, r0, r2, asr #29
     f74:	007d0002 	rsbseq	r0, sp, r2
                  (flexBusDiv << 20) |
     f78:	00001ec2 	andeq	r1, r0, r2, asr #29
     f7c:	00001ec4 	andeq	r1, r0, r4, asr #29
                  (flashDiv << 16);
     f80:	047d0002 	ldrbteq	r0, [sp], #-2
     f84:	00001ec4 	andeq	r1, r0, r4, asr #29
    clockFreq.busDiv     = busDiv;
    clockFreq.flexBusDiv = flexBusDiv;
    clockFreq.flashDiv   = flashDiv;

    /* Set the SIM clock dividers */
    SIM_CLKDIV1 = (systemDiv << 28)  |
     f88:	00001f1e 	andeq	r1, r0, lr, lsl pc
                  (busDiv << 24)     |
                  (flexBusDiv << 20) |
                  (flashDiv << 16);
}
     f8c:	287d0002 	ldmdacs	sp!, {r1}^
	...
*
* Grab the clock frequency for a particular clock source in Hz.
*
*******************************************************************************/
uint32_t clockGetFreq(clockSource_t cs)
{
     f98:	00001f20 	andeq	r1, r0, r0, lsr #30
     f9c:	00001f22 	andeq	r1, r0, r2, lsr #30
    uint32_t clock;

    switch (cs) {
     fa0:	007d0002 	rsbseq	r0, sp, r2
     fa4:	00001f22 	andeq	r1, r0, r2, lsr #30
     fa8:	00001f24 	andeq	r1, r0, r4, lsr #30
     fac:	047d0002 	ldrbteq	r0, [sp], #-2
     fb0:	00001f24 	andeq	r1, r0, r4, lsr #30
     fb4:	00001f86 	andeq	r1, r0, r6, lsl #31
     fb8:	287d0002 	ldmdacs	sp!, {r1}^
	...
    case CLOCK_SYSTEM:
        clock = clockFreq.mcgClockFreq / (clockFreq.systemDiv + 1);
     fc4:	00001fd0 	ldrdeq	r1, [r0], -r0
     fc8:	00001fd2 	ldrdeq	r1, [r0], -r2
     fcc:	007d0002 	rsbseq	r0, sp, r2
     fd0:	00001fd2 	ldrdeq	r1, [r0], -r2
     fd4:	00001fd4 	ldrdeq	r1, [r0], -r4
     fd8:	047d0002 	ldrbteq	r0, [sp], #-2
     fdc:	00001fd4 	ldrdeq	r1, [r0], -r4
        break;
    case CLOCK_BUS:
        clock = clockFreq.mcgClockFreq / (clockFreq.busDiv + 1);
     fe0:	00001ff6 	strdeq	r1, [r0], -r6
     fe4:	187d0002 	ldmdane	sp!, {r1}^
	...
     ff0:	00002000 	andeq	r2, r0, r0
     ff4:	00002002 	andeq	r2, r0, r2
     ff8:	007d0002 	rsbseq	r0, sp, r2
     ffc:	00002002 	andeq	r2, r0, r2
        break;
    case CLOCK_FLEXBUS:
        clock = clockFreq.mcgClockFreq / (clockFreq.flexBusDiv + 1);
    1000:	00002062 	andeq	r2, r0, r2, rrx
    1004:	107d0002 	rsbsne	r0, sp, r2
	...
    1010:	00002090 	muleq	r0, r0, r0
    1014:	00002092 	muleq	r0, r2, r0
    1018:	007d0002 	rsbseq	r0, sp, r2
    101c:	00002092 	muleq	r0, r2, r0
        break;
    case CLOCK_FLASH:
        clock = clockFreq.mcgClockFreq / (clockFreq.flashDiv + 1);
    1020:	000020cc 	andeq	r2, r0, ip, asr #1
    1024:	087d0002 	ldmdaeq	sp!, {r1}^
	...
    1030:	000020d0 	ldrdeq	r2, [r0], -r0
    1034:	000020d2 	ldrdeq	r2, [r0], -r2	; <UNPREDICTABLE>
    1038:	007d0002 	rsbseq	r0, sp, r2
    103c:	000020d2 	ldrdeq	r2, [r0], -r2	; <UNPREDICTABLE>
        break;
    default:
        assert(0);
    1040:	000020d4 	ldrdeq	r2, [r0], -r4
    1044:	047d0002 	ldrbteq	r0, [sp], #-2
    1048:	000020d4 	ldrdeq	r2, [r0], -r4
    104c:	00002128 	andeq	r2, r0, r8, lsr #2
    }

    return clock;
    1050:	207d0002 	rsbscs	r0, sp, r2
	...
*        ____ STOP ____ (Entered when MCU enters stop mode, and returns to
*                        previous active mode when exits stop mode )
*
*******************************************************************************/
void clockConfigMcgOut(clockConfig_t clockConfig)
{
    105c:	00002130 	andeq	r2, r0, r0, lsr r1
    1060:	00002132 	andeq	r2, r0, r2, lsr r1
    1064:	007d0002 	rsbseq	r0, sp, r2
        {  pee2fei,  pee2fee,     NULL,  pee2blpi,  pee2blpe, },
        { blpi2fei, blpi2fee, blpi2pee,      NULL, blpi2blpe, },
        { blpe2fei, blpe2fee, blpe2pee, blpe2blpi,      NULL, },
    };

    assert(clockConfig < MAX_MCG_CLOCK_OPTIONS);
    1068:	00002132 	andeq	r2, r0, r2, lsr r1
    106c:	00002134 	andeq	r2, r0, r4, lsr r1
    1070:	047d0002 	ldrbteq	r0, [sp], #-2
    1074:	00002134 	andeq	r2, r0, r4, lsr r1
    1078:	00002224 	andeq	r2, r0, r4, lsr #4

    mcgState.nextMode = clockConfigParam[clockConfig].clockMode;
    107c:	207d0002 	rsbscs	r0, sp, r2
	...
    1088:	00002230 	andeq	r2, r0, r0, lsr r2
    108c:	00002232 	andeq	r2, r0, r2, lsr r2
    1090:	007d0002 	rsbseq	r0, sp, r2

    jumpTable[mcgState.currentMode][mcgState.nextMode](clockConfig);
    1094:	00002232 	andeq	r2, r0, r2, lsr r2
    1098:	00002234 	andeq	r2, r0, r4, lsr r2
    109c:	047d0002 	ldrbteq	r0, [sp], #-2
    10a0:	00002234 	andeq	r2, r0, r4, lsr r2
    10a4:	00002318 	andeq	r2, r0, r8, lsl r3
    10a8:	207d0002 	rsbscs	r0, sp, r2
	...
    10b4:	00002320 	andeq	r2, r0, r0, lsr #6
    10b8:	00002322 	andeq	r2, r0, r2, lsr #6
    10bc:	007d0002 	rsbseq	r0, sp, r2
    10c0:	00002322 	andeq	r2, r0, r2, lsr #6
    10c4:	00002324 	andeq	r2, r0, r4, lsr #6

    /* Store the new clock frequency for clockGetFreq() */
    clockFreq.mcgClockFreq = clockConfigParam[clockConfig].clockHz;
    10c8:	047d0002 	ldrbteq	r0, [sp], #-2
    10cc:	00002324 	andeq	r2, r0, r4, lsr #6
    10d0:	00002394 	muleq	r0, r4, r3
    10d4:	207d0002 	rsbscs	r0, sp, r2
	...
    10e0:	000023a0 	andeq	r2, r0, r0, lsr #7
}
    10e4:	000023a2 	andeq	r2, r0, r2, lsr #7
    10e8:	007d0002 	rsbseq	r0, sp, r2

/*******************************************************************************
* clockConfigMcgIr
*******************************************************************************/
void clockConfigMcgIr()
{
    10ec:	000023a2 	andeq	r2, r0, r2, lsr #7
                                                            /* Not configured */
}
    10f0:	000023ca 	andeq	r2, r0, sl, asr #7
    10f4:	107d0002 	rsbsne	r0, sp, r2
	...
* clockConfigMcgFf
*******************************************************************************/
void clockConfigMcgFf()
{
                                                            /* Not configured */
}
    1100:	000023d0 	ldrdeq	r2, [r0], -r0

/*******************************************************************************
* clockConfigMcgFll
*******************************************************************************/
void clockConfigMcgFll()
{
    1104:	000023d2 	ldrdeq	r2, [r0], -r2	; <UNPREDICTABLE>
                                                            /* Not configured */
}
    1108:	007d0002 	rsbseq	r0, sp, r2
    110c:	000023d2 	ldrdeq	r2, [r0], -r2	; <UNPREDICTABLE>

/*******************************************************************************
* clockConfigMcgPll
*******************************************************************************/
void clockConfigMcgPll()
{
    1110:	000023d4 	ldrdeq	r2, [r0], -r4
                                                            /* Not configured */
}
    1114:	047d0002 	ldrbteq	r0, [sp], #-2
    1118:	000023d4 	ldrdeq	r2, [r0], -r4

/*******************************************************************************
* clockConfigOsc
*******************************************************************************/
void clockConfigOsc()
{
    111c:	0000240a 	andeq	r2, r0, sl, lsl #8
                                                            /* Not configured */
}
    1120:	187d0002 	ldmdane	sp!, {r1}^
	...
* clockConfigOsc32k
*******************************************************************************/
void clockConfigOsc32k()
{
                                                            /* Not configured */
}
    112c:	00002410 	andeq	r2, r0, r0, lsl r4
    1130:	00002412 	andeq	r2, r0, r2, lsl r4

/*******************************************************************************
* clockConfigEr32k
*******************************************************************************/
void clockConfigEr32k()
{
    1134:	007d0002 	rsbseq	r0, sp, r2
                                                            /* Not configured */
}
    1138:	00002412 	andeq	r2, r0, r2, lsl r4
    113c:	00002414 	andeq	r2, r0, r4, lsl r4

/*******************************************************************************
* clockConfigRtc
*******************************************************************************/
void clockConfigRtc()
{
    1140:	047d0002 	ldrbteq	r0, [sp], #-2
                                                            /* Not configured */
}
    1144:	00002414 	andeq	r2, r0, r4, lsl r4
    1148:	0000244c 	andeq	r2, r0, ip, asr #8

/*******************************************************************************
* clockConfigLpo
*******************************************************************************/
void clockConfigLpo()
{
    114c:	187d0002 	ldmdane	sp!, {r1}^
	...
*
* RETURNS: Nothing
*
*******************************************************************************/
void watchDogUnlock()
{
    1158:	00002450 	andeq	r2, r0, r0, asr r4
        " :
        /* No output */ :
        /* No input  */ :
        "r0", "r1" ); /* Specify which registers we destroy */
#else
    wdPtr->unlock = WDOG_UNLOCK_KEY_1;
    115c:	00002452 	andeq	r2, r0, r2, asr r4
    1160:	007d0002 	rsbseq	r0, sp, r2
    1164:	00002452 	andeq	r2, r0, r2, asr r4
    1168:	00002454 	andeq	r2, r0, r4, asr r4
    wdPtr->unlock = WDOG_UNLOCK_KEY_2;
    116c:	047d0002 	ldrbteq	r0, [sp], #-2
    1170:	00002454 	andeq	r2, r0, r4, asr r4
    1174:	00002476 	andeq	r2, r0, r6, ror r4
    1178:	187d0002 	ldmdane	sp!, {r1}^
	...

/*******************************************************************************
* watchDogInit
*******************************************************************************/
void watchDogInit(const watchDogConfig_t *wdCfgPtr)
{
    1184:	00002480 	andeq	r2, r0, r0, lsl #9
    1188:	00002482 	andeq	r2, r0, r2, lsl #9
    watchDogUnlock();
    118c:	007d0002 	rsbseq	r0, sp, r2
        " :
        /* No output */ :
        /* No input  */ :
        "r0", "r1", "r2" ); /* Specify which registers we destroy */
#else
    assert(wdCfgPtr->window < wdCfgPtr->timeout);
    1190:	00002482 	andeq	r2, r0, r2, lsl #9
    1194:	000024a6 	andeq	r2, r0, r6, lsr #9
    1198:	107d0002 	rsbsne	r0, sp, r2
	...
    11a4:	000024b0 			; <UNDEFINED> instruction: 0x000024b0
    11a8:	000024b2 			; <UNDEFINED> instruction: 0x000024b2

    wdPtr->toValL  = wdCfgPtr->timeout;
    11ac:	007d0002 	rsbseq	r0, sp, r2
    11b0:	000024b2 			; <UNDEFINED> instruction: 0x000024b2
    11b4:	000024b4 			; <UNDEFINED> instruction: 0x000024b4
    11b8:	047d0002 	ldrbteq	r0, [sp], #-2
    11bc:	000024b4 			; <UNDEFINED> instruction: 0x000024b4
    wdPtr->toValH  = wdCfgPtr->timeout >> 16;
    11c0:	000024d4 	ldrdeq	r2, [r0], -r4
    11c4:	107d0002 	rsbsne	r0, sp, r2
	...
    11d0:	000024e0 	andeq	r2, r0, r0, ror #9
    wdPtr->stCtrlH = wdCfgPtr->stCtrlFlags;
    11d4:	000024e2 	andeq	r2, r0, r2, ror #9
    11d8:	007d0002 	rsbseq	r0, sp, r2
    11dc:	000024e2 	andeq	r2, r0, r2, ror #9
    11e0:	000024fc 	strdeq	r2, [r0], -ip
    wdPtr->presc   = wdCfgPtr->prescaler;
    11e4:	087d0002 	ldmdaeq	sp!, {r1}^
	...
    11f0:	00002500 	andeq	r2, r0, r0, lsl #10
    wdPtr->winL    = wdCfgPtr->window;
    11f4:	00002502 	andeq	r2, r0, r2, lsl #10
    11f8:	007d0002 	rsbseq	r0, sp, r2
    11fc:	00002502 	andeq	r2, r0, r2, lsl #10
    1200:	00002504 	andeq	r2, r0, r4, lsl #10
    1204:	047d0002 	ldrbteq	r0, [sp], #-2
    wdPtr->winH    = wdCfgPtr->window >> 16;
    1208:	00002504 	andeq	r2, r0, r4, lsl #10
    120c:	00002526 	andeq	r2, r0, r6, lsr #10
    1210:	107d0002 	rsbsne	r0, sp, r2
	...
    }
    if (wdCfgPtr->stCtrlFlags & WDOG_TEST) {
        /* TODO: If anyone cares let me know */
    }
#endif
}
    121c:	00002530 	andeq	r2, r0, r0, lsr r5
    1220:	00002532 	andeq	r2, r0, r2, lsr r5

/* RFI: Could probably move these elsewhere for general consumption */
static void interruptDisable()
{
    1224:	007d0002 	rsbseq	r0, sp, r2
    asm volatile("\n\
    1228:	00002532 	andeq	r2, r0, r2, lsr r5
        cpsid i\n\
        " :
        /* No output */ :
        /* No input  */ :
        ); /* Specify which registers we destroy */
}
    122c:	00002578 	andeq	r2, r0, r8, ror r5
static void interruptEnable()
{
    1230:	087d0002 	ldmdaeq	sp!, {r1}^
	...

/*******************************************************************************
* watchDogKick
*******************************************************************************/
void watchDogKick()
{
    123c:	00002580 	andeq	r2, r0, r0, lsl #11
        " :
        /* No output */ :
        /* No input  */ :
        "r0", "r1" ); /* Specify which registers we destroy */
#else
    interruptDisable();
    1240:	00002582 	andeq	r2, r0, r2, lsl #11
    wdPtr->refresh = WDOG_REFRESH_KEY_1;
    1244:	007d0002 	rsbseq	r0, sp, r2
    1248:	00002582 	andeq	r2, r0, r2, lsl #11
    124c:	00002584 	andeq	r2, r0, r4, lsl #11
    1250:	047d0002 	ldrbteq	r0, [sp], #-2
    wdPtr->refresh = WDOG_REFRESH_KEY_2;
    1254:	00002584 	andeq	r2, r0, r4, lsl #11
    1258:	0000263e 	andeq	r2, r0, lr, lsr r6
    125c:	107d0002 	rsbsne	r0, sp, r2
	...
    interruptEnable();
#endif
}
    1268:	00002690 	muleq	r0, r0, r6

/*******************************************************************************
* watchDogDisable
*******************************************************************************/
void watchDogDisable()
{
    126c:	00002692 	muleq	r0, r2, r6
    watchDogUnlock();
    1270:	007d0002 	rsbseq	r0, sp, r2
        " :
        /* No output */ :
        /* No input  */ :
        "r0", "r1" ); /* Specify which registers we destroy */
#else
    wdPtr->stCtrlH = WDOG_STNDBYEN | WDOG_WAITEN | WDOG_STOPEN
    1274:	00002692 	muleq	r0, r2, r6
    1278:	00002694 	muleq	r0, r4, r6
    127c:	047d0002 	ldrbteq	r0, [sp], #-2
    1280:	00002694 	muleq	r0, r4, r6
                   | WDOG_ALLOWUPDATE;
#endif
}
    1284:	00002734 	andeq	r2, r0, r4, lsr r7
    1288:	187d0002 	ldmdane	sp!, {r1}^
	...
 * @param[in] p the thread parameter, unused in this scenario
 */
void _idle_thread(void *p) {

  (void)p;
  chRegSetThreadName("idle");
    1294:	00002740 	andeq	r2, r0, r0, asr #14
    1298:	00002742 	andeq	r2, r0, r2, asr #14
    129c:	007d0002 	rsbseq	r0, sp, r2
    12a0:	00002742 	andeq	r2, r0, r2, asr #14
    12a4:	00002744 	andeq	r2, r0, r4, asr #14
  while (TRUE) {
    port_wait_for_interrupt();
    IDLE_LOOP_HOOK();
  }
    12a8:	047d0002 	ldrbteq	r0, [sp], #-2
    12ac:	00002744 	andeq	r2, r0, r4, asr #14
 * @note    This function has special, architecture-dependent, requirements,
 *          see the notes into the various port reference manuals.
 *
 * @special
 */
void chSysInit(void) {
    12b0:	000027b8 			; <UNDEFINED> instruction: 0x000027b8
  static Thread mainthread;
#if CH_DBG_ENABLE_STACK_CHECK
  extern stkalign_t __main_thread_stack_base__;
#endif

  port_init();
    12b4:	187d0002 	ldmdane	sp!, {r1}^
	...
  _scheduler_init();
  _vt_init();
#if CH_USE_MEMCORE
  _core_init();
    12c0:	000027c0 	andeq	r2, r0, r0, asr #15
#endif
#if CH_USE_HEAP
  _heap_init();
    12c4:	000027c2 	andeq	r2, r0, r2, asr #15
#if CH_DBG_ENABLE_TRACE
  _trace_init();
#endif

  /* Now this instructions flow becomes the main thread.*/
  setcurrp(_thread_init(&mainthread, NORMALPRIO));
    12c8:	007d0002 	rsbseq	r0, sp, r2
    12cc:	000027c2 	andeq	r2, r0, r2, asr #15
    12d0:	000027c4 	andeq	r2, r0, r4, asr #15
    12d4:	047d0002 	ldrbteq	r0, [sp], #-2
    12d8:	000027c4 	andeq	r2, r0, r4, asr #15
    12dc:	00002820 	andeq	r2, r0, r0, lsr #16
    12e0:	187d0002 	ldmdane	sp!, {r1}^
	...
  currp->p_state = THD_STATE_CURRENT;
    12ec:	00002820 	andeq	r2, r0, r0, lsr #16
    12f0:	00002822 	andeq	r2, r0, r2, lsr #16
#if CH_DBG_ENABLE_STACK_CHECK
  /* This is a special case because the main thread Thread structure is not
     adjacent to its stack area.*/
  currp->p_stklimit = &__main_thread_stack_base__;
#endif
  chSysEnable();
    12f4:	007d0002 	rsbseq	r0, sp, r2
    12f8:	00002822 	andeq	r2, r0, r2, lsr #16
    12fc:	00002866 	andeq	r2, r0, r6, ror #16

  chRegSetThreadName("main");
    1300:	107d0002 	rsbsne	r0, sp, r2
	...
    130c:	00002870 	andeq	r2, r0, r0, ror r8
    1310:	00002872 	andeq	r2, r0, r2, ror r8

#if !CH_NO_IDLE_THREAD
  /* This thread has the lowest priority in the system, its role is just to
     serve interrupts in its context while keeping the lowest energy saving
     mode compatible with the system status.*/
  chThdCreateStatic(_idle_thread_wa, sizeof(_idle_thread_wa), IDLEPRIO,
    1314:	007d0002 	rsbseq	r0, sp, r2
    1318:	00002872 	andeq	r2, r0, r2, ror r8
    131c:	00002892 	muleq	r0, r2, r8
    1320:	107d0002 	rsbsne	r0, sp, r2
	...
    132c:	000028a0 	andeq	r2, r0, r0, lsr #17
    1330:	000028a2 	andeq	r2, r0, r2, lsr #17
                    (tfunc_t)_idle_thread, NULL);
#endif
}
    1334:	007d0002 	rsbseq	r0, sp, r2
    1338:	000028a2 	andeq	r2, r0, r2, lsr #17
    133c:	000028c0 	andeq	r2, r0, r0, asr #17
 *          and, together with the @p CH_TIME_QUANTUM macro, the round robin
 *          interval.
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {
    1340:	087d0002 	ldmdaeq	sp!, {r1}^
	...

  chDbgCheckClassI();

#if CH_TIME_QUANTUM > 0
  /* Running thread has not used up quantum yet? */
  if (currp->p_preempt > 0)
    134c:	000028c0 	andeq	r2, r0, r0, asr #17
    1350:	000028c2 	andeq	r2, r0, r2, asr #17
    /* Decrement remaining quantum.*/
    currp->p_preempt--;
    1354:	007d0002 	rsbseq	r0, sp, r2
    1358:	000028c2 	andeq	r2, r0, r2, asr #17
    135c:	000028de 	ldrdeq	r2, [r0], -lr
    1360:	087d0002 	ldmdaeq	sp!, {r1}^
	...
#endif
#if CH_DBG_THREADS_PROFILING
  currp->p_time++;
    136c:	000028e0 	andeq	r2, r0, r0, ror #17
    1370:	000028e2 	andeq	r2, r0, r2, ror #17
    1374:	007d0002 	rsbseq	r0, sp, r2
    1378:	000028e2 	andeq	r2, r0, r2, ror #17
#endif
  chVTDoTickI();
    137c:	000028e4 	andeq	r2, r0, r4, ror #17
    1380:	047d0002 	ldrbteq	r0, [sp], #-2
    1384:	000028e4 	andeq	r2, r0, r4, ror #17
    1388:	00002900 	andeq	r2, r0, r0, lsl #18
    138c:	107d0002 	rsbsne	r0, sp, r2
	...
    1398:	00002900 	andeq	r2, r0, r0, lsl #18
    139c:	00002902 	andeq	r2, r0, r2, lsl #18
    13a0:	007d0002 	rsbseq	r0, sp, r2
    13a4:	00002902 	andeq	r2, r0, r2, lsl #18
    13a8:	00002904 	andeq	r2, r0, r4, lsl #18
    13ac:	047d0002 	ldrbteq	r0, [sp], #-2
    13b0:	00002904 	andeq	r2, r0, r4, lsl #18
    13b4:	000029c0 	andeq	r2, r0, r0, asr #19
    13b8:	187d0002 	ldmdane	sp!, {r1}^
	...
    13c4:	000029c0 	andeq	r2, r0, r0, asr #19
    13c8:	000029c2 	andeq	r2, r0, r2, asr #19
    13cc:	007d0002 	rsbseq	r0, sp, r2
    13d0:	000029c2 	andeq	r2, r0, r2, asr #19
    13d4:	000029c4 	andeq	r2, r0, r4, asr #19
    13d8:	047d0002 	ldrbteq	r0, [sp], #-2
    13dc:	000029c4 	andeq	r2, r0, r4, asr #19
    13e0:	000029e6 	andeq	r2, r0, r6, ror #19
    13e4:	187d0002 	ldmdane	sp!, {r1}^
	...
    13f0:	000029f0 	strdeq	r2, [r0], -r0
    13f4:	000029f2 	strdeq	r2, [r0], -r2	; <UNPREDICTABLE>
    13f8:	007d0002 	rsbseq	r0, sp, r2
    13fc:	000029f2 	strdeq	r2, [r0], -r2	; <UNPREDICTABLE>
    1400:	00002a38 	andeq	r2, r0, r8, lsr sl
    1404:	087d0002 	ldmdaeq	sp!, {r1}^
	...
    1410:	00002a40 	andeq	r2, r0, r0, asr #20
#if defined(SYSTEM_TICK_EVENT_HOOK)
  SYSTEM_TICK_EVENT_HOOK();
#endif
}
    1414:	00002a42 	andeq	r2, r0, r2, asr #20
    1418:	007d0002 	rsbseq	r0, sp, r2
    141c:	00002a42 	andeq	r2, r0, r2, asr #20
 *
 * @notapi
 */
void _vt_init(void) {

  vtlist.vt_next = vtlist.vt_prev = (void *)&vtlist;
    1420:	00002a44 	andeq	r2, r0, r4, asr #20
    1424:	047d0002 	ldrbteq	r0, [sp], #-2
    1428:	00002a44 	andeq	r2, r0, r4, asr #20
    142c:	00002af0 	strdeq	r2, [r0], -r0
    1430:	207d0002 	rsbscs	r0, sp, r2
	...
    143c:	00002af0 	strdeq	r2, [r0], -r0
    1440:	00002af2 	strdeq	r2, [r0], -r2	; <UNPREDICTABLE>
    1444:	007d0002 	rsbseq	r0, sp, r2
  vtlist.vt_time = (systime_t)-1;
    1448:	00002af2 	strdeq	r2, [r0], -r2	; <UNPREDICTABLE>
    144c:	00002af4 	strdeq	r2, [r0], -r4
    1450:	047d0002 	ldrbteq	r0, [sp], #-2
  vtlist.vt_systime = 0;
    1454:	00002af4 	strdeq	r2, [r0], -r4
    1458:	00002b8c 	andeq	r2, r0, ip, lsl #23
    145c:	207d0002 	rsbscs	r0, sp, r2
	...
    1468:	00002b90 	muleq	r0, r0, fp
    146c:	00002b92 	muleq	r0, r2, fp
 * @param[in] par       a parameter that will be passed to the callback
 *                      function
 *
 * @iclass
 */
void chVTSetI(VirtualTimer *vtp, systime_t time, vtfunc_t vtfunc, void *par) {
    1470:	007d0002 	rsbseq	r0, sp, r2
    1474:	00002b92 	muleq	r0, r2, fp
    1478:	00002b94 	muleq	r0, r4, fp
  VirtualTimer *p;

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (time != TIME_IMMEDIATE),
    147c:	047d0002 	ldrbteq	r0, [sp], #-2
    1480:	00002b94 	muleq	r0, r4, fp
    1484:	00002c16 	andeq	r2, r0, r6, lsl ip
    1488:	187d0002 	ldmdane	sp!, {r1}^
	...

Disassembly of section .debug_str:

00000000 <.debug_str>:
       0:	6f6d6564 	svcvs	0x006d6564
       4:	62696843 	rsbvs	r6, r9, #4390912	; 0x430000
       8:	00632e69 	rsbeq	r2, r3, r9, ror #28
       c:	4f495047 	svcmi	0x00495047
      10:	504e495f 	subpl	r4, lr, pc, asr r9
      14:	61005455 	tstvs	r0, r5, asr r4
      18:	72657373 	rsbvc	r7, r5, #-872415231	; 0xcc000001
      1c:	75005f74 	strvc	r5, [r0, #-3956]	; 0xfffff08c
      20:	36746e69 	ldrbtcc	r6, [r4], -r9, ror #28
      24:	00745f34 	rsbseq	r5, r4, r4, lsr pc
      28:	4f495047 	svcmi	0x00495047
      2c:	45444f5f 	strbmi	r4, [r4, #-3935]	; 0xfffff0a1
      30:	6f687300 	svcvs	0x00687300
      34:	69207472 	stmdbvs	r0!, {r1, r4, r5, r6, sl, ip, sp, lr}
      38:	7300746e 	movwvc	r7, #1134	; 0x46e
      3c:	69747379 	ldmdbvs	r4!, {r0, r3, r4, r5, r6, r8, r9, ip, sp, lr}^
      40:	6e496b63 	vmlsvs.f64	d22, d9, d19
      44:	6d007469 	cfstrsvs	mvf7, [r0, #-420]	; 0xfffffe5c
      48:	006e6961 	rsbeq	r6, lr, r1, ror #18
      4c:	5f58414d 	svcpl	0x0058414d
      50:	534f5243 	movtpl	r5, #62019	; 0xf243
      54:	52414253 	subpl	r4, r1, #805306373	; 0x30000005
      58:	53414d5f 	movtpl	r4, #7519	; 0x1d5f
      5c:	53524554 	cmppl	r2, #84, 10	; 0x15000000
      60:	6f6c6300 	svcvs	0x006c6300
      64:	49736b63 	ldmdbmi	r3!, {r0, r1, r5, r6, r8, r9, fp, sp, lr}^
      68:	0074696e 	rsbseq	r6, r4, lr, ror #18
      6c:	656c6966 	strbvs	r6, [ip, #-2406]!	; 0xfffff69a
      70:	49564e00 	ldmdbmi	r6, {r9, sl, fp, lr}^
      74:	59535f43 	ldmdbpl	r3, {r0, r1, r6, r8, r9, sl, fp, ip, lr}^
      78:	43495453 	movtmi	r5, #37971	; 0x9453
      7c:	4f435f4b 	svcmi	0x00435f4b
      80:	4f52544e 	svcmi	0x0052544e
      84:	4c435f4c 	mcrrmi	15, 4, r5, r3, cr12
      88:	554f534b 	strbpl	r5, [pc, #-843]	; fffffd45 <_stack_start+0xdffefd45>
      8c:	00454352 	subeq	r4, r5, r2, asr r3
      90:	4349564e 	movtmi	r5, #38478	; 0x964e
      94:	5359535f 	cmppl	r9, #2080374785	; 0x7c000001
      98:	4b434954 	blmi	10d25f0 <_flash_swap_addr+0x1092df0>
      9c:	4e4f435f 	mcrmi	3, 2, r4, cr15, cr15, {2}
      a0:	4c4f5254 	sfmmi	f5, 2, [pc], {84}	; 0x54
      a4:	554f435f 	strbpl	r4, [pc, #-863]	; fffffd4d <_stack_start+0xdffefd4d>
      a8:	4c46544e 	cfstrdmi	mvd5, [r6], {78}	; 0x4e
      ac:	4e004741 	cdpmi	7, 0, cr4, cr0, cr1, {2}
      b0:	5f434956 	svcpl	0x00434956
      b4:	54535953 	ldrbpl	r5, [r3], #-2387	; 0xfffff6ad
      b8:	5f4b4349 	svcpl	0x004b4349
      bc:	544e4f43 	strbpl	r4, [lr], #-3907	; 0xfffff0bd
      c0:	5f4c4f52 	svcpl	0x004c4f52
      c4:	4b434954 	blmi	10d261c <_flash_swap_addr+0x1092e1c>
      c8:	00544e49 	subseq	r4, r4, r9, asr #28
      cc:	4349564e 	movtmi	r5, #38478	; 0x964e
      d0:	5359535f 	cmppl	r9, #2080374785	; 0x7c000001
      d4:	4b434954 	blmi	10d262c <_flash_swap_addr+0x1092e2c>
      d8:	4e4f435f 	mcrmi	3, 2, r4, cr15, cr15, {2}
      dc:	4c4f5254 	sfmmi	f5, 2, [pc], {84}	; 0x54
      e0:	414e455f 	cmpmi	lr, pc, asr r5
      e4:	00454c42 	subeq	r4, r5, r2, asr #24
      e8:	656e696c 	strbvs	r6, [lr, #-2412]!	; 0xfffff694
      ec:	65726600 	ldrbvs	r6, [r2, #-1536]!	; 0xfffffa00
      f0:	6f6c0071 	svcvs	0x006c0071
      f4:	6c20676e 	stcvs	7, cr6, [r0], #-440	; 0xfffffe48
      f8:	20676e6f 	rsbcs	r6, r7, pc, ror #28
      fc:	00746e69 	rsbseq	r6, r4, r9, ror #28
     100:	434f4c43 	movtmi	r4, #64579	; 0xfc43
     104:	4c465f4b 	mcrrmi	15, 4, r5, r6, cr11
     108:	00485341 	subeq	r5, r8, r1, asr #6
     10c:	434f4c43 	movtmi	r4, #64579	; 0xfc43
     110:	55425f4b 	strbpl	r5, [r2, #-3915]	; 0xfffff0b5
     114:	50470053 	subpl	r0, r7, r3, asr r0
     118:	505f4f49 	subspl	r4, pc, r9, asr #30
     11c:	444c4c55 	strbmi	r4, [ip], #-3157	; 0xfffff3ab
     120:	004e574f 	subeq	r5, lr, pc, asr #14
     124:	4f495047 	svcmi	0x00495047
     128:	4553445f 	ldrbmi	r4, [r3, #-1119]	; 0xfffffba1
     12c:	56494400 	strbpl	r4, [r9], -r0, lsl #8
     130:	5f454449 	svcpl	0x00454449
     134:	315f5942 	cmpcc	pc, r2, asr #18
     138:	49440030 	stmdbmi	r4, {r4, r5}^
     13c:	45444956 	strbmi	r4, [r4, #-2390]	; 0xfffff6aa
     140:	5f59425f 	svcpl	0x0059425f
     144:	44003131 	strmi	r3, [r0], #-305	; 0xfffffecf
     148:	44495649 	strbmi	r5, [r9], #-1609	; 0xfffff9b7
     14c:	59425f45 	stmdbpl	r2, {r0, r2, r6, r8, r9, sl, fp, ip, lr}^
     150:	0032315f 	eorseq	r3, r2, pc, asr r1
     154:	49564944 	ldmdbmi	r6, {r2, r6, r8, fp, lr}^
     158:	425f4544 	subsmi	r4, pc, #68, 10	; 0x11000000
     15c:	33315f59 	teqcc	r1, #356	; 0x164
     160:	56494400 	strbpl	r4, [r9], -r0, lsl #8
     164:	5f454449 	svcpl	0x00454449
     168:	315f5942 	cmpcc	pc, r2, asr #18
     16c:	61770034 	cmnvs	r7, r4, lsr r0
     170:	65726854 	ldrbvs	r6, [r2, #-2132]!	; 0xfffff7ac
     174:	00316461 	eorseq	r6, r1, r1, ror #8
     178:	49564944 	ldmdbmi	r6, {r2, r6, r8, fp, lr}^
     17c:	425f4544 	subsmi	r4, pc, #68, 10	; 0x11000000
     180:	36315f59 	shsaxcc	r5, r1, r9
     184:	4f524300 	svcmi	0x00524300
     188:	41425353 	cmpmi	r2, r3, asr r3
     18c:	414d5f52 	cmpmi	sp, r2, asr pc
     190:	52455453 	subpl	r5, r5, #1392508928	; 0x53000000
     194:	4253555f 	subsmi	r5, r3, #398458880	; 0x17c00000
     198:	49504700 	ldmdbmi	r0, {r8, r9, sl, lr}^
     19c:	4f4c5f4f 	svcmi	0x004c5f4f
     1a0:	414d0057 	qdaddmi	r0, r7, sp
     1a4:	434d5f58 	movtmi	r5, #57176	; 0xdf58
     1a8:	4c435f47 	mcrrmi	15, 4, r5, r3, cr7
     1ac:	5f4b434f 	svcpl	0x004b434f
     1b0:	4954504f 	ldmdbmi	r4, {r0, r1, r2, r3, r6, ip, lr}^
     1b4:	00534e4f 	subseq	r4, r3, pc, asr #28
     1b8:	69736e75 	ldmdbvs	r3!, {r0, r2, r4, r5, r6, r9, sl, fp, sp, lr}^
     1bc:	64656e67 	strbtvs	r6, [r5], #-3687	; 0xfffff199
     1c0:	61686320 	cmnvs	r8, r0, lsr #6
     1c4:	50470072 	subpl	r0, r7, r2, ror r0
     1c8:	505f4f49 	subspl	r4, pc, r9, asr #30
     1cc:	43004546 	movwmi	r4, #1350	; 0x546
     1d0:	53534f52 	cmppl	r3, #328	; 0x148
     1d4:	5f524142 	svcpl	0x00524142
     1d8:	5453414d 	ldrbpl	r4, [r3], #-333	; 0xfffffeb3
     1dc:	455f5245 	ldrbmi	r5, [pc, #-581]	; ffffff9f <_stack_start+0xdffeff9f>
     1e0:	6c004854 	stcvs	8, cr4, [r0], {84}	; 0x54
     1e4:	20676e6f 	rsbcs	r6, r7, pc, ror #28
     1e8:	676e6f6c 	strbvs	r6, [lr, -ip, ror #30]!
     1ec:	736e7520 	cmnvc	lr, #32, 10	; 0x8000000
     1f0:	656e6769 	strbvs	r6, [lr, #-1897]!	; 0xfffff897
     1f4:	6e692064 	cdpvs	0, 6, cr2, cr9, cr4, {3}
     1f8:	50470074 	subpl	r0, r7, r4, ror r0
     1fc:	4f5f4f49 	svcmi	0x005f4f49
     200:	55505455 	ldrbpl	r5, [r0, #-1109]	; 0xfffffbab
     204:	4c430054 	mcrrmi	0, 5, r0, r3, cr4
     208:	5f4b434f 	svcpl	0x004b434f
     20c:	5047434d 	subpl	r4, r7, sp, asr #6
     210:	4c434c4c 	mcrrmi	12, 4, r4, r3, cr12
     214:	682f004b 	stmdavs	pc!, {r0, r1, r3, r6}	; <UNPREDICTABLE>
     218:	2f656d6f 	svccs	0x00656d6f
     21c:	6e656b64 	vnmulvs.f64	d22, d5, d20
     220:	7964656e 	stmdbvc	r4!, {r1, r2, r3, r5, r6, r8, sl, sp, lr}^
     224:	7665642f 	strbtvc	r6, [r5], -pc, lsr #8
     228:	6e696b2f 	vmulvs.f64	d22, d9, d31
     22c:	73697465 	cmnvc	r9, #1694498816	; 0x65000000
     230:	7469672e 	strbtvc	r6, [r9], #-1838	; 0xfffff8d2
     234:	6168702f 	cmnvs	r8, pc, lsr #32
     238:	5f336573 	svcpl	0x00336573
     23c:	736f7472 	cmnvc	pc, #1912602624	; 0x72000000
     240:	4f4c4300 	svcmi	0x004c4300
     244:	435f4b43 	cmpmi	pc, #68608	; 0x10c00
     248:	0045524f 	subeq	r5, r5, pc, asr #4
     24c:	434f4c43 	movtmi	r4, #64579	; 0xfc43
     250:	434d5f4b 	movtmi	r5, #57163	; 0xdf4b
     254:	4c4c4647 	mcrrmi	6, 4, r4, ip, cr7
     258:	004b4c43 	subeq	r4, fp, r3, asr #24
     25c:	434f4c43 	movtmi	r4, #64579	; 0xfc43
     260:	4c465f4b 	mcrrmi	15, 4, r5, r6, cr11
     264:	55425845 	strbpl	r5, [r2, #-2117]	; 0xfffff7bb
     268:	68730053 	ldmdavs	r3!, {r0, r1, r4, r6}^
     26c:	2074726f 	rsbscs	r7, r4, pc, ror #4
     270:	69736e75 	ldmdbvs	r3!, {r0, r2, r4, r5, r6, r9, sl, fp, sp, lr}^
     274:	64656e67 	strbtvs	r6, [r5], #-3687	; 0xfffff199
     278:	746e6920 	strbtvc	r6, [lr], #-2336	; 0xfffff6e0
     27c:	73797300 	cmnvc	r9, #0, 6
     280:	656d6974 	strbvs	r6, [sp, #-2420]!	; 0xfffff68c
     284:	4700745f 	smlsdmi	r0, pc, r4, r7	; <UNPREDICTABLE>
     288:	4320554e 	teqmi	r0, #327155712	; 0x13800000
     28c:	362e3420 	strtcc	r3, [lr], -r0, lsr #8
     290:	4400312e 	strmi	r3, [r0], #-302	; 0xfffffed2
     294:	44495649 	strbmi	r5, [r9], #-1609	; 0xfffff9b7
     298:	59425f45 	stmdbpl	r2, {r0, r2, r6, r8, r9, sl, fp, ip, lr}^
     29c:	4400315f 	strmi	r3, [r0], #-351	; 0xfffffea1
     2a0:	44495649 	strbmi	r5, [r9], #-1609	; 0xfffff9b7
     2a4:	59425f45 	stmdbpl	r2, {r0, r2, r6, r8, r9, sl, fp, ip, lr}^
     2a8:	4400325f 	strmi	r3, [r0], #-607	; 0xfffffda1
     2ac:	44495649 	strbmi	r5, [r9], #-1609	; 0xfffff9b7
     2b0:	59425f45 	stmdbpl	r2, {r0, r2, r6, r8, r9, sl, fp, ip, lr}^
     2b4:	4400335f 	strmi	r3, [r0], #-863	; 0xfffffca1
     2b8:	44495649 	strbmi	r5, [r9], #-1609	; 0xfffff9b7
     2bc:	59425f45 	stmdbpl	r2, {r0, r2, r6, r8, r9, sl, fp, ip, lr}^
     2c0:	4400345f 	strmi	r3, [r0], #-1119	; 0xfffffba1
     2c4:	44495649 	strbmi	r5, [r9], #-1609	; 0xfffff9b7
     2c8:	59425f45 	stmdbpl	r2, {r0, r2, r6, r8, r9, sl, fp, ip, lr}^
     2cc:	4400355f 	strmi	r3, [r0], #-1375	; 0xfffffaa1
     2d0:	44495649 	strbmi	r5, [r9], #-1609	; 0xfffff9b7
     2d4:	59425f45 	stmdbpl	r2, {r0, r2, r6, r8, r9, sl, fp, ip, lr}^
     2d8:	4400365f 	strmi	r3, [r0], #-1631	; 0xfffff9a1
     2dc:	44495649 	strbmi	r5, [r9], #-1609	; 0xfffff9b7
     2e0:	59425f45 	stmdbpl	r2, {r0, r2, r6, r8, r9, sl, fp, ip, lr}^
     2e4:	4400375f 	strmi	r3, [r0], #-1887	; 0xfffff8a1
     2e8:	44495649 	strbmi	r5, [r9], #-1609	; 0xfffff9b7
     2ec:	59425f45 	stmdbpl	r2, {r0, r2, r6, r8, r9, sl, fp, ip, lr}^
     2f0:	4400385f 	strmi	r3, [r0], #-2143	; 0xfffff7a1
     2f4:	44495649 	strbmi	r5, [r9], #-1609	; 0xfffff9b7
     2f8:	59425f45 	stmdbpl	r2, {r0, r2, r6, r8, r9, sl, fp, ip, lr}^
     2fc:	7500395f 	strvc	r3, [r0, #-2399]	; 0xfffff6a1
     300:	33746e69 	cmncc	r4, #1680	; 0x690
     304:	00745f32 	rsbseq	r5, r4, r2, lsr pc
     308:	434f4c43 	movtmi	r4, #64579	; 0xfc43
     30c:	434d5f4b 	movtmi	r5, #57163	; 0xdf4b
     310:	43464647 	movtmi	r4, #26183	; 0x6647
     314:	4d004b4c 	vstrmi	d4, [r0, #-304]	; 0xfffffed0
     318:	505f4743 	subspl	r4, pc, r3, asr #14
     31c:	455f4c4c 	ldrbmi	r4, [pc, #-3148]	; fffff6d8 <_stack_start+0xdffef6d8>
     320:	52455458 	subpl	r5, r5, #88, 8	; 0x58000000
     324:	5f4c414e 	svcpl	0x004c414e
     328:	4d303031 	ldcmi	0, cr3, [r0, #-196]!	; 0xffffff3c
     32c:	4d005a48 	vstrmi	s10, [r0, #-288]	; 0xfffffee0
     330:	505f4743 	subspl	r4, pc, r3, asr #14
     334:	455f4c4c 	ldrbmi	r4, [pc, #-3148]	; fffff6f0 <_stack_start+0xdffef6f0>
     338:	52455458 	subpl	r5, r5, #88, 8	; 0x58000000
     33c:	5f4c414e 	svcpl	0x004c414e
     340:	484d3834 	stmdami	sp, {r2, r4, r5, fp, ip, sp}^
     344:	434d005a 	movtmi	r0, #53338	; 0xd05a
     348:	4c465f47 	mcrrmi	15, 4, r5, r6, cr7
     34c:	4e495f4c 	cdpmi	15, 4, cr5, cr9, cr12, {2}
     350:	4e524554 	mrcmi	5, 2, r4, cr2, cr4, {2}
     354:	325f4c41 	subscc	r4, pc, #16640	; 0x4100
     358:	5a484d34 	bpl	1213830 <_flash_swap_addr+0x11d4030>
     35c:	4f524300 	svcmi	0x00524300
     360:	41425353 	cmpmi	r2, r3, asr r3
     364:	414d5f52 	cmpmi	sp, r2, asr pc
     368:	52455453 	subpl	r5, r5, #1392508928	; 0x53000000
     36c:	414d445f 	cmpmi	sp, pc, asr r4
     370:	4f524300 	svcmi	0x00524300
     374:	41425353 	cmpmi	r2, r3, asr r3
     378:	414d5f52 	cmpmi	sp, r2, asr pc
     37c:	52455453 	subpl	r5, r5, #1392508928	; 0x53000000
     380:	5359535f 	cmppl	r9, #2080374785	; 0x7c000001
     384:	5355425f 	cmppl	r5, #-268435451	; 0xf0000005
     388:	56494400 	strbpl	r4, [r9], -r0, lsl #8
     38c:	5f454449 	svcpl	0x00454449
     390:	315f5942 	cmpcc	pc, r2, asr #18
     394:	52430035 	subpl	r0, r3, #53	; 0x35
     398:	4253534f 	subsmi	r5, r3, #1006632961	; 0x3c000001
     39c:	4d5f5241 	lfmmi	f5, 2, [pc, #-260]	; 2a0 <_vector_rom+0x2a0>
     3a0:	45545341 	ldrbmi	r5, [r4, #-833]	; 0xfffffcbf
     3a4:	44535f52 	ldrbmi	r5, [r3], #-3922	; 0xfffff0ae
     3a8:	43004348 	movwmi	r4, #840	; 0x348
     3ac:	4b434f4c 	blmi	10d40e4 <_flash_swap_addr+0x10948e4>
     3b0:	4f504c5f 	svcmi	0x00504c5f
     3b4:	6b747300 	blvs	1d1cfbc <_flash_swap_addr+0x1cdd7bc>
     3b8:	67696c61 	strbvs	r6, [r9, -r1, ror #24]!
     3bc:	00745f6e 	rsbseq	r5, r4, lr, ror #30
     3c0:	434f4c43 	movtmi	r4, #64579	; 0xfc43
     3c4:	59535f4b 	ldmdbpl	r3, {r0, r1, r3, r6, r8, r9, sl, fp, ip, lr}^
     3c8:	4d455453 	cfstrdmi	mvd5, [r5, #-332]	; 0xfffffeb4
     3cc:	4f4c4300 	svcmi	0x004c4300
     3d0:	4f5f4b43 	svcmi	0x005f4b43
     3d4:	52454353 	subpl	r4, r5, #1275068417	; 0x4c000001
     3d8:	004b4c43 	subeq	r4, fp, r3, asr #24
     3dc:	434f4c43 	movtmi	r4, #64579	; 0xfc43
     3e0:	434d5f4b 	movtmi	r5, #57163	; 0xdf4b
     3e4:	43524947 	cmpmi	r2, #1163264	; 0x11c000
     3e8:	47004b4c 	strmi	r4, [r0, -ip, asr #22]
     3ec:	5f4f4950 	svcpl	0x004f4950
     3f0:	4c4c5550 	cfstr64mi	mvdx5, [ip], {80}	; 0x50
     3f4:	43005055 	movwmi	r5, #85	; 0x55
     3f8:	53534f52 	cmppl	r3, #328	; 0x148
     3fc:	5f524142 	svcpl	0x00524142
     400:	5453414d 	ldrbpl	r4, [r3], #-333	; 0xfffffeb3
     404:	435f5245 	cmpmi	pc, #1342177284	; 0x50000004
     408:	5f45444f 	svcpl	0x0045444f
     40c:	00535542 	subseq	r5, r3, r2, asr #10
    .thumb_func

_default_reset_handler:

unlock_watchdog:
    ldr r6, =0x4005200e
     410:	434f4c43 	movtmi	r4, #64579	; 0xfc43
    ldr r0, =0xc520
    strh r0, [r6]
     414:	52455f4b 	subpl	r5, r5, #300	; 0x12c
    ldr r0, =0xd928
    strh r0, [r6]
     418:	334b4c43 	movtcc	r4, #48195	; 0xbc43

disable_watchdog:
    ldr r6, =0x40052000
    ldr r0, =0x01d2
     41c:	6d004b32 	vstrvs	d4, [r0, #-200]	; 0xffffff38
     * address 0x00000000 (which is the first element in the vector_table) by
     * the hardware. The next three lines are required in case this image
     * is not located at 0x0 (i.e. it is being launched from a bootloader).
     */

    ldr r1, =_vector_table
     420:	745f6773 	ldrbvc	r6, [pc], #-1907	; 428 <chibi_setup+0x2>
    ldr r2, [r1]
    mov	sp,r2
     424:	58414d00 	stmdapl	r1, {r8, sl, fp, lr}^
chibi_setup:
    /*
     * ChibiOS requires a process stack to be initialized.
     */
    ldr r1, =_process_stack_start
    msr PSP, r1
     428:	5649445f 			; <UNDEFINED> instruction: 0x5649445f

    /* TODO: FPU register initialization per crt0.c */
    /*
     * Set up system to run in privileged mode using the PSP stack
     */
    ldr r1, =0x00000002
     42c:	52454449 	subpl	r4, r5, #1224736768	; 0x49000000
    msr CONTROL, r1
     430:	49504700 	ldmdbmi	r0, {r8, r9, sl, lr}^
    isb
     434:	49485f4f 	stmdbmi	r8, {r0, r1, r2, r3, r6, r8, r9, sl, fp, ip, lr}^
     * address and the start address are not the same. This code supports
     * running an entire image out of SRAM.
     */

    ldr r0, =_text_start
    ldr r1, =_text_end
     438:	70004847 	andvc	r4, r0, r7, asr #16
    ldr r2, =_text_load

    cmp r0, r2
     43c:	00726464 	rsbseq	r6, r2, r4, ror #8
    beq end_text_loop
     440:	726f6370 	rsbvc	r6, pc, #112, 6	; 0xc0000001
text_loop:
    cmp r0, r1
    ittt    lt
     444:	69706700 	ldmdbvs	r0!, {r8, r9, sl, sp, lr}^
    ldrlt   r3, [r2], #4
     448:	726f506f 	rsbvc	r5, pc, #111	; 0x6f
    strlt   r3, [r0], #4
     44c:	74654774 	strbtvc	r4, [r5], #-1908	; 0xfffff88c
    blt     text_loop
     450:	2f2e2e00 	svccs	0x002e2e00
    /*
     * Relocate the .ramcode section from FLASH to SRAM.
     */

    ldr r0, =_ramcode_start
    ldr r1, =_ramcode_end
     454:	73616870 	cmnvc	r1, #112, 16	; 0x700000
    ldr r2, =_ramcode_load

ramcode_loop:
    cmp r0, r1
     458:	655f3265 	ldrbvs	r3, [pc, #-613]	; 1fb <_vector_rom+0x1fb>
    ittt    lt
    ldrlt   r3, [r2], #4
     45c:	6465626d 	strbtvs	r6, [r5], #-621	; 0xfffffd93
    strlt   r3, [r0], #4
     460:	5f646564 	svcpl	0x00646564
    blt     ramcode_loop
     464:	70672f63 	rsbvc	r2, r7, r3, ror #30

    /*
     * Relocate vector table to SRAM.
     */

     ldr r0, =_vector_ram_start
     468:	632e6f69 	teqvs	lr, #420	; 0x1a4
     ldr r1, =_vector_ram_end
     ldr r2, =_vector_rom
     46c:	69706700 	ldmdbvs	r0!, {r8, r9, sl, sp, lr}^
vector_loop:
    cmp r0, r1
    ittt    lt
     470:	6e6f436f 	cdpvs	3, 6, cr4, cr15, cr15, {3}
    ldrlt   r3, [r2], #4
     474:	00676966 	rsbeq	r6, r7, r6, ror #18
    strlt   r3, [r0], #4
     478:	756c6176 	strbvc	r6, [ip, #-374]!	; 0xfffffe8a
    blt     vector_loop
     47c:	70670065 	rsbvc	r0, r7, r5, rrx
    /*
     * Point to the SRAM vector table.
     */

    ldr r1,=0xe000ed08
    ldr r0,=_vector_ram_start
     480:	6c436f69 	mcrrvs	15, 6, r6, r3, cr9
     * Note: _data_start contains the SRAM (destination) address and
     *       _text_end contains the (source) address of the .data section
     *       in FLASH.
     */

    ldr r0, =_data_start
     484:	00726165 	rsbseq	r6, r2, r5, ror #2
    ldr r1, =_data_end
    ldr r2, =_data_load
     488:	6f697067 	svcvs	0x00697067

data_loop:
    cmp r0, r1
    ittt    lt
     48c:	74726f50 	ldrbtvc	r6, [r2], #-3920	; 0xfffff0b0
    ldrlt   r3, [r2], #4
     490:	7000745f 	andvc	r7, r0, pc, asr r4
    strlt   r3, [r0], #4
     494:	00726964 	rsbseq	r6, r2, r4, ror #18
    blt     data_loop
     498:	726f6470 	rsbvc	r6, pc, #112, 8	; 0x70000000
    /*
     * Zero out the .bss section in SRAM.
     */

    ldr r0, =_bss_start
    ldr r1, =_bss_end
     49c:	64646100 	strbtvs	r6, [r4], #-256	; 0xffffff00
    ldr r2, =0x00000000

bss_loop:
    cmp r0, r1
     4a0:	4f500072 	svcmi	0x00500072
    itt     lt
    strlt   r2, [r0], #4
     4a4:	4d5f5452 	cfldrdmi	mvd5, [pc, #-328]	; 364 <_vector_rom+0x364>
    blt     bss_loop
     4a8:	415f5855 	cmpmi	pc, r5, asr r8	; <UNPREDICTABLE>

    /*
     * Zero out heap.
     */

    ldr r0, =_heap_start
     4ac:	0031544c 	eorseq	r5, r1, ip, asr #8
    ldr r1, =_heap_end

heap_loop:
    cmp r0, r1
     4b0:	54524f50 	ldrbpl	r4, [r2], #-3920	; 0xfffff0b0
    itt     lt
    strlt   r2, [r0], #4
     4b4:	58554d5f 	ldmdapl	r5, {r0, r1, r2, r3, r4, r6, r8, sl, fp, lr}^
    blt     heap_loop
     4b8:	544c415f 	strbpl	r4, [ip], #-351	; 0xfffffea1
    ldr r0, =_stack_start
    ldr r1, =_stack_end
    ldr r2, =0xefefefef
*/

    ldr r0, =_stack_end
     4bc:	4f500032 	svcmi	0x00500032
    ldr r1, =_stack_start
    ldr r2, =0xefefefef
     4c0:	4d5f5452 	cfldrdmi	mvd5, [pc, #-328]	; 380 <_vector_rom+0x380>

stack_loop:
    cmp r0, r1
    itt     lt
     4c4:	415f5855 	cmpmi	pc, r5, asr r8	; <UNPREDICTABLE>
    strlt   r2, [r0], #4
     4c8:	0033544c 	eorseq	r5, r3, ip, asr #8
    blt     stack_loop
     4cc:	54524f50 	ldrbpl	r4, [r2], #-3920	; 0xfffff0b0

call_user_asm_code:
    bl main
     4d0:	58554d5f 	ldmdapl	r5, {r0, r1, r2, r3, r4, r6, r8, sl, fp, lr}^
    /*
     * Epilogue processing would go here.
     */

end_loop:
    b end_loop
     4d4:	544c415f 	strbpl	r4, [ip], #-351	; 0xfffffea1

    .align 2
    .thumb_func

_default_nmi_handler:
    b _default_nmi_handler
     4d8:	4f500034 	svcmi	0x00500034

    .align 2
    .thumb_func

_default_fault_handler:
    b _default_fault_handler
     4dc:	4d5f5452 	cfldrdmi	mvd5, [pc, #-328]	; 39c <_vector_rom+0x39c>

    .align 2
    .thumb_func

_default_irq_handler:
    b _default_irq_handler
     4e0:	415f5855 	cmpmi	pc, r5, asr r8	; <UNPREDICTABLE>
    .thumb_func

_default_reset_handler:

unlock_watchdog:
    ldr r6, =0x4005200e
     4e4:	0035544c 	eorseq	r5, r5, ip, asr #8
    ldr r0, =0xc520
     4e8:	54524f50 	ldrbpl	r4, [r2], #-3920	; 0xfffff0b0
    strh r0, [r6]
    ldr r0, =0xd928
     4ec:	58554d5f 	ldmdapl	r5, {r0, r1, r2, r3, r4, r6, r8, sl, fp, lr}^
    strh r0, [r6]

disable_watchdog:
    ldr r6, =0x40052000
     4f0:	544c415f 	strbpl	r4, [ip], #-351	; 0xfffffea1
    ldr r0, =0x01d2
     4f4:	4f500036 	svcmi	0x00500036
     * address 0x00000000 (which is the first element in the vector_table) by
     * the hardware. The next three lines are required in case this image
     * is not located at 0x0 (i.e. it is being launched from a bootloader).
     */

    ldr r1, =_vector_table
     4f8:	4d5f5452 	cfldrdmi	mvd5, [pc, #-328]	; 3b8 <_vector_rom+0x3b8>

chibi_setup:
    /*
     * ChibiOS requires a process stack to be initialized.
     */
    ldr r1, =_process_stack_start
     4fc:	415f5855 	cmpmi	pc, r5, asr r8	; <UNPREDICTABLE>

    /* TODO: FPU register initialization per crt0.c */
    /*
     * Set up system to run in privileged mode using the PSP stack
     */
    ldr r1, =0x00000002
     500:	0037544c 	eorseq	r5, r7, ip, asr #8
     * Relocate the .text section from FLASH to SRAM only if the load
     * address and the start address are not the same. This code supports
     * running an entire image out of SRAM.
     */

    ldr r0, =_text_start
     504:	6f697067 	svcvs	0x00697067
    ldr r1, =_text_end
     508:	67676f54 			; <UNDEFINED> instruction: 0x67676f54
    ldr r2, =_text_load
     50c:	6700656c 	strvs	r6, [r0, -ip, ror #10]

    /*
     * Relocate the .ramcode section from FLASH to SRAM.
     */

    ldr r0, =_ramcode_start
     510:	526f6970 	rsbpl	r6, pc, #112, 18	; 0x1c0000
    ldr r1, =_ramcode_end
     514:	00646165 	rsbeq	r6, r4, r5, ror #2
    ldr r2, =_ramcode_load
     518:	726f7370 	rsbvc	r7, pc, #112, 6	; 0xc0000001

    /*
     * Relocate vector table to SRAM.
     */

     ldr r0, =_vector_ram_start
     51c:	69706700 	ldmdbvs	r0!, {r8, r9, sl, sp, lr}^
     ldr r1, =_vector_ram_end
     520:	726f506f 	rsbvc	r5, pc, #111	; 0x6f
     ldr r2, =_vector_rom
     524:	4f500074 	svcmi	0x00500074

    /*
     * Point to the SRAM vector table.
     */

    ldr r1,=0xe000ed08
     528:	4d5f5452 	cfldrdmi	mvd5, [pc, #-328]	; 3e8 <_vector_rom+0x3e8>
     * Note: _data_start contains the SRAM (destination) address and
     *       _text_end contains the (source) address of the .data section
     *       in FLASH.
     */

    ldr r0, =_data_start
     52c:	415f5855 	cmpmi	pc, r5, asr r8	; <UNPREDICTABLE>
    ldr r1, =_data_end
     530:	4f4c414e 	svcmi	0x004c414e
    ldr r2, =_data_load
     534:	69700047 	ldmdbvs	r0!, {r0, r1, r2, r6}^

    /*
     * Zero out the .bss section in SRAM.
     */

    ldr r0, =_bss_start
     538:	7469426e 	strbtvc	r4, [r9], #-622	; 0xfffffd92
    ldr r1, =_bss_end
     53c:	69706700 	ldmdbvs	r0!, {r8, r9, sl, sp, lr}^
    ldr r2, =0x00000000
     540:	7465536f 	strbtvc	r5, [r5], #-879	; 0xfffffc91

    /*
     * Zero out heap.
     */

    ldr r0, =_heap_start
     544:	726f7000 	rsbvc	r7, pc, #0
    ldr r1, =_heap_end
     548:	72744374 	rsbsvc	r4, r4, #116, 6	; 0xd0000001
    ldr r0, =_stack_start
    ldr r1, =_stack_end
    ldr r2, =0xefefefef
*/

    ldr r0, =_stack_end
     54c:	7469426c 	strbtvc	r4, [r9], #-620	; 0xfffffd94
    ldr r1, =_stack_start
     550:	6f700073 	svcvs	0x00700073
    ldr r2, =0xefefefef
     554:	50007472 	andpl	r7, r0, r2, ror r4
     558:	5f54524f 	svcpl	0x0054524f
     55c:	5f58554d 	svcpl	0x0058554d
#define TSI_ORANGE_BIT    BIT_5

#define TSI_YELLOW_INDEX  8
#define TSI_YELLOW_BIT    BIT_8

void assert_(const char *file, const int line) { }
     560:	4f495047 	svcmi	0x00495047
     564:	6f747000 	svcvs	0x00747000
     568:	70670072 	rsbvc	r0, r7, r2, ror r0
     56c:	6f506f69 	svcvs	0x00506f69
     570:	65527472 	ldrbvs	r7, [r2, #-1138]	; 0xfffffb8e

static WORKING_AREA(waThread1, 128);
static msg_t Thread1(void *arg) {
     574:	50006461 	andpl	r6, r0, r1, ror #8
     578:	5f54524f 	svcpl	0x0054524f
    while (TRUE) {
        chThdSleepMilliseconds(500);
     57c:	5f58554d 	svcpl	0x0058554d
     580:	41534944 	cmpmi	r3, r4, asr #18
        gpioToggle(N_LED_YELLOW_PORT, N_LED_YELLOW_PIN);
     584:	44454c42 	strbmi	r4, [r5], #-3138	; 0xfffff3be
     588:	69706700 	ldmdbvs	r0!, {r8, r9, sl, sp, lr}^
     58c:	726f506f 	rsbvc	r5, pc, #111	; 0x6f
     590:	69725774 	ldmdbvs	r2!, {r2, r4, r5, r6, r8, r9, sl, ip, lr}^
    }
     594:	4d006574 	cfstr32mi	mvfx6, [r0, #-464]	; 0xfffffe30

    return 0;
}

static void clocksInit(void)
{
     598:	435f4743 	cmpmi	pc, #17563648	; 0x10c0000
     * System:  100 MHz
     * Bus:      50 MHz
     * Flexbus:  50 MHz
     * Flash:    25 MHz
     */
    clockSetDividers(DIVIDE_BY_1, DIVIDE_BY_2, DIVIDE_BY_4, DIVIDE_BY_4);
     59c:	52455f32 	subpl	r5, r5, #50, 30	; 0xc8
     5a0:	00534645 	subseq	r4, r3, r5, asr #12
     5a4:	73616c66 	cmnvc	r1, #26112	; 0x6600
     5a8:	76694468 	strbtvc	r4, [r9], -r8, ror #8
     5ac:	73756200 	cmnvc	r5, #0, 4
    clockConfigMcgOut(MCG_PLL_EXTERNAL_100MHZ);
     5b0:	00766944 	rsbseq	r6, r6, r4, asr #18
     5b4:	636f6c63 	cmnvs	pc, #25344	; 0x6300
}
     5b8:	6e6f436b 	cdpvs	3, 6, cr4, cr15, cr11, {3}

static void systickInit(void)
{
     5bc:	4d676966 	stclmi	9, cr6, [r7, #-408]!	; 0xfffffe68
     5c0:	6c466763 	mcrrvs	7, 6, r6, r6, cr3
    uint32_t freq = clockGetFreq(CLOCK_CORE);
     5c4:	2e2e006c 	cdpcs	0, 2, cr0, cr14, cr12, {3}
     5c8:	6168702f 	cmnvs	r8, pc, lsr #32

    NVIC_SYSTICK_RELOAD = freq / CH_FREQUENCY - 1;
     5cc:	5f326573 	svcpl	0x00326573
     5d0:	65626d65 	strbvs	r6, [r2, #-3429]!	; 0xfffff29b
     5d4:	64656464 	strbtvs	r6, [r5], #-1124	; 0xfffffb9c
     5d8:	632f635f 	teqvs	pc, #2080374785	; 0x7c000001
     5dc:	6b636f6c 	blvs	18dc394 <_flash_swap_addr+0x189cb94>
     5e0:	00632e73 	rsbeq	r2, r3, r3, ror lr
     5e4:	5f47434d 	svcpl	0x0047434d
     5e8:	4f4c5f53 	svcmi	0x004c5f53
    NVIC_SYSTICK_VALUE = 0;
     5ec:	63004b43 	movwvs	r4, #2883	; 0xb43
     5f0:	6b636f6c 	blvs	18dc3a8 <_flash_swap_addr+0x189cba8>
     5f4:	666e6f43 	strbtvs	r6, [lr], -r3, asr #30
     5f8:	734f6769 	movtvc	r6, #63337	; 0xf769
    NVIC_SYSTICK_CONTROL = NVIC_SYSTICK_CONTROL_ENABLE
     5fc:	6c630063 	stclvs	0, cr0, [r3], #-396	; 0xfffffe74
     600:	466b636f 	strbtmi	r6, [fp], -pc, ror #6
     604:	00716572 	rsbseq	r6, r1, r2, ror r5
                         | NVIC_SYSTICK_CONTROL_TICKINT
                         | NVIC_SYSTICK_CONTROL_CLKSOURCE;
}
     608:	5f47434d 	svcpl	0x0047434d
     60c:	495f3143 	ldmdbmi	pc, {r0, r1, r6, r8, ip, sp}^	; <UNPREDICTABLE>

int main(void)
{
     610:	4b4c4352 	blmi	1311360 <_flash_swap_addr+0x12d1b60>
     614:	4d004e45 	stcmi	14, cr4, [r0, #-276]	; 0xfffffeec
    clocksInit();
     618:	535f4743 	cmppl	pc, #17563648	; 0x10c0000
    systickInit();
     61c:	4552495f 	ldrbmi	r4, [r2, #-2399]	; 0xfffff6a1
    chSysInit();
     620:	00545346 	subseq	r5, r4, r6, asr #6

    gpioConfig(N_LED_ORANGE_PORT, N_LED_ORANGE_PIN, GPIO_OUTPUT | GPIO_LOW);
     624:	5f47434d 	svcpl	0x0047434d
     628:	495f3243 	ldmdbmi	pc, {r0, r1, r6, r9, ip, sp}^	; <UNPREDICTABLE>
     62c:	00534352 	subseq	r4, r3, r2, asr r3
     630:	32656566 	rsbcc	r6, r5, #427819008	; 0x19800000
     634:	00696566 	rsbeq	r6, r9, r6, ror #10
    gpioConfig(N_LED_YELLOW_PORT, N_LED_YELLOW_PIN, GPIO_OUTPUT | GPIO_LOW);
     638:	45444f4d 	strbmi	r4, [r4, #-3917]	; 0xfffff0b3
     63c:	504c425f 	subpl	r4, ip, pc, asr r2
     640:	6c630045 	stclvs	0, cr0, [r3], #-276	; 0xfffffeec
     644:	466b636f 	strbtmi	r6, [fp], -pc, ror #6
     648:	5f716572 	svcpl	0x00716572

    chThdCreateStatic(waThread1, sizeof(waThread1), NORMALPRIO, Thread1, NULL);
     64c:	434d0074 	movtmi	r0, #53364	; 0xd074
     650:	31435f47 	cmpcc	r3, r7, asr #30
     654:	4b4c435f 	blmi	13113d8 <_flash_swap_addr+0x12d1bd8>
     658:	414d5f53 	cmpmi	sp, r3, asr pc
     65c:	4d004b53 	vstrmi	d4, [r0, #-332]	; 0xfffffeb4
     660:	5f45444f 	svcpl	0x0045444f
     664:	49504c42 	ldmdbmi	r0, {r1, r6, sl, fp, lr}^
     668:	67636d00 	strbvs	r6, [r3, -r0, lsl #26]!

    hwInterruptsEnable();
     66c:	6600745f 			; <UNDEFINED> instruction: 0x6600745f

    while (TRUE) {
        chThdSleepMilliseconds(123);
     670:	53716572 	cmnpl	r1, #478150656	; 0x1c800000
     674:	6372756f 	cmnvs	r2, #465567744	; 0x1bc00000
        gpioToggle(N_LED_ORANGE_PORT, N_LED_ORANGE_PIN);
     678:	00745f65 	rsbseq	r5, r4, r5, ror #30
     67c:	5f47434d 	svcpl	0x0047434d
     680:	505f3543 	subspl	r3, pc, r3, asr #10
     684:	54534c4c 	ldrbpl	r4, [r3], #-3148	; 0xfffff3b4
*
* RETURNS: The corresponding GPIO_BASE_ADDR.
*
*******************************************************************************/
static volatile gpioPort_t *gpioPortGet(uint32_t port)
{
     688:	49004e45 	stmdbmi	r0, {r0, r2, r6, r9, sl, fp, lr}
     68c:	5245544e 	subpl	r5, r5, #1308622848	; 0x4e000000
    uint32_t addr;

    switch (port) {
     690:	5f4c414e 	svcpl	0x004c414e
     694:	484b3233 	stmdami	fp, {r0, r1, r4, r5, r9, ip, sp}^
     698:	6c62005a 	stclvs	0, cr0, [r2], #-360	; 0xfffffe98
     69c:	66326970 			; <UNDEFINED> instruction: 0x66326970
     6a0:	62006565 	andvs	r6, r0, #423624704	; 0x19400000
     6a4:	3269706c 	rsbcc	r7, r9, #108	; 0x6c
     6a8:	00696566 	rsbeq	r6, r9, r6, ror #10
     6ac:	636f6c63 	cmnvs	pc, #25344	; 0x6300
     6b0:	6e6f436b 	cdpvs	3, 6, cr4, cr15, cr11, {3}
     6b4:	4d676966 	stclmi	9, cr6, [r7, #-408]!	; 0xfffffe68
     6b8:	754f6763 	strbvc	r6, [pc, #-1891]	; ffffff5d <_stack_start+0xdffeff5d>
     6bc:	6c630074 	stclvs	0, cr0, [r3], #-464	; 0xfffffe30
     6c0:	436b636f 	cmnmi	fp, #-1140850687	; 0xbc000001
     6c4:	69666e6f 	stmdbvs	r6!, {r0, r1, r2, r3, r5, r6, r9, sl, fp, sp, lr}^
     6c8:	67634d67 	strbvs	r4, [r3, -r7, ror #26]!
     6cc:	006c6c50 	rsbeq	r6, ip, r0, asr ip
     6d0:	5f58414d 	svcpl	0x0058414d
     6d4:	45444f4d 	strbmi	r4, [r4, #-3917]	; 0xfffff0b3
     6d8:	434d0053 	movtmi	r0, #53331	; 0xd053
     6dc:	36435f47 	strbcc	r5, [r3], -r7, asr #30
    case PORTA: addr = GPIOA_BASE_ADDR; break;
     6e0:	4944565f 	stmdbmi	r4, {r0, r1, r2, r3, r4, r6, r9, sl, ip, lr}^
     6e4:	414d5f56 	cmpmi	sp, r6, asr pc
     6e8:	66004b53 			; <UNDEFINED> instruction: 0x66004b53
    case PORTB: addr = GPIOB_BASE_ADDR; break;
     6ec:	53716572 	cmnpl	r1, #478150656	; 0x1c800000
     6f0:	6372756f 	cmnvs	r2, #465567744	; 0x1bc00000
     6f4:	6c630065 	stclvs	0, cr0, [r3], #-404	; 0xfffffe6c
    case PORTC: addr = GPIOC_BASE_ADDR; break;
     6f8:	476b636f 	strbmi	r6, [fp, -pc, ror #6]!
     6fc:	72467465 	subvc	r7, r6, #1694498816	; 0x65000000
     700:	66007165 	strvs	r7, [r0], -r5, ror #2
    case PORTD: addr = GPIOD_BASE_ADDR; break;
     704:	70326565 	eorsvc	r6, r2, r5, ror #10
     708:	4d006565 	cfstr32mi	mvfx6, [r0, #-404]	; 0xfffffe6c
     70c:	435f4743 	cmpmi	pc, #17563648	; 0x10c0000
    case PORTE: addr = GPIOE_BASE_ADDR; break;
     710:	52445f34 	subpl	r5, r4, #52, 30	; 0xd0
     714:	445f5453 	ldrbmi	r5, [pc], #-1107	; 71c <gpioPortGet+0x94>
     718:	4d5f5352 	ldclmi	3, cr5, [pc, #-328]	; 5d8 <systickInit+0x1c>
    default:
        assert(0);
     71c:	004b5341 	subeq	r5, fp, r1, asr #6
     720:	5367636d 	cmnpl	r7, #-1275068415	; 0xb4000001
     724:	65746174 	ldrbvs	r6, [r4, #-372]!	; 0xfffffe8c
     728:	47434d00 	strbmi	r4, [r3, -r0, lsl #26]
        return 0;
     72c:	495f535f 	ldmdbmi	pc, {r0, r1, r2, r3, r4, r6, r8, r9, ip, lr}^	; <UNPREDICTABLE>
    }

    return ((volatile gpioPort_t *) addr);
     730:	54534352 	ldrbpl	r4, [r3], #-850	; 0xfffffcae
}
     734:	65656600 	strbvs	r6, [r5, #-1536]!	; 0xfffffa00
     738:	706c6232 	rsbvc	r6, ip, r2, lsr r2
*
* RETURNS: Nothing
*
*******************************************************************************/
void gpioConfig(uint32_t port, uint32_t pin, uint32_t opt)
{
     73c:	6c620065 	stclvs	0, cr0, [r2], #-404	; 0xfffffe6c
     740:	62326970 	eorsvs	r6, r2, #112, 18	; 0x1c0000
     744:	0065706c 	rsbeq	r7, r5, ip, rrx
    /*
     * Ensure pin number is legal
     */

    assert((pin < 32));
     748:	32656566 	rsbcc	r6, r5, #427819008	; 0x19800000
     74c:	69706c62 	ldmdbvs	r0!, {r1, r5, r6, sl, fp, sp, lr}^
     750:	444f4d00 	strbmi	r4, [pc], #-3328	; 758 <gpioConfig+0x1c>
     754:	42465f45 	submi	r5, r6, #276	; 0x114
     758:	4f4d0045 	svcmi	0x004d0045
     75c:	465f4544 	ldrbmi	r4, [pc], -r4, asr #10

    /*
     * Config the SIM Clock Gate
     */

    switch (port) {
     760:	6f004942 	svcvs	0x00004942
     764:	745f6373 	ldrbvc	r6, [pc], #-883	; 76c <gpioConfig+0x30>
     768:	72756300 	rsbsvc	r6, r5, #0, 6
     76c:	746e6572 	strbtvc	r6, [lr], #-1394	; 0xfffffa8e
     770:	65646f4d 	strbvs	r6, [r4, #-3917]!	; 0xfffff0b3
     774:	67636d00 	strbvs	r6, [r3, -r0, lsl #26]!
     778:	636f6c43 	cmnvs	pc, #17152	; 0x4300
     77c:	6c63006b 	stclvs	0, cr0, [r3], #-428	; 0xfffffe54
     780:	436b636f 	cmnmi	fp, #-1140850687	; 0xbc000001
     784:	69666e6f 	stmdbvs	r6!, {r0, r1, r2, r3, r5, r6, r9, sl, fp, sp, lr}^
     788:	67634d67 	strbvs	r4, [r3, -r7, ror #26]!
     78c:	62007249 	andvs	r7, r0, #-1879048188	; 0x90000004
     790:	3269706c 	rsbcc	r7, r9, #108	; 0x6c
     794:	00656570 	rsbeq	r6, r5, r0, ror r5
     798:	32696566 	rsbcc	r6, r9, #427819008	; 0x19800000
     79c:	65706c62 	ldrbvs	r6, [r0, #-3170]!	; 0xfffff39e
     7a0:	69656600 	stmdbvs	r5!, {r9, sl, sp, lr}^
     7a4:	706c6232 	rsbvc	r6, ip, r2, lsr r2
     7a8:	74720069 	ldrbtvc	r0, [r2], #-105	; 0xffffff97
    case PORTA: SIM_SCGC5 |= SIM_SCGC5_PORTA_ENABLE; break;
     7ac:	00745f63 	rsbseq	r5, r4, r3, ror #30
     7b0:	69766964 	ldmdbvs	r6!, {r2, r5, r6, r8, fp, sp, lr}^
     7b4:	5f726564 	svcpl	0x00726564
     7b8:	74610074 	strbtvc	r0, [r1], #-116	; 0xffffff8c
     7bc:	00687663 	rsbeq	r7, r8, r3, ror #12
     7c0:	636f6c63 	cmnvs	pc, #25344	; 0x6300
     7c4:	6e6f436b 	cdpvs	3, 6, cr4, cr15, cr11, {3}
    case PORTB: SIM_SCGC5 |= SIM_SCGC5_PORTB_ENABLE; break;
     7c8:	50676966 	rsbpl	r6, r7, r6, ror #18
     7cc:	6d617261 	sfmvs	f7, 2, [r1, #-388]!	; 0xfffffe7c
     7d0:	6300745f 	movwvs	r7, #1119	; 0x45f
     7d4:	6b636f6c 	blvs	18dc58c <_flash_swap_addr+0x189cd8c>
     7d8:	666e6f43 	strbtvs	r6, [lr], -r3, asr #30
     7dc:	61506769 	cmpvs	r0, r9, ror #14
    case PORTC: SIM_SCGC5 |= SIM_SCGC5_PORTC_ENABLE; break;
     7e0:	006d6172 	rsbeq	r6, sp, r2, ror r1
     7e4:	636f6c63 	cmnvs	pc, #25344	; 0x6300
     7e8:	6765526b 	strbvs	r5, [r5, -fp, ror #4]!
     7ec:	4d00745f 	cfstrsmi	mvf7, [r0, #-380]	; 0xfffffe84
     7f0:	435f4743 	cmpmi	pc, #17563648	; 0x10c0000
     7f4:	52505f35 	subspl	r5, r0, #53, 30	; 0xd4
     7f8:	5f564944 	svcpl	0x00564944
    case PORTD: SIM_SCGC5 |= SIM_SCGC5_PORTD_ENABLE; break;
     7fc:	4b53414d 	blmi	14d0d38 <_flash_swap_addr+0x1491538>
     800:	706c6200 	rsbvc	r6, ip, r0, lsl #4
     804:	65703265 	ldrbvs	r3, [r0, #-613]!	; 0xfffffd9b
     808:	756d0065 	strbvc	r0, [sp, #-101]!	; 0xffffff9b
     80c:	7069746c 	rsbvc	r7, r9, ip, ror #8
     810:	7265696c 	rsbvc	r6, r5, #108, 18	; 0x1b0000
    case PORTE: SIM_SCGC5 |= SIM_SCGC5_PORTE_ENABLE; break;
     814:	6f6c6300 	svcvs	0x006c6300
     818:	6f536b63 	svcvs	0x00536b63
     81c:	65637275 	strbvs	r7, [r3, #-629]!	; 0xfffffd8b
     820:	7300745f 	movwvc	r7, #1119	; 0x45f
     824:	65747379 	ldrbvs	r7, [r4, #-889]!	; 0xfffffc87
     828:	7669446d 	strbtvc	r4, [r9], -sp, ror #8
     82c:	656c6600 	strbvs	r6, [ip, #-1536]!	; 0xfffffa00
    default:
        assert(0);
     830:	73754278 	cmnvc	r5, #120, 4	; 0x80000007
     834:	00766944 	rsbseq	r6, r6, r4, asr #18
     838:	5f47434d 	svcpl	0x0047434d
     83c:	485f3243 	ldmdami	pc, {r0, r1, r6, r9, ip, sp}^	; <UNPREDICTABLE>

    /*
     * Configure the Port Controller
     */

    uint32_t portCtrlBits = PORT_MUX_GPIO;
     840:	62004f47 	andvs	r4, r0, #284	; 0x11c
     844:	3265706c 	rsbcc	r7, r5, #108	; 0x6c

    if (opt & GPIO_OUTPUT) {
     848:	69706c62 	ldmdbvs	r0!, {r1, r5, r6, sl, fp, sp, lr}^
     84c:	65657000 	strbvs	r7, [r5, #-0]!
        if (opt & GPIO_ODE) {
     850:	65656632 	strbvs	r6, [r5, #-1586]!	; 0xfffff9ce
     854:	6f6c6300 	svcvs	0x006c6300
     858:	6f436b63 	svcvs	0x00436b63
            portCtrlBits |= PORT_ODE;
     85c:	6769666e 	strbvs	r6, [r9, -lr, ror #12]!
     860:	6f6c6300 	svcvs	0x006c6300
        } else {
            if (opt & GPIO_DSE)
     864:	7a486b63 	bvc	121b5f8 <_flash_swap_addr+0x11dbdf8>
     868:	47434d00 	strbmi	r4, [r3, -r0, lsl #26]
     86c:	5f33435f 	svcpl	0x0033435f
                portCtrlBits |= PORT_DSE;
     870:	52544353 	subspl	r4, r4, #1275068417	; 0x4c000001
     874:	4d5f4d49 	ldclmi	13, cr4, [pc, #-292]	; 758 <gpioConfig+0x1c>
        }

    } else if (opt & GPIO_INPUT) {
     878:	004b5341 	subeq	r5, fp, r1, asr #6
     87c:	5f47434d 	svcpl	0x0047434d
     880:	4c435f53 	mcrrmi	15, 5, r5, r3, cr3
        if (opt & GPIO_PFE)
     884:	5f54534b 	svcpl	0x0054534b
     888:	4b53414d 	blmi	14d0dc4 <_flash_swap_addr+0x14915c4>
     88c:	47434d00 	strbmi	r4, [r3, -r0, lsl #26]
            portCtrlBits |= PORT_PFE;
     890:	5f31435f 	svcpl	0x0031435f
     894:	49445246 	stmdbmi	r4, {r1, r2, r6, r9, ip, lr}^

    } else {
        assert(0);
     898:	414d5f56 	cmpmi	sp, r6, asr pc
     89c:	66004b53 			; <UNDEFINED> instruction: 0x66004b53
     8a0:	66326965 	ldrtvs	r6, [r2], -r5, ror #18
     8a4:	6d006565 	cfstr32vs	mvfx6, [r0, #-404]	; 0xfffffe6c
        return;
     8a8:	74536763 	ldrbvc	r6, [r3], #-1891	; 0xfffff89d
    }

    if (opt & GPIO_PULLUP)
     8ac:	5f657461 	svcpl	0x00657461
     8b0:	6c630074 	stclvs	0, cr0, [r3], #-464	; 0xfffffe30
        portCtrlBits |= PORT_PULLUP_ENABLE;
     8b4:	436b636f 	cmnmi	fp, #-1140850687	; 0xbc000001
     8b8:	69666e6f 	stmdbvs	r6!, {r0, r1, r2, r3, r5, r6, r9, sl, fp, sp, lr}^
     8bc:	63745267 	cmnvs	r4, #1879048198	; 0x70000006
    else if (opt & GPIO_PULLDOWN)
     8c0:	6f6c6300 	svcvs	0x006c6300
     8c4:	6f436b63 	svcvs	0x00436b63
        portCtrlBits |= PORT_PULLDOWN_ENABLE;
     8c8:	6769666e 	strbvs	r6, [r9, -lr, ror #12]!
     8cc:	006f704c 	rsbeq	r7, pc, ip, asr #32

    PORT_PCR(port, pin) = portCtrlBits;
     8d0:	45545845 	ldrbmi	r5, [r4, #-2117]	; 0xfffff7bb
     8d4:	4c414e52 	mcrrmi	14, 5, r4, r1, cr2
     8d8:	43534f5f 	cmpmi	r3, #380	; 0x17c
     8dc:	4d30355f 	cfldr32mi	mvfx3, [r0, #-380]!	; 0xfffffe84

    /*
     * Configure the GPIO Controller
     */

    volatile gpioPort_t *gpioPort = gpioPortGet(port);
     8e0:	63005a48 	movwvs	r5, #2632	; 0xa48
     8e4:	6b636f6c 	blvs	18dc69c <_flash_swap_addr+0x189ce9c>
    uint32_t pinBit = 1 << pin;
     8e8:	65646f4d 	strbvs	r6, [r4, #-3917]!	; 0xfffff0b3
     8ec:	78656e00 	stmdavc	r5!, {r9, sl, fp, sp, lr}^
     8f0:	646f4d74 	strbtvs	r4, [pc], #-3444	; 8f8 <STACK_SIZE+0xf8>

    if (opt & GPIO_OUTPUT) {
     8f4:	434d0065 	movtmi	r0, #53349	; 0xd065
     8f8:	36435f47 	strbcc	r5, [r3], -r7, asr #30
        gpioPort->pddr |= pinBit;
     8fc:	4c4c505f 	mcrrmi	0, 5, r5, ip, cr15
     900:	6c630053 	stclvs	0, cr0, [r3], #-332	; 0xfffffeb4
     904:	4d6b636f 	stclmi	3, cr6, [fp, #-444]!	; 0xfffffe44
        if (opt & GPIO_HIGH)
     908:	5f65646f 	svcpl	0x0065646f
     90c:	6c620074 	stclvs	0, cr0, [r2], #-464	; 0xfffffe30
     910:	66326570 			; <UNDEFINED> instruction: 0x66326570
            gpioPort->psor |= pinBit;
     914:	4d006565 	cfstr32mi	mvfx6, [r0, #-404]	; 0xfffffe6c
     918:	5f45444f 	svcpl	0x0045444f
     91c:	00454250 	subeq	r4, r5, r0, asr r2
        else if (opt & GPIO_LOW)
     920:	45444f4d 	strbmi	r4, [r4, #-3917]	; 0xfffff0b3
     924:	4f54535f 	svcmi	0x0054535f
     928:	434d0050 	movtmi	r0, #53328	; 0xd050
            gpioPort->pcor |= pinBit;
     92c:	5f535f47 	svcpl	0x00535f47
     930:	4943534f 	stmdbmi	r3, {r0, r1, r2, r3, r6, r8, r9, ip, lr}^
     934:	0054494e 	subseq	r4, r4, lr, asr #18
    }
}
     938:	5f47434d 	svcpl	0x0047434d
     93c:	435f3643 	cmpmi	pc, #70254592	; 0x4300000

/*******************************************************************************
* gpioSet
*******************************************************************************/
void gpioSet(uint32_t port, uint32_t pin)
{
     940:	6300454d 	movwvs	r4, #1357	; 0x54d
     944:	6b636f6c 	blvs	18dc6fc <_flash_swap_addr+0x189cefc>
     948:	666e6f43 	strbtvs	r6, [lr], -r3, asr #30
    volatile gpioPort_t *gpioPort = gpioPortGet(port);
     94c:	745f6769 	ldrbvc	r6, [pc], #-1897	; 954 <gpioSet+0x14>
     950:	444f4d00 	strbmi	r4, [pc], #-3328	; 958 <gpioSet+0x18>
    gpioPort->psor = 1 << pin;
     954:	45465f45 	strbmi	r5, [r6, #-3909]	; 0xfffff0bb
     958:	6c630045 	stclvs	0, cr0, [r3], #-276	; 0xfffffeec
     95c:	536b636f 	cmnpl	fp, #-1140850687	; 0xbc000001
     960:	69447465 	stmdbvs	r4, {r0, r2, r5, r6, sl, ip, sp, lr}^
}
     964:	65646976 	strbvs	r6, [r4, #-2422]!	; 0xfffff68a
     968:	4d007372 	stcmi	3, cr7, [r0, #-456]	; 0xfffffe38

/*******************************************************************************
* gpioClear
*******************************************************************************/
void gpioClear(uint32_t port, uint32_t pin)
{
     96c:	5f45444f 	svcpl	0x0045444f
     970:	00494546 	subeq	r4, r9, r6, asr #10
     974:	5f47434d 	svcpl	0x0047434d
    volatile gpioPort_t *gpioPort = gpioPortGet(port);
     978:	4c505f53 	mrrcmi	15, 5, r5, r0, cr3
     97c:	0054534c 	subseq	r5, r4, ip, asr #6
    gpioPort->pcor = 1 << pin;
     980:	5f47434d 	svcpl	0x0047434d
     984:	4c5f3643 	mrrcmi	6, 4, r3, pc, cr3	; <UNPREDICTABLE>
     988:	45494c4f 	strbmi	r4, [r9, #-3151]	; 0xfffff3b1
     98c:	47434d00 	strbmi	r4, [r3, -r0, lsl #26]
}
     990:	5f34435f 	svcpl	0x0034435f
     994:	52544346 	subspl	r4, r4, #402653185	; 0x18000001

/*******************************************************************************
* gpioToggle
*******************************************************************************/
void gpioToggle(uint32_t port, uint32_t pin)
{
     998:	4d5f4d49 	ldclmi	13, cr4, [pc, #-292]	; 87c <STACK_SIZE+0x7c>
     99c:	004b5341 	subeq	r5, fp, r1, asr #6
     9a0:	5f47434d 	svcpl	0x0047434d
    volatile gpioPort_t *gpioPort = gpioPortGet(port);
     9a4:	4f4c5f53 	svcmi	0x004c5f53
     9a8:	6a00534c 	bvs	156e0 <_data_load+0x129f0>
    gpioPort->ptor = 1 << pin;
     9ac:	54706d75 	ldrbtpl	r6, [r0], #-3445	; 0xfffff28b
     9b0:	656c6261 	strbvs	r6, [ip, #-609]!	; 0xfffffd9f
     9b4:	47434d00 	strbmi	r4, [r3, -r0, lsl #26]
     9b8:	5f32435f 	svcpl	0x0032435f
}
     9bc:	6600504c 	strvs	r5, [r0], -ip, asr #32
     9c0:	70326965 	eorsvc	r6, r2, r5, ror #18
*
* RETURNS:
*
*******************************************************************************/
void gpioPortWrite(uint32_t port, uint32_t mask, uint32_t value)
{
     9c4:	63006565 	movwvs	r6, #1381	; 0x565
     9c8:	6b636f6c 	blvs	18dc780 <_flash_swap_addr+0x189cf80>
     9cc:	666e6f43 	strbtvs	r6, [lr], -r3, asr #30
}
     9d0:	634d6769 	movtvs	r6, #55145	; 0xd769
     9d4:	00664667 	rsbeq	r4, r6, r7, ror #12
     9d8:	5f47434d 	svcpl	0x0047434d
*
* RETURNS:
*
*******************************************************************************/
uint32_t gpioPortRead(uint32_t port)
{
     9dc:	495f3143 	ldmdbmi	pc, {r0, r1, r6, r8, ip, sp}^	; <UNPREDICTABLE>
     9e0:	53464552 	movtpl	r4, #25938	; 0x6552
    return 0;
     9e4:	004e4554 	subeq	r4, lr, r4, asr r5
}
     9e8:	756e755f 	strbvc	r7, [lr, #-1375]!	; 0xfffffaa1
     9ec:	31646573 	smccc	18003	; 0x4653
     9f0:	6e755f00 	cdpvs	15, 7, cr5, cr5, cr0, {0}
*
* RETURNS:
*
*******************************************************************************/
uint32_t gpioRead(uint32_t port, uint32_t pin)
{
     9f4:	64657375 	strbtvs	r7, [r5], #-885	; 0xfffffc8b
     9f8:	434d0032 	movtmi	r0, #53298	; 0xd032
     9fc:	34435f47 	strbcc	r5, [r3], #-3911	; 0xfffff0b9
    volatile gpioPort_t *gpioPort = gpioPortGet(port);
     a00:	584d445f 	stmdapl	sp, {r0, r1, r2, r3, r4, r6, sl, lr}^
     a04:	70003233 	andvc	r3, r0, r3, lsr r2
    return ((gpioPort->pdir & (1 << pin)) ? TRUE : FALSE);
     a08:	66326565 	ldrtvs	r6, [r2], -r5, ror #10
     a0c:	4d006965 	stcmi	9, cr6, [r0, #-404]	; 0xfffffe6c
     a10:	435f4743 	cmpmi	pc, #17563648	; 0x10c0000
     a14:	41525f32 	cmpmi	r2, r2, lsr pc
     a18:	5f45474e 	svcpl	0x0045474e
     a1c:	4b53414d 	blmi	14d0f58 <_flash_swap_addr+0x1491758>
}
     a20:	6f6c6300 	svcvs	0x006c6300
     a24:	6f436b63 	svcvs	0x00436b63
    .flashDiv     = FLASH_DIVIDER_DFLT,
};


static void fei2fee(clockConfig_t cc)
{
     a28:	6769666e 	strbvs	r6, [r9, -lr, ror #12]!
     a2c:	3363734f 	cmncc	r3, #1006632961	; 0x3c000001
     a30:	75006b32 	strvc	r6, [r0, #-2866]	; 0xfffff4ce
     * Uno problemo: The largest divide factor available by FRDIV is 1024... And
     * 50MHz / 1024 = 48.3 kHz, which exceeds the 39.0625 kHz range. With our
     * setup, it doesn't seem that we can reach a FEE mode (and I don't want to
     * risk the tower to see what could happen if I did!)
     */
}
     a34:	38746e69 	ldmdacc	r4!, {r0, r3, r5, r6, r9, sl, fp, sp, lr}^
     a38:	4d00745f 	cfstrsmi	mvf7, [r0, #-380]	; 0xfffffe84

static void fei2pee(clockConfig_t cc)
{
     a3c:	435f4743 	cmpmi	pc, #17563648	; 0x10c0000
     a40:	43535f34 	cmpmi	r3, #52, 30	; 0xd0
     a44:	49525446 	ldmdbmi	r2, {r1, r2, r6, sl, ip, lr}^
                                                    /* External crystal setup */
    /* Select the OSCCLK */
    SIM_SOPT2 &= ~SIM_SOPT2_MCGCLKSEL;
     a48:	636d004d 	cmnvs	sp, #77	; 0x4d
     a4c:	6f6c4367 	svcvs	0x006c4367
     a50:	72466b63 	subvc	r6, r6, #101376	; 0x18c00
     a54:	4d007165 	stfmis	f7, [r0, #-404]	; 0xfffffe6c
     a58:	435f4743 	cmpmi	pc, #17563648	; 0x10c0000
     a5c:	52495f31 	subpl	r5, r9, #49, 30	; 0xc4
     * Enabling the XTAL for 50MHz
     * RANGE=1, match the frequency of the crystal being used
     * HGO=1,   set for high gain operation (best against noise)
     * EREFS=1, enable the external oscillator
     */
    clock.mcg->c2 = (MCG_C2_RANGE_MASK & (0x1 << 4)) |
     a60:	00534645 	subseq	r4, r3, r5, asr #12
     a64:	69766964 	ldmdbvs	r6!, {r2, r5, r6, r8, fp, sp, lr}^
     a68:	00726564 	rsbseq	r6, r2, r4, ror #10
     a6c:	76637461 	strbtvc	r7, [r3], -r1, ror #8
     * mode from FBE (here we are going to PEE)
     *
     * IREFS=0, select external reference clock and enable the external
     * oscillator.
     */
    clock.mcg->c1 = ((MCG_C1_CLKS_MASK & (0x2 << 6)) |
     a70:	755f006c 	ldrbvc	r0, [pc, #-108]	; a0c <gpioRead+0x18>
     a74:	6573756e 	ldrbvs	r7, [r3, #-1390]!	; 0xfffffa92
     a78:	434d0064 	movtmi	r0, #53348	; 0xd064
     a7c:	35435f47 	strbcc	r5, [r3, #-3911]	; 0xfffff0b9
                    (MCG_C1_FRDIV_MASK & (0x3 << 3))) &
                    (~MCG_C1_IREFS);

                                                    /* Wait for status update */
    /* Wait for oscillator to initialize */
    while (!(clock.mcg->s & MCG_S_OSCINIT)) {}
     a80:	4c4c505f 	mcrrmi	0, 5, r5, ip, cr15
     a84:	454b4c43 	strbmi	r4, [fp, #-3139]	; 0xfffff3bd
     a88:	6c62004e 	stclvs	0, cr0, [r2], #-312	; 0xfffffec8
     a8c:	66326570 			; <UNDEFINED> instruction: 0x66326570
     a90:	63006965 	movwvs	r6, #2405	; 0x965
     a94:	6b636f6c 	blvs	18dc84c <_flash_swap_addr+0x189d04c>
    /* Wait for reference clock's to become the external reference */
    while (clock.mcg->s & MCG_S_IREFST) {}
     a98:	666e6f43 	strbtvs	r6, [lr], -r3, asr #30
     a9c:	72456769 	subvc	r6, r5, #27525120	; 0x1a40000
     aa0:	006b3233 	rsbeq	r3, fp, r3, lsr r2
     aa4:	32656570 	rsbcc	r6, r5, #112, 10	; 0x1c000000
     aa8:	65706c62 	ldrbvs	r6, [r0, #-3170]!	; 0xfffff39e
     aac:	65657000 	strbvs	r7, [r5, #-0]!
    /* Wait for the indicator that MCGOTUCLK is fed by the external ref clock */
    while ((clock.mcg->s & MCG_S_CLKST_MASK) != (0x2 << 2)) {}
     ab0:	706c6232 	rsbvc	r6, ip, r2, lsr r2
     ab4:	6c630069 	stclvs	0, cr0, [r3], #-420	; 0xfffffe5c
     ab8:	006b636f 	rsbeq	r6, fp, pc, ror #6
     abc:	45444f4d 	strbmi	r4, [r4, #-3917]	; 0xfffff0b3
     ac0:	4545505f 	strbmi	r5, [r5, #-95]	; 0xffffffa1
     ac4:	4f445700 	svcmi	0x00445700

                                            /* Generate correct PLL frequency */
    clock.mcg->c5 &= 0xE0; /* clear bits */
     ac8:	49445f47 	stmdbmi	r4, {r0, r1, r2, r6, r8, r9, sl, fp, ip, lr}^
     acc:	53455453 	movtpl	r5, #21587	; 0x5453
     ad0:	44570054 	ldrbmi	r0, [r7], #-84	; 0xffffffac
     ad4:	495f474f 	ldmdbmi	pc, {r0, r1, r2, r3, r6, r8, r9, sl, lr}^	; <UNPREDICTABLE>
     ad8:	53525152 	cmppl	r2, #-2147483628	; 0x80000014
     adc:	004e4554 	subeq	r4, lr, r4, asr r5
     ae0:	74437473 	strbvc	r7, [r3], #-1139	; 0xfffffb8d
     ae4:	00486c72 	subeq	r6, r8, r2, ror ip
    clock.mcg->c5 |= clockConfigParam[cc].divider;
     ae8:	74437473 	strbvc	r7, [r3], #-1139	; 0xfffffb8d
     aec:	004c6c72 	subeq	r6, ip, r2, ror ip
     af0:	474f4457 	smlsldmi	r4, pc, r7, r4	; <UNPREDICTABLE>
     af4:	4e54535f 	mrcmi	3, 2, r5, cr4, cr15, {2}
     af8:	45594244 	ldrbmi	r4, [r9, #-580]	; 0xfffffdbc
     afc:	6177004e 	cmnvs	r7, lr, asr #32
     b00:	44686374 	strbtmi	r6, [r8], #-884	; 0xfffffc8c
     b04:	6944676f 	stmdbvs	r4, {r0, r1, r2, r3, r5, r6, r8, r9, sl, sp, lr}^
     b08:	6c626173 	stfvse	f6, [r2], #-460	; 0xfffffe34
     b0c:	61770065 	cmnvs	r7, r5, rrx
     b10:	44686374 	strbtmi	r6, [r8], #-884	; 0xfffffc8c
     b14:	694b676f 	stmdbvs	fp, {r0, r1, r2, r3, r5, r6, r8, r9, sl, sp, lr}^
    clock.mcg->c6 &= 0xE0;
     b18:	70006b63 	andvc	r6, r0, r3, ror #22
     b1c:	63736572 	cmnvs	r3, #478150656	; 0x1c800000
     b20:	72656c61 	rsbvc	r6, r5, #24832	; 0x6100
     b24:	566f7400 	strbtpl	r7, [pc], -r0, lsl #8
     b28:	00486c61 	subeq	r6, r8, r1, ror #24
     b2c:	474f4457 	smlsldmi	r4, pc, r7, r4	; <UNPREDICTABLE>
     b30:	4c4c415f 	stfmie	f4, [ip], {95}	; 0x5f
     b34:	5055574f 	subspl	r5, r5, pc, asr #14
    clock.mcg->c6 |= clockConfigParam[cc].multiplier;
     b38:	45544144 	ldrbmi	r4, [r4, #-324]	; 0xfffffebc
     b3c:	74617700 	strbtvc	r7, [r1], #-1792	; 0xfffff900
     b40:	6f446863 	svcvs	0x00446863
     b44:	6e6f4367 	cdpvs	3, 6, cr4, cr15, cr7, {3}
     b48:	5f676966 	svcpl	0x00676966
     b4c:	6f740074 	svcvs	0x00740074
     b50:	4c6c6156 	stfmie	f6, [ip], #-344	; 0xfffffea8
     b54:	4f445700 	svcmi	0x00445700
     b58:	42445f47 	submi	r5, r4, #284	; 0x11c
     b5c:	004e4547 	subeq	r4, lr, r7, asr #10
     b60:	474f4457 	smlsldmi	r4, pc, r7, r4	; <UNPREDICTABLE>
     b64:	5345545f 	movtpl	r5, #21599	; 0x545f
                                                            /* Enter PBE mode */
    /* PLLS=1, select the PLL. */
    clock.mcg->c6 |= MCG_C6_PLLS;
     b68:	61770054 	cmnvs	r7, r4, asr r0
     b6c:	44686374 	strbtmi	r6, [r8], #-884	; 0xfffffc8c
     b70:	745f676f 	ldrbvc	r6, [pc], #-1903	; b78 <fei2pee+0x13c>
     b74:	4f445700 	svcmi	0x00445700
     b78:	45545f47 	ldrbmi	r5, [r4, #-3911]	; 0xfffff0b9
     b7c:	45535453 	ldrbmi	r5, [r3, #-1107]	; 0xfffffbad
     b80:	6177004c 	cmnvs	r7, ip, asr #32
     b84:	44686374 	strbtmi	r6, [r8], #-884	; 0xfffffc8c

                                                    /* Wait for status update */
    /* Wait for the PLL to be the clock source */
    while (!(clock.mcg->s & MCG_S_PLLST)) {}
     b88:	6e49676f 	cdpvs	7, 4, cr6, cr9, cr15, {3}
     b8c:	57007469 	strpl	r7, [r0, -r9, ror #8]
     b90:	5f474f44 	svcpl	0x00474f44
     b94:	54494157 	strbpl	r4, [r9], #-343	; 0xfffffea9
     b98:	77004e45 	strvc	r4, [r0, -r5, asr #28]
     b9c:	00486e69 	subeq	r6, r8, r9, ror #28
    /* Wait until the PLL has acquired lock on the external frequency */
    while (!(clock.mcg->s & MCG_S_LOCK)) {}
     ba0:	4c6e6977 	stclmi	9, cr6, [lr], #-476	; 0xfffffe24
     ba4:	4f445700 	svcmi	0x00445700
     ba8:	4e455f47 	cdpmi	15, 4, cr5, cr5, cr7, {2}
     bac:	43647700 	cmnmi	r4, #0, 14
     bb0:	74506766 	ldrbvc	r6, [r0], #-1894	; 0xfffff89a
     bb4:	65720072 	ldrbvs	r0, [r2, #-114]!	; 0xffffff8e

                                                            /* Enter PEE mode */
    /* Select the output of the PLL */
    clock.mcg->c1 &= ~MCG_C1_CLKS_MASK;
     bb8:	73657266 	cmnvc	r5, #1610612742	; 0x60000006
     bbc:	69740068 	ldmdbvs	r4!, {r3, r5, r6}^
     bc0:	756f656d 	strbvc	r6, [pc, #-1389]!	; 65b <main+0x4b>
     bc4:	44570074 	ldrbmi	r0, [r7], #-116	; 0xffffff8c
     bc8:	535f474f 	cmppl	pc, #20709376	; 0x13c0000
     bcc:	45504f54 	ldrbmi	r4, [r0, #-3924]	; 0xfffff0ac
     bd0:	6e69004e 	cdpvs	0, 6, cr0, cr9, cr14, {2}
     bd4:	72726574 	rsbsvc	r6, r2, #116, 10	; 0x1d000000

                                                    /* Wait for status update */
    /* Wait until output of the PLL is selected */
    while ((clock.mcg->s & MCG_S_CLKST_MASK) != (0x3 << 2)) {}
     bd8:	45747075 	ldrbmi	r7, [r4, #-117]!	; 0xffffff8b
     bdc:	6c62616e 	stfvse	f6, [r2], #-440	; 0xfffffe48
     be0:	44570065 	ldrbmi	r0, [r7], #-101	; 0xffffff9b
     be4:	425f474f 	subsmi	r4, pc, #20709376	; 0x13c0000
     be8:	53455459 	movtpl	r5, #21593	; 0x5459
     bec:	4c45535f 	mcrrmi	3, 5, r5, r5, cr15

    mcgState.currentMode = MODE_PEE;
     bf0:	726d7400 	rsbvc	r7, sp, #0, 8
     bf4:	4874754f 	ldmdami	r4!, {r0, r1, r2, r3, r6, r8, sl, ip, sp, lr}^
     bf8:	726d7400 	rsbvc	r7, sp, #0, 8
}
     bfc:	4c74754f 	cfldr64mi	mvdx7, [r4], #-316	; 0xfffffec4
     c00:	6e697500 	cdpvs	5, 6, cr7, cr9, cr0, {0}
     c04:	5f363174 	svcpl	0x00363174

static void fei2blpi(clockConfig_t cc)
{
     c08:	74730074 	ldrbtvc	r0, [r3], #-116	; 0xffffff8c
     c0c:	6c727443 	cfldrdvs	mvd7, [r2], #-268	; 0xfffffef4
     c10:	67616c46 	strbvs	r6, [r1, -r6, asr #24]!
                                                            /* Not configured */
}
     c14:	2e2e0073 	mcrcs	0, 1, r0, cr14, cr3, {3}
     c18:	6168702f 	cmnvs	r8, pc, lsr #32

static void fei2blpe(clockConfig_t cc)
{
     c1c:	5f326573 	svcpl	0x00326573
     c20:	65626d65 	strbvs	r6, [r2, #-3429]!	; 0xfffff29b
     c24:	64656464 	strbtvs	r6, [r5], #-1124	; 0xfffffb9c
                                                            /* Not configured */
}
     c28:	772f635f 			; <UNDEFINED> instruction: 0x772f635f
     c2c:	68637461 	stmdavs	r3!, {r0, r5, r6, sl, ip, sp, lr}^


static void fee2fei(clockConfig_t cc)
{
     c30:	2e676f44 	cdpcs	15, 6, cr6, cr7, cr4, {2}
     c34:	64770063 	ldrbtvs	r0, [r7], #-99	; 0xffffff9d
     c38:	00727450 	rsbseq	r7, r2, r0, asr r4
                                                            /* Not configured */
}
     c3c:	73657270 	cmnvc	r5, #112, 4
     c40:	6e750063 	cdpvs	0, 7, cr0, cr5, cr3, {3}

static void fee2pee(clockConfig_t cc)
{
     c44:	6b636f6c 	blvs	18dc9fc <_flash_swap_addr+0x189d1fc>
     c48:	6e697700 	cdpvs	7, 6, cr7, cr9, cr0, {0}
     c4c:	00776f64 	rsbseq	r6, r7, r4, ror #30
                                                            /* Not configured */
}
     c50:	474f4457 	smlsldmi	r4, pc, r7, r4	; <UNPREDICTABLE>
     c54:	4b4c435f 	blmi	13119d8 <_flash_swap_addr+0x12d21d8>

static void fee2blpi(clockConfig_t cc)
{
     c58:	00435253 	subeq	r5, r3, r3, asr r2
     c5c:	65746e69 	ldrbvs	r6, [r4, #-3689]!	; 0xfffff197
     c60:	70757272 	rsbsvc	r7, r5, r2, ror r2
                                                            /* Not configured */
}
     c64:	73694474 	cmnvc	r9, #116, 8	; 0x74000000
     c68:	656c6261 	strbvs	r6, [ip, #-609]!	; 0xfffffd9f

static void fee2blpe(clockConfig_t cc)
{
     c6c:	74617700 	strbtvc	r7, [r1], #-1792	; 0xfffff900
     c70:	6f446863 	svcvs	0x00446863
     c74:	6c6e5567 	cfstr64vs	mvdx5, [lr], #-412	; 0xfffffe64
                                                            /* Not configured */
}
     c78:	006b636f 	rsbeq	r6, fp, pc, ror #6
     c7c:	43747372 	cmnmi	r4, #-939524095	; 0xc8000001


static void pee2fei(clockConfig_t cc)
{
     c80:	5700746e 	strpl	r7, [r0, -lr, ror #8]
     c84:	5f474f44 	svcpl	0x00474f44
     c88:	454e4957 	strbmi	r4, [lr, #-2391]	; 0xfffff6a9

                                                            /* Enter PBE mode */
    clock.mcg->c1 = (MCG_C1_CLKS_MASK & (0x2 << 6)); /* Select external clock */
     c8c:	5f70004e 	svcpl	0x0070004e
     c90:	0067736d 	rsbeq	r7, r7, sp, ror #6
     c94:	6d796472 	cfldrdvs	mvd6, [r9, #-456]!	; 0xfffffe38
     c98:	76006773 			; <UNDEFINED> instruction: 0x76006773

                                                    /* Wait for status update */
    while ((clock.mcg->s & MCG_S_CLKST_MASK) != (0x2 << 2)) {}
     c9c:	73696c74 	cmnvc	r9, #116, 24	; 0x7400
     ca0:	68630074 	stmdavs	r3!, {r2, r4, r5, r6}^
     ca4:	54737953 	ldrbtpl	r7, [r3], #-2387	; 0xfffff6ad
     ca8:	72656d69 	rsbvc	r6, r5, #6720	; 0x1a40
     cac:	646e6148 	strbtvs	r6, [lr], #-328	; 0xfffffeb8
     cb0:	4972656c 	ldmdbmi	r2!, {r2, r3, r5, r6, r8, sl, sp, lr}^

                                                            /* Enter FBE mode */
    /*
     * With the FLL frequency valid, we can now clear the PLLS bit to select FLL
     */
    clock.mcg->c6 &= ~MCG_C6_PLLS;
     cb4:	2f2e2e00 	svccs	0x002e2e00
     cb8:	432f2e2e 	teqmi	pc, #736	; 0x2e0
     cbc:	69626968 	stmdbvs	r2!, {r3, r5, r6, r8, fp, sp, lr}^
     cc0:	6f2f534f 	svcvs	0x002f534f
     cc4:	656b2f73 	strbvs	r2, [fp, #-3955]!	; 0xfffff08d
     cc8:	6c656e72 	stclvs	14, cr6, [r5], #-456	; 0xfffffe38
     ccc:	6372732f 	cmnvs	r2, #-1140850688	; 0xbc000000
     cd0:	7368632f 	cmnvc	r8, #-1140850688	; 0xbc000000

                                                    /* Wait for status update */
    /* Wait until the current source is FLL */
    while (clock.mcg->s & MCG_S_PLLST) {}
     cd4:	632e7379 	teqvs	lr, #-469762047	; 0xe4000001
     cd8:	69786500 	ldmdbvs	r8!, {r8, sl, sp, lr}^
     cdc:	646f6374 	strbtvs	r6, [pc], #-884	; ce4 <pee2fei+0x64>
     ce0:	616d0065 	cmnvs	sp, r5, rrx
     ce4:	68746e69 	ldmdavs	r4!, {r0, r3, r5, r6, r9, sl, fp, sp, lr}^
     ce8:	64616572 	strbtvs	r6, [r1], #-1394	; 0xfffffa8e

                                            /* Generate correct FLL frequency */
    clock.mcg->c4 = clockConfigParam[cc].multiplier;
     cec:	705f7000 	subsvc	r7, pc, r0
     cf0:	006f6972 	rsbeq	r6, pc, r2, ror r9	; <UNPREDICTABLE>
     cf4:	79536863 	ldmdbvc	r3, {r0, r1, r5, r6, fp, sp, lr}^
     cf8:	696e4973 	stmdbvs	lr!, {r0, r1, r4, r5, r6, r8, fp, lr}^
     cfc:	5f700074 	svcpl	0x00700074
     d00:	6f6f706d 	svcvs	0x006f706d
     d04:	5f6d006c 	svcpl	0x006d006c

                                                            /* Enter FEI mode */
    clock.mcg->c1 = (MCG_C1_CLKS_MASK & (0x0 << 6)) |
     d08:	75657571 	strbvc	r7, [r5, #-1393]!	; 0xfffffa8f
     d0c:	73740065 	cmnvc	r4, #101	; 0x65
     d10:	6563696c 	strbvs	r6, [r3, #-2412]!	; 0xfffff694
     d14:	00745f73 	rsbseq	r5, r4, r3, ror pc
                    (MCG_C1_IREFS);

                                                    /* Wait for status update */
    /* Wait for reference clock's to become the internal reference */
    while (!(clock.mcg->s & MCG_S_IREFST)) {}
     d18:	61747374 	cmnvs	r4, r4, ror r3
     d1c:	745f6574 	ldrbvc	r6, [pc], #-1396	; d24 <pee2fei+0xa4>
     d20:	6e5f7000 	cdpvs	0, 5, cr7, cr15, cr0, {0}
     d24:	72657765 	rsbvc	r7, r5, #26476544	; 0x1940000
     d28:	64695f00 	strbtvs	r5, [r9], #-3840	; 0xfffff100
     d2c:	745f656c 	ldrbvc	r6, [pc], #-1388	; d34 <pee2fei+0xb4>
    /* Wait until the output of the FLL is selected */
    while ((clock.mcg->s & MCG_S_CLKST_MASK) != (0x0 << 2)) {}
     d30:	61657268 	cmnvs	r5, r8, ror #4
     d34:	61775f64 	cmnvs	r7, r4, ror #30
     d38:	6e5f7200 	cdpvs	2, 5, cr7, cr15, cr0, {0}
     d3c:	72657765 	rsbvc	r7, r5, #26476544	; 0x1940000
     d40:	67657200 	strbvs	r7, [r5, -r0, lsl #4]!
     d44:	5f6d7261 	svcpl	0x006d7261

    mcgState.currentMode = MODE_FEI;
     d48:	74760074 	ldrbtvc	r0, [r6], #-116	; 0xffffff8c
     d4c:	6572705f 	ldrbvs	r7, [r2, #-95]!	; 0xffffffa1
     d50:	74760076 	ldrbtvc	r0, [r6], #-118	; 0xffffff8a
     d54:	78656e5f 	stmdavc	r5!, {r0, r1, r2, r3, r4, r6, r9, sl, fp, sp, lr}^
}
     d58:	6f630074 	svcvs	0x00630074
     d5c:	7865746e 	stmdavc	r5!, {r1, r2, r3, r5, r6, sl, ip, sp, lr}^

static void pee2fee(clockConfig_t cc)
{
     d60:	6d740074 	ldclvs	0, cr0, [r4, #-464]!	; 0xfffffe30
     d64:	5f65646f 	svcpl	0x0065646f
     d68:	68540074 	ldmdavs	r4, {r2, r4, r5, r6}^
                                                            /* Not configured */
}
     d6c:	64616572 	strbtvs	r6, [r1], #-1394	; 0xfffffa8e
     d70:	73694c73 	cmnvc	r9, #29440	; 0x7300

static void pee2blpi(clockConfig_t cc)
{
     d74:	76650074 			; <UNDEFINED> instruction: 0x76650074
     d78:	6d746e65 	ldclvs	14, cr6, [r4, #-404]!	; 0xfffffe6c
     d7c:	5f6b7361 	svcpl	0x006b7361
                                                            /* Not configured */
}
     d80:	754d0074 	strbvc	r0, [sp, #-116]	; 0xffffff8c
     d84:	00786574 	rsbseq	r6, r8, r4, ror r5

static void pee2blpe(clockConfig_t cc)
{
     d88:	745f7476 	ldrbvc	r7, [pc], #-1142	; d90 <pee2blpe+0x8>
     d8c:	00656d69 	rsbeq	r6, r5, r9, ror #26
     d90:	665f7476 			; <UNDEFINED> instruction: 0x665f7476
                                                            /* Not configured */
}
     d94:	00636e75 	rsbeq	r6, r3, r5, ror lr
     d98:	6c6f5f70 	stclvs	15, cr5, [pc], #-448	; be0 <fei2pee+0x1a4>


static void blpi2fei(clockConfig_t cc)
{
     d9c:	00726564 	rsbseq	r6, r2, r4, ror #10
     da0:	74635f72 	strbtvc	r5, [r3], #-3954	; 0xfffff08e
     da4:	68540078 	ldmdavs	r4, {r3, r4, r5, r6}^
                                                            /* Not configured */
}
     da8:	64616572 	strbtvs	r6, [r1], #-1394	; 0xfffffa8e
     dac:	65755173 	ldrbvs	r5, [r5, #-371]!	; 0xfffffe8d

static void blpi2fee(clockConfig_t cc)
{
     db0:	72006575 	andvc	r6, r0, #490733568	; 0x1d400000
     db4:	7275635f 	rsbsvc	r6, r5, #2080374785	; 0x7c000001
     db8:	746e6572 	strbtvc	r6, [lr], #-1394	; 0xfffffa8e
                                                            /* Not configured */
}
     dbc:	6f5f7200 	svcvs	0x005f7200
     dc0:	7265646c 	rsbvc	r6, r5, #108, 8	; 0x6c000000

static void blpi2pee(clockConfig_t cc)
{
     dc4:	64695f00 	strbtvs	r5, [r9], #-3840	; 0xfffff100
     dc8:	745f656c 	ldrbvc	r6, [pc], #-1388	; dd0 <blpi2pee+0xc>
     dcc:	61657268 	cmnvs	r5, r8, ror #4
                                                            /* Not configured */
}
     dd0:	72740064 	rsbsvc	r0, r4, #100	; 0x64
     dd4:	5f736665 	svcpl	0x00736665

static void blpi2blpe(clockConfig_t cc)
{
     dd8:	5f700074 	svcpl	0x00700074
     ddc:	76657270 			; <UNDEFINED> instruction: 0x76657270
     de0:	72707400 	rsbsvc	r7, r0, #0, 8
                                                            /* Not configured */
}
     de4:	745f6f69 	ldrbvc	r6, [pc], #-3945	; dec <blpe2fei>
     de8:	6d5f7000 	ldclvs	0, cr7, [pc, #-0]	; df0 <blpe2fei+0x4>


static void blpe2fei(clockConfig_t cc)
{
     dec:	696c7874 	stmdbvs	ip!, {r2, r4, r5, r6, fp, ip, sp, lr}^
     df0:	70007473 	andvc	r7, r0, r3, ror r4
     df4:	6174735f 	cmnvs	r4, pc, asr r3
                                                            /* Not configured */
}
     df8:	70006574 	andvc	r6, r0, r4, ror r5
     dfc:	6572705f 	ldrbvs	r7, [r2, #-95]!	; 0xffffffa1

static void blpe2fee(clockConfig_t cc)
{
     e00:	74706d65 	ldrbtvc	r6, [r0], #-3429	; 0xfffff29b
     e04:	705f7200 	subsvc	r7, pc, r0, lsl #4
     e08:	006f6972 	rsbeq	r6, pc, r2, ror r9	; <UNPREDICTABLE>
                                                            /* Not configured */
}
     e0c:	616d7765 	cmnvs	sp, r5, ror #14
     e10:	70006b73 	andvc	r6, r0, r3, ror fp

static void blpe2pee(clockConfig_t cc)
{
     e14:	616c665f 	cmnvs	ip, pc, asr r6
     e18:	54007367 	strpl	r7, [r0], #-871	; 0xfffffc99
     e1c:	61657268 	cmnvs	r5, r8, ror #4
                                                            /* Not configured */
}
     e20:	5f700064 	svcpl	0x00700064
     e24:	6e657065 	cdpvs	0, 6, cr7, cr5, cr5, {3}

static void blpe2blpi(clockConfig_t cc)
{
     e28:	676e6964 	strbvs	r6, [lr, -r4, ror #18]!
     e2c:	715f7200 	cmpvc	pc, r0, lsl #4
     e30:	65756575 	ldrbvs	r6, [r5, #-1397]!	; 0xfffffa8b
                                                            /* Not configured */
}
     e34:	72695600 	rsbvc	r5, r9, #0, 12
     e38:	6c617574 	cfstr64vs	mvdx7, [r1], #-464	; 0xfffffe30
* system, bus, flexbus, and flash clock frequencies.
*
*******************************************************************************/
void clockSetDividers(divider_t systemDiv, divider_t busDiv,
                                       divider_t flexBusDiv, divider_t flashDiv)
{
     e3c:	656d6954 	strbvs	r6, [sp, #-2388]!	; 0xfffff6ac
     e40:	5f6d0072 	svcpl	0x006d0072
     e44:	7478656e 	ldrbtvc	r6, [r8], #-1390	; 0xfffffa92
     e48:	725f7000 	subsvc	r7, pc, #0
    int mcgClock = clockFreq.mcgClockFreq;
     e4c:	706c6165 	rsbvc	r6, ip, r5, ror #2
     e50:	006f6972 	rsbeq	r6, pc, r2, ror r9	; <UNPREDICTABLE>
     e54:	75667476 	strbvc	r7, [r6, #-1142]!	; 0xfffffb8a

    /*
     * The asserts are raised when the internal clock requirements (sec. 5.5)
     * are not met.
     */
    assert( (mcgClock / (systemDiv +1)) <= MAX_SYSTEM_FREQ);
     e58:	745f636e 	ldrbvc	r6, [pc], #-878	; e60 <clockSetDividers+0x24>
     e5c:	745f7000 	ldrbvc	r7, [pc], #-0	; e64 <clockSetDividers+0x28>
     e60:	00656d69 	rsbeq	r6, r5, r9, ror #26
     e64:	63746e69 	cmnvs	r4, #1680	; 0x690
     e68:	70007874 	andvc	r7, r0, r4, ror r8
     e6c:	67736d5f 			; <UNDEFINED> instruction: 0x67736d5f
     e70:	75657571 	strbvc	r7, [r5, #-1393]!	; 0xfffffa8f
     e74:	74760065 	ldrbtvc	r0, [r6], #-101	; 0xffffff9b
     e78:	7261705f 	rsbvc	r7, r1, #95	; 0x5f
     e7c:	725f7000 	subsvc	r7, pc, #0

    assert( (mcgClock / (busDiv    +1)) <= MAX_BUS_FREQ &&
     e80:	00736665 	rsbseq	r6, r3, r5, ror #12
     e84:	64616552 	strbtvs	r6, [r1], #-1362	; 0xfffffaae
     e88:	73694c79 	cmnvc	r9, #30976	; 0x7900
     e8c:	6c720074 	ldclvs	0, cr0, [r2], #-464	; 0xfffffe30
     e90:	00747369 	rsbseq	r7, r4, r9, ror #6
     e94:	626f7477 	rsbvs	r7, pc, #1996488704	; 0x77000000
     e98:	7000706a 	andvc	r7, r0, sl, rrx
     e9c:	6d616e5f 	stclvs	14, cr6, [r1, #-380]!	; 0xfffffe84
     ea0:	74760065 	ldrbtvc	r0, [r6], #-101	; 0xffffff9b
     ea4:	7379735f 	cmnvc	r9, #2080374785	; 0x7c000001
     ea8:	656d6974 	strbvs	r6, [sp, #-2420]!	; 0xfffff68c
     eac:	4c545600 	mrrcmi	6, 0, r5, r4, cr0
     eb0:	00747369 	rsbseq	r7, r4, r9, ror #6
     eb4:	776f5f6d 	strbvc	r5, [pc, -sp, ror #30]!
     eb8:	0072656e 	rsbseq	r6, r2, lr, ror #10
     ebc:	74635f70 	strbtvc	r5, [r3], #-3952	; 0xfffff090
     ec0:	5f700078 	svcpl	0x00700078
            (mcgClock / (busDiv    +1)) <= (mcgClock / (systemDiv+1)));

    assert( (mcgClock / (flashDiv  +1)) <= MAX_FLASH_FREQ &&
     ec4:	74696177 	strbtvc	r6, [r9], #-375	; 0xfffffe89
     ec8:	00676e69 	rsbeq	r6, r7, r9, ror #28
     ecc:	54566863 	ldrbpl	r6, [r6], #-2147	; 0xfffff79d
     ed0:	49746553 	ldmdbmi	r4!, {r0, r1, r4, r6, r8, sl, sp, lr}^
     ed4:	6f6f6200 	svcvs	0x006f6200
     ed8:	00745f6c 	rsbseq	r5, r4, ip, ror #30
     edc:	5f74765f 	svcpl	0x0074765f
     ee0:	74696e69 	strbtvc	r6, [r9], #-3689	; 0xfffff197
     ee4:	66747600 	ldrbtvs	r7, [r4], -r0, lsl #12
     ee8:	00636e75 	rsbeq	r6, r3, r5, ror lr
     eec:	69546863 	ldmdbvs	r4, {r0, r1, r5, r6, fp, sp, lr}^
     ef0:	7349656d 	movtvc	r6, #38253	; 0x956d
     ef4:	68746957 	ldmdavs	r4!, {r0, r1, r2, r4, r6, r8, fp, sp, lr}^
     ef8:	2e006e69 	cdpcs	14, 0, cr6, cr0, cr9, {3}
     efc:	2e2e2f2e 	cdpcs	15, 2, cr2, cr14, cr14, {1}
     f00:	6968432f 	stmdbvs	r8!, {r0, r1, r2, r3, r5, r8, r9, lr}^
     f04:	534f6962 	movtpl	r6, #63842	; 0xf962
            (mcgClock / (flashDiv  +1)) <= (mcgClock / (busDiv+1)));

    assert( (mcgClock / (flexBusDiv+1)) <= (mcgClock / (busDiv+1)));
     f08:	2f736f2f 	svccs	0x00736f2f
     f0c:	6e72656b 	cdpvs	5, 7, cr6, cr2, cr11, {3}
     f10:	732f6c65 	teqvc	pc, #25856	; 0x6500
     f14:	632f6372 	teqvs	pc, #-939524095	; 0xc8000001
     f18:	2e747668 	cdpcs	6, 7, cr7, cr4, cr8, {3}
     f1c:	68630063 	stmdavs	r3!, {r0, r1, r5, r6}^
     f20:	65525456 	ldrbvs	r5, [r2, #-1110]	; 0xfffffbaa
     f24:	49746573 	ldmdbmi	r4!, {r0, r1, r4, r5, r6, r8, sl, sp, lr}^
     f28:	53686300 	cmnpl	r8, #0, 6
     f2c:	6f446863 	svcvs	0x00446863
     f30:	63736552 	cmnvs	r3, #343932928	; 0x14800000

    /* Save the new dividers */
    clockFreq.systemDiv  = systemDiv;
     f34:	75646568 	strbvc	r6, [r4, #-1384]!	; 0xfffffa98
     f38:	6841656c 	stmdavs	r1, {r2, r3, r5, r6, r8, sl, sp, lr}^
     f3c:	00646165 	rsbeq	r6, r4, r5, ror #2
    clockFreq.busDiv     = busDiv;
     f40:	6863735f 	stmdavs	r3!, {r0, r1, r2, r3, r4, r6, r8, r9, ip, sp, lr}^
     f44:	6c756465 	cfldrdvs	mvd6, [r5], #-404	; 0xfffffe6c
     f48:	695f7265 	ldmdbvs	pc, {r0, r2, r5, r6, r9, ip, sp, lr}^	; <UNPREDICTABLE>
    clockFreq.flexBusDiv = flexBusDiv;
     f4c:	0074696e 	rsbseq	r6, r4, lr, ror #18
     f50:	75715f73 	ldrbvc	r5, [r1, #-3955]!	; 0xfffff08d
     f54:	00657565 	rsbeq	r7, r5, r5, ror #10
    clockFreq.flashDiv   = flashDiv;
     f58:	63536863 	cmpvs	r3, #6488064	; 0x630000
     f5c:	73655268 	cmnvc	r5, #104, 4	; 0x80000006
     f60:	64656863 	strbtvs	r6, [r5], #-2147	; 0xfffff79d

    /* Set the SIM clock dividers */
    SIM_CLKDIV1 = (systemDiv << 28)  |
     f64:	53656c75 	cmnpl	r5, #29952	; 0x7500
     f68:	53686300 	cmnpl	r8, #0, 6
     f6c:	6f446863 	svcvs	0x00446863
                  (busDiv << 24)     |
     f70:	63736552 	cmnvs	r3, #343932928	; 0x14800000
     f74:	75646568 	strbvc	r6, [r4, #-1384]!	; 0xfffffa98
                  (flexBusDiv << 20) |
     f78:	6300656c 	movwvs	r6, #1388	; 0x56c
     f7c:	745f746e 	ldrbvc	r7, [pc], #-1134	; f84 <clockSetDividers+0x148>
                  (flashDiv << 16);
     f80:	6b617700 	blvs	185eb88 <_flash_swap_addr+0x181f388>
     f84:	00707565 	rsbseq	r7, r0, r5, ror #10
    clockFreq.busDiv     = busDiv;
    clockFreq.flexBusDiv = flexBusDiv;
    clockFreq.flashDiv   = flashDiv;

    /* Set the SIM clock dividers */
    SIM_CLKDIV1 = (systemDiv << 28)  |
     f88:	6e635f73 	mcrvs	15, 3, r5, cr3, cr3, {3}
                  (busDiv << 24)     |
                  (flexBusDiv << 20) |
                  (flashDiv << 16);
}
     f8c:	68630074 	stmdavs	r3!, {r2, r4, r5, r6}^
     f90:	57686353 			; <UNDEFINED> instruction: 0x57686353
*
* Grab the clock frequency for a particular clock source in Hz.
*
*******************************************************************************/
uint32_t clockGetFreq(clockSource_t cs)
{
     f94:	75656b61 	strbvc	r6, [r5, #-2913]!	; 0xfffff49f
     f98:	63005370 	movwvs	r5, #880	; 0x370
     f9c:	68635368 	stmdavs	r3!, {r3, r5, r6, r8, r9, ip, lr}^
    uint32_t clock;

    switch (cs) {
     fa0:	65526f44 	ldrbvs	r6, [r2, #-3908]	; 0xfffff0bc
     fa4:	65686373 	strbvs	r6, [r8, #-883]!	; 0xfffffc8d
     fa8:	656c7564 	strbvs	r7, [ip, #-1380]!	; 0xfffffa9c
     fac:	69686542 	stmdbvs	r8!, {r1, r6, r8, sl, sp, lr}^
     fb0:	6400646e 	strvs	r6, [r0], #-1134	; 0xfffffb92
     fb4:	65757165 	ldrbvs	r7, [r5, #-357]!	; 0xfffffe9b
     fb8:	2e006575 	cfrshl64cs	mvdx0, mvdx5, r6
     fbc:	2e2e2f2e 	cdpcs	15, 2, cr2, cr14, cr14, {1}
    case CLOCK_SYSTEM:
        clock = clockFreq.mcgClockFreq / (clockFreq.systemDiv + 1);
     fc0:	6968432f 	stmdbvs	r8!, {r0, r1, r2, r3, r5, r8, r9, lr}^
     fc4:	534f6962 	movtpl	r6, #63842	; 0xf962
     fc8:	2f736f2f 	svccs	0x00736f2f
     fcc:	6e72656b 	cdpvs	5, 7, cr6, cr2, cr11, {3}
     fd0:	732f6c65 	teqvc	pc, #25856	; 0x6500
     fd4:	632f6372 	teqvs	pc, #-939524095	; 0xc8000001
     fd8:	68637368 	stmdavs	r3!, {r3, r5, r6, r8, r9, ip, sp, lr}^
     fdc:	00632e64 	rsbeq	r2, r3, r4, ror #28
        break;
    case CLOCK_BUS:
        clock = clockFreq.mcgClockFreq / (clockFreq.busDiv + 1);
     fe0:	7377656e 	cmnvc	r7, #461373440	; 0x1b800000
     fe4:	65746174 	ldrbvs	r6, [r4, #-372]!	; 0xfffffe8c
     fe8:	53686300 	cmnpl	r8, #0, 6
     fec:	6f476863 	svcvs	0x00476863
     ff0:	65656c53 	strbvs	r6, [r5, #-3155]!	; 0xfffff3ad
     ff4:	66005370 			; <UNDEFINED> instruction: 0x66005370
     ff8:	5f6f6669 	svcpl	0x006f6669
     ffc:	6f6d6572 	svcvs	0x006d6572
        break;
    case CLOCK_FLEXBUS:
        clock = clockFreq.mcgClockFreq / (clockFreq.flexBusDiv + 1);
    1000:	63006576 	movwvs	r6, #1398	; 0x576
    1004:	68635368 	stmdavs	r3!, {r3, r5, r6, r8, r9, ip, lr}^
    1008:	64616552 	strbtvs	r6, [r1], #-1362	; 0xfffffaae
    100c:	53004979 	movwpl	r4, #2425	; 0x979
    1010:	70616d65 	rsbvc	r6, r1, r5, ror #26
    1014:	65726f68 	ldrbvs	r6, [r2, #-3944]!	; 0xfffff098
    1018:	53686300 	cmnpl	r8, #0, 6
    101c:	6f476863 	svcvs	0x00476863
        break;
    case CLOCK_FLASH:
        clock = clockFreq.mcgClockFreq / (clockFreq.flashDiv + 1);
    1020:	65656c53 	strbvs	r6, [r5, #-3155]!	; 0xfffff3ad
    1024:	6d695470 	cfstrdvs	mvd5, [r9, #-448]!	; 0xfffffe40
    1028:	74756f65 	ldrbtvc	r6, [r5], #-3941	; 0xfffff09b
    102c:	69730053 	ldmdbvs	r3!, {r0, r1, r4, r6}^
    1030:	745f657a 	ldrbvc	r6, [pc], #-1402	; 1038 <clockGetFreq+0xa4>
    1034:	2f2e2e00 	svccs	0x002e2e00
    1038:	432f2e2e 	teqmi	pc, #736	; 0x2e0
    103c:	69626968 	stmdbvs	r2!, {r3, r5, r6, r8, fp, sp, lr}^
        break;
    default:
        assert(0);
    1040:	6f2f534f 	svcvs	0x002f534f
    1044:	656b2f73 	strbvs	r2, [fp, #-3955]!	; 0xfffff08d
    1048:	6c656e72 	stclvs	14, cr6, [r5], #-456	; 0xfffffe38
    104c:	6372732f 	cmnvs	r2, #-1140850688	; 0xbc000000
    }

    return clock;
    1050:	7468632f 	strbtvc	r6, [r8], #-815	; 0xfffffcd1
}
    1054:	61657268 	cmnvs	r5, r8, ror #4
    1058:	632e7364 	teqvs	lr, #100, 6	; 0x90000001
*        ____ STOP ____ (Entered when MCU enters stop mode, and returns to
*                        previous active mode when exits stop mode )
*
*******************************************************************************/
void clockConfigMcgOut(clockConfig_t clockConfig)
{
    105c:	54686300 	strbtpl	r6, [r8], #-768	; 0xfffffd00
    1060:	78456468 	stmdavc	r5, {r3, r5, r6, sl, sp, lr}^
    1064:	00537469 	subseq	r7, r3, r9, ror #8
        {  pee2fei,  pee2fee,     NULL,  pee2blpi,  pee2blpe, },
        { blpi2fei, blpi2fee, blpi2pee,      NULL, blpi2blpe, },
        { blpe2fei, blpe2fee, blpe2pee, blpe2blpi,      NULL, },
    };

    assert(clockConfig < MAX_MCG_CLOCK_OPTIONS);
    1068:	68546863 	ldmdavs	r4, {r0, r1, r5, r6, fp, sp, lr}^
    106c:	69784564 	ldmdbvs	r8!, {r2, r5, r6, r8, sl, lr}^
    1070:	68630074 	stmdavs	r3!, {r2, r4, r5, r6}^
    1074:	43646854 	cmnmi	r4, #84, 16	; 0x540000
    1078:	74616572 	strbtvc	r6, [r1], #-1394	; 0xfffffa8e

    mcgState.nextMode = clockConfigParam[clockConfig].clockMode;
    107c:	6c004965 	stcvs	9, cr4, [r0], {101}	; 0x65
    1080:	5f747369 	svcpl	0x00747369
    1084:	6f6d6572 	svcvs	0x006d6572
    1088:	63006576 	movwvs	r6, #1398	; 0x576
    108c:	64685468 	strbtvs	r5, [r8], #-1128	; 0xfffffb98
    1090:	50746553 	rsbspl	r6, r4, r3, asr r5

    jumpTable[mcgState.currentMode][mcgState.nextMode](clockConfig);
    1094:	726f6972 	rsbvc	r6, pc, #1867776	; 0x1c8000
    1098:	00797469 	rsbseq	r7, r9, r9, ror #8
    109c:	7077656e 	rsbsvc	r6, r7, lr, ror #10
    10a0:	006f6972 	rsbeq	r6, pc, r2, ror r9	; <UNPREDICTABLE>
    10a4:	68546863 	ldmdavs	r4, {r0, r1, r5, r6, fp, sp, lr}^
    10a8:	72655464 	rsbvc	r5, r5, #100, 8	; 0x64000000
    10ac:	616e696d 	cmnvs	lr, sp, ror #18
    10b0:	6f006574 	svcvs	0x00006574
    10b4:	7270646c 	rsbsvc	r6, r0, #108, 8	; 0x6c000000
    10b8:	63006f69 	movwvs	r6, #3945	; 0xf69
    10bc:	64685468 	strbtvs	r5, [r8], #-1128	; 0xfffffb98
    10c0:	61657243 	cmnvs	r5, r3, asr #4
    10c4:	74536574 	ldrbvc	r6, [r3], #-1396	; 0xfffffa8c

    /* Store the new clock frequency for clockGetFreq() */
    clockFreq.mcgClockFreq = clockConfigParam[clockConfig].clockHz;
    10c8:	63697461 	cmnvs	r9, #1627389952	; 0x61000000
    10cc:	54686300 	strbtpl	r6, [r8], #-768	; 0xfffffd00
    10d0:	65526468 	ldrbvs	r6, [r2, #-1128]	; 0xfffffb98
    10d4:	656d7573 	strbvs	r7, [sp, #-1395]!	; 0xfffffa8d
    10d8:	73696c00 	cmnvc	r9, #0, 24
    10dc:	6e695f74 	mcrvs	15, 3, r5, cr9, cr4, {3}
    10e0:	74726573 	ldrbtvc	r6, [r2], #-1395	; 0xfffffa8d
}
    10e4:	54686300 	strbtpl	r6, [r8], #-768	; 0xfffffd00
    10e8:	6c536468 	cfldrdvs	mvd6, [r3], {104}	; 0x68

/*******************************************************************************
* clockConfigMcgIr
*******************************************************************************/
void clockConfigMcgIr()
{
    10ec:	55706565 	ldrbpl	r6, [r0, #-1381]!	; 0xfffffa9b
                                                            /* Not configured */
}
    10f0:	6c69746e 	cfstrdvs	mvd7, [r9], #-440	; 0xfffffe48
    10f4:	68745f00 	ldmdavs	r4!, {r8, r9, sl, fp, ip, lr}^

/*******************************************************************************
* clockConfigMcgFf
*******************************************************************************/
void clockConfigMcgFf()
{
    10f8:	64616572 	strbtvs	r6, [r1], #-1394	; 0xfffffa8e
                                                            /* Not configured */
}
    10fc:	696e695f 	stmdbvs	lr!, {r0, r1, r2, r3, r4, r6, r8, fp, sp, lr}^
    1100:	68630074 	stmdavs	r3!, {r2, r4, r5, r6}^

/*******************************************************************************
* clockConfigMcgFll
*******************************************************************************/
void clockConfigMcgFll()
{
    1104:	57646854 			; <UNDEFINED> instruction: 0x57646854
                                                            /* Not configured */
}
    1108:	00746961 	rsbseq	r6, r4, r1, ror #18
    110c:	68546863 	ldmdavs	r4, {r0, r1, r5, r6, fp, sp, lr}^

/*******************************************************************************
* clockConfigMcgPll
*******************************************************************************/
void clockConfigMcgPll()
{
    1110:	656c5364 	strbvs	r5, [ip, #-868]!	; 0xfffffc9c
                                                            /* Not configured */
}
    1114:	63007065 	movwvs	r7, #101	; 0x65
    1118:	64685468 	strbtvs	r5, [r8], #-1128	; 0xfffffb98

/*******************************************************************************
* clockConfigOsc
*******************************************************************************/
void clockConfigOsc()
{
    111c:	6c656959 	stclvs	9, cr6, [r5], #-356	; 0xfffffe9c
                                                            /* Not configured */
}
    1120:	656d0064 	strbvs	r0, [sp, #-100]!	; 0xffffff9c
    1124:	7465676d 	strbtvc	r6, [r5], #-1901	; 0xfffff893

/*******************************************************************************
* clockConfigOsc32k
*******************************************************************************/
void clockConfigOsc32k()
{
    1128:	636e7566 	cmnvs	lr, #427819008	; 0x19800000
                                                            /* Not configured */
}
    112c:	6800745f 	stmdavs	r0, {r0, r1, r2, r3, r4, r6, sl, ip, sp, lr}
    1130:	6572665f 	ldrbvs	r6, [r2, #-1631]!	; 0xfffff9a1

/*******************************************************************************
* clockConfigEr32k
*******************************************************************************/
void clockConfigEr32k()
{
    1134:	65680065 	strbvs	r0, [r8, #-101]!	; 0xffffff9b
                                                            /* Not configured */
}
    1138:	00707061 	rsbseq	r7, r0, r1, rrx
    113c:	746d5f68 	strbtvc	r5, [sp], #-3944	; 0xfffff098

/*******************************************************************************
* clockConfigRtc
*******************************************************************************/
void clockConfigRtc()
{
    1140:	68630078 	stmdavs	r3!, {r3, r4, r5, r6}^
                                                            /* Not configured */
}
    1144:	43646854 	cmnmi	r4, #84, 16	; 0x540000
    1148:	74616572 	strbtvc	r6, [r1], #-1394	; 0xfffffa8e

/*******************************************************************************
* clockConfigLpo
*******************************************************************************/
void clockConfigLpo()
{
    114c:	6f724665 	svcvs	0x00724665
                                                            /* Not configured */
}
    1150:	6165486d 	cmnvs	r5, sp, ror #16
    1154:	706d0070 	rsbvc	r0, sp, r0, ror r0
*
* RETURNS: Nothing
*
*******************************************************************************/
void watchDogUnlock()
{
    1158:	78656e5f 	stmdavc	r5!, {r0, r1, r2, r3, r4, r6, r9, sl, fp, sp, lr}^
        " :
        /* No output */ :
        /* No input  */ :
        "r0", "r1" ); /* Specify which registers we destroy */
#else
    wdPtr->unlock = WDOG_UNLOCK_KEY_1;
    115c:	68630074 	stmdavs	r3!, {r2, r4, r5, r6}^
    1160:	43646854 	cmnmi	r4, #84, 16	; 0x540000
    1164:	74616572 	strbtvc	r6, [r1], #-1394	; 0xfffffa8e
    1168:	6f724665 	svcvs	0x00724665
    wdPtr->unlock = WDOG_UNLOCK_KEY_2;
    116c:	6d654d6d 	stclvs	13, cr4, [r5, #-436]!	; 0xfffffe4c
    1170:	5079726f 	rsbspl	r7, r9, pc, ror #4
    1174:	006c6f6f 	rsbeq	r6, ip, pc, ror #30
    1178:	705f706d 	subsvc	r7, pc, sp, rrx
#endif
    /* NOTE: Need to wait one clock cycle before updating any registers */
}
    117c:	69766f72 	ldmdbvs	r6!, {r1, r4, r5, r6, r8, r9, sl, fp, sp, lr}^
    1180:	00726564 	rsbseq	r6, r2, r4, ror #10

/*******************************************************************************
* watchDogInit
*******************************************************************************/
void watchDogInit(const watchDogConfig_t *wdCfgPtr)
{
    1184:	67696c61 	strbvs	r6, [r9, -r1, ror #24]!
    1188:	6863006e 	stmdavs	r3!, {r1, r2, r3, r5, r6}^
    watchDogUnlock();
    118c:	41646854 	cmnmi	r4, r4, asr r8
        " :
        /* No output */ :
        /* No input  */ :
        "r0", "r1", "r2" ); /* Specify which registers we destroy */
#else
    assert(wdCfgPtr->window < wdCfgPtr->timeout);
    1190:	65526464 	ldrbvs	r6, [r2, #-1124]	; 0xfffffb9c
    1194:	706d0066 	rsbvc	r0, sp, r6, rrx
    1198:	6a626f5f 	bvs	189cf1c <_flash_swap_addr+0x185d71c>
    119c:	5f746365 	svcpl	0x00746365
    11a0:	657a6973 	ldrbvs	r6, [sl, #-2419]!	; 0xfffff68d
    11a4:	6d654d00 	stclvs	13, cr4, [r5, #-0]
    11a8:	4879726f 	ldmdami	r9!, {r0, r1, r2, r3, r5, r6, r9, ip, sp, lr}^

    wdPtr->toValL  = wdCfgPtr->timeout;
    11ac:	00706165 	rsbseq	r6, r0, r5, ror #2
    11b0:	6e5f6870 	mrcvs	8, 2, r6, cr15, cr0, {3}
    11b4:	00747865 	rsbseq	r7, r4, r5, ror #16
    11b8:	72705f68 	rsbsvc	r5, r0, #104, 30	; 0x1a0
    11bc:	6469766f 	strbtvs	r7, [r9], #-1647	; 0xfffff991
    wdPtr->toValH  = wdCfgPtr->timeout >> 16;
    11c0:	68007265 	stmdavs	r0, {r0, r2, r5, r6, r9, ip, sp, lr}
    11c4:	5f706165 	svcpl	0x00706165
    11c8:	64616568 	strbtvs	r6, [r1], #-1384	; 0xfffffa98
    11cc:	63007265 	movwvs	r7, #613	; 0x265
    11d0:	64685468 	strbtvs	r5, [r8], #-1128	; 0xfffffb98
    wdPtr->stCtrlH = wdCfgPtr->stCtrlFlags;
    11d4:	656c6552 	strbvs	r6, [ip, #-1362]!	; 0xfffffaae
    11d8:	00657361 	rsbeq	r7, r5, r1, ror #6
    11dc:	2e2f2e2e 	cdpcs	14, 2, cr2, cr15, cr14, {1}
    11e0:	68432f2e 	stmdavs	r3, {r1, r2, r3, r5, r8, r9, sl, fp, sp}^
    wdPtr->presc   = wdCfgPtr->prescaler;
    11e4:	4f696269 	svcmi	0x00696269
    11e8:	736f2f53 	cmnvc	pc, #332	; 0x14c
    11ec:	72656b2f 	rsbvc	r6, r5, #48128	; 0xbc00
    11f0:	2f6c656e 	svccs	0x006c656e
    wdPtr->winL    = wdCfgPtr->window;
    11f4:	2f637273 	svccs	0x00637273
    11f8:	79646863 	stmdbvc	r4!, {r0, r1, r5, r6, fp, sp, lr}^
    11fc:	696d616e 	stmdbvs	sp!, {r1, r2, r3, r5, r6, r8, sp, lr}^
    1200:	00632e63 	rsbeq	r2, r3, r3, ror #28
    1204:	6c6f6f70 	stclvs	15, cr6, [pc], #-448	; 104c <clockGetFreq+0xb8>
    wdPtr->winH    = wdCfgPtr->window >> 16;
    1208:	6165685f 	cmnvs	r5, pc, asr r8
    120c:	00726564 	rsbseq	r6, r2, r4, ror #10
    1210:	6f6d656d 	svcvs	0x006d656d
    1214:	685f7972 	ldmdavs	pc, {r1, r4, r5, r6, r8, fp, ip, sp, lr}^	; <UNPREDICTABLE>
    1218:	00706165 	rsbseq	r6, r0, r5, ror #2
    }
    if (wdCfgPtr->stCtrlFlags & WDOG_TEST) {
        /* TODO: If anyone cares let me know */
    }
#endif
}
    121c:	2e2f2e2e 	cdpcs	14, 2, cr2, cr15, cr14, {1}
    1220:	68432f2e 	stmdavs	r3, {r1, r2, r3, r5, r8, r9, sl, fp, sp}^

/* RFI: Could probably move these elsewhere for general consumption */
static void interruptDisable()
{
    1224:	4f696269 	svcmi	0x00696269
    asm volatile("\n\
    1228:	736f2f53 	cmnvc	pc, #332	; 0x14c
        cpsid i\n\
        " :
        /* No output */ :
        /* No input  */ :
        ); /* Specify which registers we destroy */
}
    122c:	72656b2f 	rsbvc	r6, r5, #48128	; 0xbc00
static void interruptEnable()
{
    1230:	2f6c656e 	svccs	0x006c656e
    asm volatile("\n\
    1234:	2f637273 	svccs	0x00637273
        cpsie i\n\
        " :
        /* No output */ :
        /* No input  */ :
        ); /* Specify which registers we destroy */
}
    1238:	656d6863 	strbvs	r6, [sp, #-2147]!	; 0xfffff79d

/*******************************************************************************
* watchDogKick
*******************************************************************************/
void watchDogKick()
{
    123c:	726f636d 	rsbvc	r6, pc, #-1275068415	; 0xb4000001
        " :
        /* No output */ :
        /* No input  */ :
        "r0", "r1" ); /* Specify which registers we destroy */
#else
    interruptDisable();
    1240:	00632e65 	rsbeq	r2, r3, r5, ror #28
    wdPtr->refresh = WDOG_REFRESH_KEY_1;
    1244:	7478656e 	ldrbtvc	r6, [r8], #-1390	; 0xfffffa92
    1248:	006d656d 	rsbeq	r6, sp, sp, ror #10
    124c:	65685f5f 	strbvs	r5, [r8, #-3935]!	; 0xfffff0a1
    1250:	655f7061 	ldrbvs	r7, [pc, #-97]	; 11f7 <watchDogInit+0x73>
    wdPtr->refresh = WDOG_REFRESH_KEY_2;
    1254:	5f5f646e 	svcpl	0x005f646e
    1258:	685f5f00 	ldmdavs	pc, {r8, r9, sl, fp, ip, lr}^	; <UNPREDICTABLE>
    125c:	5f706165 	svcpl	0x00706165
    1260:	65736162 	ldrbvs	r6, [r3, #-354]!	; 0xfffffe9e
    interruptEnable();
    1264:	63005f5f 	movwvs	r5, #3935	; 0xf5f
#endif
}
    1268:	726f4368 	rsbvc	r4, pc, #104, 6	; 0xa0000001

/*******************************************************************************
* watchDogDisable
*******************************************************************************/
void watchDogDisable()
{
    126c:	6c6c4165 	stfvse	f4, [ip], #-404	; 0xfffffe6c
    watchDogUnlock();
    1270:	6500636f 	strvs	r6, [r0, #-879]	; 0xfffffc91
        " :
        /* No output */ :
        /* No input  */ :
        "r0", "r1" ); /* Specify which registers we destroy */
#else
    wdPtr->stCtrlH = WDOG_STNDBYEN | WDOG_WAITEN | WDOG_STOPEN
    1274:	656d646e 	strbvs	r6, [sp, #-1134]!	; 0xfffffb92
    1278:	6863006d 	stmdavs	r3!, {r0, r2, r3, r5, r6}^
    127c:	65726f43 	ldrbvs	r6, [r2, #-3907]!	; 0xfffff0bd
    1280:	6f6c6c41 	svcvs	0x006c6c41
                   | WDOG_ALLOWUPDATE;
#endif
}
    1284:	5f004963 	svcpl	0x00004963
    1288:	65726f63 	ldrbvs	r6, [r2, #-3939]!	; 0xfffff09d
    128c:	696e695f 	stmdbvs	lr!, {r0, r1, r2, r3, r4, r6, r8, fp, sp, lr}^
 *          that this thread is executed only if there are no other ready
 *          threads in the system.
 *
 * @param[in] p the thread parameter, unused in this scenario
 */
void _idle_thread(void *p) {
    1290:	68630074 	stmdavs	r3!, {r2, r4, r5, r6}^

  (void)p;
  chRegSetThreadName("idle");
    1294:	65726f43 	ldrbvs	r6, [r2, #-3907]!	; 0xfffff0bd
    1298:	74617453 	strbtvc	r7, [r1], #-1107	; 0xfffffbad
    129c:	63007375 	movwvs	r7, #885	; 0x375
    12a0:	61654868 	cmnvs	r5, r8, ror #16
    12a4:	696e4970 	stmdbvs	lr!, {r4, r5, r6, r8, fp, lr}^
  while (TRUE) {
    port_wait_for_interrupt();
    IDLE_LOOP_HOOK();
  }
    12a8:	68630074 	stmdavs	r3!, {r2, r4, r5, r6}^
    12ac:	70616548 	rsbvc	r6, r1, r8, asr #10
 * @note    This function has special, architecture-dependent, requirements,
 *          see the notes into the various port reference manuals.
 *
 * @special
 */
void chSysInit(void) {
    12b0:	65657246 	strbvs	r7, [r5, #-582]!	; 0xfffffdba
  static Thread mainthread;
#if CH_DBG_ENABLE_STACK_CHECK
  extern stkalign_t __main_thread_stack_base__;
#endif

  port_init();
    12b4:	2f2e2e00 	svccs	0x002e2e00
  _scheduler_init();
    12b8:	432f2e2e 	teqmi	pc, #736	; 0x2e0
  _vt_init();
    12bc:	69626968 	stmdbvs	r2!, {r3, r5, r6, r8, fp, sp, lr}^
#if CH_USE_MEMCORE
  _core_init();
    12c0:	6f2f534f 	svcvs	0x002f534f
#endif
#if CH_USE_HEAP
  _heap_init();
    12c4:	656b2f73 	strbvs	r2, [fp, #-3955]!	; 0xfffff08d
#if CH_DBG_ENABLE_TRACE
  _trace_init();
#endif

  /* Now this instructions flow becomes the main thread.*/
  setcurrp(_thread_init(&mainthread, NORMALPRIO));
    12c8:	6c656e72 	stclvs	14, cr6, [r5], #-456	; 0xfffffe38
    12cc:	6372732f 	cmnvs	r2, #-1140850688	; 0xbc000000
    12d0:	6868632f 	stmdavs	r8!, {r0, r1, r2, r3, r5, r8, r9, sp, lr}^
    12d4:	2e706165 	rpwcssz	f6, f0, f5
    12d8:	68630063 	stmdavs	r3!, {r0, r1, r5, r6}^
    12dc:	70616548 	rsbvc	r6, r1, r8, asr #10
    12e0:	6f6c6c41 	svcvs	0x006c6c41
  currp->p_state = THD_STATE_CURRENT;
    12e4:	65640063 	strbvs	r0, [r4, #-99]!	; 0xffffff9d
    12e8:	6c756166 	ldfvse	f6, [r5], #-408	; 0xfffffe68
    12ec:	65685f74 	strbvs	r5, [r8, #-3956]!	; 0xfffff08c
    12f0:	63007061 	movwvs	r7, #97	; 0x61
#if CH_DBG_ENABLE_STACK_CHECK
  /* This is a special case because the main thread Thread structure is not
     adjacent to its stack area.*/
  currp->p_stklimit = &__main_thread_stack_base__;
#endif
  chSysEnable();
    12f4:	61654868 	cmnvs	r5, r8, ror #16
    12f8:	61745370 	cmnvs	r4, r0, ror r3
    12fc:	00737574 	rsbseq	r7, r3, r4, ror r5

  chRegSetThreadName("main");
    1300:	657a6973 	ldrbvs	r6, [sl, #-2419]!	; 0xfffff68d
    1304:	685f0070 	ldmdavs	pc, {r4, r5, r6}^	; <UNPREDICTABLE>
    1308:	5f706165 	svcpl	0x00706165
    130c:	74696e69 	strbtvc	r6, [r9], #-3689	; 0xfffff197
    1310:	50686300 	rsbpl	r6, r8, r0, lsl #6

#if !CH_NO_IDLE_THREAD
  /* This thread has the lowest priority in the system, its role is just to
     serve interrupts in its context while keeping the lowest energy saving
     mode compatible with the system status.*/
  chThdCreateStatic(_idle_thread_wa, sizeof(_idle_thread_wa), IDLEPRIO,
    1314:	4c6c6f6f 	stclmi	15, cr6, [ip], #-444	; 0xfffffe44
    1318:	4164616f 	cmnmi	r4, pc, ror #2
    131c:	79617272 	stmdbvc	r1!, {r1, r4, r5, r6, r9, ip, sp, lr}^
    1320:	50686300 	rsbpl	r6, r8, r0, lsl #6
    1324:	466c6f6f 	strbtmi	r6, [ip], -pc, ror #30
    1328:	49656572 	stmdbmi	r5!, {r1, r4, r5, r6, r8, sl, sp, lr}^
    132c:	50686300 	rsbpl	r6, r8, r0, lsl #6
    1330:	466c6f6f 	strbtmi	r6, [ip], -pc, ror #30
                    (tfunc_t)_idle_thread, NULL);
#endif
}
    1334:	00656572 	rsbeq	r6, r5, r2, ror r5
    1338:	6f506863 	svcvs	0x00506863
    133c:	6c416c6f 	mcrrvs	12, 6, r6, r1, cr15
 *          and, together with the @p CH_TIME_QUANTUM macro, the round robin
 *          interval.
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {
    1340:	49636f6c 	stmdbmi	r3!, {r2, r3, r5, r6, r8, r9, sl, fp, sp, lr}^

  chDbgCheckClassI();

#if CH_TIME_QUANTUM > 0
  /* Running thread has not used up quantum yet? */
  if (currp->p_preempt > 0)
    1344:	2f2e2e00 	svccs	0x002e2e00
    1348:	432f2e2e 	teqmi	pc, #736	; 0x2e0
    134c:	69626968 	stmdbvs	r2!, {r3, r5, r6, r8, fp, sp, lr}^
    1350:	6f2f534f 	svcvs	0x002f534f
    /* Decrement remaining quantum.*/
    currp->p_preempt--;
    1354:	656b2f73 	strbvs	r2, [fp, #-3955]!	; 0xfffff08d
    1358:	6c656e72 	stclvs	14, cr6, [r5], #-456	; 0xfffffe38
    135c:	6372732f 	cmnvs	r2, #-1140850688	; 0xbc000000
    1360:	6d68632f 	stclvs	3, cr6, [r8, #-188]!	; 0xffffff44
    1364:	6f706d65 	svcvs	0x00706d65
#endif
#if CH_DBG_THREADS_PROFILING
  currp->p_time++;
    1368:	2e736c6f 	cdpcs	12, 7, cr6, cr3, cr15, {3}
    136c:	68630063 	stmdavs	r3!, {r0, r1, r5, r6}^
    1370:	6c6f6f50 	stclvs	15, cr6, [pc], #-320	; 1238 <interruptEnable+0x8>
    1374:	6f6c6c41 	svcvs	0x006c6c41
    1378:	68630063 	stmdavs	r3!, {r0, r1, r5, r6}^
#endif
  chVTDoTickI();
    137c:	6c6f6f50 	stclvs	15, cr6, [pc], #-320	; 1244 <watchDogKick+0x8>
    1380:	74696e49 	strbtvc	r6, [r9], #-3657	; 0xfffff1b7
    1384:	2f2e2e00 	svccs	0x002e2e00
    1388:	432f2e2e 	teqmi	pc, #736	; 0x2e0
    138c:	69626968 	stmdbvs	r2!, {r3, r5, r6, r8, fp, sp, lr}^
    1390:	6f2f534f 	svcvs	0x002f534f
    1394:	6f702f73 	svcvs	0x00702f73
    1398:	2f737472 	svccs	0x00737472
    139c:	2f434347 	svccs	0x00434347
    13a0:	434d5241 	movtmi	r5, #53825	; 0xd241
    13a4:	632f784d 	teqvs	pc, #5046272	; 0x4d0000
    13a8:	726f6368 	rsbvc	r6, pc, #104, 6	; 0xa0000001
    13ac:	37765f65 	ldrbcc	r5, [r6, -r5, ror #30]!
    13b0:	00632e6d 	rsbeq	r2, r3, sp, ror #28
    13b4:	5f784d43 	svcpl	0x00784d43
    13b8:	00424353 	subeq	r4, r2, r3, asr r3
    13bc:	54737953 	ldrbtpl	r7, [r3], #-2387	; 0xfffff6ad
    13c0:	566b6369 	strbtpl	r6, [fp], -r9, ror #6
    13c4:	6f746365 	svcvs	0x00746365
    13c8:	705f0072 	subsvc	r0, pc, r2, ror r0	; <UNPREDICTABLE>
    13cc:	5f74726f 	svcpl	0x0074726f
    13d0:	65726874 	ldrbvs	r6, [r2, #-2164]!	; 0xfffff78c
    13d4:	735f6461 	cmpvc	pc, #1627389952	; 0x61000000
    13d8:	74726174 	ldrbtvc	r6, [r2], #-372	; 0xfffffe8c
    13dc:	41464200 	mrsmi	r4, (UNDEF: 102)
    13e0:	726c0052 	rsbvc	r0, ip, #82	; 0x52
    13e4:	6468745f 	strbtvs	r7, [r8], #-1119	; 0xfffffba1
    13e8:	74786500 	ldrbtvc	r6, [r8], #-1280	; 0xfffffb00
    13ec:	00787463 	rsbseq	r7, r8, r3, ror #8
    13f0:	726f705f 	rsbvc	r7, pc, #95	; 0x5f
    13f4:	77735f74 			; <UNDEFINED> instruction: 0x77735f74
    13f8:	68637469 	stmdavs	r3!, {r0, r3, r5, r6, sl, ip, sp, lr}^
    13fc:	4f545600 	svcmi	0x00545600
    1400:	705f0052 	subsvc	r0, pc, r2, asr r0	; <UNPREDICTABLE>
    1404:	5f74726f 	svcpl	0x0074726f
    1408:	74697773 	strbtvc	r7, [r9], #-1907	; 0xfffff88d
    140c:	665f6863 	ldrbvs	r6, [pc], -r3, ror #16
    1410:	5f6d6f72 	svcpl	0x006d6f72
#if defined(SYSTEM_TICK_EVENT_HOOK)
  SYSTEM_TICK_EVENT_HOOK();
#endif
}
    1414:	00727369 	rsbseq	r7, r2, r9, ror #6
    1418:	52534349 	subspl	r4, r3, #603979777	; 0x24000001
    141c:	52494100 	subpl	r4, r9, #0, 2
 *
 * @notapi
 */
void _vt_init(void) {

  vtlist.vt_next = vtlist.vt_prev = (void *)&vtlist;
    1420:	44005243 	strmi	r5, [r0], #-579	; 0xfffffdbd
    1424:	00525346 	subseq	r5, r2, r6, asr #6
    1428:	41464d4d 	cmpmi	r6, sp, asr #26
    142c:	705f0052 	subsvc	r0, pc, r2, asr r0	; <UNPREDICTABLE>
    1430:	5f74726f 	svcpl	0x0074726f
    1434:	5f717269 	svcpl	0x00717269
    1438:	6c697065 	stclvs	0, cr7, [r9], #-404	; 0xfffffe6c
    143c:	6575676f 	ldrbvs	r6, [r5, #-1903]!	; 0xfffff891
    1440:	53464300 	movtpl	r4, #25344	; 0x6300
    1444:	50430052 	subpl	r0, r3, r2, asr r0
  vtlist.vt_time = (systime_t)-1;
    1448:	00444955 	subeq	r4, r4, r5, asr r9
    144c:	70787463 	rsbsvc	r7, r8, r3, ror #8
    1450:	43485300 	movtmi	r5, #33536	; 0x8300
  vtlist.vt_systime = 0;
    1454:	78005253 	stmdavc	r0, {r0, r1, r4, r6, r9, ip, lr}
    1458:	00727370 	rsbseq	r7, r2, r0, ror r3
    145c:	52534641 	subspl	r4, r3, #68157440	; 0x4100000
    1460:	43565300 	cmpmi	r6, #0, 6
    1464:	566c6c61 	strbtpl	r6, [ip], -r1, ror #24
    1468:	6f746365 	svcvs	0x00746365
    146c:	48530072 	ldmdami	r3, {r1, r4, r5, r6}^
 * @param[in] par       a parameter that will be passed to the callback
 *                      function
 *
 * @iclass
 */
void chVTSetI(VirtualTimer *vtp, systime_t time, vtfunc_t vtfunc, void *par) {
    1470:	4d005250 	sfmmi	f5, 4, [r0, #-320]	; 0xfffffec0
    1474:	0052464d 	subseq	r4, r2, sp, asr #12
    1478:	726f705f 	rsbvc	r7, pc, #95	; 0x5f
  VirtualTimer *p;

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (time != TIME_IMMEDIATE),
    147c:	6e695f74 	mcrvs	15, 3, r5, cr9, cr4, {3}
    1480:	43007469 	movwmi	r7, #1129	; 0x469
    1484:	52434150 	subpl	r4, r3, #80, 2
    1488:	53464800 	movtpl	r4, #26624	; 0x6800
             "chVTSetI");

  vtp->vt_par = par;
    148c:	2e2e0052 	mcrcs	0, 1, r0, cr14, cr2, {2}
  vtp->vt_func = vtfunc;
    1490:	2f2e2e2f 	svccs	0x002e2e2f
    1494:	62696843 	rsbvs	r6, r9, #4390912	; 0x430000
  p = vtlist.vt_next;
    1498:	2f534f69 	svccs	0x00534f69
    149c:	702f736f 	eorvc	r7, pc, pc, ror #6
    14a0:	7374726f 	cmnvc	r4, #-268435450	; 0xf0000006
  while (p->vt_time < time) {
    time -= p->vt_time;
    14a4:	6d6f632f 	stclvs	3, cr6, [pc, #-188]!	; 13f0 <chSysTimerHandlerI+0xb0>
    14a8:	2f6e6f6d 	svccs	0x006e6f6d
    14ac:	434d5241 	movtmi	r5, #53825	; 0xd241
    p = p->vt_next;
    14b0:	6e2f784d 	cdpvs	8, 2, cr7, cr15, cr13, {2}
             "chVTSetI");

  vtp->vt_par = par;
  vtp->vt_func = vtfunc;
  p = vtlist.vt_next;
  while (p->vt_time < time) {
    14b4:	2e636976 	mcrcs	9, 3, r6, cr3, cr6, {3}
    14b8:	43490063 	movtmi	r0, #36963	; 0x9063
    14bc:	6e005250 	mcrvs	2, 0, r5, cr0, cr0, {2}
    time -= p->vt_time;
    p = p->vt_next;
  }

  vtp->vt_prev = (vtp->vt_next = p)->vt_prev;
    14c0:	44636976 	strbtmi	r6, [r3], #-2422	; 0xfffff68a
    14c4:	62617369 	rsbvs	r7, r1, #-1543503871	; 0xa4000001
    14c8:	6556656c 	ldrbvs	r6, [r6, #-1388]	; 0xfffffa94
    14cc:	726f7463 	rsbvc	r7, pc, #1660944384	; 0x63000000
  vtp->vt_prev->vt_next = p->vt_prev = vtp;
    14d0:	784d4300 	stmdavc	sp, {r8, r9, lr}^
    14d4:	49564e5f 	ldmdbmi	r6, {r0, r1, r2, r3, r4, r6, r9, sl, fp, lr}^
    14d8:	43490043 	movtmi	r0, #36931	; 0x9043
    14dc:	75005245 	strvc	r5, [r0, #-581]	; 0xfffffdbb
  vtp->vt_time = time;
    14e0:	6573756e 	ldrbvs	r7, [r3, #-1390]!	; 0xfffffa92
  if (p != (void *)&vtlist)
    14e4:	75003364 	strvc	r3, [r0, #-868]	; 0xfffffc9c
    14e8:	6573756e 	ldrbvs	r7, [r3, #-1390]!	; 0xfffffa92
    14ec:	75003464 	strvc	r3, [r0, #-1124]	; 0xfffffb9c
    14f0:	6573756e 	ldrbvs	r7, [r3, #-1390]!	; 0xfffffa92
    p->vt_time -= time;
    14f4:	75003564 	strvc	r3, [r0, #-1380]	; 0xfffffa9c
    14f8:	6573756e 	ldrbvs	r7, [r3, #-1390]!	; 0xfffffa92
    14fc:	53003664 	movwpl	r3, #1636	; 0x664
}
    1500:	00524954 	subseq	r4, r2, r4, asr r9
    1504:	52505349 	subspl	r5, r0, #603979777	; 0x24000001
    1508:	6e616800 	cdpvs	8, 6, cr6, cr1, cr0, {0}
    150c:	72656c64 	rsbvc	r6, r5, #100, 24	; 0x6400
 *
 * @param[in] vtp       the @p VirtualTimer structure pointer
 *
 * @iclass
 */
void chVTResetI(VirtualTimer *vtp) {
    1510:	45534900 	ldrbmi	r4, [r3, #-2304]	; 0xfffff700
  chDbgCheck(vtp != NULL, "chVTResetI");
  chDbgAssert(vtp->vt_func != NULL,
              "chVTResetI(), #1",
              "timer not set or already triggered");

  if (vtp->vt_next != (void *)&vtlist)
    1514:	766e0052 			; <UNDEFINED> instruction: 0x766e0052
    1518:	65536369 	ldrbvs	r6, [r3, #-873]	; 0xfffffc97
    151c:	73795374 	cmnvc	r9, #116, 6	; 0xd0000001
    1520:	486d6574 	stmdami	sp!, {r2, r4, r5, r6, r8, sl, sp, lr}^
    vtp->vt_next->vt_time += vtp->vt_time;
    1524:	6c646e61 	stclvs	14, cr6, [r4], #-388	; 0xfffffe7c
    1528:	72507265 	subsvc	r7, r0, #1342177286	; 0x50000006
    152c:	69726f69 	ldmdbvs	r2!, {r0, r3, r5, r6, r8, r9, sl, fp, sp, lr}^
    1530:	49007974 	stmdbmi	r0, {r2, r4, r5, r6, r8, fp, ip, sp, lr}
    1534:	00524241 	subseq	r4, r2, r1, asr #4
  vtp->vt_prev->vt_next = vtp->vt_next;
    1538:	6369766e 	cmnvs	r9, #115343360	; 0x6e00000
    153c:	62616e45 	rsbvs	r6, r1, #1104	; 0x450
  vtp->vt_next->vt_prev = vtp->vt_prev;
    1540:	6556656c 	ldrbvs	r6, [r6, #-1388]	; 0xfffffa94
    1544:	726f7463 	rsbvc	r7, pc, #1660944384	; 0x63000000
    1548:	4d686300 	stclmi	3, cr6, [r8, #-0]
  vtp->vt_func = (vtfunc_t)NULL;
    154c:	6e557874 	mrcvs	8, 2, r7, cr5, cr4, {3}
    1550:	6b636f6c 	blvs	18dd308 <_flash_swap_addr+0x189db08>
}
    1554:	4d686300 	stclmi	3, cr6, [r8, #-0]
    1558:	6f4c7874 	svcvs	0x004c7874
    155c:	00536b63 	subseq	r6, r3, r3, ror #22
 * @retval TRUE         current time within the specified time window.
 * @retval FALSE        current time not within the specified time window.
 *
 * @api
 */
bool_t chTimeIsWithin(systime_t start, systime_t end) {
    1560:	744d6863 	strbvc	r6, [sp], #-2147	; 0xfffff79d
    1564:	79725478 	ldmdbvc	r2!, {r3, r4, r5, r6, sl, ip, lr}^

  systime_t time = chTimeNow();
    1568:	6b636f4c 	blvs	18dd2a0 <_flash_swap_addr+0x189daa0>
    156c:	68630053 	stmdavs	r3!, {r0, r1, r4, r6}^
    1570:	5578744d 	ldrbpl	r7, [r8, #-1101]!	; 0xfffffbb3
  return end > start ? (time >= start) && (time < end) :
    1574:	636f6c6e 	cmnvs	pc, #28160	; 0x6e00
    1578:	7000536b 	andvc	r5, r0, fp, ror #6
    157c:	5f6f6972 	svcpl	0x006f6972
    1580:	65736e69 	ldrbvs	r6, [r3, #-3689]!	; 0xfffff197
    1584:	63007472 	movwvs	r7, #1138	; 0x472
    1588:	78744d68 	ldmdavc	r4!, {r3, r5, r6, r8, sl, fp, lr}^
    158c:	6f6c6e55 	svcvs	0x006c6e55
    1590:	6c416b63 	mcrrvs	11, 6, r6, r1, cr3
    1594:	6863006c 	stmdavs	r3!, {r2, r3, r5, r6}^
    1598:	5478744d 	ldrbtpl	r7, [r8], #-1101	; 0xfffffbb3
    159c:	6f4c7972 	svcvs	0x004c7972
                       (time >= start) || (time < end);
    15a0:	63006b63 	movwvs	r6, #2915	; 0xb63
    15a4:	78744d68 	ldmdavc	r4!, {r3, r5, r6, r8, sl, fp, lr}^
 * @api
 */
bool_t chTimeIsWithin(systime_t start, systime_t end) {

  systime_t time = chTimeNow();
  return end > start ? (time >= start) && (time < end) :
    15a8:	6b636f4c 	blvs	18dd2e0 <_flash_swap_addr+0x189dae0>
    15ac:	4d686300 	stclmi	3, cr6, [r8, #-0]
                       (time >= start) || (time < end);
}
    15b0:	6e497874 	mcrvs	8, 2, r7, cr9, cr4, {3}
    15b4:	2e007469 	cdpcs	4, 0, cr7, cr0, cr9, {3}
    15b8:	2e2e2f2e 	cdpcs	15, 2, cr2, cr14, cr14, {1}
    15bc:	6968432f 	stmdbvs	r8!, {r0, r1, r2, r3, r5, r8, r9, lr}^
  tp->p_next = (Thread *)tqp;
  tp->p_prev = tqp->p_prev;
  tp->p_prev->p_next = tqp->p_prev = tp;
}

static INLINE Thread *fifo_remove(ThreadsQueue *tqp) {
    15c0:	534f6962 	movtpl	r6, #63842	; 0xf962
  Thread *tp = tqp->p_next;
    15c4:	2f736f2f 	svccs	0x00736f2f
    15c8:	6e72656b 	cdpvs	5, 7, cr6, cr2, cr11, {3}

  (tqp->p_next = tp->p_next)->p_prev = (Thread *)tqp;
    15cc:	732f6c65 	teqvc	pc, #25856	; 0x6500
    15d0:	632f6372 	teqvs	pc, #-939524095	; 0xc8000001
    15d4:	78746d68 	ldmdavc	r4!, {r3, r5, r6, r8, sl, fp, sp, lr}^
    15d8:	Address 0x000015d8 is out of bounds.


Disassembly of section .debug_frame:

00000000 <.debug_frame>:
   0:	0000000c 	andeq	r0, r0, ip
   4:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff
   8:	7c020001 	stcvc	0, cr0, [r2], {1}
   c:	000d0c0e 	andeq	r0, sp, lr, lsl #24
  10:	00000018 	andeq	r0, r0, r8, lsl r0
  14:	00000000 	andeq	r0, r0, r0
  18:	00000560 	andeq	r0, r0, r0, ror #10
  1c:	00000014 	andeq	r0, r0, r4, lsl r0
  20:	87040e41 	strhi	r0, [r4, -r1, asr #28]
  24:	100e4101 	andne	r4, lr, r1, lsl #2
  28:	00070d41 	andeq	r0, r7, r1, asr #26
  2c:	0000001c 	andeq	r0, r0, ip, lsl r0
  30:	00000000 	andeq	r0, r0, r0
  34:	00000574 	andeq	r0, r0, r4, ror r5
  38:	00000022 	andeq	r0, r0, r2, lsr #32
  3c:	8e080e41 	cdphi	14, 0, cr0, cr8, cr1, {2}
  40:	41028701 	tstmi	r2, r1, lsl #14
  44:	0d41100e 	stcleq	0, cr1, [r1, #-56]	; 0xffffffc8
  48:	00000007 	andeq	r0, r0, r7
  4c:	00000018 	andeq	r0, r0, r8, lsl r0
  50:	00000000 	andeq	r0, r0, r0
  54:	00000598 	muleq	r0, r8, r5
  58:	00000022 	andeq	r0, r0, r2, lsr #32
  5c:	8e080e41 	cdphi	14, 0, cr0, cr8, cr1, {2}
  60:	41028701 	tstmi	r2, r1, lsl #14
  64:	0000070d 	andeq	r0, r0, sp, lsl #14
  68:	0000001c 	andeq	r0, r0, ip, lsl r0
  6c:	00000000 	andeq	r0, r0, r0
  70:	000005bc 			; <UNDEFINED> instruction: 0x000005bc
  74:	00000054 	andeq	r0, r0, r4, asr r0
  78:	8e080e41 	cdphi	14, 0, cr0, cr8, cr1, {2}
  7c:	41028701 	tstmi	r2, r1, lsl #14
  80:	0d41100e 	stcleq	0, cr1, [r1, #-56]	; 0xffffffc8
  84:	00000007 	andeq	r0, r0, r7
  88:	0000001c 	andeq	r0, r0, ip, lsl r0
  8c:	00000000 	andeq	r0, r0, r0
  90:	00000610 	andeq	r0, r0, r0, lsl r6
  94:	00000078 	andeq	r0, r0, r8, ror r0
  98:	8e080e41 	cdphi	14, 0, cr0, cr8, cr1, {2}
  9c:	41028701 	tstmi	r2, r1, lsl #14
  a0:	0c41100e 	mcrreq	0, 0, r1, r1, cr14
  a4:	00000807 	andeq	r0, r0, r7, lsl #16
  a8:	0000000c 	andeq	r0, r0, ip
  ac:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff
  b0:	7c020001 	stcvc	0, cr0, [r2], {1}
  b4:	000d0c0e 	andeq	r0, sp, lr, lsl #24
  b8:	0000001c 	andeq	r0, r0, ip, lsl r0
  bc:	000000a8 	andeq	r0, r0, r8, lsr #1
  c0:	00000688 	andeq	r0, r0, r8, lsl #13
  c4:	000000b4 	strheq	r0, [r0], -r4
  c8:	8e080e41 	cdphi	14, 0, cr0, cr8, cr1, {2}
  cc:	41028701 	tstmi	r2, r1, lsl #14
  d0:	0d41180e 	stcleq	8, cr1, [r1, #-56]	; 0xffffffc8
  d4:	00000007 	andeq	r0, r0, r7
  d8:	0000001c 	andeq	r0, r0, ip, lsl r0
  dc:	000000a8 	andeq	r0, r0, r8, lsr #1
  e0:	0000073c 	andeq	r0, r0, ip, lsr r7
  e4:	00000202 	andeq	r0, r0, r2, lsl #4
  e8:	8e080e41 	cdphi	14, 0, cr0, cr8, cr1, {2}
  ec:	41028701 	tstmi	r2, r1, lsl #14
  f0:	0d41280e 	stcleq	8, cr2, [r1, #-56]	; 0xffffffc8
  f4:	00000007 	andeq	r0, r0, r7
  f8:	0000001c 	andeq	r0, r0, ip, lsl r0
  fc:	000000a8 	andeq	r0, r0, r8, lsr #1
 100:	00000940 	andeq	r0, r0, r0, asr #18
 104:	0000002a 	andeq	r0, r0, sl, lsr #32
 108:	8e080e41 	cdphi	14, 0, cr0, cr8, cr1, {2}
 10c:	41028701 	tstmi	r2, r1, lsl #14
 110:	0d41180e 	stcleq	8, cr1, [r1, #-56]	; 0xffffffc8
 114:	00000007 	andeq	r0, r0, r7
 118:	0000001c 	andeq	r0, r0, ip, lsl r0
 11c:	000000a8 	andeq	r0, r0, r8, lsr #1
 120:	0000096c 	andeq	r0, r0, ip, ror #18
 124:	0000002a 	andeq	r0, r0, sl, lsr #32
 128:	8e080e41 	cdphi	14, 0, cr0, cr8, cr1, {2}
 12c:	41028701 	tstmi	r2, r1, lsl #14
 130:	0d41180e 	stcleq	8, cr1, [r1, #-56]	; 0xffffffc8
 134:	00000007 	andeq	r0, r0, r7
 138:	0000001c 	andeq	r0, r0, ip, lsl r0
 13c:	000000a8 	andeq	r0, r0, r8, lsr #1
 140:	00000998 	muleq	r0, r8, r9
 144:	0000002a 	andeq	r0, r0, sl, lsr #32
 148:	8e080e41 	cdphi	14, 0, cr0, cr8, cr1, {2}
 14c:	41028701 	tstmi	r2, r1, lsl #14
 150:	0d41180e 	stcleq	8, cr1, [r1, #-56]	; 0xffffffc8
 154:	00000007 	andeq	r0, r0, r7
 158:	00000018 	andeq	r0, r0, r8, lsl r0
 15c:	000000a8 	andeq	r0, r0, r8, lsr #1
 160:	000009c4 	andeq	r0, r0, r4, asr #19
 164:	00000016 	andeq	r0, r0, r6, lsl r0
 168:	87040e41 	strhi	r0, [r4, -r1, asr #28]
 16c:	180e4101 	stmdane	lr, {r0, r8, lr}
 170:	00070d41 	andeq	r0, r7, r1, asr #26
 174:	00000018 	andeq	r0, r0, r8, lsl r0
 178:	000000a8 	andeq	r0, r0, r8, lsr #1
 17c:	000009dc 	ldrdeq	r0, [r0], -ip
 180:	00000018 	andeq	r0, r0, r8, lsl r0
 184:	87040e41 	strhi	r0, [r4, -r1, asr #28]
 188:	100e4101 	andne	r4, lr, r1, lsl #2
 18c:	00070d41 	andeq	r0, r7, r1, asr #26
 190:	0000001c 	andeq	r0, r0, ip, lsl r0
 194:	000000a8 	andeq	r0, r0, r8, lsr #1
 198:	000009f4 	strdeq	r0, [r0], -r4
 19c:	00000034 	andeq	r0, r0, r4, lsr r0
 1a0:	8e080e41 	cdphi	14, 0, cr0, cr8, cr1, {2}
 1a4:	41028701 	tstmi	r2, r1, lsl #14
 1a8:	0d41180e 	stcleq	8, cr1, [r1, #-56]	; 0xffffffc8
 1ac:	00000007 	andeq	r0, r0, r7
 1b0:	0000000c 	andeq	r0, r0, ip
 1b4:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff
 1b8:	7c020001 	stcvc	0, cr0, [r2], {1}
 1bc:	000d0c0e 	andeq	r0, sp, lr, lsl #24
 1c0:	00000018 	andeq	r0, r0, r8, lsl r0
 1c4:	000001b0 			; <UNDEFINED> instruction: 0x000001b0
 1c8:	00000a28 	andeq	r0, r0, r8, lsr #20
 1cc:	00000014 	andeq	r0, r0, r4, lsl r0
 1d0:	87040e41 	strhi	r0, [r4, -r1, asr #28]
 1d4:	100e4101 	andne	r4, lr, r1, lsl #2
 1d8:	00070d41 	andeq	r0, r7, r1, asr #26
 1dc:	00000018 	andeq	r0, r0, r8, lsl r0
 1e0:	000001b0 			; <UNDEFINED> instruction: 0x000001b0
 1e4:	00000a3c 	andeq	r0, r0, ip, lsr sl
 1e8:	000001ca 	andeq	r0, r0, sl, asr #3
 1ec:	87040e41 	strhi	r0, [r4, -r1, asr #28]
 1f0:	100e4101 	andne	r4, lr, r1, lsl #2
 1f4:	00070d41 	andeq	r0, r7, r1, asr #26
 1f8:	00000018 	andeq	r0, r0, r8, lsl r0
 1fc:	000001b0 			; <UNDEFINED> instruction: 0x000001b0
 200:	00000c08 	andeq	r0, r0, r8, lsl #24
 204:	00000014 	andeq	r0, r0, r4, lsl r0
 208:	87040e41 	strhi	r0, [r4, -r1, asr #28]
 20c:	100e4101 	andne	r4, lr, r1, lsl #2
 210:	00070d41 	andeq	r0, r7, r1, asr #26
 214:	00000018 	andeq	r0, r0, r8, lsl r0
 218:	000001b0 			; <UNDEFINED> instruction: 0x000001b0
 21c:	00000c1c 	andeq	r0, r0, ip, lsl ip
 220:	00000014 	andeq	r0, r0, r4, lsl r0
 224:	87040e41 	strhi	r0, [r4, -r1, asr #28]
 228:	100e4101 	andne	r4, lr, r1, lsl #2
 22c:	00070d41 	andeq	r0, r7, r1, asr #26
 230:	00000018 	andeq	r0, r0, r8, lsl r0
 234:	000001b0 			; <UNDEFINED> instruction: 0x000001b0
 238:	00000c30 	andeq	r0, r0, r0, lsr ip
 23c:	00000014 	andeq	r0, r0, r4, lsl r0
 240:	87040e41 	strhi	r0, [r4, -r1, asr #28]
 244:	100e4101 	andne	r4, lr, r1, lsl #2
 248:	00070d41 	andeq	r0, r7, r1, asr #26
 24c:	00000018 	andeq	r0, r0, r8, lsl r0
 250:	000001b0 			; <UNDEFINED> instruction: 0x000001b0
 254:	00000c44 	andeq	r0, r0, r4, asr #24
 258:	00000014 	andeq	r0, r0, r4, lsl r0
 25c:	87040e41 	strhi	r0, [r4, -r1, asr #28]
 260:	100e4101 	andne	r4, lr, r1, lsl #2
 264:	00070d41 	andeq	r0, r7, r1, asr #26
 268:	00000018 	andeq	r0, r0, r8, lsl r0
 26c:	000001b0 			; <UNDEFINED> instruction: 0x000001b0
 270:	00000c58 	andeq	r0, r0, r8, asr ip
 274:	00000014 	andeq	r0, r0, r4, lsl r0
 278:	87040e41 	strhi	r0, [r4, -r1, asr #28]
 27c:	100e4101 	andne	r4, lr, r1, lsl #2
 280:	00070d41 	andeq	r0, r7, r1, asr #26
 284:	00000018 	andeq	r0, r0, r8, lsl r0
 288:	000001b0 			; <UNDEFINED> instruction: 0x000001b0
 28c:	00000c6c 	andeq	r0, r0, ip, ror #24
 290:	00000014 	andeq	r0, r0, r4, lsl r0
 294:	87040e41 	strhi	r0, [r4, -r1, asr #28]
 298:	100e4101 	andne	r4, lr, r1, lsl #2
 29c:	00070d41 	andeq	r0, r7, r1, asr #26
 2a0:	00000018 	andeq	r0, r0, r8, lsl r0
 2a4:	000001b0 			; <UNDEFINED> instruction: 0x000001b0
 2a8:	00000c80 	andeq	r0, r0, r0, lsl #25
 2ac:	000000e0 	andeq	r0, r0, r0, ror #1
 2b0:	87040e41 	strhi	r0, [r4, -r1, asr #28]
 2b4:	100e4101 	andne	r4, lr, r1, lsl #2
 2b8:	00070d41 	andeq	r0, r7, r1, asr #26
 2bc:	00000018 	andeq	r0, r0, r8, lsl r0
 2c0:	000001b0 			; <UNDEFINED> instruction: 0x000001b0
 2c4:	00000d60 	andeq	r0, r0, r0, ror #26
 2c8:	00000014 	andeq	r0, r0, r4, lsl r0
 2cc:	87040e41 	strhi	r0, [r4, -r1, asr #28]
 2d0:	100e4101 	andne	r4, lr, r1, lsl #2
 2d4:	00070d41 	andeq	r0, r7, r1, asr #26
 2d8:	00000018 	andeq	r0, r0, r8, lsl r0
 2dc:	000001b0 			; <UNDEFINED> instruction: 0x000001b0
 2e0:	00000d74 	andeq	r0, r0, r4, ror sp
 2e4:	00000014 	andeq	r0, r0, r4, lsl r0
 2e8:	87040e41 	strhi	r0, [r4, -r1, asr #28]
 2ec:	100e4101 	andne	r4, lr, r1, lsl #2
 2f0:	00070d41 	andeq	r0, r7, r1, asr #26
 2f4:	00000018 	andeq	r0, r0, r8, lsl r0
 2f8:	000001b0 			; <UNDEFINED> instruction: 0x000001b0
 2fc:	00000d88 	andeq	r0, r0, r8, lsl #27
 300:	00000014 	andeq	r0, r0, r4, lsl r0
 304:	87040e41 	strhi	r0, [r4, -r1, asr #28]
 308:	100e4101 	andne	r4, lr, r1, lsl #2
 30c:	00070d41 	andeq	r0, r7, r1, asr #26
 310:	00000018 	andeq	r0, r0, r8, lsl r0
 314:	000001b0 			; <UNDEFINED> instruction: 0x000001b0
 318:	00000d9c 	muleq	r0, ip, sp
 31c:	00000014 	andeq	r0, r0, r4, lsl r0
 320:	87040e41 	strhi	r0, [r4, -r1, asr #28]
 324:	100e4101 	andne	r4, lr, r1, lsl #2
 328:	00070d41 	andeq	r0, r7, r1, asr #26
 32c:	00000018 	andeq	r0, r0, r8, lsl r0
 330:	000001b0 			; <UNDEFINED> instruction: 0x000001b0
 334:	00000db0 			; <UNDEFINED> instruction: 0x00000db0
 338:	00000014 	andeq	r0, r0, r4, lsl r0
 33c:	87040e41 	strhi	r0, [r4, -r1, asr #28]
 340:	100e4101 	andne	r4, lr, r1, lsl #2
 344:	00070d41 	andeq	r0, r7, r1, asr #26
 348:	00000018 	andeq	r0, r0, r8, lsl r0
 34c:	000001b0 			; <UNDEFINED> instruction: 0x000001b0
 350:	00000dc4 	andeq	r0, r0, r4, asr #27
 354:	00000014 	andeq	r0, r0, r4, lsl r0
 358:	87040e41 	strhi	r0, [r4, -r1, asr #28]
 35c:	100e4101 	andne	r4, lr, r1, lsl #2
 360:	00070d41 	andeq	r0, r7, r1, asr #26
 364:	00000018 	andeq	r0, r0, r8, lsl r0
 368:	000001b0 			; <UNDEFINED> instruction: 0x000001b0
 36c:	00000dd8 	ldrdeq	r0, [r0], -r8
 370:	00000014 	andeq	r0, r0, r4, lsl r0
 374:	87040e41 	strhi	r0, [r4, -r1, asr #28]
 378:	100e4101 	andne	r4, lr, r1, lsl #2
 37c:	00070d41 	andeq	r0, r7, r1, asr #26
 380:	00000018 	andeq	r0, r0, r8, lsl r0
 384:	000001b0 			; <UNDEFINED> instruction: 0x000001b0
 388:	00000dec 	andeq	r0, r0, ip, ror #27
 38c:	00000014 	andeq	r0, r0, r4, lsl r0
 390:	87040e41 	strhi	r0, [r4, -r1, asr #28]
 394:	100e4101 	andne	r4, lr, r1, lsl #2
 398:	00070d41 	andeq	r0, r7, r1, asr #26
 39c:	00000018 	andeq	r0, r0, r8, lsl r0
 3a0:	000001b0 			; <UNDEFINED> instruction: 0x000001b0
 3a4:	00000e00 	andeq	r0, r0, r0, lsl #28
 3a8:	00000014 	andeq	r0, r0, r4, lsl r0
 3ac:	87040e41 	strhi	r0, [r4, -r1, asr #28]
 3b0:	100e4101 	andne	r4, lr, r1, lsl #2
 3b4:	00070d41 	andeq	r0, r7, r1, asr #26
 3b8:	00000018 	andeq	r0, r0, r8, lsl r0
 3bc:	000001b0 			; <UNDEFINED> instruction: 0x000001b0
 3c0:	00000e14 	andeq	r0, r0, r4, lsl lr
 3c4:	00000014 	andeq	r0, r0, r4, lsl r0
 3c8:	87040e41 	strhi	r0, [r4, -r1, asr #28]
 3cc:	100e4101 	andne	r4, lr, r1, lsl #2
 3d0:	00070d41 	andeq	r0, r7, r1, asr #26
 3d4:	00000018 	andeq	r0, r0, r8, lsl r0
 3d8:	000001b0 			; <UNDEFINED> instruction: 0x000001b0
 3dc:	00000e28 	andeq	r0, r0, r8, lsr #28
 3e0:	00000014 	andeq	r0, r0, r4, lsl r0
 3e4:	87040e41 	strhi	r0, [r4, -r1, asr #28]
 3e8:	100e4101 	andne	r4, lr, r1, lsl #2
 3ec:	00070d41 	andeq	r0, r7, r1, asr #26
 3f0:	0000001c 	andeq	r0, r0, ip, lsl r0
 3f4:	000001b0 			; <UNDEFINED> instruction: 0x000001b0
 3f8:	00000e3c 	andeq	r0, r0, ip, lsr lr
 3fc:	00000156 	andeq	r0, r0, r6, asr r1
 400:	8e080e41 	cdphi	14, 0, cr0, cr8, cr1, {2}
 404:	41028701 	tstmi	r2, r1, lsl #14
 408:	0d41180e 	stcleq	8, cr1, [r1, #-56]	; 0xffffffc8
 40c:	00000007 	andeq	r0, r0, r7
    .thumb_func

_default_reset_handler:

unlock_watchdog:
    ldr r6, =0x4005200e
 410:	0000001c 	andeq	r0, r0, ip, lsl r0
    ldr r0, =0xc520
    strh r0, [r6]
 414:	000001b0 			; <UNDEFINED> instruction: 0x000001b0
    ldr r0, =0xd928
    strh r0, [r6]
 418:	00000f94 	muleq	r0, r4, pc	; <UNPREDICTABLE>

disable_watchdog:
    ldr r6, =0x40052000
    ldr r0, =0x01d2
 41c:	000000c8 	andeq	r0, r0, r8, asr #1
     * address 0x00000000 (which is the first element in the vector_table) by
     * the hardware. The next three lines are required in case this image
     * is not located at 0x0 (i.e. it is being launched from a bootloader).
     */

    ldr r1, =_vector_table
 420:	8e080e41 	cdphi	14, 0, cr0, cr8, cr1, {2}
    ldr r2, [r1]
    mov	sp,r2
 424:	41028701 	tstmi	r2, r1, lsl #14
chibi_setup:
    /*
     * ChibiOS requires a process stack to be initialized.
     */
    ldr r1, =_process_stack_start
    msr PSP, r1
 428:	0d41180e 	stcleq	8, cr1, [r1, #-56]	; 0xffffffc8

    /* TODO: FPU register initialization per crt0.c */
    /*
     * Set up system to run in privileged mode using the PSP stack
     */
    ldr r1, =0x00000002
 42c:	00000007 	andeq	r0, r0, r7
    msr CONTROL, r1
 430:	0000001c 	andeq	r0, r0, ip, lsl r0
    isb
 434:	000001b0 			; <UNDEFINED> instruction: 0x000001b0
     * address and the start address are not the same. This code supports
     * running an entire image out of SRAM.
     */

    ldr r0, =_text_start
    ldr r1, =_text_end
 438:	0000105c 	andeq	r1, r0, ip, asr r0
    ldr r2, =_text_load

    cmp r0, r2
 43c:	00000090 	muleq	r0, r0, r0
    beq end_text_loop
 440:	8e080e41 	cdphi	14, 0, cr0, cr8, cr1, {2}
text_loop:
    cmp r0, r1
    ittt    lt
 444:	41028701 	tstmi	r2, r1, lsl #14
    ldrlt   r3, [r2], #4
 448:	0d41100e 	stcleq	0, cr1, [r1, #-56]	; 0xffffffc8
    strlt   r3, [r0], #4
 44c:	00000007 	andeq	r0, r0, r7
    blt     text_loop
 450:	00000014 	andeq	r0, r0, r4, lsl r0
    /*
     * Relocate the .ramcode section from FLASH to SRAM.
     */

    ldr r0, =_ramcode_start
    ldr r1, =_ramcode_end
 454:	000001b0 			; <UNDEFINED> instruction: 0x000001b0
    ldr r2, =_ramcode_load

ramcode_loop:
    cmp r0, r1
 458:	000010ec 	andeq	r1, r0, ip, ror #1
    ittt    lt
    ldrlt   r3, [r2], #4
 45c:	0000000a 	andeq	r0, r0, sl
    strlt   r3, [r0], #4
 460:	87040e41 	strhi	r0, [r4, -r1, asr #28]
    blt     ramcode_loop
 464:	070d4101 	streq	r4, [sp, -r1, lsl #2]

    /*
     * Relocate vector table to SRAM.
     */

     ldr r0, =_vector_ram_start
 468:	00000014 	andeq	r0, r0, r4, lsl r0
     ldr r1, =_vector_ram_end
     ldr r2, =_vector_rom
 46c:	000001b0 			; <UNDEFINED> instruction: 0x000001b0
vector_loop:
    cmp r0, r1
    ittt    lt
 470:	000010f8 	strdeq	r1, [r0], -r8
    ldrlt   r3, [r2], #4
 474:	0000000a 	andeq	r0, r0, sl
    strlt   r3, [r0], #4
 478:	87040e41 	strhi	r0, [r4, -r1, asr #28]
    blt     vector_loop
 47c:	070d4101 	streq	r4, [sp, -r1, lsl #2]
    /*
     * Point to the SRAM vector table.
     */

    ldr r1,=0xe000ed08
    ldr r0,=_vector_ram_start
 480:	00000014 	andeq	r0, r0, r4, lsl r0
     * Note: _data_start contains the SRAM (destination) address and
     *       _text_end contains the (source) address of the .data section
     *       in FLASH.
     */

    ldr r0, =_data_start
 484:	000001b0 			; <UNDEFINED> instruction: 0x000001b0
    ldr r1, =_data_end
    ldr r2, =_data_load
 488:	00001104 	andeq	r1, r0, r4, lsl #2

data_loop:
    cmp r0, r1
    ittt    lt
 48c:	0000000a 	andeq	r0, r0, sl
    ldrlt   r3, [r2], #4
 490:	87040e41 	strhi	r0, [r4, -r1, asr #28]
    strlt   r3, [r0], #4
 494:	070d4101 	streq	r4, [sp, -r1, lsl #2]
    blt     data_loop
 498:	00000014 	andeq	r0, r0, r4, lsl r0
    /*
     * Zero out the .bss section in SRAM.
     */

    ldr r0, =_bss_start
    ldr r1, =_bss_end
 49c:	000001b0 			; <UNDEFINED> instruction: 0x000001b0
    ldr r2, =0x00000000

bss_loop:
    cmp r0, r1
 4a0:	00001110 	andeq	r1, r0, r0, lsl r1
    itt     lt
    strlt   r2, [r0], #4
 4a4:	0000000a 	andeq	r0, r0, sl
    blt     bss_loop
 4a8:	87040e41 	strhi	r0, [r4, -r1, asr #28]

    /*
     * Zero out heap.
     */

    ldr r0, =_heap_start
 4ac:	070d4101 	streq	r4, [sp, -r1, lsl #2]
    ldr r1, =_heap_end

heap_loop:
    cmp r0, r1
 4b0:	00000014 	andeq	r0, r0, r4, lsl r0
    itt     lt
    strlt   r2, [r0], #4
 4b4:	000001b0 			; <UNDEFINED> instruction: 0x000001b0
    blt     heap_loop
 4b8:	0000111c 	andeq	r1, r0, ip, lsl r1
    ldr r0, =_stack_start
    ldr r1, =_stack_end
    ldr r2, =0xefefefef
*/

    ldr r0, =_stack_end
 4bc:	0000000a 	andeq	r0, r0, sl
    ldr r1, =_stack_start
    ldr r2, =0xefefefef
 4c0:	87040e41 	strhi	r0, [r4, -r1, asr #28]

stack_loop:
    cmp r0, r1
    itt     lt
 4c4:	070d4101 	streq	r4, [sp, -r1, lsl #2]
    strlt   r2, [r0], #4
 4c8:	00000014 	andeq	r0, r0, r4, lsl r0
    blt     stack_loop
 4cc:	000001b0 			; <UNDEFINED> instruction: 0x000001b0

call_user_asm_code:
    bl main
 4d0:	00001128 	andeq	r1, r0, r8, lsr #2
    /*
     * Epilogue processing would go here.
     */

end_loop:
    b end_loop
 4d4:	0000000a 	andeq	r0, r0, sl

    .align 2
    .thumb_func

_default_nmi_handler:
    b _default_nmi_handler
 4d8:	87040e41 	strhi	r0, [r4, -r1, asr #28]

    .align 2
    .thumb_func

_default_fault_handler:
    b _default_fault_handler
 4dc:	070d4101 	streq	r4, [sp, -r1, lsl #2]

    .align 2
    .thumb_func

_default_irq_handler:
    b _default_irq_handler
 4e0:	00000014 	andeq	r0, r0, r4, lsl r0
    .thumb_func

_default_reset_handler:

unlock_watchdog:
    ldr r6, =0x4005200e
 4e4:	000001b0 			; <UNDEFINED> instruction: 0x000001b0
    ldr r0, =0xc520
 4e8:	00001134 	andeq	r1, r0, r4, lsr r1
    strh r0, [r6]
    ldr r0, =0xd928
 4ec:	0000000a 	andeq	r0, r0, sl
    strh r0, [r6]

disable_watchdog:
    ldr r6, =0x40052000
 4f0:	87040e41 	strhi	r0, [r4, -r1, asr #28]
    ldr r0, =0x01d2
 4f4:	070d4101 	streq	r4, [sp, -r1, lsl #2]
     * address 0x00000000 (which is the first element in the vector_table) by
     * the hardware. The next three lines are required in case this image
     * is not located at 0x0 (i.e. it is being launched from a bootloader).
     */

    ldr r1, =_vector_table
 4f8:	00000014 	andeq	r0, r0, r4, lsl r0

chibi_setup:
    /*
     * ChibiOS requires a process stack to be initialized.
     */
    ldr r1, =_process_stack_start
 4fc:	000001b0 			; <UNDEFINED> instruction: 0x000001b0

    /* TODO: FPU register initialization per crt0.c */
    /*
     * Set up system to run in privileged mode using the PSP stack
     */
    ldr r1, =0x00000002
 500:	00001140 	andeq	r1, r0, r0, asr #2
     * Relocate the .text section from FLASH to SRAM only if the load
     * address and the start address are not the same. This code supports
     * running an entire image out of SRAM.
     */

    ldr r0, =_text_start
 504:	0000000a 	andeq	r0, r0, sl
    ldr r1, =_text_end
 508:	87040e41 	strhi	r0, [r4, -r1, asr #28]
    ldr r2, =_text_load
 50c:	070d4101 	streq	r4, [sp, -r1, lsl #2]

    /*
     * Relocate the .ramcode section from FLASH to SRAM.
     */

    ldr r0, =_ramcode_start
 510:	00000014 	andeq	r0, r0, r4, lsl r0
    ldr r1, =_ramcode_end
 514:	000001b0 			; <UNDEFINED> instruction: 0x000001b0
    ldr r2, =_ramcode_load
 518:	0000114c 	andeq	r1, r0, ip, asr #2

    /*
     * Relocate vector table to SRAM.
     */

     ldr r0, =_vector_ram_start
 51c:	0000000a 	andeq	r0, r0, sl
     ldr r1, =_vector_ram_end
 520:	87040e41 	strhi	r0, [r4, -r1, asr #28]
     ldr r2, =_vector_rom
 524:	070d4101 	streq	r4, [sp, -r1, lsl #2]

    /*
     * Point to the SRAM vector table.
     */

    ldr r1,=0xe000ed08
 528:	0000000c 	andeq	r0, r0, ip
     * Note: _data_start contains the SRAM (destination) address and
     *       _text_end contains the (source) address of the .data section
     *       in FLASH.
     */

    ldr r0, =_data_start
 52c:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff
    ldr r1, =_data_end
 530:	7c020001 	stcvc	0, cr0, [r2], {1}
    ldr r2, =_data_load
 534:	000d0c0e 	andeq	r0, sp, lr, lsl #24

    /*
     * Zero out the .bss section in SRAM.
     */

    ldr r0, =_bss_start
 538:	00000014 	andeq	r0, r0, r4, lsl r0
    ldr r1, =_bss_end
 53c:	00000528 	andeq	r0, r0, r8, lsr #10
    ldr r2, =0x00000000
 540:	00001158 	andeq	r1, r0, r8, asr r1

    /*
     * Zero out heap.
     */

    ldr r0, =_heap_start
 544:	0000002a 	andeq	r0, r0, sl, lsr #32
    ldr r1, =_heap_end
 548:	87040e41 	strhi	r0, [r4, -r1, asr #28]
    ldr r0, =_stack_start
    ldr r1, =_stack_end
    ldr r2, =0xefefefef
*/

    ldr r0, =_stack_end
 54c:	070d4101 	streq	r4, [sp, -r1, lsl #2]
    ldr r1, =_stack_start
 550:	0000001c 	andeq	r0, r0, ip, lsl r0
    ldr r2, =0xefefefef
 554:	00000528 	andeq	r0, r0, r8, lsr #10
 558:	00001184 	andeq	r1, r0, r4, lsl #3
 55c:	000000a0 	andeq	r0, r0, r0, lsr #1
#define TSI_ORANGE_BIT    BIT_5

#define TSI_YELLOW_INDEX  8
#define TSI_YELLOW_BIT    BIT_8

void assert_(const char *file, const int line) { }
 560:	8e080e41 	cdphi	14, 0, cr0, cr8, cr1, {2}
 564:	41028701 	tstmi	r2, r1, lsl #14
 568:	0d41100e 	stcleq	0, cr1, [r1, #-56]	; 0xffffffc8
 56c:	00000007 	andeq	r0, r0, r7
 570:	00000014 	andeq	r0, r0, r4, lsl r0

static WORKING_AREA(waThread1, 128);
static msg_t Thread1(void *arg) {
 574:	00000528 	andeq	r0, r0, r8, lsr #10
 578:	00001224 	andeq	r1, r0, r4, lsr #4
    while (TRUE) {
        chThdSleepMilliseconds(500);
 57c:	0000000c 	andeq	r0, r0, ip
 580:	87040e41 	strhi	r0, [r4, -r1, asr #28]
        gpioToggle(N_LED_YELLOW_PORT, N_LED_YELLOW_PIN);
 584:	070d4101 	streq	r4, [sp, -r1, lsl #2]
 588:	00000014 	andeq	r0, r0, r4, lsl r0
 58c:	00000528 	andeq	r0, r0, r8, lsr #10
 590:	00001230 	andeq	r1, r0, r0, lsr r2
    }
 594:	0000000c 	andeq	r0, r0, ip

    return 0;
}

static void clocksInit(void)
{
 598:	87040e41 	strhi	r0, [r4, -r1, asr #28]
     * System:  100 MHz
     * Bus:      50 MHz
     * Flexbus:  50 MHz
     * Flash:    25 MHz
     */
    clockSetDividers(DIVIDE_BY_1, DIVIDE_BY_2, DIVIDE_BY_4, DIVIDE_BY_4);
 59c:	070d4101 	streq	r4, [sp, -r1, lsl #2]
 5a0:	00000018 	andeq	r0, r0, r8, lsl r0
 5a4:	00000528 	andeq	r0, r0, r8, lsr #10
 5a8:	0000123c 	andeq	r1, r0, ip, lsr r2
 5ac:	0000002e 	andeq	r0, r0, lr, lsr #32
    clockConfigMcgOut(MCG_PLL_EXTERNAL_100MHZ);
 5b0:	8e080e41 	cdphi	14, 0, cr0, cr8, cr1, {2}
 5b4:	41028701 	tstmi	r2, r1, lsl #14
}
 5b8:	0000070d 	andeq	r0, r0, sp, lsl #14

static void systickInit(void)
{
 5bc:	00000018 	andeq	r0, r0, r8, lsl r0
 5c0:	00000528 	andeq	r0, r0, r8, lsr #10
    uint32_t freq = clockGetFreq(CLOCK_CORE);
 5c4:	0000126c 	andeq	r1, r0, ip, ror #4
 5c8:	0000001a 	andeq	r0, r0, sl, lsl r0

    NVIC_SYSTICK_RELOAD = freq / CH_FREQUENCY - 1;
 5cc:	8e080e41 	cdphi	14, 0, cr0, cr8, cr1, {2}
 5d0:	41028701 	tstmi	r2, r1, lsl #14
 5d4:	0000070d 	andeq	r0, r0, sp, lsl #14
 5d8:	0000000c 	andeq	r0, r0, ip
 5dc:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff
 5e0:	7c020001 	stcvc	0, cr0, [r2], {1}
 5e4:	000d0c0e 	andeq	r0, sp, lr, lsl #24
 5e8:	00000010 	andeq	r0, r0, r0, lsl r0
    NVIC_SYSTICK_VALUE = 0;
 5ec:	000005d8 	ldrdeq	r0, [r0], -r8
 5f0:	00001290 	muleq	r0, r0, r2
 5f4:	0000001a 	andeq	r0, r0, sl, lsl r0
 5f8:	00080e41 	andeq	r0, r8, r1, asr #28
    NVIC_SYSTICK_CONTROL = NVIC_SYSTICK_CONTROL_ENABLE
 5fc:	00000014 	andeq	r0, r0, r4, lsl r0
 600:	000005d8 	ldrdeq	r0, [r0], -r8
 604:	000012b0 			; <UNDEFINED> instruction: 0x000012b0
                         | NVIC_SYSTICK_CONTROL_TICKINT
                         | NVIC_SYSTICK_CONTROL_CLKSOURCE;
}
 608:	00000088 	andeq	r0, r0, r8, lsl #1
 60c:	8e040e41 	cdphi	14, 0, cr0, cr4, cr1, {2}

int main(void)
{
 610:	100e4101 	andne	r4, lr, r1, lsl #2
 614:	00000014 	andeq	r0, r0, r4, lsl r0
    clocksInit();
 618:	000005d8 	ldrdeq	r0, [r0], -r8
    systickInit();
 61c:	00001340 	andeq	r1, r0, r0, asr #6
    chSysInit();
 620:	000000d8 	ldrdeq	r0, [r0], -r8

    gpioConfig(N_LED_ORANGE_PORT, N_LED_ORANGE_PIN, GPIO_OUTPUT | GPIO_LOW);
 624:	8e040e41 	cdphi	14, 0, cr0, cr4, cr1, {2}
 628:	100e4101 	andne	r4, lr, r1, lsl #2
 62c:	0000000c 	andeq	r0, r0, ip
 630:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff
 634:	7c020001 	stcvc	0, cr0, [r2], {1}
    gpioConfig(N_LED_YELLOW_PORT, N_LED_YELLOW_PIN, GPIO_OUTPUT | GPIO_LOW);
 638:	000d0c0e 	andeq	r0, sp, lr, lsl #24
 63c:	0000000c 	andeq	r0, r0, ip
 640:	0000062c 	andeq	r0, r0, ip, lsr #12
 644:	00001420 	andeq	r1, r0, r0, lsr #8
 648:	00000044 	andeq	r0, r0, r4, asr #32

    chThdCreateStatic(waThread1, sizeof(waThread1), NORMALPRIO, Thread1, NULL);
 64c:	00000010 	andeq	r0, r0, r0, lsl r0
 650:	0000062c 	andeq	r0, r0, ip, lsr #12
 654:	00001470 	andeq	r1, r0, r0, ror r4
 658:	00000092 	muleq	r0, r2, r0
 65c:	00180e41 	andseq	r0, r8, r1, asr #28
 660:	00000010 	andeq	r0, r0, r0, lsl r0
 664:	0000062c 	andeq	r0, r0, ip, lsr #12
 668:	00001510 	andeq	r1, r0, r0, lsl r5

    hwInterruptsEnable();
 66c:	00000046 	andeq	r0, r0, r6, asr #32

    while (TRUE) {
        chThdSleepMilliseconds(123);
 670:	00080e41 	andeq	r0, r8, r1, asr #28
 674:	00000010 	andeq	r0, r0, r0, lsl r0
        gpioToggle(N_LED_ORANGE_PORT, N_LED_ORANGE_PIN);
 678:	0000062c 	andeq	r0, r0, ip, lsr #12
 67c:	00001560 	andeq	r1, r0, r0, ror #10
 680:	00000056 	andeq	r0, r0, r6, asr r0
 684:	00100e41 	andseq	r0, r0, r1, asr #28
*
* RETURNS: The corresponding GPIO_BASE_ADDR.
*
*******************************************************************************/
static volatile gpioPort_t *gpioPortGet(uint32_t port)
{
 688:	0000000c 	andeq	r0, r0, ip
 68c:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff
    uint32_t addr;

    switch (port) {
 690:	7c020001 	stcvc	0, cr0, [r2], {1}
 694:	000d0c0e 	andeq	r0, sp, lr, lsl #24
 698:	00000010 	andeq	r0, r0, r0, lsl r0
 69c:	00000688 	andeq	r0, r0, r8, lsl #13
 6a0:	000015c0 	andeq	r1, r0, r0, asr #11
 6a4:	00000022 	andeq	r0, r0, r2, lsr #32
 6a8:	00100e41 	andseq	r0, r0, r1, asr #28
 6ac:	00000010 	andeq	r0, r0, r0, lsl r0
 6b0:	00000688 	andeq	r0, r0, r8, lsl #13
 6b4:	000015f0 	strdeq	r1, [r0], -r0
 6b8:	00000020 	andeq	r0, r0, r0, lsr #32
 6bc:	00080e41 	andeq	r0, r8, r1, asr #28
 6c0:	0000000c 	andeq	r0, r0, ip
 6c4:	00000688 	andeq	r0, r0, r8, lsl #13
 6c8:	00001610 	andeq	r1, r0, r0, lsl r6
 6cc:	0000005c 	andeq	r0, r0, ip, asr r0
 6d0:	00000010 	andeq	r0, r0, r0, lsl r0
 6d4:	00000688 	andeq	r0, r0, r8, lsl #13
 6d8:	00001670 	andeq	r1, r0, r0, ror r6
 6dc:	0000005e 	andeq	r0, r0, lr, asr r0
    case PORTA: addr = GPIOA_BASE_ADDR; break;
 6e0:	00100e41 	andseq	r0, r0, r1, asr #28
 6e4:	00000014 	andeq	r0, r0, r4, lsl r0
 6e8:	00000688 	andeq	r0, r0, r8, lsl #13
    case PORTB: addr = GPIOB_BASE_ADDR; break;
 6ec:	000016d0 	ldrdeq	r1, [r0], -r0
 6f0:	00000064 	andeq	r0, r0, r4, rrx
 6f4:	8e040e41 	cdphi	14, 0, cr0, cr4, cr1, {2}
    case PORTC: addr = GPIOC_BASE_ADDR; break;
 6f8:	180e4101 	stmdane	lr, {r0, r8, lr}
 6fc:	00000014 	andeq	r0, r0, r4, lsl r0
 700:	00000688 	andeq	r0, r0, r8, lsl #13
    case PORTD: addr = GPIOD_BASE_ADDR; break;
 704:	00001740 	andeq	r1, r0, r0, asr #14
 708:	0000008e 	andeq	r0, r0, lr, lsl #1
 70c:	8e040e41 	cdphi	14, 0, cr0, cr4, cr1, {2}
    case PORTE: addr = GPIOE_BASE_ADDR; break;
 710:	180e4101 	stmdane	lr, {r0, r8, lr}
 714:	00000014 	andeq	r0, r0, r4, lsl r0
 718:	00000688 	andeq	r0, r0, r8, lsl #13
    default:
        assert(0);
 71c:	000017d0 	ldrdeq	r1, [r0], -r0
 720:	00000066 	andeq	r0, r0, r6, rrx
 724:	8e040e41 	cdphi	14, 0, cr0, cr4, cr1, {2}
 728:	280e4101 	stmdacs	lr, {r0, r8, lr}
        return 0;
 72c:	00000014 	andeq	r0, r0, r4, lsl r0
    }

    return ((volatile gpioPort_t *) addr);
 730:	00000688 	andeq	r0, r0, r8, lsl #13
}
 734:	00001840 	andeq	r1, r0, r0, asr #16
 738:	0000005c 	andeq	r0, r0, ip, asr r0
*
* RETURNS: Nothing
*
*******************************************************************************/
void gpioConfig(uint32_t port, uint32_t pin, uint32_t opt)
{
 73c:	8e040e41 	cdphi	14, 0, cr0, cr4, cr1, {2}
 740:	180e4101 	stmdane	lr, {r0, r8, lr}
 744:	00000014 	andeq	r0, r0, r4, lsl r0
    /*
     * Ensure pin number is legal
     */

    assert((pin < 32));
 748:	00000688 	andeq	r0, r0, r8, lsl #13
 74c:	000018a0 	andeq	r1, r0, r0, lsr #17
 750:	00000024 	andeq	r0, r0, r4, lsr #32
 754:	8e080e41 	cdphi	14, 0, cr0, cr8, cr1, {2}
 758:	00028301 	andeq	r8, r2, r1, lsl #6
 75c:	00000014 	andeq	r0, r0, r4, lsl r0

    /*
     * Config the SIM Clock Gate
     */

    switch (port) {
 760:	00000688 	andeq	r0, r0, r8, lsl #13
 764:	000018d0 	ldrdeq	r1, [r0], -r0
 768:	0000005c 	andeq	r0, r0, ip, asr r0
 76c:	8e040e41 	cdphi	14, 0, cr0, cr4, cr1, {2}
 770:	100e4101 	andne	r4, lr, r1, lsl #2
 774:	00000014 	andeq	r0, r0, r4, lsl r0
 778:	00000688 	andeq	r0, r0, r8, lsl #13
 77c:	00001930 	andeq	r1, r0, r0, lsr r9
 780:	00000090 	muleq	r0, r0, r0
 784:	8e040e41 	cdphi	14, 0, cr0, cr4, cr1, {2}
 788:	100e4101 	andne	r4, lr, r1, lsl #2
 78c:	00000014 	andeq	r0, r0, r4, lsl r0
 790:	00000688 	andeq	r0, r0, r8, lsl #13
 794:	000019c0 	andeq	r1, r0, r0, asr #19
 798:	0000001e 	andeq	r0, r0, lr, lsl r0
 79c:	8e080e41 	cdphi	14, 0, cr0, cr8, cr1, {2}
 7a0:	00028301 	andeq	r8, r2, r1, lsl #6
 7a4:	0000000c 	andeq	r0, r0, ip
 7a8:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff
    case PORTA: SIM_SCGC5 |= SIM_SCGC5_PORTA_ENABLE; break;
 7ac:	7c020001 	stcvc	0, cr0, [r2], {1}
 7b0:	000d0c0e 	andeq	r0, sp, lr, lsl #24
 7b4:	00000010 	andeq	r0, r0, r0, lsl r0
 7b8:	000007a4 	andeq	r0, r0, r4, lsr #15
 7bc:	000019e0 	andeq	r1, r0, r0, ror #19
 7c0:	00000018 	andeq	r0, r0, r8, lsl r0
 7c4:	00080e41 	andeq	r0, r8, r1, asr #28
    case PORTB: SIM_SCGC5 |= SIM_SCGC5_PORTB_ENABLE; break;
 7c8:	00000010 	andeq	r0, r0, r0, lsl r0
 7cc:	000007a4 	andeq	r0, r0, r4, lsr #15
 7d0:	00001a00 	andeq	r1, r0, r0, lsl #20
 7d4:	0000001a 	andeq	r0, r0, sl, lsl r0
 7d8:	00100e41 	andseq	r0, r0, r1, asr #28
 7dc:	00000010 	andeq	r0, r0, r0, lsl r0
    case PORTC: SIM_SCGC5 |= SIM_SCGC5_PORTC_ENABLE; break;
 7e0:	000007a4 	andeq	r0, r0, r4, lsr #15
 7e4:	00001a20 	andeq	r1, r0, r0, lsr #20
 7e8:	000000ac 	andeq	r0, r0, ip, lsr #1
 7ec:	00080e41 	andeq	r0, r8, r1, asr #28
 7f0:	00000014 	andeq	r0, r0, r4, lsl r0
 7f4:	000007a4 	andeq	r0, r0, r4, lsr #15
 7f8:	00001ad0 	ldrdeq	r1, [r0], -r0
    case PORTD: SIM_SCGC5 |= SIM_SCGC5_PORTD_ENABLE; break;
 7fc:	00000062 	andeq	r0, r0, r2, rrx
 800:	8e040e41 	cdphi	14, 0, cr0, cr4, cr1, {2}
 804:	200e4101 	andcs	r4, lr, r1, lsl #2
 808:	00000014 	andeq	r0, r0, r4, lsl r0
 80c:	000007a4 	andeq	r0, r0, r4, lsr #15
 810:	00001b40 	andeq	r1, r0, r0, asr #22
    case PORTE: SIM_SCGC5 |= SIM_SCGC5_PORTE_ENABLE; break;
 814:	00000040 	andeq	r0, r0, r0, asr #32
 818:	8e040e41 	cdphi	14, 0, cr0, cr4, cr1, {2}
 81c:	280e4101 	stmdacs	lr, {r0, r8, lr}
 820:	00000014 	andeq	r0, r0, r4, lsl r0
 824:	000007a4 	andeq	r0, r0, r4, lsr #15
 828:	00001b80 	andeq	r1, r0, r0, lsl #23
 82c:	0000007a 	andeq	r0, r0, sl, ror r0
    default:
        assert(0);
 830:	8e040e41 	cdphi	14, 0, cr0, cr4, cr1, {2}
 834:	180e4101 	stmdane	lr, {r0, r8, lr}
 838:	00000014 	andeq	r0, r0, r4, lsl r0
 83c:	000007a4 	andeq	r0, r0, r4, lsr #15

    /*
     * Configure the Port Controller
     */

    uint32_t portCtrlBits = PORT_MUX_GPIO;
 840:	00001c00 	andeq	r1, r0, r0, lsl #24
 844:	00000028 	andeq	r0, r0, r8, lsr #32

    if (opt & GPIO_OUTPUT) {
 848:	8e040e41 	cdphi	14, 0, cr0, cr4, cr1, {2}
 84c:	100e4101 	andne	r4, lr, r1, lsl #2
        if (opt & GPIO_ODE) {
 850:	00000010 	andeq	r0, r0, r0, lsl r0
 854:	000007a4 	andeq	r0, r0, r4, lsr #15
 858:	00001c30 	andeq	r1, r0, r0, lsr ip
            portCtrlBits |= PORT_ODE;
 85c:	00000026 	andeq	r0, r0, r6, lsr #32
 860:	00080e41 	andeq	r0, r8, r1, asr #28
        } else {
            if (opt & GPIO_DSE)
 864:	00000014 	andeq	r0, r0, r4, lsl r0
 868:	000007a4 	andeq	r0, r0, r4, lsr #15
 86c:	00001c60 	andeq	r1, r0, r0, ror #24
                portCtrlBits |= PORT_DSE;
 870:	00000024 	andeq	r0, r0, r4, lsr #32
 874:	8e040e41 	cdphi	14, 0, cr0, cr4, cr1, {2}
        }

    } else if (opt & GPIO_INPUT) {
 878:	100e4101 	andne	r4, lr, r1, lsl #2
 87c:	00000014 	andeq	r0, r0, r4, lsl r0
 880:	000007a4 	andeq	r0, r0, r4, lsr #15
        if (opt & GPIO_PFE)
 884:	00001c90 	muleq	r0, r0, ip
 888:	0000003a 	andeq	r0, r0, sl, lsr r0
 88c:	8e040e41 	cdphi	14, 0, cr0, cr4, cr1, {2}
            portCtrlBits |= PORT_PFE;
 890:	100e4101 	andne	r4, lr, r1, lsl #2
 894:	00000014 	andeq	r0, r0, r4, lsl r0

    } else {
        assert(0);
 898:	000007a4 	andeq	r0, r0, r4, lsr #15
 89c:	00001cd0 	ldrdeq	r1, [r0], -r0
 8a0:	00000034 	andeq	r0, r0, r4, lsr r0
 8a4:	8e080e41 	cdphi	14, 0, cr0, cr8, cr1, {2}
        return;
 8a8:	00028301 	andeq	r8, r2, r1, lsl #6
    }

    if (opt & GPIO_PULLUP)
 8ac:	00000014 	andeq	r0, r0, r4, lsl r0
 8b0:	000007a4 	andeq	r0, r0, r4, lsr #15
        portCtrlBits |= PORT_PULLUP_ENABLE;
 8b4:	00001d10 	andeq	r1, r0, r0, lsl sp
 8b8:	00000018 	andeq	r0, r0, r8, lsl r0
 8bc:	8e040e41 	cdphi	14, 0, cr0, cr4, cr1, {2}
    else if (opt & GPIO_PULLDOWN)
 8c0:	100e4101 	andne	r4, lr, r1, lsl #2
 8c4:	00000014 	andeq	r0, r0, r4, lsl r0
        portCtrlBits |= PORT_PULLDOWN_ENABLE;
 8c8:	000007a4 	andeq	r0, r0, r4, lsr #15
 8cc:	00001d30 	andeq	r1, r0, r0, lsr sp

    PORT_PCR(port, pin) = portCtrlBits;
 8d0:	00000068 	andeq	r0, r0, r8, rrx
 8d4:	8e040e41 	cdphi	14, 0, cr0, cr4, cr1, {2}
 8d8:	180e4101 	stmdane	lr, {r0, r8, lr}
 8dc:	00000014 	andeq	r0, r0, r4, lsl r0

    /*
     * Configure the GPIO Controller
     */

    volatile gpioPort_t *gpioPort = gpioPortGet(port);
 8e0:	000007a4 	andeq	r0, r0, r4, lsr #15
 8e4:	00001da0 	andeq	r1, r0, r0, lsr #27
    uint32_t pinBit = 1 << pin;
 8e8:	00000052 	andeq	r0, r0, r2, asr r0
 8ec:	8e040e41 	cdphi	14, 0, cr0, cr4, cr1, {2}
 8f0:	180e4101 	stmdane	lr, {r0, r8, lr}

    if (opt & GPIO_OUTPUT) {
 8f4:	0000000c 	andeq	r0, r0, ip
 8f8:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff
        gpioPort->pddr |= pinBit;
 8fc:	7c020001 	stcvc	0, cr0, [r2], {1}
 900:	000d0c0e 	andeq	r0, sp, lr, lsl #24
 904:	00000010 	andeq	r0, r0, r0, lsl r0
        if (opt & GPIO_HIGH)
 908:	000008f4 	strdeq	r0, [r0], -r4
 90c:	00001e00 	andeq	r1, r0, r0, lsl #28
 910:	0000002a 	andeq	r0, r0, sl, lsr #32
            gpioPort->psor |= pinBit;
 914:	00080e41 	andeq	r0, r8, r1, asr #28
 918:	00000014 	andeq	r0, r0, r4, lsl r0
 91c:	000008f4 	strdeq	r0, [r0], -r4
        else if (opt & GPIO_LOW)
 920:	00001e30 	andeq	r1, r0, r0, lsr lr
 924:	00000090 	muleq	r0, r0, r0
 928:	8e040e41 	cdphi	14, 0, cr0, cr4, cr1, {2}
            gpioPort->pcor |= pinBit;
 92c:	180e4101 	stmdane	lr, {r0, r8, lr}
 930:	00000014 	andeq	r0, r0, r4, lsl r0
 934:	000008f4 	strdeq	r0, [r0], -r4
    }
}
 938:	00001ec0 	andeq	r1, r0, r0, asr #29
 93c:	0000005e 	andeq	r0, r0, lr, asr r0

/*******************************************************************************
* gpioSet
*******************************************************************************/
void gpioSet(uint32_t port, uint32_t pin)
{
 940:	8e040e41 	cdphi	14, 0, cr0, cr4, cr1, {2}
 944:	280e4101 	stmdacs	lr, {r0, r8, lr}
 948:	00000014 	andeq	r0, r0, r4, lsl r0
    volatile gpioPort_t *gpioPort = gpioPortGet(port);
 94c:	000008f4 	strdeq	r0, [r0], -r4
 950:	00001f20 	andeq	r1, r0, r0, lsr #30
    gpioPort->psor = 1 << pin;
 954:	00000066 	andeq	r0, r0, r6, rrx
 958:	8e040e41 	cdphi	14, 0, cr0, cr4, cr1, {2}
 95c:	280e4101 	stmdacs	lr, {r0, r8, lr}
 960:	0000000c 	andeq	r0, r0, ip
}
 964:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff
 968:	7c020001 	stcvc	0, cr0, [r2], {1}

/*******************************************************************************
* gpioClear
*******************************************************************************/
void gpioClear(uint32_t port, uint32_t pin)
{
 96c:	000d0c0e 	andeq	r0, sp, lr, lsl #24
 970:	0000000c 	andeq	r0, r0, ip
 974:	00000960 	andeq	r0, r0, r0, ror #18
    volatile gpioPort_t *gpioPort = gpioPortGet(port);
 978:	00001f90 	muleq	r0, r0, pc	; <UNPREDICTABLE>
 97c:	00000036 	andeq	r0, r0, r6, lsr r0
    gpioPort->pcor = 1 << pin;
 980:	00000014 	andeq	r0, r0, r4, lsl r0
 984:	00000960 	andeq	r0, r0, r0, ror #18
 988:	00001fd0 	ldrdeq	r1, [r0], -r0
 98c:	00000026 	andeq	r0, r0, r6, lsr #32
}
 990:	8e040e41 	cdphi	14, 0, cr0, cr4, cr1, {2}
 994:	180e4101 	stmdane	lr, {r0, r8, lr}

/*******************************************************************************
* gpioToggle
*******************************************************************************/
void gpioToggle(uint32_t port, uint32_t pin)
{
 998:	00000010 	andeq	r0, r0, r0, lsl r0
 99c:	00000960 	andeq	r0, r0, r0, ror #18
 9a0:	00002000 	andeq	r2, r0, r0
    volatile gpioPort_t *gpioPort = gpioPortGet(port);
 9a4:	00000062 	andeq	r0, r0, r2, rrx
 9a8:	00100e41 	andseq	r0, r0, r1, asr #28
    gpioPort->ptor = 1 << pin;
 9ac:	0000000c 	andeq	r0, r0, ip
 9b0:	00000960 	andeq	r0, r0, r0, ror #18
 9b4:	00002070 	andeq	r2, r0, r0, ror r0
 9b8:	0000001c 	andeq	r0, r0, ip, lsl r0
}
 9bc:	0000000c 	andeq	r0, r0, ip
 9c0:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff
*
* RETURNS:
*
*******************************************************************************/
void gpioPortWrite(uint32_t port, uint32_t mask, uint32_t value)
{
 9c4:	7c020001 	stcvc	0, cr0, [r2], {1}
 9c8:	000d0c0e 	andeq	r0, sp, lr, lsl #24
 9cc:	00000014 	andeq	r0, r0, r4, lsl r0
}
 9d0:	000009bc 			; <UNDEFINED> instruction: 0x000009bc
 9d4:	00002090 	muleq	r0, r0, r0
 9d8:	0000003c 	andeq	r0, r0, ip, lsr r0
*
* RETURNS:
*
*******************************************************************************/
uint32_t gpioPortRead(uint32_t port)
{
 9dc:	8e080e41 	cdphi	14, 0, cr0, cr8, cr1, {2}
 9e0:	00028301 	andeq	r8, r2, r1, lsl #6
    return 0;
 9e4:	00000014 	andeq	r0, r0, r4, lsl r0
}
 9e8:	000009bc 			; <UNDEFINED> instruction: 0x000009bc
 9ec:	000020d0 	ldrdeq	r2, [r0], -r0
 9f0:	00000058 	andeq	r0, r0, r8, asr r0
*
* RETURNS:
*
*******************************************************************************/
uint32_t gpioRead(uint32_t port, uint32_t pin)
{
 9f4:	8e040e41 	cdphi	14, 0, cr0, cr4, cr1, {2}
 9f8:	200e4101 	andcs	r4, lr, r1, lsl #2
 9fc:	00000014 	andeq	r0, r0, r4, lsl r0
    volatile gpioPort_t *gpioPort = gpioPortGet(port);
 a00:	000009bc 			; <UNDEFINED> instruction: 0x000009bc
 a04:	00002130 	andeq	r2, r0, r0, lsr r1
    return ((gpioPort->pdir & (1 << pin)) ? TRUE : FALSE);
 a08:	000000f4 	strdeq	r0, [r0], -r4
 a0c:	8e040e41 	cdphi	14, 0, cr0, cr4, cr1, {2}
 a10:	200e4101 	andcs	r4, lr, r1, lsl #2
 a14:	00000014 	andeq	r0, r0, r4, lsl r0
 a18:	000009bc 			; <UNDEFINED> instruction: 0x000009bc
 a1c:	00002230 	andeq	r2, r0, r0, lsr r2
}
 a20:	000000e8 	andeq	r0, r0, r8, ror #1
 a24:	8e040e41 	cdphi	14, 0, cr0, cr4, cr1, {2}
    .flashDiv     = FLASH_DIVIDER_DFLT,
};


static void fei2fee(clockConfig_t cc)
{
 a28:	200e4101 	andcs	r4, lr, r1, lsl #2
 a2c:	00000014 	andeq	r0, r0, r4, lsl r0
 a30:	000009bc 			; <UNDEFINED> instruction: 0x000009bc
     * Uno problemo: The largest divide factor available by FRDIV is 1024... And
     * 50MHz / 1024 = 48.3 kHz, which exceeds the 39.0625 kHz range. With our
     * setup, it doesn't seem that we can reach a FEE mode (and I don't want to
     * risk the tower to see what could happen if I did!)
     */
}
 a34:	00002320 	andeq	r2, r0, r0, lsr #6
 a38:	00000074 	andeq	r0, r0, r4, ror r0

static void fei2pee(clockConfig_t cc)
{
 a3c:	8e040e41 	cdphi	14, 0, cr0, cr4, cr1, {2}
 a40:	200e4101 	andcs	r4, lr, r1, lsl #2
 a44:	0000000c 	andeq	r0, r0, ip
                                                    /* External crystal setup */
    /* Select the OSCCLK */
    SIM_SOPT2 &= ~SIM_SOPT2_MCGCLKSEL;
 a48:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff
 a4c:	7c020001 	stcvc	0, cr0, [r2], {1}
 a50:	000d0c0e 	andeq	r0, sp, lr, lsl #24
 a54:	00000010 	andeq	r0, r0, r0, lsl r0
 a58:	00000a44 	andeq	r0, r0, r4, asr #20
 a5c:	000023a0 	andeq	r2, r0, r0, lsr #7
     * Enabling the XTAL for 50MHz
     * RANGE=1, match the frequency of the crystal being used
     * HGO=1,   set for high gain operation (best against noise)
     * EREFS=1, enable the external oscillator
     */
    clock.mcg->c2 = (MCG_C2_RANGE_MASK & (0x1 << 4)) |
 a60:	0000002a 	andeq	r0, r0, sl, lsr #32
 a64:	00100e41 	andseq	r0, r0, r1, asr #28
 a68:	00000014 	andeq	r0, r0, r4, lsl r0
 a6c:	00000a44 	andeq	r0, r0, r4, asr #20
     * mode from FBE (here we are going to PEE)
     *
     * IREFS=0, select external reference clock and enable the external
     * oscillator.
     */
    clock.mcg->c1 = ((MCG_C1_CLKS_MASK & (0x2 << 6)) |
 a70:	000023d0 	ldrdeq	r2, [r0], -r0
 a74:	0000003a 	andeq	r0, r0, sl, lsr r0
 a78:	8e040e41 	cdphi	14, 0, cr0, cr4, cr1, {2}
 a7c:	180e4101 	stmdane	lr, {r0, r8, lr}
                    (MCG_C1_FRDIV_MASK & (0x3 << 3))) &
                    (~MCG_C1_IREFS);

                                                    /* Wait for status update */
    /* Wait for oscillator to initialize */
    while (!(clock.mcg->s & MCG_S_OSCINIT)) {}
 a80:	00000014 	andeq	r0, r0, r4, lsl r0
 a84:	00000a44 	andeq	r0, r0, r4, asr #20
 a88:	00002410 	andeq	r2, r0, r0, lsl r4
 a8c:	0000003c 	andeq	r0, r0, ip, lsr r0
 a90:	8e040e41 	cdphi	14, 0, cr0, cr4, cr1, {2}
 a94:	180e4101 	stmdane	lr, {r0, r8, lr}
    /* Wait for reference clock's to become the external reference */
    while (clock.mcg->s & MCG_S_IREFST) {}
 a98:	00000014 	andeq	r0, r0, r4, lsl r0
 a9c:	00000a44 	andeq	r0, r0, r4, asr #20
 aa0:	00002450 	andeq	r2, r0, r0, asr r4
 aa4:	00000026 	andeq	r0, r0, r6, lsr #32
 aa8:	8e040e41 	cdphi	14, 0, cr0, cr4, cr1, {2}
 aac:	180e4101 	stmdane	lr, {r0, r8, lr}
    /* Wait for the indicator that MCGOTUCLK is fed by the external ref clock */
    while ((clock.mcg->s & MCG_S_CLKST_MASK) != (0x2 << 2)) {}
 ab0:	00000010 	andeq	r0, r0, r0, lsl r0
 ab4:	00000a44 	andeq	r0, r0, r4, asr #20
 ab8:	00002480 	andeq	r2, r0, r0, lsl #9
 abc:	00000026 	andeq	r0, r0, r6, lsr #32
 ac0:	00100e41 	andseq	r0, r0, r1, asr #28
 ac4:	00000014 	andeq	r0, r0, r4, lsl r0

                                            /* Generate correct PLL frequency */
    clock.mcg->c5 &= 0xE0; /* clear bits */
 ac8:	00000a44 	andeq	r0, r0, r4, asr #20
 acc:	000024b0 			; <UNDEFINED> instruction: 0x000024b0
 ad0:	00000024 	andeq	r0, r0, r4, lsr #32
 ad4:	8e040e41 	cdphi	14, 0, cr0, cr4, cr1, {2}
 ad8:	100e4101 	andne	r4, lr, r1, lsl #2
 adc:	0000000c 	andeq	r0, r0, ip
 ae0:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff
 ae4:	7c020001 	stcvc	0, cr0, [r2], {1}
    clock.mcg->c5 |= clockConfigParam[cc].divider;
 ae8:	000d0c0e 	andeq	r0, sp, lr, lsl #24
 aec:	00000014 	andeq	r0, r0, r4, lsl r0
 af0:	00000adc 	ldrdeq	r0, [r0], -ip
 af4:	000024e0 	andeq	r2, r0, r0, ror #9
 af8:	0000001c 	andeq	r0, r0, ip, lsl r0
 afc:	8e080e41 	cdphi	14, 0, cr0, cr8, cr1, {2}
 b00:	00028301 	andeq	r8, r2, r1, lsl #6
 b04:	00000014 	andeq	r0, r0, r4, lsl r0
 b08:	00000adc 	ldrdeq	r0, [r0], -ip
 b0c:	00002500 	andeq	r2, r0, r0, lsl #10
 b10:	00000026 	andeq	r0, r0, r6, lsr #32
 b14:	84040e41 	strhi	r0, [r4], #-3649	; 0xfffff1bf
    clock.mcg->c6 &= 0xE0;
 b18:	100e4101 	andne	r4, lr, r1, lsl #2
 b1c:	00000014 	andeq	r0, r0, r4, lsl r0
 b20:	00000adc 	ldrdeq	r0, [r0], -ip
 b24:	00002530 	andeq	r2, r0, r0, lsr r5
 b28:	00000048 	andeq	r0, r0, r8, asr #32
 b2c:	8e080e41 	cdphi	14, 0, cr0, cr8, cr1, {2}
 b30:	00028301 	andeq	r8, r2, r1, lsl #6
 b34:	00000014 	andeq	r0, r0, r4, lsl r0
    clock.mcg->c6 |= clockConfigParam[cc].multiplier;
 b38:	00000adc 	ldrdeq	r0, [r0], -ip
 b3c:	00002580 	andeq	r2, r0, r0, lsl #11
 b40:	000000be 	strheq	r0, [r0], -lr
 b44:	84040e41 	strhi	r0, [r4], #-3649	; 0xfffff1bf
 b48:	100e4101 	andne	r4, lr, r1, lsl #2
 b4c:	0000000c 	andeq	r0, r0, ip
 b50:	00000adc 	ldrdeq	r0, [r0], -ip
 b54:	00002640 	andeq	r2, r0, r0, asr #12
 b58:	00000006 	andeq	r0, r0, r6
 b5c:	0000000c 	andeq	r0, r0, ip
 b60:	00000adc 	ldrdeq	r0, [r0], -ip
 b64:	00002650 	andeq	r2, r0, r0, asr r6
                                                            /* Enter PBE mode */
    /* PLLS=1, select the PLL. */
    clock.mcg->c6 |= MCG_C6_PLLS;
 b68:	00000014 	andeq	r0, r0, r4, lsl r0
 b6c:	0000000c 	andeq	r0, r0, ip
 b70:	00000adc 	ldrdeq	r0, [r0], -ip
 b74:	00002670 	andeq	r2, r0, r0, ror r6
 b78:	00000012 	andeq	r0, r0, r2, lsl r0
 b7c:	0000000c 	andeq	r0, r0, ip
 b80:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff
 b84:	7c020001 	stcvc	0, cr0, [r2], {1}

                                                    /* Wait for status update */
    /* Wait for the PLL to be the clock source */
    while (!(clock.mcg->s & MCG_S_PLLST)) {}
 b88:	000d0c0e 	andeq	r0, sp, lr, lsl #24
 b8c:	00000014 	andeq	r0, r0, r4, lsl r0
 b90:	00000b7c 	andeq	r0, r0, ip, ror fp
 b94:	00002690 	muleq	r0, r0, r6
 b98:	000000a4 	andeq	r0, r0, r4, lsr #1
 b9c:	84040e41 	strhi	r0, [r4], #-3649	; 0xfffff1bf
    /* Wait until the PLL has acquired lock on the external frequency */
    while (!(clock.mcg->s & MCG_S_LOCK)) {}
 ba0:	180e4101 	stmdane	lr, {r0, r8, lr}
 ba4:	00000014 	andeq	r0, r0, r4, lsl r0
 ba8:	00000b7c 	andeq	r0, r0, ip, ror fp
 bac:	00002740 	andeq	r2, r0, r0, asr #14
 bb0:	00000078 	andeq	r0, r0, r8, ror r0
 bb4:	84040e41 	strhi	r0, [r4], #-3649	; 0xfffff1bf

                                                            /* Enter PEE mode */
    /* Select the output of the PLL */
    clock.mcg->c1 &= ~MCG_C1_CLKS_MASK;
 bb8:	180e4101 	stmdane	lr, {r0, r8, lr}
 bbc:	00000014 	andeq	r0, r0, r4, lsl r0
 bc0:	00000b7c 	andeq	r0, r0, ip, ror fp
 bc4:	000027c0 	andeq	r2, r0, r0, asr #15
 bc8:	00000060 	andeq	r0, r0, r0, rrx
 bcc:	84040e41 	strhi	r0, [r4], #-3649	; 0xfffff1bf
 bd0:	180e4101 	stmdane	lr, {r0, r8, lr}
 bd4:	0000000c 	andeq	r0, r0, ip

                                                    /* Wait for status update */
    /* Wait until output of the PLL is selected */
    while ((clock.mcg->s & MCG_S_CLKST_MASK) != (0x3 << 2)) {}
 bd8:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff
 bdc:	7c020001 	stcvc	0, cr0, [r2], {1}
 be0:	000d0c0e 	andeq	r0, sp, lr, lsl #24
 be4:	00000010 	andeq	r0, r0, r0, lsl r0
 be8:	00000bd4 	ldrdeq	r0, [r0], -r4
 bec:	00002820 	andeq	r2, r0, r0, lsr #16

    mcgState.currentMode = MODE_PEE;
 bf0:	00000046 	andeq	r0, r0, r6, asr #32
 bf4:	00100e41 	andseq	r0, r0, r1, asr #28
 bf8:	00000010 	andeq	r0, r0, r0, lsl r0
}
 bfc:	00000bd4 	ldrdeq	r0, [r0], -r4
 c00:	00002870 	andeq	r2, r0, r0, ror r8
 c04:	00000022 	andeq	r0, r0, r2, lsr #32

static void fei2blpi(clockConfig_t cc)
{
 c08:	00100e41 	andseq	r0, r0, r1, asr #28
 c0c:	00000010 	andeq	r0, r0, r0, lsl r0
 c10:	00000bd4 	ldrdeq	r0, [r0], -r4
                                                            /* Not configured */
}
 c14:	000028a0 	andeq	r2, r0, r0, lsr #17
 c18:	00000020 	andeq	r0, r0, r0, lsr #32

static void fei2blpe(clockConfig_t cc)
{
 c1c:	00080e41 	andeq	r0, r8, r1, asr #28
 c20:	00000010 	andeq	r0, r0, r0, lsl r0
 c24:	00000bd4 	ldrdeq	r0, [r0], -r4
                                                            /* Not configured */
}
 c28:	000028c0 	andeq	r2, r0, r0, asr #17
 c2c:	0000001e 	andeq	r0, r0, lr, lsl r0


static void fee2fei(clockConfig_t cc)
{
 c30:	00080e41 	andeq	r0, r8, r1, asr #28
 c34:	00000014 	andeq	r0, r0, r4, lsl r0
 c38:	00000bd4 	ldrdeq	r0, [r0], -r4
                                                            /* Not configured */
}
 c3c:	000028e0 	andeq	r2, r0, r0, ror #17
 c40:	00000020 	andeq	r0, r0, r0, lsr #32

static void fee2pee(clockConfig_t cc)
{
 c44:	8e040e41 	cdphi	14, 0, cr0, cr4, cr1, {2}
 c48:	100e4101 	andne	r4, lr, r1, lsl #2
 c4c:	00000014 	andeq	r0, r0, r4, lsl r0
                                                            /* Not configured */
}
 c50:	00000bd4 	ldrdeq	r0, [r0], -r4
 c54:	00002900 	andeq	r2, r0, r0, lsl #18

static void fee2blpi(clockConfig_t cc)
{
 c58:	000000c0 	andeq	r0, r0, r0, asr #1
 c5c:	8e040e41 	cdphi	14, 0, cr0, cr4, cr1, {2}
 c60:	180e4101 	stmdane	lr, {r0, r8, lr}
                                                            /* Not configured */
}
 c64:	00000014 	andeq	r0, r0, r4, lsl r0
 c68:	00000bd4 	ldrdeq	r0, [r0], -r4

static void fee2blpe(clockConfig_t cc)
{
 c6c:	000029c0 	andeq	r2, r0, r0, asr #19
 c70:	00000026 	andeq	r0, r0, r6, lsr #32
 c74:	8e040e41 	cdphi	14, 0, cr0, cr4, cr1, {2}
                                                            /* Not configured */
}
 c78:	180e4101 	stmdane	lr, {r0, r8, lr}
 c7c:	00000010 	andeq	r0, r0, r0, lsl r0


static void pee2fei(clockConfig_t cc)
{
 c80:	00000bd4 	ldrdeq	r0, [r0], -r4
 c84:	000029f0 	strdeq	r2, [r0], -r0
 c88:	00000048 	andeq	r0, r0, r8, asr #32

                                                            /* Enter PBE mode */
    clock.mcg->c1 = (MCG_C1_CLKS_MASK & (0x2 << 6)); /* Select external clock */
 c8c:	00080e41 	andeq	r0, r8, r1, asr #28
 c90:	00000014 	andeq	r0, r0, r4, lsl r0
 c94:	00000bd4 	ldrdeq	r0, [r0], -r4
 c98:	00002a40 	andeq	r2, r0, r0, asr #20

                                                    /* Wait for status update */
    while ((clock.mcg->s & MCG_S_CLKST_MASK) != (0x2 << 2)) {}
 c9c:	000000b0 	strheq	r0, [r0], -r0	; <UNPREDICTABLE>
 ca0:	8e040e41 	cdphi	14, 0, cr0, cr4, cr1, {2}
 ca4:	200e4101 	andcs	r4, lr, r1, lsl #2
 ca8:	00000014 	andeq	r0, r0, r4, lsl r0
 cac:	00000bd4 	ldrdeq	r0, [r0], -r4
 cb0:	00002af0 	strdeq	r2, [r0], -r0

                                                            /* Enter FBE mode */
    /*
     * With the FLL frequency valid, we can now clear the PLLS bit to select FLL
     */
    clock.mcg->c6 &= ~MCG_C6_PLLS;
 cb4:	0000009c 	muleq	r0, ip, r0
 cb8:	8e040e41 	cdphi	14, 0, cr0, cr4, cr1, {2}
 cbc:	200e4101 	andcs	r4, lr, r1, lsl #2
 cc0:	00000014 	andeq	r0, r0, r4, lsl r0
 cc4:	00000bd4 	ldrdeq	r0, [r0], -r4
 cc8:	00002b90 	muleq	r0, r0, fp
 ccc:	00000086 	andeq	r0, r0, r6, lsl #1
 cd0:	8e040e41 	cdphi	14, 0, cr0, cr4, cr1, {2}

                                                    /* Wait for status update */
    /* Wait until the current source is FLL */
    while (clock.mcg->s & MCG_S_PLLST) {}
 cd4:	180e4101 	stmdane	lr, {r0, r8, lr}

Disassembly of section .debug_ranges:

00000000 <.debug_ranges>:
   0:	00001290 	muleq	r0, r0, r2
   4:	000012aa 	andeq	r1, r0, sl, lsr #5
   8:	000012b0 			; <UNDEFINED> instruction: 0x000012b0
   c:	00001338 	andeq	r1, r0, r8, lsr r3
  10:	00001340 	andeq	r1, r0, r0, asr #6
  14:	00001418 	andeq	r1, r0, r8, lsl r4
	...
  20:	00001420 	andeq	r1, r0, r0, lsr #8
  24:	00001464 	andeq	r1, r0, r4, ror #8
  28:	00001470 	andeq	r1, r0, r0, ror r4
  2c:	00001502 	andeq	r1, r0, r2, lsl #10
  30:	00001510 	andeq	r1, r0, r0, lsl r5
  34:	00001556 	andeq	r1, r0, r6, asr r5
  38:	00001560 	andeq	r1, r0, r0, ror #10
  3c:	000015b6 			; <UNDEFINED> instruction: 0x000015b6
	...
  48:	000015c0 	andeq	r1, r0, r0, asr #11
  4c:	000015e2 	andeq	r1, r0, r2, ror #11
  50:	000015f0 	strdeq	r1, [r0], -r0
  54:	00001610 	andeq	r1, r0, r0, lsl r6
  58:	00001610 	andeq	r1, r0, r0, lsl r6
  5c:	0000166c 	andeq	r1, r0, ip, ror #12
  60:	00001670 	andeq	r1, r0, r0, ror r6
  64:	000016ce 	andeq	r1, r0, lr, asr #13
  68:	000016d0 	ldrdeq	r1, [r0], -r0
  6c:	00001734 	andeq	r1, r0, r4, lsr r7
  70:	00001740 	andeq	r1, r0, r0, asr #14
  74:	000017ce 	andeq	r1, r0, lr, asr #15
  78:	000017d0 	ldrdeq	r1, [r0], -r0
  7c:	00001836 	andeq	r1, r0, r6, lsr r8
  80:	00001840 	andeq	r1, r0, r0, asr #16
  84:	0000189c 	muleq	r0, ip, r8
  88:	000018a0 	andeq	r1, r0, r0, lsr #17
  8c:	000018c4 	andeq	r1, r0, r4, asr #17
  90:	000018d0 	ldrdeq	r1, [r0], -r0
  94:	0000192c 	andeq	r1, r0, ip, lsr #18
  98:	00001930 	andeq	r1, r0, r0, lsr r9
  9c:	000019c0 	andeq	r1, r0, r0, asr #19
  a0:	000019c0 	andeq	r1, r0, r0, asr #19
  a4:	000019de 	ldrdeq	r1, [r0], -lr
	...
  b0:	000019e0 	andeq	r1, r0, r0, ror #19
  b4:	000019f8 	strdeq	r1, [r0], -r8
  b8:	00001a00 	andeq	r1, r0, r0, lsl #20
  bc:	00001a1a 	andeq	r1, r0, sl, lsl sl
  c0:	00001a20 	andeq	r1, r0, r0, lsr #20
  c4:	00001acc 	andeq	r1, r0, ip, asr #21
  c8:	00001ad0 	ldrdeq	r1, [r0], -r0
  cc:	00001b32 	andeq	r1, r0, r2, lsr fp
  d0:	00001b40 	andeq	r1, r0, r0, asr #22
  d4:	00001b80 	andeq	r1, r0, r0, lsl #23
  d8:	00001b80 	andeq	r1, r0, r0, lsl #23
  dc:	00001bfa 	strdeq	r1, [r0], -sl
  e0:	00001c00 	andeq	r1, r0, r0, lsl #24
  e4:	00001c28 	andeq	r1, r0, r8, lsr #24
  e8:	00001c30 	andeq	r1, r0, r0, lsr ip
  ec:	00001c56 	andeq	r1, r0, r6, asr ip
  f0:	00001c60 	andeq	r1, r0, r0, ror #24
  f4:	00001c84 	andeq	r1, r0, r4, lsl #25
  f8:	00001c90 	muleq	r0, r0, ip
  fc:	00001cca 	andeq	r1, r0, sl, asr #25
 100:	00001cd0 	ldrdeq	r1, [r0], -r0
 104:	00001d04 	andeq	r1, r0, r4, lsl #26
 108:	00001d10 	andeq	r1, r0, r0, lsl sp
 10c:	00001d28 	andeq	r1, r0, r8, lsr #26
 110:	00001d30 	andeq	r1, r0, r0, lsr sp
 114:	00001d98 	muleq	r0, r8, sp
 118:	00001da0 	andeq	r1, r0, r0, lsr #27
 11c:	00001df2 	strdeq	r1, [r0], -r2
	...
 128:	00001e00 	andeq	r1, r0, r0, lsl #28
 12c:	00001e2a 	andeq	r1, r0, sl, lsr #28
 130:	00001e30 	andeq	r1, r0, r0, lsr lr
 134:	00001ec0 	andeq	r1, r0, r0, asr #29
 138:	00001ec0 	andeq	r1, r0, r0, asr #29
 13c:	00001f1e 	andeq	r1, r0, lr, lsl pc
 140:	00001f20 	andeq	r1, r0, r0, lsr #30
 144:	00001f86 	andeq	r1, r0, r6, lsl #31
	...
 150:	00001f90 	muleq	r0, r0, pc	; <UNPREDICTABLE>
 154:	00001fc6 	andeq	r1, r0, r6, asr #31
 158:	00001fd0 	ldrdeq	r1, [r0], -r0
 15c:	00001ff6 	strdeq	r1, [r0], -r6
 160:	00002000 	andeq	r2, r0, r0
 164:	00002062 	andeq	r2, r0, r2, rrx
 168:	00002070 	andeq	r2, r0, r0, ror r0
 16c:	0000208c 	andeq	r2, r0, ip, lsl #1
	...
 178:	00002090 	muleq	r0, r0, r0
 17c:	000020cc 	andeq	r2, r0, ip, asr #1
 180:	000020d0 	ldrdeq	r2, [r0], -r0
 184:	00002128 	andeq	r2, r0, r8, lsr #2
 188:	00002130 	andeq	r2, r0, r0, lsr r1
 18c:	00002224 	andeq	r2, r0, r4, lsr #4
 190:	00002230 	andeq	r2, r0, r0, lsr r2
 194:	00002318 	andeq	r2, r0, r8, lsl r3
 198:	00002320 	andeq	r2, r0, r0, lsr #6
 19c:	00002394 	muleq	r0, r4, r3
	...
 1a8:	000023a0 	andeq	r2, r0, r0, lsr #7
 1ac:	000023ca 	andeq	r2, r0, sl, asr #7
 1b0:	000023d0 	ldrdeq	r2, [r0], -r0
 1b4:	0000240a 	andeq	r2, r0, sl, lsl #8
 1b8:	00002410 	andeq	r2, r0, r0, lsl r4
 1bc:	0000244c 	andeq	r2, r0, ip, asr #8
 1c0:	00002450 	andeq	r2, r0, r0, asr r4
 1c4:	00002476 	andeq	r2, r0, r6, ror r4
 1c8:	00002480 	andeq	r2, r0, r0, lsl #9
 1cc:	000024a6 	andeq	r2, r0, r6, lsr #9
 1d0:	000024b0 			; <UNDEFINED> instruction: 0x000024b0
 1d4:	000024d4 	ldrdeq	r2, [r0], -r4
	...
 1e0:	000024e0 	andeq	r2, r0, r0, ror #9
 1e4:	000024fc 	strdeq	r2, [r0], -ip
 1e8:	00002500 	andeq	r2, r0, r0, lsl #10
 1ec:	00002526 	andeq	r2, r0, r6, lsr #10
 1f0:	00002530 	andeq	r2, r0, r0, lsr r5
 1f4:	00002578 	andeq	r2, r0, r8, ror r5
 1f8:	00002580 	andeq	r2, r0, r0, lsl #11
 1fc:	0000263e 	andeq	r2, r0, lr, lsr r6
 200:	00002640 	andeq	r2, r0, r0, asr #12
 204:	00002646 	andeq	r2, r0, r6, asr #12
 208:	00002650 	andeq	r2, r0, r0, asr r6
 20c:	00002664 	andeq	r2, r0, r4, ror #12
 210:	00002670 	andeq	r2, r0, r0, ror r6
 214:	00002682 	andeq	r2, r0, r2, lsl #13
	...
 220:	00002690 	muleq	r0, r0, r6
 224:	00002734 	andeq	r2, r0, r4, lsr r7
 228:	00002740 	andeq	r2, r0, r0, asr #14
 22c:	000027b8 			; <UNDEFINED> instruction: 0x000027b8
 230:	000027c0 	andeq	r2, r0, r0, asr #15
 234:	00002820 	andeq	r2, r0, r0, lsr #16
	...
 240:	00002820 	andeq	r2, r0, r0, lsr #16
 244:	00002866 	andeq	r2, r0, r6, ror #16
 248:	00002870 	andeq	r2, r0, r0, ror r8
 24c:	00002892 	muleq	r0, r2, r8
 250:	000028a0 	andeq	r2, r0, r0, lsr #17
 254:	000028c0 	andeq	r2, r0, r0, asr #17
 258:	000028c0 	andeq	r2, r0, r0, asr #17
 25c:	000028de 	ldrdeq	r2, [r0], -lr
 260:	000028e0 	andeq	r2, r0, r0, ror #17
 264:	00002900 	andeq	r2, r0, r0, lsl #18
 268:	00002900 	andeq	r2, r0, r0, lsl #18
 26c:	000029c0 	andeq	r2, r0, r0, asr #19
 270:	000029c0 	andeq	r2, r0, r0, asr #19
 274:	000029e6 	andeq	r2, r0, r6, ror #19
 278:	000029f0 	strdeq	r2, [r0], -r0
 27c:	00002a38 	andeq	r2, r0, r8, lsr sl
 280:	00002a40 	andeq	r2, r0, r0, asr #20
 284:	00002af0 	strdeq	r2, [r0], -r0
 288:	00002af0 	strdeq	r2, [r0], -r0
 28c:	00002b8c 	andeq	r2, r0, ip, lsl #23
 290:	00002b90 	muleq	r0, r0, fp
 294:	00002c16 	andeq	r2, r0, r6, lsl ip
	...
